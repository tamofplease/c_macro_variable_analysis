<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/source/util/src/tcompression.c"><comment type="block">/*
 * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the GNU Affero General Public License, version 3
 * or later ("AGPL"), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<comment type="block">/* README.md   TAOS compression
 *
 * INTEGER Compression Algorithm:
 *   To compress integers (including char, short, int32_t, int64_t), the difference
 *   between two integers is calculated at first. Then the difference is
 *   transformed to positive by zig-zag encoding method
 *   (https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba). Then the value is
 *   encoded using simple 8B method. For more information about simple 8B,
 *   refer to https://en.wikipedia.org/wiki/8b/10b_encoding.
 *
 *   NOTE : For bigint, only 59 bits can be used, which means data from -(2**59) to (2**59)-1
 *   are allowed.
 *
 * BOOLEAN Compression Algorithm:
 *   We provide two methods for compress boolean types. Because boolean types in C
 *   code are char bytes with 0 and 1 values only, only one bit can used to discriminate
 *   the values.
 *   1. The first method is using only 1 bit to represent the boolean value with 1 for
 *   true and 0 for false. Then the compression rate is 1/8.
 *   2. The second method is using run length encoding (RLE) methods. This method works
 *   better when there are a lot of consecutive true values or false values.
 *
 * STRING Compression Algorithm:
 *   We us LZ4 method to compress the string type.
 *
 * FLOAT Compression Algorithm:
 *   We use the same method with Akumuli to compress float and double types. The compression
 *   algorithm assumes the float/double values change slightly. So we take the XOR between two
 *   adjacent values. Then compare the number of leading zeros and trailing zeros. If the number
 *   of leading zeros are larger than the trailing zeros, then record the last serveral bytes
 *   of the XORed value with informations. If not, record the first corresponding bytes.
 *
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_DEFAULT_SOURCE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcompression.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lz4.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tRealloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tlog.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TD_TSZ</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"td_sz.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int32_t</name></type> <name>TEST_NUMBER</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_bigendian</name><parameter_list>()</parameter_list></cpp:macro>     <cpp:value>((*(char *)&amp;TEST_NUMBER) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIMPLE8B_MAX_INT64</name></cpp:macro> <cpp:value>((uint64_t)1152921504606846974LL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>safeInt64Add</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(((a &gt;= 0) &amp;&amp; (b &lt;= INT64_MAX - a)) || ((a &lt; 0) &amp;&amp; (b &gt;= INT64_MIN - a)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIGZAG_ENCODE</name><parameter_list>(<parameter><type><name>T</name></type></parameter>, <parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((u##T)((v) &gt;&gt; (sizeof(T) * 8 - 1))) ^ (((u##T)(v)) &lt;&lt; 1))</cpp:value></cpp:define>  <comment type="line">// zigzag encode</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIGZAG_DECODE</name><parameter_list>(<parameter><type><name>T</name></type></parameter>, <parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((v) &gt;&gt; 1) ^ -((T)((v)&amp;1)))</cpp:value></cpp:define>                                 <comment type="line">// zigzag decode</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TD_TSZ</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type> <name>lossyFloat</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>lossyDouble</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="line">// init call</comment>
<function><type><name>int32_t</name></type> <name>tsCompressInit</name><parameter_list>()</parameter_list> <block>{<block_content>
  <comment type="line">// config</comment>
  <if_stmt><if>if <condition>(<expr><name><name>lossyColumns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>lossyFloat</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lossyDouble</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>lossyFloat</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>lossyColumns</name></expr></argument>, <argument><expr><literal type="string">"float"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>lossyDouble</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>lossyColumns</name></expr></argument>, <argument><expr><literal type="string">"double"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>lossyFloat</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name>lossyDouble</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>tdszInit</name><argument_list>(<argument><expr><name>fPrecision</name></expr></argument>, <argument><expr><name>dPrecision</name></expr></argument>, <argument><expr><name>maxRange</name></expr></argument>, <argument><expr><name>curRange</name></expr></argument>, <argument><expr><name>Compressor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>lossyFloat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>uTrace</name><argument_list>(<argument><expr><literal type="string">"lossy compression float  is opened. "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>lossyDouble</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>uTrace</name><argument_list>(<argument><expr><literal type="string">"lossy compression double is opened. "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<comment type="line">// exit call</comment>
<function><type><name>void</name></type> <name>tsCompressExit</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>tdszExit</name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Compress Integer (Simple8B).
 */</comment>
<function><type><name>int32_t</name></type> <name>tsCompressINTImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// Selector value:              0    1   2   3   4   5   6   7   8  9  10  11</comment>
  <comment type="line">// 12  13  14  15</comment>
  <decl_stmt><decl><type><name>char</name></type>    <name><name>bit_per_integer</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">60</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name><name>selector_to_elems</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">240</literal></expr>, <expr><literal type="number">120</literal></expr>, <expr><literal type="number">60</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>    <name><name>bit_to_selector</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">9</literal></expr>,  <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>,
                               <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>,
                               <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <comment type="line">// get the byte limit.</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>word_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
      <expr_stmt><expr><name>word_length</name> <operator>=</operator> <name>LONG_BYTES</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
      <expr_stmt><expr><name>word_length</name> <operator>=</operator> <name>INT_BYTES</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
      <expr_stmt><expr><name>word_length</name> <operator>=</operator> <name>SHORT_BYTES</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
      <expr_stmt><expr><name>word_length</name> <operator>=</operator> <name>CHAR_BYTES</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><call><name>uError</name><argument_list>(<argument><expr><literal type="string">"Invalid compress integer type:%d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></switch>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>byte_limit</name> <init>= <expr><name>nelements</name> <operator>*</operator> <name>word_length</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>opos</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>prev_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelements</name></expr>;</condition><incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>    <name>selector</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>    <name>bit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>elems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>prev_value_tmp</name> <init>= <expr><name>prev_value</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><name>i</name></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nelements</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <comment type="line">// Read data from the input stream and convert it to INT64 type.</comment>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>curr_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
          <expr_stmt><expr><name>curr_value</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <name>j</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
          <expr_stmt><expr><name>curr_value</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <name>j</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
          <expr_stmt><expr><name>curr_value</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <name>j</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
          <expr_stmt><expr><name>curr_value</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <name>j</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>
      </block_content>}</block></switch>
      <comment type="line">// Get difference.</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>safeInt64Add</name><argument_list>(<argument><expr><name>curr_value</name></expr></argument>, <argument><expr><operator>-</operator><name>prev_value_tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_copy_and_exit</name>;</goto></block_content></block></if></if_stmt>

      <decl_stmt><decl><type><name>int64_t</name></type> <name>diff</name> <init>= <expr><name>curr_value</name> <operator>-</operator> <name>prev_value_tmp</name></expr></init></decl>;</decl_stmt>
      <comment type="line">// Zigzag encode the value.</comment>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>zigzag_value</name> <init>= <expr><call><name>ZIGZAG_ENCODE</name><argument_list>(<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>zigzag_value</name> <operator>&gt;=</operator> <name>SIMPLE8B_MAX_INT64</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_copy_and_exit</name>;</goto></block_content></block></if></if_stmt>

      <decl_stmt><decl><type><name>int64_t</name></type> <name>tmp_bit</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>zigzag_value</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// Take care here, __builtin_clzl give wrong anser for value 0;</comment>
        <expr_stmt><expr><name>tmp_bit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>tmp_bit</name> <operator>=</operator> <operator>(</operator><name>LONG_BYTES</name> <operator>*</operator> <name>BITS_PER_BYTE</name><operator>)</operator> <operator>-</operator> <call><name>BUILDIN_CLZL</name><argument_list>(<argument><expr><name>zigzag_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>elems</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name><name>selector_to_elems</name><index>[<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>selector</name></expr>]</index></name> <operator>&amp;&amp;</operator>
          <name>elems</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name><name>selector_to_elems</name><index>[<expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name><name>bit_to_selector</name><index>[<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>tmp_bit</name></expr>]</index></name><operator>)</operator></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <comment type="line">// If can hold another one.</comment>
        <expr_stmt><expr><name>selector</name> <operator>=</operator> <ternary><condition><expr><name>selector</name> <operator>&gt;</operator> <name><name>bit_to_selector</name><index>[<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>tmp_bit</name></expr>]</index></name></expr> ?</condition><then> <expr><name>selector</name></expr> </then><else>: <expr><name><name>bit_to_selector</name><index>[<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>tmp_bit</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>elems</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>bit</name> <operator>=</operator> <name><name>bit_per_integer</name><index>[<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>selector</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// if cannot hold another one.</comment>
        <while>while <condition>(<expr><name>elems</name> <operator>&lt;</operator> <name><name>selector_to_elems</name><index>[<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>selector</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>selector</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>elems</name> <operator>=</operator> <name><name>selector_to_elems</name><index>[<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>selector</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bit</name> <operator>=</operator> <name><name>bit_per_integer</name><index>[<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>selector</name></expr>]</index></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>prev_value_tmp</name> <operator>=</operator> <name>curr_value</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>buffer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>buffer</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>selector</name></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>elems</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>curr_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* get current values */</comment>
      <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
          <expr_stmt><expr><name>curr_value</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <name>i</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
          <expr_stmt><expr><name>curr_value</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <name>i</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
          <expr_stmt><expr><name>curr_value</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <name>i</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
          <expr_stmt><expr><name>curr_value</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>input</name> <operator>+</operator> <name>i</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>
      </block_content>}</block></switch>
      <decl_stmt><decl><type><name>int64_t</name></type>  <name>diff</name> <init>= <expr><name>curr_value</name> <operator>-</operator> <name>prev_value</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>zigzag_value</name> <init>= <expr><call><name>ZIGZAG_ENCODE</name><argument_list>(<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>buffer</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>zigzag_value</name> <operator>&amp;</operator> <call><name>INT64MASK</name><argument_list>(<argument><expr><name>bit</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>bit</name> <operator>*</operator> <name>k</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>prev_value</name> <operator>=</operator> <name>curr_value</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// Output the encoded value to the output.</comment>
    <if_stmt><if>if <condition>(<expr><name>opos</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>byte_limit</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <name>opos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>opos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
    <label><name>_copy_and_exit</name>:</label>
      <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>byte_limit</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>byte_limit</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <comment type="line">// set the indicator.</comment>
  <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>opos</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressINTImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>word_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
      <expr_stmt><expr><name>word_length</name> <operator>=</operator> <name>LONG_BYTES</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
      <expr_stmt><expr><name>word_length</name> <operator>=</operator> <name>INT_BYTES</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
      <expr_stmt><expr><name>word_length</name> <operator>=</operator> <name>SHORT_BYTES</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
      <expr_stmt><expr><name>word_length</name> <operator>=</operator> <name>CHAR_BYTES</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><call><name>uError</name><argument_list>(<argument><expr><literal type="string">"Invalid decompress integer type:%d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></switch>

  <comment type="line">// If not compressed.</comment>
  <if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>nelements</name> <operator>*</operator> <name>word_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nelements</name> <operator>*</operator> <name>word_length</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// Selector value:              0    1   2   3   4   5   6   7   8  9  10  11</comment>
  <comment type="line">// 12  13  14  15</comment>
  <decl_stmt><decl><type><name>char</name></type>    <name><name>bit_per_integer</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">60</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name><name>selector_to_elems</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">240</literal></expr>, <expr><literal type="number">120</literal></expr>, <expr><literal type="number">60</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type>     <name>prev_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <name>nelements</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>w</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>LONG_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name></type>    <name>selector</name> <init>= <expr><operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>w</name> <operator>&amp;</operator> <call><name>INT64MASK</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>       <comment type="line">// selector = 4</comment>
    <decl_stmt><decl><type><name>char</name></type>    <name>bit</name> <init>= <expr><name><name>bit_per_integer</name><index>[<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>selector</name></expr>]</index></name></expr></init></decl>;</decl_stmt>  <comment type="line">// bit = 3</comment>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>elems</name> <init>= <expr><name><name>selector_to_elems</name><index>[<expr><operator>(</operator><name>int32_t</name><operator>)</operator><name>selector</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>elems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>zigzag_value</name></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>selector</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>selector</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>zigzag_value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>zigzag_value</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">4</literal> <operator>+</operator> <name>bit</name> <operator>*</operator> <name>i</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <call><name>INT64MASK</name><argument_list>(<argument><expr><name>bit</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>diff</name> <init>= <expr><call><name>ZIGZAG_DECODE</name><argument_list>(<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>zigzag_value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>curr_value</name> <init>= <expr><name>diff</name> <operator>+</operator> <name>prev_value</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>prev_value</name> <operator>=</operator> <name>curr_value</name></expr>;</expr_stmt>

      <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>+</operator> <name>_pos</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>curr_value</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>_pos</name><operator>++</operator></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>+</operator> <name>_pos</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name>curr_value</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>_pos</name><operator>++</operator></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>+</operator> <name>_pos</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><name>curr_value</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>_pos</name><operator>++</operator></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>+</operator> <name>_pos</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>int8_t</name><operator>)</operator><name>curr_value</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>_pos</name><operator>++</operator></expr>;</expr_stmt>
          <break>break;</break>
        <default>default:</default>
          <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"Wrong integer types.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></switch>
      <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <name>nelements</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>ip</name> <operator>+=</operator> <name>LONG_BYTES</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>nelements</name> <operator>*</operator> <name>word_length</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------Bool Compression
 * ---------------------------------------------- */</comment>
<comment type="line">// TODO: You can also implement it using RLE method.</comment>
<function><type><name>int32_t</name></type> <name>tsCompressBoolImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>pos</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>ele_per_byte</name> <init>= <expr><name>BITS_PER_BYTE</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name>ele_per_byte</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>output</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>uint8_t</name></type> <name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>i</name> <operator>%</operator> <name>ele_per_byte</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>output</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>|=</operator> <name>t</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>i</name> <operator>%</operator> <name>ele_per_byte</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <comment type="block">/* t = (~((( uint8_t)1) &lt;&lt; (7-i%BITS_PER_BYTE))); */</comment>
      <expr_stmt><expr><name><name>output</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>&amp;=</operator> <name>t</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>TSDB_DATA_BOOL_NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">2</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>i</name> <operator>%</operator> <name>ele_per_byte</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      <comment type="block">/* t = (~((( uint8_t)1) &lt;&lt; (7-i%BITS_PER_BYTE))); */</comment>
      <expr_stmt><expr><name><name>output</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>|=</operator> <name>t</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>uError</name><argument_list>(<argument><expr><literal type="string">"Invalid compress bool value:%d"</literal></expr></argument>, <argument><expr><name><name>output</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressBoolImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>ipos</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>opos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>ele_per_byte</name> <init>= <expr><name>BITS_PER_BYTE</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name>ele_per_byte</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ipos</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>uint8_t</name></type> <name>ele</name> <init>= <expr><operator>(</operator><name><name>input</name><index>[<expr><name>ipos</name></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>i</name> <operator>%</operator> <name>ele_per_byte</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ele</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>output</name><index>[<expr><name>opos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ele</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>output</name><index>[<expr><name>opos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>TSDB_DATA_BOOL_NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>output</name><index>[<expr><name>opos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>nelements</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* Run Length Encoding(RLE) Method */</comment>
int32_t tsCompressBoolRLEImp(const char *const input, const int32_t nelements, char *const output) {
  int32_t _pos = 0;

  for (int32_t i = 0; i &lt; nelements;) {
    unsigned char counter = 1;
    char          num = input[i];

    for (++i; i &lt; nelements; i++) {
      if (input[i] == num) {
        counter++;
        if (counter == INT8MASK(7)) {
          i++;
          break;
        }
      } else {
        break;
      }
    }

    <comment type="line">// Encode the data.</comment>
    if (num == 1) {
      output[_pos++] = INT8MASK(1) | (counter &lt;&lt; 1);
    } else if (num == 0) {
      output[_pos++] = (counter &lt;&lt; 1) | INT8MASK(0);
    } else {
      uError("Invalid compress bool value:%d", output[_pos]);
      return -1;
    }
  }

  return _pos;
}

int32_t tsDecompressBoolRLEImp(const char *const input, const int32_t nelements, char *const output) {
  int32_t ipos = 0, opos = 0;
  while (1) {
    char     encode = input[ipos++];
    unsigned counter = (encode &gt;&gt; 1) &amp; INT8MASK(7);
    char     value = encode &amp; INT8MASK(1);

    memset(output + opos, value, counter);
    opos += counter;
    if (opos &gt;= nelements) {
      return nelements;
    }
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----------------------------------------------String Compression
 * ---------------------------------------------- */</comment>
<comment type="line">// Note: the size of the output must be larger than input_size + 1 and</comment>
<comment type="line">// LZ4_compressBound(size) + 1;</comment>
<comment type="line">// &gt;= max(input_size, LZ4_compressBound(input_size)) + 1;</comment>
<function><type><name>int32_t</name></type> <name>tsCompressStringImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputSize</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>outputSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// Try to compress using LZ4 algorithm.</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>compressed_data_size</name> <init>= <expr><call><name>LZ4_compress_default</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>, <argument><expr><name>outputSize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// If cannot compress or after compression, data becomes larger.</comment>
  <if_stmt><if>if <condition>(<expr><name>compressed_data_size</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>compressed_data_size</name> <operator>&gt;</operator> <name>inputSize</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* First byte is for indicator */</comment>
    <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>inputSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>inputSize</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>compressed_data_size</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressStringImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>outputSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// compressedSize is the size of data after compression.</comment>

  <if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* It is compressed by LZ4 algorithm */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>decompressed_size</name> <init>= <expr><call><name>LZ4_decompress_safe</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>compressedSize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>outputSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>decompressed_size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>uError</name><argument_list>(<argument><expr><literal type="string">"Failed to decompress string with LZ4 algorithm, decompressed size:%d"</literal></expr></argument>, <argument><expr><name>decompressed_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>decompressed_size</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* It is not compressed by LZ4 algorithm */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>compressedSize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>compressedSize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>uError</name><argument_list>(<argument><expr><literal type="string">"Invalid decompress string indicator:%d"</literal></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------Timestamp Compression
 * ---------------------------------------------- */</comment>
<comment type="line">// TODO: Take care here, we assumes little endian encoding.</comment>
<function><type><name>int32_t</name></type> <name>tsCompressTimestampImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>_pos</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nelements</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>nelements</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>istream</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>input</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int64_t</name></type> <name>prev_value</name> <init>= <expr><name><name>istream</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>prev_value</name> <operator>&gt;=</operator> <literal type="number">0x8000000000000000</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>uWarn</name><argument_list>(<argument><expr><literal type="string">"compression timestamp is over signed long long range. ts = 0x%"</literal> <name>PRIx64</name> <literal type="string">" \n"</literal></expr></argument>, <argument><expr><name>prev_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>_exit_over</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type>  <name>prev_delta</name> <init>= <expr><operator>-</operator><name>prev_value</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type>  <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>flag1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>flag2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>dd1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>dd2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>curr_value</name> <init>= <expr><name><name>istream</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>safeInt64Add</name><argument_list>(<argument><expr><name>curr_value</name></expr></argument>, <argument><expr><operator>-</operator><name>prev_value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit_over</name>;</goto></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>curr_delta</name> <init>= <expr><name>curr_value</name> <operator>-</operator> <name>prev_value</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>safeInt64Add</name><argument_list>(<argument><expr><name>curr_delta</name></expr></argument>, <argument><expr><operator>-</operator><name>prev_delta</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit_over</name>;</goto></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>delta_of_delta</name> <init>= <expr><name>curr_delta</name> <operator>-</operator> <name>prev_delta</name></expr></init></decl>;</decl_stmt>
    <comment type="line">// zigzag encode the value.</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>zigzag_value</name> <init>= <expr><call><name>ZIGZAG_ENCODE</name><argument_list>(<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>delta_of_delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>dd1</name> <operator>=</operator> <name>zigzag_value</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>dd1</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>flag1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>flag1</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>LONG_BYTES</name> <operator>-</operator> <call><name>BUILDIN_CLZL</name><argument_list>(<argument><expr><name>dd1</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>BITS_PER_BYTE</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>dd2</name> <operator>=</operator> <name>zigzag_value</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>dd2</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>flag2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>flag2</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>LONG_BYTES</name> <operator>-</operator> <call><name>BUILDIN_CLZL</name><argument_list>(<argument><expr><name>dd2</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>BITS_PER_BYTE</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>flag1</name> <operator>|</operator> <operator>(</operator><name>flag2</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
      <comment type="line">// Encode the flag.</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>_pos</name> <operator>+</operator> <name>CHAR_BYTES</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit_over</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <name>_pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>CHAR_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>_pos</name> <operator>+=</operator> <name>CHAR_BYTES</name></expr>;</expr_stmt>
      <comment type="block">/* Here, we assume it is little endian encoding method. */</comment>
      <comment type="line">// Encode dd1</comment>
      <if_stmt><if>if <condition>(<expr><call><name>is_bigendian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>_pos</name> <operator>+</operator> <name>flag1</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit_over</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <name>_pos</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>dd1</name><operator>)</operator> <operator>+</operator> <name>LONG_BYTES</name> <operator>-</operator> <name>flag1</name></expr></argument>, <argument><expr><name>flag1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>_pos</name> <operator>+</operator> <name>flag1</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit_over</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <name>_pos</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>dd1</name><operator>)</operator></expr></argument>, <argument><expr><name>flag1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>_pos</name> <operator>+=</operator> <name>flag1</name></expr>;</expr_stmt>
      <comment type="line">// Encode dd2;</comment>
      <if_stmt><if>if <condition>(<expr><call><name>is_bigendian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>_pos</name> <operator>+</operator> <name>flag2</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit_over</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <name>_pos</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>dd2</name><operator>)</operator> <operator>+</operator> <name>LONG_BYTES</name> <operator>-</operator> <name>flag2</name></expr></argument>, <argument><expr><name>flag2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>_pos</name> <operator>+</operator> <name>flag2</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit_over</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <name>_pos</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>dd2</name><operator>)</operator></expr></argument>, <argument><expr><name>flag2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>_pos</name> <operator>+=</operator> <name>flag2</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>prev_value</name> <operator>=</operator> <name>curr_value</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev_delta</name> <operator>=</operator> <name>curr_delta</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>nelements</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>flag2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>flag1</name> <operator>|</operator> <operator>(</operator><name>flag2</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
    <comment type="line">// Encode the flag.</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>_pos</name> <operator>+</operator> <name>CHAR_BYTES</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit_over</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <name>_pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>CHAR_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>_pos</name> <operator>+=</operator> <name>CHAR_BYTES</name></expr>;</expr_stmt>
    <comment type="line">// Encode dd1;</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_bigendian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>_pos</name> <operator>+</operator> <name>flag1</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit_over</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <name>_pos</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>dd1</name><operator>)</operator> <operator>+</operator> <name>LONG_BYTES</name> <operator>-</operator> <name>flag1</name></expr></argument>, <argument><expr><name>flag1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>_pos</name> <operator>+</operator> <name>flag1</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit_over</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <name>_pos</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>dd1</name><operator>)</operator></expr></argument>, <argument><expr><name>flag1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>_pos</name> <operator>+=</operator> <name>flag1</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="line">// Means the string is compressed</comment>
  <return>return <expr><name>_pos</name></expr>;</return>

<label><name>_exit_over</name>:</label>
  <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="line">// Means the string is not compressed</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressTimestampImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nelements</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>nelements</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="line">// Decompress</comment>
    <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>ostream</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>output</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>ipos</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>opos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int8_t</name></type>  <name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>prev_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>prev_delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>delta_of_delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>flags</name> <init>= <expr><name><name>input</name><index>[<expr><name>ipos</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <comment type="line">// Decode dd1</comment>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>dd1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>flags</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>delta_of_delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>is_bigendian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>dd1</name><operator>)</operator><operator>)</operator> <operator>+</operator> <name>LONG_BYTES</name> <operator>-</operator> <name>nbytes</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <name>ipos</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dd1</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <name>ipos</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>delta_of_delta</name> <operator>=</operator> <call><name>ZIGZAG_DECODE</name><argument_list>(<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>dd1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>ipos</name> <operator>+=</operator> <name>nbytes</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>opos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>prev_value</name> <operator>=</operator> <name>delta_of_delta</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev_delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ostream</name><index>[<expr><name>opos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>delta_of_delta</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>prev_delta</name> <operator>=</operator> <name>delta_of_delta</name> <operator>+</operator> <name>prev_delta</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev_value</name> <operator>=</operator> <name>prev_value</name> <operator>+</operator> <name>prev_delta</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ostream</name><index>[<expr><name>opos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>prev_value</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>opos</name> <operator>==</operator> <name>nelements</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr>;</return></block_content></block></if></if_stmt>

      <comment type="line">// Decode dd2</comment>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>dd2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>delta_of_delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>is_bigendian</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>dd2</name><operator>)</operator><operator>)</operator> <operator>+</operator> <name>LONG_BYTES</name> <operator>-</operator> <name>nbytes</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <name>ipos</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dd2</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <name>ipos</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="line">// zigzag_decoding</comment>
        <expr_stmt><expr><name>delta_of_delta</name> <operator>=</operator> <call><name>ZIGZAG_DECODE</name><argument_list>(<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>dd2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>ipos</name> <operator>+=</operator> <name>nbytes</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>prev_delta</name> <operator>=</operator> <name>delta_of_delta</name> <operator>+</operator> <name>prev_delta</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>prev_value</name> <operator>=</operator> <name>prev_value</name> <operator>+</operator> <name>prev_delta</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ostream</name><index>[<expr><name>opos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>prev_value</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>opos</name> <operator>==</operator> <name>nelements</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>nelements</name> <operator>*</operator> <name>LONG_BYTES</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></while>

  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<comment type="block">/* --------------------------------------------Double Compression
 * ---------------------------------------------- */</comment>
<function><type><name>void</name></type> <name>encodeDoubleValue</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>diff</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>nbytes</name> <init>= <expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>nshift</name> <init>= <expr><operator>(</operator><name>LONG_BYTES</name> <operator>*</operator> <name>BITS_PER_BYTE</name> <operator>-</operator> <name>nbytes</name> <operator>*</operator> <name>BITS_PER_BYTE</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>flag</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>diff</name> <operator>&gt;&gt;=</operator> <name>nshift</name></expr>;</expr_stmt>

  <while>while <condition>(<expr><name>nbytes</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>output</name><index>[<expr><operator>(</operator><operator>*</operator><name>pos</name><operator>)</operator><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int8_t</name><operator>)</operator><operator>(</operator><name>diff</name> <operator>&amp;</operator> <call><name>INT64MASK</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>diff</name> <operator>&gt;&gt;=</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nbytes</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsCompressDoubleImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>byte_limit</name> <init>= <expr><name>nelements</name> <operator>*</operator> <name>DOUBLE_BYTES</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>opos</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>uint64_t</name></type> <name>prev_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>prev_diff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type>  <name>prev_flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>istream</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>input</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// Main loop</comment>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <union>union <block>{
      <decl_stmt><decl><type><name>double</name></type>   <name>real</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>bits</name></decl>;</decl_stmt>
    }</block> <decl><name>curr</name></decl>;</union>

    <expr_stmt><expr><name><name>curr</name><operator>.</operator><name>real</name></name> <operator>=</operator> <name><name>istream</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="line">// Here we assume the next value is the same as previous one.</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>predicted</name> <init>= <expr><name>prev_value</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>diff</name> <init>= <expr><name><name>curr</name><operator>.</operator><name>bits</name></name> <operator>^</operator> <name>predicted</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>leading_zeros</name> <init>= <expr><name>LONG_BYTES</name> <operator>*</operator> <name>BITS_PER_BYTE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>trailing_zeros</name> <init>= <expr><name>leading_zeros</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>diff</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>trailing_zeros</name> <operator>=</operator> <call><name>BUILDIN_CTZL</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>leading_zeros</name> <operator>=</operator> <call><name>BUILDIN_CLZL</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>uint8_t</name></type> <name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>flag</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>trailing_zeros</name> <operator>&gt;</operator> <name>leading_zeros</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>LONG_BYTES</name> <operator>-</operator> <name>trailing_zeros</name> <operator>/</operator> <name>BITS_PER_BYTE</name><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nbytes</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>flag</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name>nbytes</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>LONG_BYTES</name> <operator>-</operator> <name>leading_zeros</name> <operator>/</operator> <name>BITS_PER_BYTE</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nbytes</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>flag</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>prev_diff</name> <operator>=</operator> <name>diff</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>prev_flag</name> <operator>=</operator> <name>flag</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>nbyte1</name> <init>= <expr><operator>(</operator><name>prev_flag</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>nbyte2</name> <init>= <expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>opos</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>nbyte1</name> <operator>+</operator> <name>nbyte2</name> <operator>&lt;=</operator> <name>byte_limit</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>flags</name> <init>= <expr><name>prev_flag</name> <operator>|</operator> <operator>(</operator><name>flag</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>output</name><index>[<expr><name>opos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>encodeDoubleValue</name><argument_list>(<argument><expr><name>prev_diff</name></expr></argument>, <argument><expr><name>prev_flag</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>encodeDoubleValue</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>byte_limit</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>byte_limit</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>prev_value</name> <operator>=</operator> <name><name>curr</name><operator>.</operator><name>bits</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>nelements</name> <operator>%</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>nbyte1</name> <init>= <expr><operator>(</operator><name>prev_flag</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>nbyte2</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>opos</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>nbyte1</name> <operator>+</operator> <name>nbyte2</name> <operator>&lt;=</operator> <name>byte_limit</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>flags</name> <init>= <expr><name>prev_flag</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>output</name><index>[<expr><name>opos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>encodeDoubleValue</name><argument_list>(<argument><expr><name>prev_diff</name></expr></argument>, <argument><expr><name>prev_flag</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>encodeDoubleValue</name><argument_list>(<argument><expr><literal type="number">0ul</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>byte_limit</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>byte_limit</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>opos</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type> <name>decodeDoubleValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ipos</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flag</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>diff</name> <init>= <expr><literal type="number">0ul</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>nbytes</name> <init>= <expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbytes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>diff</name> <operator>=</operator> <name>diff</name> <operator>|</operator> <operator>(</operator><operator>(</operator><call><name>INT64MASK</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name><name>input</name><index>[<expr><operator>(</operator><operator>*</operator><name>ipos</name><operator>)</operator><operator>++</operator></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <name>BITS_PER_BYTE</name> <operator>*</operator> <name>i</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>shift_width</name> <init>= <expr><operator>(</operator><name>LONG_BYTES</name> <operator>*</operator> <name>BITS_PER_BYTE</name> <operator>-</operator> <name>nbytes</name> <operator>*</operator> <name>BITS_PER_BYTE</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>flag</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>diff</name> <operator>&lt;&lt;=</operator> <name>shift_width</name></expr>;</expr_stmt>

  <return>return <expr><name>diff</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressDoubleImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// output stream</comment>
  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>ostream</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>output</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>nelements</name> <operator>*</operator> <name>DOUBLE_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nelements</name> <operator>*</operator> <name>DOUBLE_BYTES</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>uint8_t</name></type>  <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>ipos</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>opos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>prev_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>input</name><index>[<expr><name>ipos</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>uint8_t</name></type> <name>flag</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>flags</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>diff</name> <init>= <expr><call><name>decodeDoubleValue</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ipos</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <union>union <block>{
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>bits</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type>   <name>real</name></decl>;</decl_stmt>
    }</block> <decl><name>curr</name></decl>;</union>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>predicted</name> <init>= <expr><name>prev_value</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>curr</name><operator>.</operator><name>bits</name></name> <operator>=</operator> <name>predicted</name> <operator>^</operator> <name>diff</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev_value</name> <operator>=</operator> <name><name>curr</name><operator>.</operator><name>bits</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ostream</name><index>[<expr><name>opos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>curr</name><operator>.</operator><name>real</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>nelements</name> <operator>*</operator> <name>DOUBLE_BYTES</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------Float Compression
 * ---------------------------------------------- */</comment>
<function><type><name>void</name></type> <name>encodeFloatValue</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>diff</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>nbytes</name> <init>= <expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>nshift</name> <init>= <expr><operator>(</operator><name>FLOAT_BYTES</name> <operator>*</operator> <name>BITS_PER_BYTE</name> <operator>-</operator> <name>nbytes</name> <operator>*</operator> <name>BITS_PER_BYTE</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>flag</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>diff</name> <operator>&gt;&gt;=</operator> <name>nshift</name></expr>;</expr_stmt>

  <while>while <condition>(<expr><name>nbytes</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>output</name><index>[<expr><operator>(</operator><operator>*</operator><name>pos</name><operator>)</operator><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int8_t</name><operator>)</operator><operator>(</operator><name>diff</name> <operator>&amp;</operator> <call><name>INT32MASK</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>diff</name> <operator>&gt;&gt;=</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nbytes</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsCompressFloatImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name>  <modifier>*</modifier></type><name>istream</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>input</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>byte_limit</name> <init>= <expr><name>nelements</name> <operator>*</operator> <name>FLOAT_BYTES</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>opos</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>uint32_t</name></type> <name>prev_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>prev_diff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type>  <name>prev_flag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// Main loop</comment>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <union>union <block>{
      <decl_stmt><decl><type><name>float</name></type>    <name>real</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
    }</block> <decl><name>curr</name></decl>;</union>

    <expr_stmt><expr><name><name>curr</name><operator>.</operator><name>real</name></name> <operator>=</operator> <name><name>istream</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="line">// Here we assume the next value is the same as previous one.</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>predicted</name> <init>= <expr><name>prev_value</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>diff</name> <init>= <expr><name><name>curr</name><operator>.</operator><name>bits</name></name> <operator>^</operator> <name>predicted</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>clz</name> <init>= <expr><name>FLOAT_BYTES</name> <operator>*</operator> <name>BITS_PER_BYTE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>ctz</name> <init>= <expr><name>clz</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>diff</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>ctz</name> <operator>=</operator> <call><name>BUILDIN_CTZ</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>clz</name> <operator>=</operator> <call><name>BUILDIN_CLZ</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>uint8_t</name></type> <name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>flag</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ctz</name> <operator>&gt;</operator> <name>clz</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>FLOAT_BYTES</name> <operator>-</operator> <name>ctz</name> <operator>/</operator> <name>BITS_PER_BYTE</name><operator>)</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nbytes</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>flag</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name>nbytes</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>FLOAT_BYTES</name> <operator>-</operator> <name>clz</name> <operator>/</operator> <name>BITS_PER_BYTE</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nbytes</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>flag</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>prev_diff</name> <operator>=</operator> <name>diff</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>prev_flag</name> <operator>=</operator> <name>flag</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>nbyte1</name> <init>= <expr><operator>(</operator><name>prev_flag</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>nbyte2</name> <init>= <expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>opos</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>nbyte1</name> <operator>+</operator> <name>nbyte2</name> <operator>&lt;=</operator> <name>byte_limit</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>flags</name> <init>= <expr><name>prev_flag</name> <operator>|</operator> <operator>(</operator><name>flag</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>output</name><index>[<expr><name>opos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>encodeFloatValue</name><argument_list>(<argument><expr><name>prev_diff</name></expr></argument>, <argument><expr><name>prev_flag</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>encodeFloatValue</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>byte_limit</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>byte_limit</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>prev_value</name> <operator>=</operator> <name><name>curr</name><operator>.</operator><name>bits</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>nelements</name> <operator>%</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>nbyte1</name> <init>= <expr><operator>(</operator><name>prev_flag</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>nbyte2</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>opos</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>nbyte1</name> <operator>+</operator> <name>nbyte2</name> <operator>&lt;=</operator> <name>byte_limit</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>flags</name> <init>= <expr><name>prev_flag</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>output</name><index>[<expr><name>opos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>encodeFloatValue</name><argument_list>(<argument><expr><name>prev_diff</name></expr></argument>, <argument><expr><name>prev_flag</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>encodeFloatValue</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>byte_limit</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>byte_limit</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>opos</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32_t</name></type> <name>decodeFloatValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ipos</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flag</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>diff</name> <init>= <expr><literal type="number">0ul</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>nbytes</name> <init>= <expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbytes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>diff</name> <operator>=</operator> <name>diff</name> <operator>|</operator> <operator>(</operator><operator>(</operator><call><name>INT32MASK</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name><name>input</name><index>[<expr><operator>(</operator><operator>*</operator><name>ipos</name><operator>)</operator><operator>++</operator></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <name>BITS_PER_BYTE</name> <operator>*</operator> <name>i</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>shift_width</name> <init>= <expr><operator>(</operator><name>FLOAT_BYTES</name> <operator>*</operator> <name>BITS_PER_BYTE</name> <operator>-</operator> <name>nbytes</name> <operator>*</operator> <name>BITS_PER_BYTE</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>flag</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>diff</name> <operator>&lt;&lt;=</operator> <name>shift_width</name></expr>;</expr_stmt>

  <return>return <expr><name>diff</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressFloatImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>ostream</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>output</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>nelements</name> <operator>*</operator> <name>FLOAT_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nelements</name> <operator>*</operator> <name>FLOAT_BYTES</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>uint8_t</name></type>  <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>ipos</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>opos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>prev_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>input</name><index>[<expr><name>ipos</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>uint8_t</name></type> <name>flag</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <call><name>INT8MASK</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>flags</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint32_t</name></type> <name>diff</name> <init>= <expr><call><name>decodeFloatValue</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ipos</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <union>union <block>{
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>float</name></type>    <name>real</name></decl>;</decl_stmt>
    }</block> <decl><name>curr</name></decl>;</union>

    <decl_stmt><decl><type><name>uint32_t</name></type> <name>predicted</name> <init>= <expr><name>prev_value</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>curr</name><operator>.</operator><name>bits</name></name> <operator>=</operator> <name>predicted</name> <operator>^</operator> <name>diff</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev_value</name> <operator>=</operator> <name><name>curr</name><operator>.</operator><name>bits</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ostream</name><index>[<expr><name>opos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>curr</name><operator>.</operator><name>real</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>nelements</name> <operator>*</operator> <name>FLOAT_BYTES</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TD_TSZ</name></cpp:ifdef>
<comment type="line">//</comment>
<comment type="line">//   ----------  float double lossy  -----------</comment>
<comment type="line">//</comment>
<function><type><name>int32_t</name></type> <name>tsCompressFloatLossyImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// compress with sz</comment>
  <decl_stmt><decl><type><name>int32_t</name></type>       <name>compressedSize</name> <init>= <expr><call><name>tdszCompress</name><argument_list>(<argument><expr><name>SZ_FLOAT</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>nelements</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>algo</name> <init>= <expr><name>ALGO_SZ_LOSSY</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>compressedSize</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>compressedSize</name> <operator>&gt;=</operator> <name>nelements</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
    <comment type="line">// compressed error or large than original</comment>
    <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>MODE_NOCOMPRESS</name> <operator>|</operator> <name>algo</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>nelements</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>compressedSize</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>nelements</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="line">// compressed successfully</comment>
    <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>MODE_COMPRESS</name> <operator>|</operator> <name>algo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>compressedSize</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>compressedSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressFloatLossyImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>,
                                  <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>decompressedSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>HEAD_MODE</name><argument_list>(<argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MODE_NOCOMPRESS</name></expr>)</condition> <block>{<block_content>
    <comment type="line">// orginal so memcpy directly</comment>
    <expr_stmt><expr><name>decompressedSize</name> <operator>=</operator> <name>nelements</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>decompressedSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>decompressedSize</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// decompressed with sz</comment>
  <return>return <expr><call><name>tdszDecompress</name><argument_list>(<argument><expr><name>SZ_FLOAT</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>compressedSize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>nelements</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsCompressDoubleLossyImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// compress with sz</comment>
  <decl_stmt><decl><type><name>int32_t</name></type>       <name>compressedSize</name> <init>= <expr><call><name>tdszCompress</name><argument_list>(<argument><expr><name>SZ_DOUBLE</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>nelements</name></expr></argument>, <argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>algo</name> <init>= <expr><name>ALGO_SZ_LOSSY</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>compressedSize</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>compressedSize</name> <operator>&gt;=</operator> <name>nelements</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
    <comment type="line">// compressed error or large than original</comment>
    <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>MODE_NOCOMPRESS</name> <operator>|</operator> <name>algo</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>nelements</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>compressedSize</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>nelements</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="line">// compressed successfully</comment>
    <expr_stmt><expr><name><name>output</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>MODE_COMPRESS</name> <operator>|</operator> <name>algo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>compressedSize</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>compressedSize</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressDoubleLossyImp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>compressedSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name></type> <name>nelements</name></decl></parameter>,
                                   <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>decompressedSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>HEAD_MODE</name><argument_list>(<argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MODE_NOCOMPRESS</name></expr>)</condition> <block>{<block_content>
    <comment type="line">// orginal so memcpy directly</comment>
    <expr_stmt><expr><name>decompressedSize</name> <operator>=</operator> <name>nelements</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>decompressedSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>decompressedSize</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// decompressed with sz</comment>
  <return>return <expr><call><name>tdszDecompress</name><argument_list>(<argument><expr><name>SZ_DOUBLE</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>compressedSize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>nelements</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*************************************************************************
 *                  STREAM COMPRESSION
 *************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I64_SAFE_ADD</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((a) &gt;= 0 &amp;&amp; (b) &lt;= INT64_MAX - (a)) || ((a) &lt; 0 &amp;&amp; (b) &gt;= INT64_MIN - (a)))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompBoolStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompBool</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompBoolEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nData</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompIntStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompInt</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompIntEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nData</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompFloatStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompFloat</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompFloatEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nData</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompDoubleStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompDouble</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompDoubleEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nData</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompTimestampStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompTimestamp</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompTimestampEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nData</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompBinaryStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompBinary</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompBinaryEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nData</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int64_t</name></type> <name>tGetI64OfI8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int64_t</name></type> <name>tGetI64OfI16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int64_t</name></type> <name>tGetI64OfI32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int64_t</name></type> <name>tGetI64OfI64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>void</name></type> <name>tPutI64OfI8</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>pData</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>void</name></type> <name>tPutI64OfI16</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>pData</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>void</name></type> <name>tPutI64OfI32</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>pData</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>void</name></type> <name>tPutI64OfI64</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>pData</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt> </block_content>}</block></function>

<struct><specifier>static</specifier> struct <block>{
  <decl_stmt><decl><type><name>int8_t</name></type>  <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>bytes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type>  <name>isVarLen</name></decl>;</decl_stmt>
  <function_decl><type><name>int32_t</name></type> (<modifier>*</modifier><name>startFn</name>)<parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list>;</function_decl>
  <function_decl><type><name>int32_t</name></type> (<modifier>*</modifier><name>cmprFn</name>)<parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list>;</function_decl>
  <function_decl><type><name>int32_t</name></type> (<modifier>*</modifier><name>endFn</name>)<parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  <function_decl><type><name>int64_t</name></type> (<modifier>*</modifier><name>getI64</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>putI64</name>)<parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>)</parameter_list>;</function_decl>
}</block> <decl><name><name>DATA_TYPE_INFO</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_NULL</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_BOOL</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompBoolStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompBool</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompBoolEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_TINYINT</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompIntStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompInt</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompIntEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>tGetI64OfI8</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>tPutI64OfI8</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_SMALLINT</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">2</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompIntStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompInt</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompIntEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>tGetI64OfI16</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>tPutI64OfI16</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_INT</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">4</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompIntStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompInt</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompIntEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>tGetI64OfI32</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>tPutI64OfI32</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_BIGINT</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">8</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompIntStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompInt</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompIntEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>tGetI64OfI64</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>tPutI64OfI64</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_FLOAT</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">4</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompFloatStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompFloat</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompFloatEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_DOUBLE</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">8</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompDoubleStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompDouble</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompDoubleEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_VARCHAR</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompBinaryStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompBinary</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompBinaryEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">8</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompTimestampStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompTimestamp</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompTimestampEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompBinaryStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompBinary</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompBinaryEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_UTINYINT</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompIntStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompInt</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompIntEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>tGetI64OfI8</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>tPutI64OfI8</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_USMALLINT</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">2</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompIntStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompInt</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompIntEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>tGetI64OfI16</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>tPutI64OfI16</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_UINT</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">4</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompIntStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompInt</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompIntEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>tGetI64OfI32</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>tPutI64OfI32</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_UBIGINT</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">8</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">0</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompIntStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompInt</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompIntEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>tGetI64OfI64</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>tPutI64OfI64</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_JSON</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompBinaryStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompBinary</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompBinaryEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_VARBINARY</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompBinaryStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompBinary</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompBinaryEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_DECIMAL</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompBinaryStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompBinary</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompBinaryEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_BLOB</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompBinaryStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompBinary</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompBinaryEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>TSDB_DATA_TYPE_MEDIUMBLOB</name></expr>,
     <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>isVarLen</name> <operator>=</operator> <literal type="number">1</literal></expr>,
     <expr><operator>.</operator><name>startFn</name> <operator>=</operator> <name>tCompBinaryStart</name></expr>,
     <expr><operator>.</operator><name>cmprFn</name> <operator>=</operator> <name>tCompBinary</name></expr>,
     <expr><operator>.</operator><name>endFn</name> <operator>=</operator> <name>tCompBinaryEnd</name></expr>,
     <expr><operator>.</operator><name>getI64</name> <operator>=</operator> <name>NULL</name></expr>,
     <expr><operator>.</operator><name>putI64</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>,
}</block></expr></init></decl>;</struct>

<struct>struct <name>SCompressor</name> <block>{
  <decl_stmt><decl><type><name>int8_t</name></type>   <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type>   <name>cmprAlg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type>   <name>autoAlloc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>nVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pBuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>nBuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name><name>aBuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
  <union>union <block>{
    <comment type="line">// Timestamp ----</comment>
    <struct>struct <block>{
      <decl_stmt><decl><type><name>int64_t</name></type>  <name>ts_prev_val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int64_t</name></type>  <name>ts_prev_delta</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>ts_flag_p</name></decl>;</decl_stmt>
    }</block>;</struct>
    <comment type="line">// Integer ----</comment>
    <struct>struct <block>{
      <decl_stmt><decl><type><name>int64_t</name></type>  <name>i_prev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type>  <name>i_selector</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type>  <name>i_start</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type>  <name>i_end</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type>  <name>i_nEle</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name><name>i_aZigzag</name><index>[<expr><literal type="number">241</literal></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int8_t</name></type>   <name><name>i_aBitN</name><index>[<expr><literal type="number">241</literal></expr>]</index></name></decl>;</decl_stmt>
    }</block>;</struct>
    <comment type="line">// Float ----</comment>
    <struct>struct <block>{
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>f_prev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>f_flag_p</name></decl>;</decl_stmt>
    }</block>;</struct>
    <comment type="line">// Double ----</comment>
    <struct>struct <block>{
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>d_prev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>d_flag_p</name></decl>;</decl_stmt>
    }</block>;</struct>
  }</block>;</union>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tTwoStageComp</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>szComp</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>szComp</name> <operator>=</operator> <call><name>LZ4_compress_default</name><argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>szComp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>szComp</name> <operator>&lt;</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>szComp</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>szComp</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Timestamp =====================================================</comment>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompTimestampStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompTSSwitchToCopy</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit</name>;</goto></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>nBuf</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>delta</name></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>iVal</name> <operator>&lt;</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</condition><incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>aN</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator></expr>, <expr><operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>vZigzag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>uint8_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>aN</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>vZigzag</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name>n</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">8</literal> <operator>*</operator> <name>j</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>

      <decl_stmt><decl><type><name>int64_t</name></type> <name>delta_of_delta</name> <init>= <expr><call><name>ZIGZAG_DECODE</name><argument_list>(<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>vZigzag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>iVal</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>delta</name> <operator>=</operator> <name>delta_of_delta</name> <operator>+</operator> <name>delta</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <name>delta</name> <operator>+</operator> <name>value</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <name>delta_of_delta</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>nBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nBuf</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

      <expr_stmt><expr><name>iVal</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>iVal</name> <operator>&gt;=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>&amp;&amp;</operator> <name>nBuf</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pBuf</name> <init>= <expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pBuf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <name>nBuf</name></expr>;</expr_stmt>

<label><name>_exit</name>:</label>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompTimestamp</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int64_t</name></type> <name>ts</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>pData</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>nData</name> <operator>==</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>ts_prev_val</name></name> <operator>=</operator> <name>ts</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>ts_prev_delta</name></name> <operator>=</operator> <operator>-</operator><name>ts</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>I64_SAFE_ADD</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><operator>-</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>ts_prev_val</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tCompTSSwitchToCopy</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
      <goto>goto <name>_copy_cmpr</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>delta</name> <init>= <expr><name>ts</name> <operator>-</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>ts_prev_val</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>I64_SAFE_ADD</name><argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr><operator>-</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>ts_prev_delta</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tCompTSSwitchToCopy</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
      <goto>goto <name>_copy_cmpr</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type>  <name>delta_of_delta</name> <init>= <expr><name>delta</name> <operator>-</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>ts_prev_delta</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>vZigzag</name> <init>= <expr><call><name>ZIGZAG_ENCODE</name><argument_list>(<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>delta_of_delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>ts_prev_val</name></name> <operator>=</operator> <name>ts</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>ts_prev_delta</name></name> <operator>=</operator> <name>delta</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>&amp;</operator> <literal type="number">0x1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+</operator> <literal type="number">17</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>code</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>ts_flag_p</name></name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>+</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>ts_flag_p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <while>while <condition>(<expr><name>vZigzag</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>vZigzag</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>ts_flag_p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>vZigzag</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <while>while <condition>(<expr><name>vZigzag</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>vZigzag</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>ts_flag_p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">0x10</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>vZigzag</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
  <label><name>_copy_cmpr</name>:</label>
    <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>+</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name><operator>++</operator></expr>;</expr_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompTimestampEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tCompTSSwitchToCopy</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>cmprAlg</name></name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tTwoStageComp</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>cmprAlg</name></name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>nData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Integer =====================================================</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIMPLE8B_MAX</name></cpp:macro> <cpp:value>((uint64_t)1152921504606846974LL)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>BIT_PER_INTEGER</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">60</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int32_t</name></type> <name><name>SELECTOR_TO_ELEMS</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">240</literal></expr>, <expr><literal type="number">120</literal></expr>, <expr><literal type="number">60</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>BIT_TO_SELECTOR</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">9</literal></expr>,  <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">12</literal></expr>,
                                          <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>,
                                          <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>,
                                          <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">15</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int32_t</name></type> <name><name>NEXT_IDX</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">2</literal></expr>,   <expr><literal type="number">3</literal></expr>,   <expr><literal type="number">4</literal></expr>,   <expr><literal type="number">5</literal></expr>,   <expr><literal type="number">6</literal></expr>,   <expr><literal type="number">7</literal></expr>,   <expr><literal type="number">8</literal></expr>,   <expr><literal type="number">9</literal></expr>,   <expr><literal type="number">10</literal></expr>,  <expr><literal type="number">11</literal></expr>,  <expr><literal type="number">12</literal></expr>,  <expr><literal type="number">13</literal></expr>,  <expr><literal type="number">14</literal></expr>,  <expr><literal type="number">15</literal></expr>,  <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">17</literal></expr>,  <expr><literal type="number">18</literal></expr>,  <expr><literal type="number">19</literal></expr>,  <expr><literal type="number">20</literal></expr>,  <expr><literal type="number">21</literal></expr>,  <expr><literal type="number">22</literal></expr>,
    <expr><literal type="number">23</literal></expr>,  <expr><literal type="number">24</literal></expr>,  <expr><literal type="number">25</literal></expr>,  <expr><literal type="number">26</literal></expr>,  <expr><literal type="number">27</literal></expr>,  <expr><literal type="number">28</literal></expr>,  <expr><literal type="number">29</literal></expr>,  <expr><literal type="number">30</literal></expr>,  <expr><literal type="number">31</literal></expr>,  <expr><literal type="number">32</literal></expr>,  <expr><literal type="number">33</literal></expr>,  <expr><literal type="number">34</literal></expr>,  <expr><literal type="number">35</literal></expr>,  <expr><literal type="number">36</literal></expr>,  <expr><literal type="number">37</literal></expr>,  <expr><literal type="number">38</literal></expr>,  <expr><literal type="number">39</literal></expr>,  <expr><literal type="number">40</literal></expr>,  <expr><literal type="number">41</literal></expr>,  <expr><literal type="number">42</literal></expr>,  <expr><literal type="number">43</literal></expr>,  <expr><literal type="number">44</literal></expr>,
    <expr><literal type="number">45</literal></expr>,  <expr><literal type="number">46</literal></expr>,  <expr><literal type="number">47</literal></expr>,  <expr><literal type="number">48</literal></expr>,  <expr><literal type="number">49</literal></expr>,  <expr><literal type="number">50</literal></expr>,  <expr><literal type="number">51</literal></expr>,  <expr><literal type="number">52</literal></expr>,  <expr><literal type="number">53</literal></expr>,  <expr><literal type="number">54</literal></expr>,  <expr><literal type="number">55</literal></expr>,  <expr><literal type="number">56</literal></expr>,  <expr><literal type="number">57</literal></expr>,  <expr><literal type="number">58</literal></expr>,  <expr><literal type="number">59</literal></expr>,  <expr><literal type="number">60</literal></expr>,  <expr><literal type="number">61</literal></expr>,  <expr><literal type="number">62</literal></expr>,  <expr><literal type="number">63</literal></expr>,  <expr><literal type="number">64</literal></expr>,  <expr><literal type="number">65</literal></expr>,  <expr><literal type="number">66</literal></expr>,
    <expr><literal type="number">67</literal></expr>,  <expr><literal type="number">68</literal></expr>,  <expr><literal type="number">69</literal></expr>,  <expr><literal type="number">70</literal></expr>,  <expr><literal type="number">71</literal></expr>,  <expr><literal type="number">72</literal></expr>,  <expr><literal type="number">73</literal></expr>,  <expr><literal type="number">74</literal></expr>,  <expr><literal type="number">75</literal></expr>,  <expr><literal type="number">76</literal></expr>,  <expr><literal type="number">77</literal></expr>,  <expr><literal type="number">78</literal></expr>,  <expr><literal type="number">79</literal></expr>,  <expr><literal type="number">80</literal></expr>,  <expr><literal type="number">81</literal></expr>,  <expr><literal type="number">82</literal></expr>,  <expr><literal type="number">83</literal></expr>,  <expr><literal type="number">84</literal></expr>,  <expr><literal type="number">85</literal></expr>,  <expr><literal type="number">86</literal></expr>,  <expr><literal type="number">87</literal></expr>,  <expr><literal type="number">88</literal></expr>,
    <expr><literal type="number">89</literal></expr>,  <expr><literal type="number">90</literal></expr>,  <expr><literal type="number">91</literal></expr>,  <expr><literal type="number">92</literal></expr>,  <expr><literal type="number">93</literal></expr>,  <expr><literal type="number">94</literal></expr>,  <expr><literal type="number">95</literal></expr>,  <expr><literal type="number">96</literal></expr>,  <expr><literal type="number">97</literal></expr>,  <expr><literal type="number">98</literal></expr>,  <expr><literal type="number">99</literal></expr>,  <expr><literal type="number">100</literal></expr>, <expr><literal type="number">101</literal></expr>, <expr><literal type="number">102</literal></expr>, <expr><literal type="number">103</literal></expr>, <expr><literal type="number">104</literal></expr>, <expr><literal type="number">105</literal></expr>, <expr><literal type="number">106</literal></expr>, <expr><literal type="number">107</literal></expr>, <expr><literal type="number">108</literal></expr>, <expr><literal type="number">109</literal></expr>, <expr><literal type="number">110</literal></expr>,
    <expr><literal type="number">111</literal></expr>, <expr><literal type="number">112</literal></expr>, <expr><literal type="number">113</literal></expr>, <expr><literal type="number">114</literal></expr>, <expr><literal type="number">115</literal></expr>, <expr><literal type="number">116</literal></expr>, <expr><literal type="number">117</literal></expr>, <expr><literal type="number">118</literal></expr>, <expr><literal type="number">119</literal></expr>, <expr><literal type="number">120</literal></expr>, <expr><literal type="number">121</literal></expr>, <expr><literal type="number">122</literal></expr>, <expr><literal type="number">123</literal></expr>, <expr><literal type="number">124</literal></expr>, <expr><literal type="number">125</literal></expr>, <expr><literal type="number">126</literal></expr>, <expr><literal type="number">127</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><literal type="number">129</literal></expr>, <expr><literal type="number">130</literal></expr>, <expr><literal type="number">131</literal></expr>, <expr><literal type="number">132</literal></expr>,
    <expr><literal type="number">133</literal></expr>, <expr><literal type="number">134</literal></expr>, <expr><literal type="number">135</literal></expr>, <expr><literal type="number">136</literal></expr>, <expr><literal type="number">137</literal></expr>, <expr><literal type="number">138</literal></expr>, <expr><literal type="number">139</literal></expr>, <expr><literal type="number">140</literal></expr>, <expr><literal type="number">141</literal></expr>, <expr><literal type="number">142</literal></expr>, <expr><literal type="number">143</literal></expr>, <expr><literal type="number">144</literal></expr>, <expr><literal type="number">145</literal></expr>, <expr><literal type="number">146</literal></expr>, <expr><literal type="number">147</literal></expr>, <expr><literal type="number">148</literal></expr>, <expr><literal type="number">149</literal></expr>, <expr><literal type="number">150</literal></expr>, <expr><literal type="number">151</literal></expr>, <expr><literal type="number">152</literal></expr>, <expr><literal type="number">153</literal></expr>, <expr><literal type="number">154</literal></expr>,
    <expr><literal type="number">155</literal></expr>, <expr><literal type="number">156</literal></expr>, <expr><literal type="number">157</literal></expr>, <expr><literal type="number">158</literal></expr>, <expr><literal type="number">159</literal></expr>, <expr><literal type="number">160</literal></expr>, <expr><literal type="number">161</literal></expr>, <expr><literal type="number">162</literal></expr>, <expr><literal type="number">163</literal></expr>, <expr><literal type="number">164</literal></expr>, <expr><literal type="number">165</literal></expr>, <expr><literal type="number">166</literal></expr>, <expr><literal type="number">167</literal></expr>, <expr><literal type="number">168</literal></expr>, <expr><literal type="number">169</literal></expr>, <expr><literal type="number">170</literal></expr>, <expr><literal type="number">171</literal></expr>, <expr><literal type="number">172</literal></expr>, <expr><literal type="number">173</literal></expr>, <expr><literal type="number">174</literal></expr>, <expr><literal type="number">175</literal></expr>, <expr><literal type="number">176</literal></expr>,
    <expr><literal type="number">177</literal></expr>, <expr><literal type="number">178</literal></expr>, <expr><literal type="number">179</literal></expr>, <expr><literal type="number">180</literal></expr>, <expr><literal type="number">181</literal></expr>, <expr><literal type="number">182</literal></expr>, <expr><literal type="number">183</literal></expr>, <expr><literal type="number">184</literal></expr>, <expr><literal type="number">185</literal></expr>, <expr><literal type="number">186</literal></expr>, <expr><literal type="number">187</literal></expr>, <expr><literal type="number">188</literal></expr>, <expr><literal type="number">189</literal></expr>, <expr><literal type="number">190</literal></expr>, <expr><literal type="number">191</literal></expr>, <expr><literal type="number">192</literal></expr>, <expr><literal type="number">193</literal></expr>, <expr><literal type="number">194</literal></expr>, <expr><literal type="number">195</literal></expr>, <expr><literal type="number">196</literal></expr>, <expr><literal type="number">197</literal></expr>, <expr><literal type="number">198</literal></expr>,
    <expr><literal type="number">199</literal></expr>, <expr><literal type="number">200</literal></expr>, <expr><literal type="number">201</literal></expr>, <expr><literal type="number">202</literal></expr>, <expr><literal type="number">203</literal></expr>, <expr><literal type="number">204</literal></expr>, <expr><literal type="number">205</literal></expr>, <expr><literal type="number">206</literal></expr>, <expr><literal type="number">207</literal></expr>, <expr><literal type="number">208</literal></expr>, <expr><literal type="number">209</literal></expr>, <expr><literal type="number">210</literal></expr>, <expr><literal type="number">211</literal></expr>, <expr><literal type="number">212</literal></expr>, <expr><literal type="number">213</literal></expr>, <expr><literal type="number">214</literal></expr>, <expr><literal type="number">215</literal></expr>, <expr><literal type="number">216</literal></expr>, <expr><literal type="number">217</literal></expr>, <expr><literal type="number">218</literal></expr>, <expr><literal type="number">219</literal></expr>, <expr><literal type="number">220</literal></expr>,
    <expr><literal type="number">221</literal></expr>, <expr><literal type="number">222</literal></expr>, <expr><literal type="number">223</literal></expr>, <expr><literal type="number">224</literal></expr>, <expr><literal type="number">225</literal></expr>, <expr><literal type="number">226</literal></expr>, <expr><literal type="number">227</literal></expr>, <expr><literal type="number">228</literal></expr>, <expr><literal type="number">229</literal></expr>, <expr><literal type="number">230</literal></expr>, <expr><literal type="number">231</literal></expr>, <expr><literal type="number">232</literal></expr>, <expr><literal type="number">233</literal></expr>, <expr><literal type="number">234</literal></expr>, <expr><literal type="number">235</literal></expr>, <expr><literal type="number">236</literal></expr>, <expr><literal type="number">237</literal></expr>, <expr><literal type="number">238</literal></expr>, <expr><literal type="number">239</literal></expr>, <expr><literal type="number">240</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompIntStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_prev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_start</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompIntSwitchToCopy</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit</name>;</goto></block_content></block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>size</name> <init>= <expr><name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>bytes</name> <operator>*</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>nBuf</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>vPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>b</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type>  <name>i_selector</name> <init>= <expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type>  <name>nEle</name> <init>= <expr><name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name>i_selector</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type>  <name>bits</name> <init>= <expr><name><name>BIT_PER_INTEGER</name><index>[<expr><name>i_selector</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>mask</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>bits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>iEle</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>iEle</name> <operator>&lt;</operator> <name>nEle</name></expr>;</condition> <incr><expr><name>iEle</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>vZigzag</name> <init>= <expr><operator>(</operator><name>b</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>bits</name> <operator>*</operator> <name>iEle</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>mask</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>vPrev</name> <operator>=</operator> <call><name>ZIGZAG_DECODE</name><argument_list>(<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>vZigzag</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>vPrev</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><call><name>putI64</name><argument_list>(<argument><expr><name>vPrev</name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nBuf</name> <operator>+=</operator> <name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>bytes</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></while>

  <while>while <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>vPrev</name> <operator>=</operator> <call><name>ZIGZAG_DECODE</name><argument_list>(<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_aZigzag</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_start</name></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>vPrev</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>nBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vPrev</name></expr></argument>, <argument><expr><name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nBuf</name> <operator>+=</operator> <name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>bytes</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_start</name></name> <operator>=</operator> <name><name>NEXT_IDX</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_start</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>&amp;&amp;</operator> <name>nBuf</name> <operator>==</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pBuf</name> <init>= <expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pBuf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<label><name>_exit</name>:</label>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompInt</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>nData</name> <operator>==</operator> <name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>val</name> <init>= <expr><name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><call><name>getI64</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>I64_SAFE_ADD</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>-</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_prev</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tCompIntSwitchToCopy</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
      <goto>goto <name>_copy_cmpr</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type>  <name>diff</name> <init>= <expr><name>val</name> <operator>-</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>i_prev</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>vZigzag</name> <init>= <expr><call><name>ZIGZAG_ENCODE</name><argument_list>(<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>vZigzag</name> <operator>&gt;=</operator> <name>SIMPLE8B_MAX</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tCompIntSwitchToCopy</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
      <goto>goto <name>_copy_cmpr</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int8_t</name></type> <name>nBit</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>vZigzag</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">64</literal> <operator>-</operator> <call><name>BUILDIN_CLZL</name><argument_list>(<argument><expr><name>vZigzag</name></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_prev</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name> <operator>&amp;&amp;</operator>
          <name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name><name>BIT_TO_SELECTOR</name><index>[<expr><name>nBit</name></expr>]</index></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>&lt;</operator> <name><name>BIT_TO_SELECTOR</name><index>[<expr><name>nBit</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>=</operator> <name><name>BIT_TO_SELECTOR</name><index>[<expr><name>nBit</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_aZigzag</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_end</name></name></expr>]</index></name> <operator>=</operator> <name>vZigzag</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_aBitN</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_end</name></name></expr>]</index></name> <operator>=</operator> <name>nBit</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_end</name></name> <operator>=</operator> <name><name>NEXT_IDX</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_end</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name> <operator>&lt;</operator> <name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>lidx</name> <init>= <expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>ridx</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>
          <while>while <condition>(<expr><name>lidx</name> <operator>&lt;=</operator> <name>ridx</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>=</operator> <operator>(</operator><name>lidx</name> <operator>+</operator> <name>ridx</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name> <operator>&lt;</operator> <name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name>lidx</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name> <operator>&gt;</operator> <name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name>ridx</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <break>break;</break>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></while>

          <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name> <operator>&lt;</operator> <name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>nEle</name> <init>= <expr><name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>code</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>+</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>bits</name> <init>= <expr><name><name>BIT_PER_INTEGER</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>iVal</name> <operator>&lt;</operator> <name>nEle</name></expr>;</condition> <incr><expr><name>iVal</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><name><name>bp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_aZigzag</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_start</name></name></expr>]</index></name> <operator>&lt;&lt;</operator> <operator>(</operator><name>bits</name> <operator>*</operator> <name>iVal</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_start</name></name> <operator>=</operator> <name><name>NEXT_IDX</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_start</name></name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// reset and continue</comment>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>iVal</name> <init>= <expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_start</name></name></expr></init></decl>;</init> <condition><expr><name>iVal</name> <operator>&lt;</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>i_end</name></name></expr>;</condition> <incr><expr><name>iVal</name> <operator>=</operator> <name><name>NEXT_IDX</name><index>[<expr><name>iVal</name></expr>]</index></name></expr></incr>)</control> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>&lt;</operator> <name><name>BIT_TO_SELECTOR</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_aBitN</name><index>[<expr><name>iVal</name></expr>]</index></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>=</operator> <name><name>BIT_TO_SELECTOR</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_aBitN</name><index>[<expr><name>iVal</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <else>else <block>{<block_content>
  <label><name>_copy_cmpr</name>:</label>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+</operator> <name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>+</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+=</operator> <name>nData</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name><operator>++</operator></expr>;</expr_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompIntEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init>;</init> <condition><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name></expr>;</condition><incr/>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name> <operator>&lt;</operator> <name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>lidx</name> <init>= <expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>ridx</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>lidx</name> <operator>&lt;=</operator> <name>ridx</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>=</operator> <operator>(</operator><name>lidx</name> <operator>+</operator> <name>ridx</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name> <operator>&lt;</operator> <name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>lidx</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name> <operator>&gt;</operator> <name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>ridx</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></while>

      <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name> <operator>&lt;</operator> <name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>nEle</name> <init>= <expr><name><name>SELECTOR_TO_ELEMS</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>+</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>bits</name> <init>= <expr><name><name>BIT_PER_INTEGER</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>iVal</name> <operator>&lt;</operator> <name>nEle</name></expr>;</condition> <incr><expr><name>iVal</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>bp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_aZigzag</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_start</name></name></expr>]</index></name> <operator>&lt;&lt;</operator> <operator>(</operator><name>bits</name> <operator>*</operator> <name>iVal</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_start</name></name> <operator>=</operator> <name><name>NEXT_IDX</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_start</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_nEle</name></name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>i_selector</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>&gt;=</operator> <name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>bytes</name> <operator>*</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tCompIntSwitchToCopy</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>cmprAlg</name></name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tTwoStageComp</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>cmprAlg</name></name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>nData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Float =====================================================</comment>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompFloatStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>f_prev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>f_flag_p</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompFloatSwitchToCopy</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit</name>;</goto></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>nBuf</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <union>union <block>{
    <decl_stmt><decl><type><name>float</name></type>    <name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>u</name></decl>;</decl_stmt>
  }</block> <decl><name>val</name> <init>= <expr><block>{<expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr></init></decl>;</union>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>iVal</name> <operator>&lt;</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</condition><incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>flags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator></expr>, <expr><operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>int8_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>flag</name> <init>= <expr><name><name>flags</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>uint32_t</name></type> <name>diff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int8_t</name></type>   <name>nBytes</name> <init>= <expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <literal type="number">0x7</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nBytes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>diff</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name>n</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">8</literal> <operator>*</operator> <name>j</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <literal type="number">0x8</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>diff</name> <operator>&lt;&lt;=</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>nBytes</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>val</name><operator>.</operator><name>u</name></name> <operator>^=</operator> <name>diff</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>nBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>val</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nBuf</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

      <expr_stmt><expr><name>iVal</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>iVal</name> <operator>&gt;=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pBuf</name> <init>= <expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pBuf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <name>nBuf</name></expr>;</expr_stmt>

<label><name>_exit</name>:</label>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompFloat</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>nData</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <union>union <block>{
    <decl_stmt><decl><type><name>float</name></type>    <name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>u</name></decl>;</decl_stmt>
  }</block> <decl><name>val</name> <init>= <expr><block>{<expr><operator>.</operator><name>f</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>}</block></expr></init></decl>;</union>

  <decl_stmt><decl><type><name>uint32_t</name></type> <name>diff</name> <init>= <expr><name><name>val</name><operator>.</operator><name>u</name></name> <operator>^</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>f_prev</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>f_prev</name></name> <operator>=</operator> <name><name>val</name><operator>.</operator><name>u</name></name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>clz</name></decl>, <decl><type ref="prev"/><name>ctz</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>diff</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>clz</name> <operator>=</operator> <call><name>BUILDIN_CLZ</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctz</name> <operator>=</operator> <call><name>BUILDIN_CTZ</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>clz</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctz</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <decl_stmt><decl><type><name>uint8_t</name></type> <name>nBytes</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>clz</name> <operator>&lt;</operator> <name>ctz</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>nBytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>ctz</name> <operator>/</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nBytes</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>diff</name> <operator>&gt;&gt;=</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>nBytes</name> <operator>*</operator> <name>BITS_PER_BYTE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>nBytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>clz</name> <operator>/</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>nBytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nBytes</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>&amp;</operator> <literal type="number">0x1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+</operator> <literal type="number">9</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>f_flag_p</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>clz</name> <operator>&lt;</operator> <name>ctz</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>f_flag_p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">0x08</literal> <operator>|</operator> <operator>(</operator><name>nBytes</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>f_flag_p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nBytes</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>clz</name> <operator>&lt;</operator> <name>ctz</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>f_flag_p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><literal type="number">0x08</literal> <operator>|</operator> <operator>(</operator><name>nBytes</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>f_flag_p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>nBytes</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>nBytes</name></expr>;</condition> <incr><expr><name>nBytes</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>diff</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>diff</name> <operator>&gt;&gt;=</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name><operator>++</operator></expr>;</expr_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompFloatEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tCompFloatSwitchToCopy</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>cmprAlg</name></name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tTwoStageComp</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>cmprAlg</name></name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>nData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Double =====================================================</comment>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompDoubleStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>d_prev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>d_flag_p</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompDoubleSwitchToCopy</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>_exit</name>;</goto></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>nBuf</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <union>union <block>{
    <decl_stmt><decl><type><name>double</name></type>   <name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>u</name></decl>;</decl_stmt>
  }</block> <decl><name>val</name> <init>= <expr><block>{<expr><operator>.</operator><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr></init></decl>;</union>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>iVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>iVal</name> <operator>&lt;</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name></expr>;</condition><incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>flags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator></expr>, <expr><operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>int8_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>flag</name> <init>= <expr><name><name>flags</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>uint64_t</name></type> <name>diff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int8_t</name></type>   <name>nBytes</name> <init>= <expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <literal type="number">0x7</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nBytes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>diff</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name>n</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">8</literal> <operator>*</operator> <name>j</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <literal type="number">0x8</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>diff</name> <operator>&lt;&lt;=</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <name>nBytes</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>val</name><operator>.</operator><name>u</name></name> <operator>^=</operator> <name>diff</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>nBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>val</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nBuf</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

      <expr_stmt><expr><name>iVal</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>iVal</name> <operator>&gt;=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pBuf</name> <init>= <expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pBuf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <name>nBuf</name></expr>;</expr_stmt>

<label><name>_exit</name>:</label>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompDouble</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>nData</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <union>union <block>{
    <decl_stmt><decl><type><name>double</name></type>   <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>u</name></decl>;</decl_stmt>
  }</block> <decl><name>val</name> <init>= <expr><block>{<expr><operator>.</operator><name>d</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>pData</name></expr>}</block></expr></init></decl>;</union>

  <decl_stmt><decl><type><name>uint64_t</name></type> <name>diff</name> <init>= <expr><name><name>val</name><operator>.</operator><name>u</name></name> <operator>^</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>d_prev</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>d_prev</name></name> <operator>=</operator> <name><name>val</name><operator>.</operator><name>u</name></name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>clz</name></decl>, <decl><type ref="prev"/><name>ctz</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>diff</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>clz</name> <operator>=</operator> <call><name>BUILDIN_CLZL</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctz</name> <operator>=</operator> <call><name>BUILDIN_CTZL</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>clz</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctz</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <decl_stmt><decl><type><name>uint8_t</name></type> <name>nBytes</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>clz</name> <operator>&lt;</operator> <name>ctz</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>nBytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>ctz</name> <operator>/</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nBytes</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>diff</name> <operator>&gt;&gt;=</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <name>nBytes</name> <operator>*</operator> <name>BITS_PER_BYTE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>nBytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>clz</name> <operator>/</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>nBytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nBytes</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>&amp;</operator> <literal type="number">0x1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+</operator> <literal type="number">17</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>d_flag_p</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>clz</name> <operator>&lt;</operator> <name>ctz</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>d_flag_p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">0x08</literal> <operator>|</operator> <operator>(</operator><name>nBytes</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>d_flag_p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>nBytes</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>clz</name> <operator>&lt;</operator> <name>ctz</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>d_flag_p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><literal type="number">0x08</literal> <operator>|</operator> <operator>(</operator><name>nBytes</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>d_flag_p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>nBytes</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>nBytes</name></expr>;</condition> <incr><expr><name>nBytes</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>diff</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>diff</name> <operator>&gt;&gt;=</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name><operator>++</operator></expr>;</expr_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompDoubleEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tCompDoubleSwitchToCopy</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>cmprAlg</name></name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tTwoStageComp</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>cmprAlg</name></name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>nData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Binary =====================================================</comment>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompBinaryStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompBinary</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>nData</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+</operator> <name>nData</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>+</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>+=</operator> <name>nData</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name><operator>++</operator></expr>;</expr_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompBinaryEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>szComp</name> <init>=
      <expr><call><name>LZ4_compress_default</name><argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>szComp</name> <operator>&amp;&amp;</operator> <name>szComp</name> <operator>&lt;</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>nData</name> <operator>=</operator> <name>szComp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>nData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Bool =====================================================</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>BOOL_CMPR_TABLE</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0b01</literal></expr>, <expr><literal type="number">0b0100</literal></expr>, <expr><literal type="number">0b010000</literal></expr>, <expr><literal type="number">0b01000000</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompBoolStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompBool</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>bool</name></type> <name>vBool</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>pData</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>mod4</name> <init>= <expr><operator>(</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>mod4</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>code</name> <operator>=</operator> <call><name>tRealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>vBool</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name><name>BOOL_CMPR_TABLE</name><index>[<expr><name>mod4</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name><operator>++</operator></expr>;</expr_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tCompBoolEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>cmprAlg</name></name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tTwoStageComp</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>cmprAlg</name></name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>nData</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// SCompressor =====================================================</comment>
<function><type><name>int32_t</name></type> <name>tCompressorCreate</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCmprsor</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppCmprsor</name> <operator>=</operator> <operator>(</operator><name>SCompressor</name> <operator>*</operator><operator>)</operator><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCompressor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>ppCmprsor</name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tCompressorDestroy</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>tFree</name><argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>nBuf</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name></name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>iBuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>iBuf</name> <operator>&lt;</operator> <name>nBuf</name></expr>;</condition> <incr><expr><name>iBuf</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>tFree</name><argument_list>(<argument><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>aBuf</name><index>[<expr><name>iBuf</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tCompressStart</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>cmprAlg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>cmprAlg</name></name> <operator>=</operator> <name>cmprAlg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>autoAlloc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>DATA_TYPE_INFO</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>startFn</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>DATA_TYPE_INFO</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><call><name>startFn</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cmprAlg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tCompressEnd</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>nOrigin</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppOut</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>nOut</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>nOrigin</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>isVarLen</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>nOrigin</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nBuf</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>nOrigin</name> <operator>=</operator> <name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>*</operator> <name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>bytes</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>nVal</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>endFn</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><call><name>endFn</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>, <argument><expr><name>ppOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tCompress</name><parameter_list>(<parameter><decl><type><name>SCompressor</name> <modifier>*</modifier></type><name>pCmprsor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name><name>DATA_TYPE_INFO</name><index>[<expr><name><name>pCmprsor</name><operator>-&gt;</operator><name>type</name></name></expr>]</index></name><operator>.</operator><call><name>cmprFn</name><argument_list>(<argument><expr><name>pCmprsor</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*************************************************************************
 *                  REGULAR COMPRESSION
 *************************************************************************/</comment>
<comment type="line">// Timestamp =====================================================</comment>
<function><type><name>int32_t</name></type> <name>tsCompressTimestamp</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                            <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsCompressTimestampImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>tsCompressTimestampImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>tsCompressStringImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressTimestamp</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>,
                              <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsDecompressTimestampImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tsDecompressStringImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>tsDecompressTimestampImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Float =====================================================</comment>
<function><type><name>int32_t</name></type> <name>tsCompressFloat</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                        <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TD_TSZ</name></cpp:ifdef>
  <comment type="line">// lossy mode</comment>
  <if_stmt><if>if <condition>(<expr><name>lossyFloat</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsCompressFloatLossyImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
    <comment type="line">// lossless mode</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>tsCompressFloatImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>tsCompressFloatImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>tsCompressStringImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TD_TSZ</name></cpp:ifdef>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressFloat</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                          <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TD_TSZ</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><call><name>HEAD_ALGO</name><argument_list>(<argument><expr><name><name>pIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ALGO_SZ_LOSSY</name></expr>)</condition> <block>{<block_content>
    <comment type="line">// decompress lossy</comment>
    <return>return <expr><call><name>tsDecompressFloatLossyImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// decompress lossless</comment>
    <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>tsDecompressFloatImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>tsDecompressStringImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><call><name>tsDecompressFloatImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TD_TSZ</name></cpp:ifdef>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">// Double =====================================================</comment>
<function><type><name>int32_t</name></type> <name>tsCompressDouble</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                         <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TD_TSZ</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>lossyDouble</name></expr>)</condition> <block>{<block_content>
    <comment type="line">// lossy mode</comment>
    <return>return <expr><call><name>tsCompressDoubleLossyImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// lossless mode</comment>
    <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>tsCompressDoubleImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>tsCompressDoubleImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>tsCompressStringImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TD_TSZ</name></cpp:ifdef>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressDouble</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                           <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TD_TSZ</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><call><name>HEAD_ALGO</name><argument_list>(<argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ALGO_SZ_LOSSY</name></expr>)</condition> <block>{<block_content>
    <comment type="line">// decompress lossy</comment>
    <return>return <expr><call><name>tsDecompressDoubleLossyImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="line">// decompress lossless</comment>
    <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>tsDecompressDoubleImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>tsDecompressStringImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <return>return <expr><call><name>tsDecompressDoubleImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TD_TSZ</name></cpp:ifdef>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="line">// Binary =====================================================</comment>
<function><type><name>int32_t</name></type> <name>tsCompressString</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                         <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>tsCompressStringImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressString</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                           <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>tsDecompressStringImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Bool =====================================================</comment>
<function><type><name>int32_t</name></type> <name>tsCompressBool</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                       <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsCompressBoolImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>tsCompressBoolImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>tsCompressStringImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressBool</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                         <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsDecompressBoolImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tsDecompressStringImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>tsDecompressBoolImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Tinyint =====================================================</comment>
<function><type><name>int32_t</name></type> <name>tsCompressTinyint</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                          <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsCompressINTImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_TINYINT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>tsCompressINTImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_TINYINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>tsCompressStringImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressTinyint</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                            <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsDecompressINTImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_TINYINT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tsDecompressStringImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>tsDecompressINTImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_TINYINT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Smallint =====================================================</comment>
<function><type><name>int32_t</name></type> <name>tsCompressSmallint</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                           <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsCompressINTImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>tsCompressINTImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>tsCompressStringImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressSmallint</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>,
                             <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsDecompressINTImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tsDecompressStringImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>tsDecompressINTImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Int =====================================================</comment>
<function><type><name>int32_t</name></type> <name>tsCompressInt</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                      <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsCompressINTImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_INT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>tsCompressINTImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_INT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>tsCompressStringImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressInt</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                        <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsDecompressINTImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_INT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tsDecompressStringImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>tsDecompressINTImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_INT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Bigint =====================================================</comment>
<function><type><name>int32_t</name></type> <name>tsCompressBigint</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                         <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsCompressINTImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_BIGINT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>tsCompressINTImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_BIGINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>tsCompressStringImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>nOut</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tsDecompressBigint</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nIn</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nEle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>nOut</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>cmprAlg</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,
                           <parameter><decl><type><name>int32_t</name></type> <name>nBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>ONE_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tsDecompressINTImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_BIGINT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmprAlg</name> <operator>==</operator> <name>TWO_STAGE_COMP</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tsDecompressStringImp</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>tsDecompressINTImp</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nEle</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_BIGINT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
