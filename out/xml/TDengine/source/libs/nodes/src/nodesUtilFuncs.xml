<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/source/libs/nodes/src/nodesUtilFuncs.c"><comment type="block">/*
 * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the GNU Affero General Public License, version 3
 * or later ("AGPL"), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmdnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodesUtil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"querynodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"taos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"taoserror.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdatablock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tref.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>SNodeMemChunk</name> <block>{
  <decl_stmt><decl><type><name>int32_t</name></type>               <name>availableSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>               <name>usedSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>                 <name>pBuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>SNodeMemChunk</name></name><modifier>*</modifier></type> <name>pNext</name></decl>;</decl_stmt>
}</block></struct></type> <name>SNodeMemChunk</name>;</typedef>

<typedef>typedef <type><struct>struct <name>SNodeAllocator</name> <block>{
  <decl_stmt><decl><type><name>int64_t</name></type>        <name>self</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type>        <name>queryId</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>        <name>chunkSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>        <name>chunkNum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeMemChunk</name><modifier>*</modifier></type> <name>pCurrChunk</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeMemChunk</name><modifier>*</modifier></type> <name>pChunks</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TdThreadMutex</name></type>  <name>mutex</name></decl>;</decl_stmt>
}</block></struct></type> <name>SNodeAllocator</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>threadlocal</name> <name>SNodeAllocator</name><modifier>*</modifier></type> <name>g_pNodeAllocator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int32_t</name></type>                     <name>g_allocatorReqRefPool</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>SNodeMemChunk</name><modifier>*</modifier></type> <name>callocNodeChunk</name><parameter_list>(<parameter><decl><type><name>SNodeAllocator</name><modifier>*</modifier></type> <name>pAllocator</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeMemChunk</name><modifier>*</modifier></type> <name>pNewChunk</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SNodeMemChunk</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>pAllocator</name><operator>-&gt;</operator><name>chunkSize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pNewChunk</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pNewChunk</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>pNewChunk</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNewChunk</name><operator>-&gt;</operator><name>availableSize</name></name> <operator>=</operator> <name><name>pAllocator</name><operator>-&gt;</operator><name>chunkSize</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNewChunk</name><operator>-&gt;</operator><name>usedSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNewChunk</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pAllocator</name><operator>-&gt;</operator><name>pCurrChunk</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pAllocator</name><operator>-&gt;</operator><name>pCurrChunk</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pNewChunk</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pAllocator</name><operator>-&gt;</operator><name>pCurrChunk</name></name> <operator>=</operator> <name>pNewChunk</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pAllocator</name><operator>-&gt;</operator><name>pChunks</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pAllocator</name><operator>-&gt;</operator><name>pChunks</name></name> <operator>=</operator> <name>pNewChunk</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pAllocator</name><operator>-&gt;</operator><name>chunkNum</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>pNewChunk</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>nodesCallocImpl</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>g_pNodeAllocator</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>g_pNodeAllocator</name><operator>-&gt;</operator><name>pCurrChunk</name><operator>-&gt;</operator><name>usedSize</name></name> <operator>+</operator> <name>size</name> <operator>&gt;</operator> <name><name>g_pNodeAllocator</name><operator>-&gt;</operator><name>pCurrChunk</name><operator>-&gt;</operator><name>availableSize</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>callocNodeChunk</name><argument_list>(<argument><expr><name>g_pNodeAllocator</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><name><name>g_pNodeAllocator</name><operator>-&gt;</operator><name>pCurrChunk</name><operator>-&gt;</operator><name>pBuf</name></name> <operator>+</operator> <name><name>g_pNodeAllocator</name><operator>-&gt;</operator><name>pCurrChunk</name><operator>-&gt;</operator><name>usedSize</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>g_pNodeAllocator</name><operator>-&gt;</operator><name>pCurrChunk</name><operator>-&gt;</operator><name>usedSize</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>nodesCalloc</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><call><name>nodesCallocImpl</name><argument_list>(<argument><expr><name>num</name> <operator>*</operator> <name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>p</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>NULL</name> <operator>!=</operator> <name>g_pNodeAllocator</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>nodesFree</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>ptr</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>*</operator><name>ptr</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createNodeAllocator</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>chunkSize</name></decl></parameter>, <parameter><decl><type><name>SNodeAllocator</name><modifier>*</modifier><modifier>*</modifier></type> <name>pAllocator</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pAllocator</name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SNodeAllocator</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pAllocator</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pAllocator</name><operator>)</operator><operator>-&gt;</operator><name>chunkSize</name></name> <operator>=</operator> <name>chunkSize</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>callocNodeChunk</name><argument_list>(<argument><expr><operator>*</operator><name>pAllocator</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><operator>*</operator><name>pAllocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>taosThreadMutexInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pAllocator</name><operator>)</operator><operator>-&gt;</operator><name>mutex</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyNodeAllocator</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>p</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNodeAllocator</name><modifier>*</modifier></type> <name>pAllocator</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>nodesDebug</name><argument_list>(<argument><expr><literal type="string">"query id %"</literal> <name>PRIx64</name> <literal type="string">" allocator id %"</literal> <name>PRIx64</name> <literal type="string">" alloc chunkNum: %d, chunkTotakSize: %d"</literal></expr></argument>,
             <argument><expr><name><name>pAllocator</name><operator>-&gt;</operator><name>queryId</name></name></expr></argument>, <argument><expr><name><name>pAllocator</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><name><name>pAllocator</name><operator>-&gt;</operator><name>chunkNum</name></name></expr></argument>, <argument><expr><name><name>pAllocator</name><operator>-&gt;</operator><name>chunkNum</name></name> <operator>*</operator> <name><name>pAllocator</name><operator>-&gt;</operator><name>chunkSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>SNodeMemChunk</name><modifier>*</modifier></type> <name>pChunk</name> <init>= <expr><name><name>pAllocator</name><operator>-&gt;</operator><name>pChunks</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>pChunk</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SNodeMemChunk</name><modifier>*</modifier></type> <name>pTemp</name> <init>= <expr><name><name>pChunk</name><operator>-&gt;</operator><name>pNext</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pChunk</name> <operator>=</operator> <name>pTemp</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>taosThreadMutexDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAllocator</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pAllocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesInitAllocatorSet</name><parameter_list>()</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>g_allocatorReqRefPool</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesWarn</name><argument_list>(<argument><expr><literal type="string">"nodes already initialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>g_allocatorReqRefPool</name> <operator>=</operator> <call><name>taosOpenRef</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><name>destroyNodeAllocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>g_allocatorReqRefPool</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesError</name><argument_list>(<argument><expr><literal type="string">"init nodes failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesDestroyAllocatorSet</name><parameter_list>()</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>g_allocatorReqRefPool</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SNodeAllocator</name><modifier>*</modifier></type> <name>pAllocator</name> <init>= <expr><call><name>taosIterateRef</name><argument_list>(<argument><expr><name>g_allocatorReqRefPool</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type>         <name>refId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>pAllocator</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>refId</name> <operator>=</operator> <name><name>pAllocator</name><operator>-&gt;</operator><name>self</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosRemoveRef</name><argument_list>(<argument><expr><name>g_allocatorReqRefPool</name></expr></argument>, <argument><expr><name>refId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pAllocator</name> <operator>=</operator> <call><name>taosIterateRef</name><argument_list>(<argument><expr><name>g_allocatorReqRefPool</name></expr></argument>, <argument><expr><name>refId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>taosCloseRef</name><argument_list>(<argument><expr><name>g_allocatorReqRefPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesCreateAllocator</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>queryId</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>chunkSize</name></decl></parameter>, <parameter><decl><type><name>int64_t</name><modifier>*</modifier></type> <name>pAllocatorId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeAllocator</name><modifier>*</modifier></type> <name>pAllocator</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>         <name>code</name> <init>= <expr><call><name>createNodeAllocator</name><argument_list>(<argument><expr><name>chunkSize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pAllocator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pAllocator</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <call><name>taosAddRef</name><argument_list>(<argument><expr><name>g_allocatorReqRefPool</name></expr></argument>, <argument><expr><name>pAllocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pAllocator</name><operator>-&gt;</operator><name>self</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>terrno</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pAllocator</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <name>queryId</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pAllocatorId</name> <operator>=</operator> <name><name>pAllocator</name><operator>-&gt;</operator><name>self</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesAcquireAllocator</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>allocatorId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>allocatorId</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNodeAllocator</name><modifier>*</modifier></type> <name>pAllocator</name> <init>= <expr><call><name>taosAcquireRef</name><argument_list>(<argument><expr><name>g_allocatorReqRefPool</name></expr></argument>, <argument><expr><name>allocatorId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pAllocator</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>terrno</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>taosThreadMutexLock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAllocator</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>g_pNodeAllocator</name> <operator>=</operator> <name>pAllocator</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesReleaseAllocator</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>allocatorId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>allocatorId</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>g_pNodeAllocator</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesError</name><argument_list>(<argument><expr><literal type="string">"allocator id %"</literal> <name>PRIx64</name>
               <literal type="string">" release failed: The nodesReleaseAllocator function needs to be called after the nodesAcquireAllocator "</literal>
               <literal type="string">"function is called!"</literal></expr></argument>,
               <argument><expr><name>allocatorId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNodeAllocator</name><modifier>*</modifier></type> <name>pAllocator</name> <init>= <expr><name>g_pNodeAllocator</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>g_pNodeAllocator</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosThreadMutexUnlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAllocator</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>taosReleaseRef</name><argument_list>(<argument><expr><name>g_allocatorReqRefPool</name></expr></argument>, <argument><expr><name>allocatorId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64_t</name></type> <name>nodesMakeAllocatorWeakRef</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>allocatorId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>allocatorId</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNodeAllocator</name><modifier>*</modifier></type> <name>pAllocator</name> <init>= <expr><call><name>taosAcquireRef</name><argument_list>(<argument><expr><name>g_allocatorReqRefPool</name></expr></argument>, <argument><expr><name>allocatorId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pAllocator</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesError</name><argument_list>(<argument><expr><literal type="string">"allocator id %"</literal> <name>PRIx64</name> <literal type="string">" weak reference failed"</literal></expr></argument>, <argument><expr><name>allocatorId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pAllocator</name><operator>-&gt;</operator><name>self</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64_t</name></type> <name>nodesReleaseAllocatorWeakRef</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>allocatorId</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>taosReleaseRef</name><argument_list>(<argument><expr><name>g_allocatorReqRefPool</name></expr></argument>, <argument><expr><name>allocatorId</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesDestroyAllocator</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>allocatorId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>allocatorId</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>taosRemoveRef</name><argument_list>(<argument><expr><name>g_allocatorReqRefPool</name></expr></argument>, <argument><expr><name>allocatorId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>makeNode</name><parameter_list>(<parameter><decl><type><name>ENodeType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><call><name>nodesCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>p</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>setNodeType</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SNode</name><modifier>*</modifier></type> <name>nodesMakeNode</name><parameter_list>(<parameter><decl><type><name>ENodeType</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_COLUMN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SColumnNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_VALUE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SValueNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_OPERATOR</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SOperatorNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_CONDITION</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SLogicConditionNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_FUNCTION</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SFunctionNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_REAL_TABLE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SRealTableNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_TEMP_TABLE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STempTableNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_JOIN_TABLE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SJoinTableNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_GROUPING_SET</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SGroupingSetNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_ORDER_BY_EXPR</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SOrderByExprNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LIMIT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SLimitNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_STATE_WINDOW</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStateWindowNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SESSION_WINDOW</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSessionWindowNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_INTERVAL_WINDOW</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SIntervalWindowNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_NODE_LIST</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SNodeListNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_FILL</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SFillNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_RAW_EXPR</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SRawExprNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_TARGET</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STargetNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DATABLOCK_DESC</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDataBlockDescNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SLOT_DESC</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSlotDescNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_COLUMN_DEF</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SColumnDefNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DOWNSTREAM_SOURCE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDownstreamSourceNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DATABASE_OPTIONS</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDatabaseOptions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_TABLE_OPTIONS</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STableOptions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_INDEX_OPTIONS</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SIndexOptions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_EXPLAIN_OPTIONS</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SExplainOptions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_STREAM_OPTIONS</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStreamOptions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LEFT_VALUE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SLeftValueNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_COLUMN_REF</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SColumnDefNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_WHEN_THEN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SWhenThenNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_CASE_WHEN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCaseWhenNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SET_OPERATOR</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSetOperator</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SELECT_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSelectStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_VNODE_MODIF_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVnodeModifOpStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_CREATE_DATABASE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCreateDatabaseStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_DATABASE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDropDatabaseStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_ALTER_DATABASE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SAlterDatabaseStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_FLUSH_DATABASE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SFlushDatabaseStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_TRIM_DATABASE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STrimDatabaseStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_CREATE_TABLE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCreateTableStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_CREATE_SUBTABLE_CLAUSE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCreateSubTableClause</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_CREATE_MULTI_TABLE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCreateMultiTableStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_TABLE_CLAUSE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDropTableClause</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_TABLE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDropTableStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_SUPER_TABLE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDropSuperTableStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_ALTER_TABLE_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_ALTER_SUPER_TABLE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SAlterTableStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_CREATE_USER_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCreateUserStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_ALTER_USER_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SAlterUserStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_USER_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDropUserStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_USE_DATABASE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SUseDatabaseStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_CREATE_DNODE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCreateDnodeStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_DNODE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDropDnodeStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_ALTER_DNODE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SAlterDnodeStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_CREATE_INDEX_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCreateIndexStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_INDEX_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDropIndexStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_CREATE_QNODE_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_CREATE_BNODE_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_CREATE_SNODE_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_CREATE_MNODE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCreateComponentNodeStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_QNODE_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_DROP_BNODE_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_DROP_SNODE_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_DROP_MNODE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDropComponentNodeStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_CREATE_TOPIC_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCreateTopicStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_TOPIC_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDropTopicStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_CGROUP_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDropCGroupStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_ALTER_LOCAL_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SAlterLocalStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_EXPLAIN_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SExplainStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DESCRIBE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDescribeStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_RESET_QUERY_CACHE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_COMPACT_STMT</name></expr>:</case>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_CREATE_FUNCTION_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCreateFunctionStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_FUNCTION_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDropFunctionStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_CREATE_STREAM_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCreateStreamStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_STREAM_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDropStreamStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_BALANCE_VGROUP_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SBalanceVgroupStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_MERGE_VGROUP_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SMergeVgroupStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_REDISTRIBUTE_VGROUP_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SRedistributeVgroupStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SPLIT_VGROUP_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSplitVgroupStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SYNCDB_STMT</name></expr>:</case>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_GRANT_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SGrantStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_REVOKE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SRevokeStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SHOW_DNODES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_MNODES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_MODULES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_QNODES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_SNODES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_BNODES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_CLUSTER_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_DATABASES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_FUNCTIONS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_INDEXES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_STABLES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_STREAMS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_TABLES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_USERS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_LICENCES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_VGROUPS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_TOPICS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_CONSUMERS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_CONNECTIONS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_QUERIES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_VNODES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_APPS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_SCORES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_VARIABLES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_LOCAL_VARIABLES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_TRANSACTIONS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_SUBSCRIPTIONS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_TAGS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_USER_PRIVILEGES_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SShowStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SHOW_TABLE_TAGS_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SShowTableTagsStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SHOW_DNODE_VARIABLES_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SShowDnodeVariablesStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SHOW_CREATE_DATABASE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SShowCreateDatabaseStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SHOW_CREATE_TABLE_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_CREATE_STABLE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SShowCreateTableStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SHOW_TABLE_DISTRIBUTED_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SShowTableDistributedStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_KILL_QUERY_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SKillQueryStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_KILL_TRANSACTION_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_KILL_CONNECTION_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SKillStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DELETE_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDeleteStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_INSERT_STMT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SInsertStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_QUERY</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SQuery</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SScanLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_JOIN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SJoinLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SAggLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SProjectLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_VNODE_MODIFY</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVnodeModifyLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_EXCHANGE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SExchangeLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_MERGE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SMergeLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SWindowLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_FILL</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SFillLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SORT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSortLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SPartitionLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_INDEF_ROWS_FUNC</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SIndefRowsFuncLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_INTERP_FUNC</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SInterpFuncLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_SUBPLAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SLogicSubplan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SQueryLogicPlan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_TAG_SCAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STagScanPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_TABLE_SCAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STableScanPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_TABLE_SEQ_SCAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STableSeqScanPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_TABLE_MERGE_SCAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STableMergeScanPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SCAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStreamScanPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_SYSTABLE_SCAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSystemTableScanPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_BLOCK_DIST_SCAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SBlockDistScanPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_LAST_ROW_SCAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SLastRowScanPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_TABLE_COUNT_SCAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STableCountScanPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_PROJECT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SProjectPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_JOIN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSortMergeJoinPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_HASH_AGG</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SAggPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_EXCHANGE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SExchangePhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SMergePhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_SORT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSortPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_GROUP_SORT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SGroupSortPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_HASH_INTERVAL</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SIntervalPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_ALIGNED_INTERVAL</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SMergeAlignedIntervalPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_INTERVAL</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStreamIntervalPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_FINAL_INTERVAL</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStreamFinalIntervalPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SEMI_INTERVAL</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStreamSemiIntervalPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_FILL</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_FILL</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SFillPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_SESSION</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSessionWinodwPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SESSION</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStreamSessionWinodwPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SEMI_SESSION</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStreamSemiSessionWinodwPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_FINAL_SESSION</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStreamFinalSessionWinodwPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_STATE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStateWinodwPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_STATE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStreamStateWinodwPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_PARTITION</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SPartitionPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_PARTITION</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SStreamPartitionPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_INDEF_ROWS_FUNC</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SIndefRowsFuncPhysiNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_INTERP_FUNC</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SInterpFuncLogicNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_DISPATCH</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDataDispatcherNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_INSERT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDataInserterNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_QUERY_INSERT</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SQueryInserterNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_DELETE</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDataDeleterNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_SUBPLAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSubplan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN</name></expr>:</case>
      <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SQueryPlan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>nodesError</name><argument_list>(<argument><expr><literal type="string">"nodesMakeNode unknown node = %s"</literal></expr></argument>, <argument><expr><call><name>nodesNodeName</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyVgDataBlockArray</name><parameter_list>(<parameter><decl><type><name>SArray</name><modifier>*</modifier></type> <name>pArray</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>taosArrayGetSize</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SVgDataBlocks</name><modifier>*</modifier></type> <name>pVg</name> <init>= <expr><call><name>taosArrayGetP</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pVg</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name>pVg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>taosArrayDestroy</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pConditions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pSlimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyPhysiNode</name><parameter_list>(<parameter><decl><type><name>SPhysiNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pConditions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pNode</name><operator>-&gt;</operator><name>pOutputDataBlockDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pSlimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyWinodwPhysiNode</name><parameter_list>(<parameter><decl><type><name>SWinodwPhysiNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>destroyPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pTspk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pTsEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyPartitionPhysiNode</name><parameter_list>(<parameter><decl><type><name>SPartitionPhysiNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>destroyPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pPartitionKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyScanPhysiNode</name><parameter_list>(<parameter><decl><type><name>SScanPhysiNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>destroyPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyDataSinkNode</name><parameter_list>(<parameter><decl><type><name>SDataSinkNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pNode</name><operator>-&gt;</operator><name>pInputDataBlockDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyExprNode</name><parameter_list>(<parameter><decl><type><name>SExprNode</name><modifier>*</modifier></type> <name>pExpr</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>taosArrayDestroy</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>pAssociation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyTableCfg</name><parameter_list>(<parameter><decl><type><name>STableCfg</name><modifier>*</modifier></type> <name>pCfg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pCfg</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>taosArrayDestroy</name><argument_list>(<argument><expr><name><name>pCfg</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name><name>pCfg</name><operator>-&gt;</operator><name>pComment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name><name>pCfg</name><operator>-&gt;</operator><name>pSchemas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name><name>pCfg</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pCfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>destroySmaIndex</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pIndex</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>STableIndexInfo</name><operator>*</operator><operator>)</operator><name>pIndex</name><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesDestroyNode</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pNode</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_COLUMN</name></expr>:</case>
      <expr_stmt><expr><call><name>destroyExprNode</name><argument_list>(<argument><expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_VALUE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SValueNode</name><modifier>*</modifier></type> <name>pValue</name> <init>= <expr><operator>(</operator><name>SValueNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyExprNode</name><argument_list>(<argument><expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pValue</name><operator>-&gt;</operator><name>literal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name><name>pValue</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pValue</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_OPERATOR</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SOperatorNode</name><modifier>*</modifier></type> <name>pOp</name> <init>= <expr><operator>(</operator><name>SOperatorNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyExprNode</name><argument_list>(<argument><expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_CONDITION</name></expr>:</case>
      <expr_stmt><expr><call><name>destroyExprNode</name><argument_list>(<argument><expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_FUNCTION</name></expr>:</case>
      <expr_stmt><expr><call><name>destroyExprNode</name><argument_list>(<argument><expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_REAL_TABLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SRealTableNode</name><modifier>*</modifier></type> <name>pReal</name> <init>= <expr><operator>(</operator><name>SRealTableNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pReal</name><operator>-&gt;</operator><name>pMeta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pReal</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosArrayDestroyEx</name><argument_list>(<argument><expr><name><name>pReal</name><operator>-&gt;</operator><name>pSmaIndexes</name></name></expr></argument>, <argument><expr><name>destroySmaIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_TEMP_TABLE</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>STempTableNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pSubquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_JOIN_TABLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SJoinTableNode</name><modifier>*</modifier></type> <name>pJoin</name> <init>= <expr><operator>(</operator><name>SJoinTableNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pOnCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_GROUPING_SET</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SGroupingSetNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_ORDER_BY_EXPR</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SOrderByExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LIMIT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_STATE_WINDOW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SStateWindowNode</name><modifier>*</modifier></type> <name>pState</name> <init>= <expr><operator>(</operator><name>SStateWindowNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pState</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pState</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_SESSION_WINDOW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SSessionWindowNode</name><modifier>*</modifier></type> <name>pSession</name> <init>= <expr><operator>(</operator><name>SSessionWindowNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pSession</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pSession</name><operator>-&gt;</operator><name>pGap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_INTERVAL_WINDOW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SIntervalWindowNode</name><modifier>*</modifier></type> <name>pJoin</name> <init>= <expr><operator>(</operator><name>SIntervalWindowNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pInterval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pSliding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pFill</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_NODE_LIST</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SNodeListNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_FILL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SFillNode</name><modifier>*</modifier></type> <name>pFill</name> <init>= <expr><operator>(</operator><name>SFillNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pFill</name><operator>-&gt;</operator><name>pValues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pFill</name><operator>-&gt;</operator><name>pWStartTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_RAW_EXPR</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SRawExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_TARGET</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>STargetNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_DATABLOCK_DESC</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SDataBlockDescNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_SLOT_DESC</name></expr>:</case>          <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_COLUMN_DEF</name></expr>:</case>         <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_DOWNSTREAM_SOURCE</name></expr>:</case>  <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_DATABASE_OPTIONS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SDatabaseOptions</name><modifier>*</modifier></type> <name>pOptions</name> <init>= <expr><operator>(</operator><name>SDatabaseOptions</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pOptions</name><operator>-&gt;</operator><name>pDaysPerFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pKeep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pRetentions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_TABLE_OPTIONS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>STableOptions</name><modifier>*</modifier></type> <name>pOptions</name> <init>= <expr><operator>(</operator><name>STableOptions</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pMaxDelay</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pWatermark</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pRollupFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pSma</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pDeleteMark</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_INDEX_OPTIONS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SIndexOptions</name><modifier>*</modifier></type> <name>pOptions</name> <init>= <expr><operator>(</operator><name>SIndexOptions</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pInterval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pSliding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pStreamOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_EXPLAIN_OPTIONS</name></expr>:</case>  <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_STREAM_OPTIONS</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SStreamOptions</name><modifier>*</modifier></type> <name>pOptions</name> <init>= <expr><operator>(</operator><name>SStreamOptions</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pDelay</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pWatermark</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pOptions</name><operator>-&gt;</operator><name>pDeleteMark</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LEFT_VALUE</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_COLUMN_REF</name></expr>:</case>  <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_WHEN_THEN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SWhenThenNode</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SWhenThenNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pWhen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pThen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_CASE_WHEN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SCaseWhenNode</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SCaseWhenNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pCase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pElse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pWhenThenList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_SET_OPERATOR</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SSetOperator</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SSetOperator</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pProjectionList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pOrderByList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_SELECT_STMT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SSelectStmt</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pProjectionList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pFromTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pPartitionByList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pSubtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pWindow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pGroupByList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pRange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pEvery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pFill</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pOrderByList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pSlimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_VNODE_MODIF_STMT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SVnodeModifOpStmt</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SVnodeModifOpStmt</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyVgDataBlockArray</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pDataBlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pTableMeta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pVgroupsHashObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pSubTableHashObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pTableNameHashObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pDbFNameHashObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pStmt</name><operator>-&gt;</operator><name>freeHashFunc</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>pStmt</name><operator>-&gt;</operator><name>freeHashFunc</name></name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pTableBlockHashObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pStmt</name><operator>-&gt;</operator><name>freeArrayFunc</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>pStmt</name><operator>-&gt;</operator><name>freeArrayFunc</name></name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pVgDataBlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>tdDestroySVCreateTbReq</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pStmt</name><operator>-&gt;</operator><name>createTblReq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosCloseFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pStmt</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_CREATE_DATABASE_STMT</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>SCreateDatabaseStmt</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_DROP_DATABASE_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_ALTER_DATABASE_STMT</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>SAlterDatabaseStmt</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_FLUSH_DATABASE_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_TRIM_DATABASE_STMT</name></expr>:</case>   <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_CREATE_TABLE_STMT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SCreateTableStmt</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SCreateTableStmt</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_CREATE_SUBTABLE_CLAUSE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SCreateSubTableClause</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SCreateSubTableClause</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pSpecificTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pValsOfTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_CREATE_MULTI_TABLE_STMT</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SCreateMultiTableStmt</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pSubTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_DROP_TABLE_CLAUSE</name></expr>:</case>  <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_DROP_TABLE_STMT</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SDropTableStmt</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_DROP_SUPER_TABLE_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_ALTER_TABLE_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_ALTER_SUPER_TABLE_STMT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SAlterTableStmt</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SAlterTableStmt</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_CREATE_USER_STMT</name></expr>:</case>   <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_ALTER_USER_STMT</name></expr>:</case>    <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_DROP_USER_STMT</name></expr>:</case>     <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_USE_DATABASE_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_CREATE_DNODE_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_DROP_DNODE_STMT</name></expr>:</case>    <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_ALTER_DNODE_STMT</name></expr>:</case>   <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_CREATE_INDEX_STMT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SCreateIndexStmt</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SCreateIndexStmt</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_DROP_INDEX_STMT</name></expr>:</case>    <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_CREATE_QNODE_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_DROP_QNODE_STMT</name></expr>:</case>    <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_CREATE_BNODE_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_DROP_BNODE_STMT</name></expr>:</case>    <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_CREATE_SNODE_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_DROP_SNODE_STMT</name></expr>:</case>    <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_CREATE_MNODE_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_DROP_MNODE_STMT</name></expr>:</case>    <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_CREATE_TOPIC_STMT</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SCreateTopicStmt</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_DROP_TOPIC_STMT</name></expr>:</case>   <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_DROP_CGROUP_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_ALTER_LOCAL_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_EXPLAIN_STMT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SExplainStmt</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SExplainStmt</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pQuery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_DESCRIBE_STMT</name></expr>:</case>
      <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SDescribeStmt</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_RESET_QUERY_CACHE_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_COMPACT_STMT</name></expr>:</case>            <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_CREATE_FUNCTION_STMT</name></expr>:</case>    <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_DROP_FUNCTION_STMT</name></expr>:</case>      <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_CREATE_STREAM_STMT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SCreateStreamStmt</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SCreateStreamStmt</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pStmt</name><operator>-&gt;</operator><name>pOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pQuery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pSubtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_DROP_STREAM_STMT</name></expr>:</case>     <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_BALANCE_VGROUP_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_MERGE_VGROUP_STMT</name></expr>:</case>    <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_REDISTRIBUTE_VGROUP_STMT</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SRedistributeVgroupStmt</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pDnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_SPLIT_VGROUP_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_SYNCDB_STMT</name></expr>:</case>        <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_GRANT_STMT</name></expr>:</case>         <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_REVOKE_STMT</name></expr>:</case>        <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_SHOW_DNODES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_MNODES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_MODULES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_QNODES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_SNODES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_BNODES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_CLUSTER_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_DATABASES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_FUNCTIONS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_INDEXES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_STABLES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_STREAMS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_TABLES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_USERS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_LICENCES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_VGROUPS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_TOPICS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_CONSUMERS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_CONNECTIONS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_QUERIES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_VNODES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_APPS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_SCORES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_VARIABLES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_LOCAL_VARIABLES_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_TRANSACTIONS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_SUBSCRIPTIONS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_TAGS_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_USER_PRIVILEGES_STMT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SShowStmt</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SShowStmt</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pDbName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pTbName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_SHOW_TABLE_TAGS_STMT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SShowTableTagsStmt</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SShowTableTagsStmt</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pDbName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pTbName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_SHOW_DNODE_VARIABLES_STMT</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SShowDnodeVariablesStmt</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pDnodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SShowDnodeVariablesStmt</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pLikePattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_SHOW_CREATE_DATABASE_STMT</name></expr>:</case>
      <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SShowCreateDatabaseStmt</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pCfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_SHOW_CREATE_TABLE_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_SHOW_CREATE_STABLE_STMT</name></expr>:</case>
      <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SShowCreateTableStmt</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pDbCfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>destroyTableCfg</name><argument_list>(<argument><expr><operator>(</operator><name>STableCfg</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>SShowCreateTableStmt</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pTableCfg</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_SHOW_TABLE_DISTRIBUTED_STMT</name></expr>:</case>  <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_KILL_CONNECTION_STMT</name></expr>:</case>         <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_KILL_QUERY_STMT</name></expr>:</case>              <comment type="line">// no pointer field</comment>
    <case>case <expr><name>QUERY_NODE_KILL_TRANSACTION_STMT</name></expr>:</case>        <comment type="line">// no pointer field</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_DELETE_STMT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SDeleteStmt</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SDeleteStmt</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pFromTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pCountFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pFirstFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pLastFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pTagCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_INSERT_STMT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SInsertStmt</name><modifier>*</modifier></type> <name>pStmt</name> <init>= <expr><operator>(</operator><name>SInsertStmt</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pQuery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_QUERY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SQuery</name><modifier>*</modifier></type> <name>pQuery</name> <init>= <expr><operator>(</operator><name>SQuery</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pResSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>pCmdMsg</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pCmdMsg</name><operator>-&gt;</operator><name>pMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pCmdMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>taosArrayDestroy</name><argument_list>(<argument><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pDbList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosArrayDestroy</name><argument_list>(<argument><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pTableList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosArrayDestroy</name><argument_list>(<argument><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pTargetTableList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosArrayDestroy</name><argument_list>(<argument><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pPlaceholderValues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pPrepareRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pDynamicScanFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pTagCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pTagIndexCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosArrayDestroyEx</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pSmaIndexes</name></name></expr></argument>, <argument><expr><name>destroySmaIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pSubtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_JOIN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name> <init>= <expr><operator>(</operator><name>SJoinLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pMergeCondition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pOnConditions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name> <init>= <expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name> <init>= <expr><operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pProjections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_VNODE_MODIFY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SVnodeModifyLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name> <init>= <expr><operator>(</operator><name>SVnodeModifyLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>destroyVgDataBlockArray</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pDataBlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// pVgDataBlocks is weak reference</comment>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pAffectedRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pStartTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pEndTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pInsertCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_EXCHANGE</name></expr>:</case>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_MERGE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SMergeLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name> <init>= <expr><operator>(</operator><name>SMergeLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pMergeKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pInputs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name> <init>= <expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pTspk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pTsEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pStateExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_FILL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SFillLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name> <init>= <expr><operator>(</operator><name>SFillLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pWStartTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pValues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pFillExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pNotFillExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SORT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SSortLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name> <init>= <expr><operator>(</operator><name>SSortLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pSortKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SPartitionLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name> <init>= <expr><operator>(</operator><name>SPartitionLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pPartitionKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pSubtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_INDEF_ROWS_FUNC</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SIndefRowsFuncLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name> <init>= <expr><operator>(</operator><name>SIndefRowsFuncLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_INTERP_FUNC</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SInterpFuncLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name> <init>= <expr><operator>(</operator><name>SInterpFuncLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyLogicNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pFillValues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pTimeSeries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_SUBPLAN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name> <init>= <expr><operator>(</operator><name>SLogicSubplan</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesClearList</name><argument_list>(<argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pParents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SQueryLogicPlan</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pTopSubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_TAG_SCAN</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_SYSTABLE_SCAN</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_BLOCK_DIST_SCAN</name></expr>:</case>
      <expr_stmt><expr><call><name>destroyScanPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_LAST_ROW_SCAN</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_TABLE_COUNT_SCAN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SLastRowScanPhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>SLastRowScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyScanPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_TABLE_SCAN</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_TABLE_SEQ_SCAN</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_TABLE_MERGE_SCAN</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SCAN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>STableScanPhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>STableScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyScanPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pDynamicScanFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pSubtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_PROJECT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SProjectPhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>SProjectPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pProjections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_JOIN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SSortMergeJoinPhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>SSortMergeJoinPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pMergeCondition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pOnConditions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_HASH_AGG</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SAggPhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>SAggPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_EXCHANGE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SExchangePhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>SExchangePhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pSrcEndPoints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SMergePhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>SMergePhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pMergeKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_SORT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_GROUP_SORT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SSortPhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>SSortPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pSortKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_HASH_INTERVAL</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_ALIGNED_INTERVAL</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_INTERVAL</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_FINAL_INTERVAL</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SEMI_INTERVAL</name></expr>:</case>
      <expr_stmt><expr><call><name>destroyWinodwPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SWinodwPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_FILL</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_FILL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SFillPhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>SFillPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pFillExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pNotFillExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pWStartTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pValues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_SESSION</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SESSION</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SEMI_SESSION</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_FINAL_SESSION</name></expr>:</case>
      <expr_stmt><expr><call><name>destroyWinodwPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SWinodwPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_STATE</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_STATE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SStateWinodwPhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>SStateWinodwPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyWinodwPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SWinodwPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pStateKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_PARTITION</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>destroyPartitionPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPartitionPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_PARTITION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SStreamPartitionPhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>SStreamPartitionPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyPartitionPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPartitionPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pSubtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_INDEF_ROWS_FUNC</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SIndefRowsFuncPhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>SIndefRowsFuncPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_INTERP_FUNC</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SInterpFuncPhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name> <init>= <expr><operator>(</operator><name>SInterpFuncPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyPhysiNode</name><argument_list>(<argument><expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pFillValues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pTimeSeries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_DISPATCH</name></expr>:</case>
      <expr_stmt><expr><call><name>destroyDataSinkNode</name><argument_list>(<argument><expr><operator>(</operator><name>SDataSinkNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_INSERT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SDataInserterNode</name><modifier>*</modifier></type> <name>pSink</name> <init>= <expr><operator>(</operator><name>SDataInserterNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyDataSinkNode</name><argument_list>(<argument><expr><operator>(</operator><name>SDataSinkNode</name><operator>*</operator><operator>)</operator><name>pSink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pSink</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_QUERY_INSERT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SQueryInserterNode</name><modifier>*</modifier></type> <name>pSink</name> <init>= <expr><operator>(</operator><name>SQueryInserterNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyDataSinkNode</name><argument_list>(<argument><expr><operator>(</operator><name>SDataSinkNode</name><operator>*</operator><operator>)</operator><name>pSink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pSink</name><operator>-&gt;</operator><name>pCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_DELETE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SDataDeleterNode</name><modifier>*</modifier></type> <name>pSink</name> <init>= <expr><operator>(</operator><name>SDataDeleterNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyDataSinkNode</name><argument_list>(<argument><expr><operator>(</operator><name>SDataSinkNode</name><operator>*</operator><operator>)</operator><name>pSink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pSink</name><operator>-&gt;</operator><name>pAffectedRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pSink</name><operator>-&gt;</operator><name>pStartTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pSink</name><operator>-&gt;</operator><name>pEndTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_SUBPLAN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SSubplan</name><modifier>*</modifier></type> <name>pSubplan</name> <init>= <expr><operator>(</operator><name>SSubplan</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>nodesClearList</name><argument_list>(<argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pSubplan</name><operator>-&gt;</operator><name>pDataSink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pSubplan</name><operator>-&gt;</operator><name>pTagCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pSubplan</name><operator>-&gt;</operator><name>pTagIndexCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesClearList</name><argument_list>(<argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pParents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SQueryPlan</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pSubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>nodesFree</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<function><type><name>SNodeList</name><modifier>*</modifier></type> <name>nodesMakeList</name><parameter_list>()</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><call><name>nodesCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SNodeList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>p</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesListAppend</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pList</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>pNode</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SListCell</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><call><name>nodesCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>p</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNode</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pList</name><operator>-&gt;</operator><name>pHead</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>pHead</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pList</name><operator>-&gt;</operator><name>pTail</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>pTail</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>pTail</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pList</name><operator>-&gt;</operator><name>length</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesListStrictAppend</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pNode</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesListAppend</name><argument_list>(<argument><expr><name>pList</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesListMakeAppend</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pList</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pList</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pList</name> <operator>=</operator> <call><name>nodesMakeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pList</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>nodesListAppend</name><argument_list>(<argument><expr><operator>*</operator><name>pList</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesListMakeStrictAppend</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pList</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pList</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pList</name> <operator>=</operator> <call><name>nodesMakeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pList</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><operator>*</operator><name>pList</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesListAppendList</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTarget</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSrc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pTarget</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>pSrc</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pTarget</name><operator>-&gt;</operator><name>pHead</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pTarget</name><operator>-&gt;</operator><name>pHead</name></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pHead</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>pTarget</name><operator>-&gt;</operator><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pHead</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pHead</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pHead</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>pTarget</name><operator>-&gt;</operator><name>pTail</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pTarget</name><operator>-&gt;</operator><name>pTail</name></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTail</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTarget</name><operator>-&gt;</operator><name>length</name></name> <operator>+=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesFree</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesListStrictAppendList</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTarget</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSrc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSrc</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesListAppendList</name><argument_list>(<argument><expr><name>pTarget</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesListPushFront</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pList</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>pNode</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SListCell</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><call><name>nodesCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>p</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNode</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pList</name><operator>-&gt;</operator><name>pHead</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>pHead</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pList</name><operator>-&gt;</operator><name>pHead</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>pHead</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pList</name><operator>-&gt;</operator><name>length</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SListCell</name><modifier>*</modifier></type> <name>nodesListErase</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>, <parameter><decl><type><name>SListCell</name><modifier>*</modifier></type> <name>pCell</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pPrev</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>pHead</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pNext</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pList</name><operator>-&gt;</operator><name>pTail</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>pCell</name><operator>-&gt;</operator><name>pNext</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>pCell</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <decl_stmt><decl><type><name>SListCell</name><modifier>*</modifier></type> <name>pNext</name> <init>= <expr><name><name>pCell</name><operator>-&gt;</operator><name>pNext</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pCell</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesFree</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>--</operator><operator>(</operator><name><name>pList</name><operator>-&gt;</operator><name>length</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>pNext</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesListInsertList</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTarget</name></decl></parameter>, <parameter><decl><type><name>SListCell</name><modifier>*</modifier></type> <name>pPos</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSrc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pTarget</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>pPos</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>pSrc</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pPos</name><operator>-&gt;</operator><name>pPrev</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pTarget</name><operator>-&gt;</operator><name>pHead</name></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pHead</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>pPos</name><operator>-&gt;</operator><name>pPrev</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pHead</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pHead</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>pPos</name><operator>-&gt;</operator><name>pPrev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSrc</name><operator>-&gt;</operator><name>pTail</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>pPos</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPos</name><operator>-&gt;</operator><name>pPrev</name></name> <operator>=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pTail</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pTarget</name><operator>-&gt;</operator><name>length</name></name> <operator>+=</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesFree</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>SNode</name><modifier>*</modifier></type> <name>nodesListGetNode</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>node</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>node</argument>, <argument>pList</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>index</name><operator>--</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>node</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SListCell</name><modifier>*</modifier></type> <name>nodesListGetCell</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>node</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>node</argument>, <argument>pList</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>index</name><operator>--</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>cell</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesDestroyList</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pList</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SListCell</name><modifier>*</modifier></type> <name>pNext</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>pHead</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>pNext</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <call><name>nodesListErase</name><argument_list>(<argument><expr><name>pList</name></expr></argument>, <argument><expr><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>nodesFree</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesClearList</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pList</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SListCell</name><modifier>*</modifier></type> <name>pNext</name> <init>= <expr><name><name>pList</name><operator>-&gt;</operator><name>pHead</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>pNext</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SListCell</name><modifier>*</modifier></type> <name>tmp</name> <init>= <expr><name>pNext</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>pNext</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesFree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>nodesFree</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>nodesGetValueFromNode</name><parameter_list>(<parameter><decl><type><name>SValueNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>pNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case>
      <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_NCHAR</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_VARCHAR</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_VARBINARY</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_JSON</name></expr>:</case>
      <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>p</name></name></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesSetValueNodeValue</name><parameter_list>(<parameter><decl><type><name>SValueNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>pNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>b</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int8_t</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int8_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int16_t</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int16_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int32_t</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int64_t</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int64_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>i</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int64_t</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int64_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>u</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int8_t</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int8_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>u</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>u</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int16_t</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int16_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>u</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>u</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int32_t</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>u</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>u</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint64_t</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint64_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>u</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>d</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>float</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>float</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>d</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>d</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNode</name><operator>-&gt;</operator><name>typeData</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>d</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_NCHAR</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_VARCHAR</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_VARBINARY</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_JSON</name></expr>:</case>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>p</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <return>return <expr><name>TSDB_CODE_APP_ERROR</name></expr>;</return>
  </block_content>}</block></switch>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier></type> <name>nodesGetStrValueFromNode</name><parameter_list>(<parameter><decl><type><name>SValueNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>pNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>buf</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name>MAX_NUM_STR_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>buf</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>b</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>buf</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>buf</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name>MAX_NUM_STR_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>buf</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRId64</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>buf</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>buf</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name>MAX_NUM_STR_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>buf</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>u</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>buf</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>buf</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name>MAX_NUM_STR_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>buf</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%e"</literal></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>buf</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_NCHAR</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_VARCHAR</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_VARBINARY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>bufSize</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type>   <name>buf</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name>bufSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>buf</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufSize</name></expr></argument>, <argument><expr><literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>buf</name></expr>;</return>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>nodesIsExprNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>ENodeType</name></type> <name>type</name> <init>= <expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <name>type</name> <operator>||</operator> <name>QUERY_NODE_VALUE</name> <operator>==</operator> <name>type</name> <operator>||</operator> <name>QUERY_NODE_OPERATOR</name> <operator>==</operator> <name>type</name> <operator>||</operator>
          <name>QUERY_NODE_FUNCTION</name> <operator>==</operator> <name>type</name> <operator>||</operator> <name>QUERY_NODE_LOGIC_CONDITION</name> <operator>==</operator> <name>type</name> <operator>||</operator> <name>QUERY_NODE_CASE_WHEN</name> <operator>==</operator> <name>type</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>nodesIsUnaryOp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SOperatorNode</name><modifier>*</modifier></type> <name>pOp</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>pOp</name><operator>-&gt;</operator><name>opType</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OP_TYPE_MINUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_NULL</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_NOT_NULL</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_TRUE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_FALSE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_UNKNOWN</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_NOT_TRUE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_NOT_FALSE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_NOT_UNKNOWN</name></expr>:</case>
      <return>return <expr><name>true</name></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>nodesIsArithmeticOp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SOperatorNode</name><modifier>*</modifier></type> <name>pOp</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>pOp</name><operator>-&gt;</operator><name>opType</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OP_TYPE_ADD</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_SUB</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_MULTI</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_DIV</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_REM</name></expr>:</case>
      <return>return <expr><name>true</name></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>nodesIsComparisonOp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SOperatorNode</name><modifier>*</modifier></type> <name>pOp</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>pOp</name><operator>-&gt;</operator><name>opType</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OP_TYPE_GREATER_THAN</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_GREATER_EQUAL</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_LOWER_THAN</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_LOWER_EQUAL</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_EQUAL</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_NOT_EQUAL</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IN</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_NOT_IN</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_LIKE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_NOT_LIKE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_MATCH</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_NMATCH</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_JSON_CONTAINS</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_NULL</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_NOT_NULL</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_TRUE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_FALSE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_UNKNOWN</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_NOT_TRUE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_NOT_FALSE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_IS_NOT_UNKNOWN</name></expr>:</case>
      <return>return <expr><name>true</name></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>nodesIsJsonOp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SOperatorNode</name><modifier>*</modifier></type> <name>pOp</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>pOp</name><operator>-&gt;</operator><name>opType</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OP_TYPE_JSON_GET_VALUE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_JSON_CONTAINS</name></expr>:</case>
      <return>return <expr><name>true</name></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>nodesIsRegularOp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SOperatorNode</name><modifier>*</modifier></type> <name>pOp</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>pOp</name><operator>-&gt;</operator><name>opType</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OP_TYPE_LIKE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_NOT_LIKE</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_MATCH</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_NMATCH</name></expr>:</case>
      <return>return <expr><name>true</name></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>nodesIsBitwiseOp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SOperatorNode</name><modifier>*</modifier></type> <name>pOp</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>pOp</name><operator>-&gt;</operator><name>opType</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OP_TYPE_BIT_AND</name></expr>:</case>
    <case>case <expr><name>OP_TYPE_BIT_OR</name></expr>:</case>
      <return>return <expr><name>true</name></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SCollectColumnsCxt</name> <block>{
  <decl_stmt><decl><type><name>int32_t</name></type>         <name>errCode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>     <name>pTableAlias</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ECollectColType</name></type> <name>collectType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type>      <name>pCols</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SHashObj</name><modifier>*</modifier></type>       <name>pColHash</name></decl>;</decl_stmt>
}</block></struct></type> <name>SCollectColumnsCxt</name>;</typedef>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>doCollect</name><parameter_list>(<parameter><decl><type><name>SCollectColumnsCxt</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type>    <name><name>name</name><index>[<expr><name>TSDB_TABLE_NAME_LEN</name> <operator>+</operator> <name>TSDB_COL_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>==</operator> <name><name>pCol</name><operator>-&gt;</operator><name>tableAlias</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>tableAlias</name></name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>taosHashGet</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pColHash</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>taosHashPut</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pColHash</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>errCode</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pCols</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><ternary><condition><expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>errCode</name></name></expr> ?</condition><then> <expr><name>DEAL_RES_IGNORE_CHILD</name></expr> </then><else>: <expr><name>DEAL_RES_ERROR</name></expr></else></ternary><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isCollectType</name><parameter_list>(<parameter><decl><type><name>ECollectColType</name></type> <name>collectType</name></decl></parameter>, <parameter><decl><type><name>EColumnType</name></type> <name>colType</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>COLLECT_COL_TYPE_ALL</name> <operator>==</operator> <name>collectType</name></expr>
             ?</condition><then> <expr><name>true</name></expr>
             </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>COLLECT_COL_TYPE_TAG</name> <operator>==</operator> <name>collectType</name></expr> ?</condition><then> <expr><name>COLUMN_TYPE_TAG</name> <operator>==</operator> <name>colType</name></expr> </then><else>: <expr><name>COLUMN_TYPE_TAG</name> <operator>!=</operator> <name>colType</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>collectColumns</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SCollectColumnsCxt</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><operator>(</operator><name>SCollectColumnsCxt</name><operator>*</operator><operator>)</operator><name>pContext</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isCollectType</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>collectType</name></name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colType</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>NULL</name> <operator>==</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>pTableAlias</name></name> <operator>||</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pTableAlias</name></name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>tableAlias</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>doCollect</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesCollectColumns</name><parameter_list>(<parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>ESqlClause</name></type> <name>clause</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pTableAlias</name></decl></parameter>, <parameter><decl><type><name>ECollectColType</name></type> <name>type</name></decl></parameter>,
                            <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pCols</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSelect</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>pCols</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SCollectColumnsCxt</name></type> <name>cxt</name> <init>= <expr><block>{
      <expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>,
      <expr><operator>.</operator><name>pTableAlias</name> <operator>=</operator> <name>pTableAlias</name></expr>,
      <expr><operator>.</operator><name>collectType</name> <operator>=</operator> <name>type</name></expr>,
      <expr><operator>.</operator><name>pCols</name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pCols</name> <operator>?</operator> <call><name>nodesMakeList</name><argument_list>()</argument_list></call> <operator>:</operator> <operator>*</operator><name>pCols</name><operator>)</operator></expr>,
      <expr><operator>.</operator><name>pColHash</name> <operator>=</operator> <macro><name>taosHashInit</name><argument_list>(<argument><literal type="number">128</literal></argument>, <argument>taosGetDefaultHashFunction(TSDB_DATA_TYPE_BINARY)</argument>, <argument>true</argument>, <argument>HASH_NO_LOCK</argument>)</argument_list></macro></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>pCols</name></name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>pColHash</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pCols</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesWalkSelectStmt</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>collectColumns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pColHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pCols</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pCols</name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>pCols</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesCollectColumnsFromNode</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pTableAlias</name></decl></parameter>, <parameter><decl><type><name>ECollectColType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pCols</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pCols</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SCollectColumnsCxt</name></type> <name>cxt</name> <init>= <expr><block>{
      <expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>,
      <expr><operator>.</operator><name>pTableAlias</name> <operator>=</operator> <name>pTableAlias</name></expr>,
      <expr><operator>.</operator><name>collectType</name> <operator>=</operator> <name>type</name></expr>,
      <expr><operator>.</operator><name>pCols</name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pCols</name> <operator>?</operator> <call><name>nodesMakeList</name><argument_list>()</argument_list></call> <operator>:</operator> <operator>*</operator><name>pCols</name><operator>)</operator></expr>,
      <expr><operator>.</operator><name>pColHash</name> <operator>=</operator> <macro><name>taosHashInit</name><argument_list>(<argument><literal type="number">128</literal></argument>, <argument>taosGetDefaultHashFunction(TSDB_DATA_TYPE_BINARY)</argument>, <argument>true</argument>, <argument>HASH_NO_LOCK</argument>)</argument_list></macro></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>pCols</name></name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>pColHash</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pCols</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>collectColumns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pColHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pCols</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pCols</name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>pCols</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SCollectFuncsCxt</name> <block>{
  <decl_stmt><decl><type><name>int32_t</name></type>         <name>errCode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FFuncClassifier</name></type> <name>classifier</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type>      <name>pFuncs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SHashObj</name><modifier>*</modifier></type>       <name>pFuncsSet</name></decl>;</decl_stmt>
}</block></struct></type> <name>SCollectFuncsCxt</name>;</typedef>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>collectFuncs</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SCollectFuncsCxt</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><operator>(</operator><name>SCollectFuncsCxt</name><operator>*</operator><operator>)</operator><name>pContext</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_FUNCTION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>pCxt</name><operator>-&gt;</operator><name>classifier</name></name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>funcId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <operator>!</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>orderAlias</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SExprNode</name><modifier>*</modifier></type> <name>pExpr</name> <init>= <expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>taosHashGet</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pFuncsSet</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExpr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SExprNode</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosHashPut</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pFuncsSet</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExpr</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExpr</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><ternary><condition><expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>errCode</name></name></expr> ?</condition><then> <expr><name>DEAL_RES_IGNORE_CHILD</name></expr> </then><else>: <expr><name>DEAL_RES_ERROR</name></expr></else></ternary><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>funcNodeHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pKey</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExprNode</name><modifier>*</modifier></type> <name>pExpr</name> <init>= <expr><operator>*</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pKey</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>MurmurHash3_32</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>aliasName</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>aliasName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>funcNodeEqual</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>pRight</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>SExprNode</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pLeft</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>SExprNode</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pRight</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><ternary><condition><expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>SNode</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pLeft</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>SNode</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesCollectFuncs</name><parameter_list>(<parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>ESqlClause</name></type> <name>clause</name></decl></parameter>, <parameter><decl><type><name>FFuncClassifier</name></type> <name>classifier</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pFuncs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSelect</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>pFuncs</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SCollectFuncsCxt</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>,
                          <expr><operator>.</operator><name>classifier</name> <operator>=</operator> <name>classifier</name></expr>,
                          <expr><operator>.</operator><name>pFuncs</name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pFuncs</name> <operator>?</operator> <call><name>nodesMakeList</name><argument_list>()</argument_list></call> <operator>:</operator> <operator>*</operator><name>pFuncs</name><operator>)</operator></expr>,
                          <expr><operator>.</operator><name>pFuncsSet</name> <operator>=</operator> <macro><name>taosHashInit</name><argument_list>(<argument><literal type="number">4</literal></argument>, <argument>funcNodeHash</argument>, <argument>false</argument>, <argument>false</argument>)</argument_list></macro></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>pFuncs</name></name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>pFuncsSet</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>taosHashSetEqualFp</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pFuncsSet</name></name></expr></argument>, <argument><expr><name>funcNodeEqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pFuncs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesWalkSelectStmt</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>collectFuncs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pFuncs</name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>pFuncs</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pFuncsSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SCollectSpecialNodesCxt</name> <block>{
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>errCode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ENodeType</name></type>  <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pNodes</name></decl>;</decl_stmt>
}</block></struct></type> <name>SCollectSpecialNodesCxt</name>;</typedef>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>collectSpecialNodes</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SCollectSpecialNodesCxt</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><operator>(</operator><name>SCollectSpecialNodesCxt</name><operator>*</operator><operator>)</operator><name>pContext</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pCxt</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pNodes</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><ternary><condition><expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>errCode</name></name></expr> ?</condition><then> <expr><name>DEAL_RES_IGNORE_CHILD</name></expr> </then><else>: <expr><name>DEAL_RES_ERROR</name></expr></else></ternary><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesCollectSpecialNodes</name><parameter_list>(<parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>ESqlClause</name></type> <name>clause</name></decl></parameter>, <parameter><decl><type><name>ENodeType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pNodes</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSelect</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>pNodes</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SCollectSpecialNodesCxt</name></type> <name>cxt</name> <init>= <expr><block>{
      <expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>, <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>type</name></expr>, <expr><operator>.</operator><name>pNodes</name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pNodes</name> <operator>?</operator> <call><name>nodesMakeList</name><argument_list>()</argument_list></call> <operator>:</operator> <operator>*</operator><name>pNodes</name><operator>)</operator></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>pNodes</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pNodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nodesWalkSelectStmt</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_GROUP_BY</name></expr></argument>, <argument><expr><name>collectSpecialNodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pNodes</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pNodes</name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>pNodes</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>hasColumn</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><name>pContext</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <return>return <expr><name>DEAL_RES_END</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>nodesExprHasColumn</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>hasCol</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesWalkExprPostOrder</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>hasColumn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>hasCol</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>nodesExprsHasColumn</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>hasCol</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesWalkExprsPostOrder</name><argument_list>(<argument><expr><name>pList</name></expr></argument>, <argument><expr><name>hasColumn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>hasCol</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier></type> <name>nodesGetFillModeString</name><parameter_list>(<parameter><decl><type><name>EFillMode</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>FILL_MODE_NONE</name></expr>:</case>
      <return>return <expr><literal type="string">"none"</literal></expr>;</return>
    <case>case <expr><name>FILL_MODE_VALUE</name></expr>:</case>
      <return>return <expr><literal type="string">"value"</literal></expr>;</return>
    <case>case <expr><name>FILL_MODE_PREV</name></expr>:</case>
      <return>return <expr><literal type="string">"prev"</literal></expr>;</return>
    <case>case <expr><name>FILL_MODE_NULL</name></expr>:</case>
      <return>return <expr><literal type="string">"null"</literal></expr>;</return>
    <case>case <expr><name>FILL_MODE_LINEAR</name></expr>:</case>
      <return>return <expr><literal type="string">"linear"</literal></expr>;</return>
    <case>case <expr><name>FILL_MODE_NEXT</name></expr>:</case>
      <return>return <expr><literal type="string">"next"</literal></expr>;</return>
    <default>default:</default>
      <return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier></type> <name>nodesGetNameFromColumnNode</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pNode</name> <operator>||</operator> <name>QUERY_NODE_COLUMN</name> <operator>!=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="string">"NULL"</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesGetOutputNumFromSlotList</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSlots</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSlots</name> <operator>||</operator> <name><name>pSlots</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pSlots</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_SLOT_DESC</name> <operator>!=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>SSlotDescNode</name><modifier>*</modifier></type> <name>descNode</name> <init>= <expr><operator>(</operator><name>SSlotDescNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>descNode</name><operator>-&gt;</operator><name>output</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>++</operator><name>num</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesValueNodeToVariant</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SValueNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>SVariant</name><modifier>*</modifier></type> <name>pVal</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pNode</name><operator>-&gt;</operator><name>isNull</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name>TSDB_DATA_TYPE_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>nLen</name></name> <operator>=</operator> <name><name>tDataTypes</name><index>[<expr><name>TSDB_DATA_TYPE_NULL</name></expr>]</index></name><operator>.</operator><name>bytes</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>nType</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>nLen</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>bytes</name></name></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name><name>pNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_NULL</name></expr>:</case>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case>
      <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>b</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>:</case>
      <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case>
      <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>u</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>u</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case>
      <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>d</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case>
      <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>d</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>d</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_NCHAR</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_VARCHAR</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_VARBINARY</name></expr>:</case>
      <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>pz</name></name> <operator>=</operator> <call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>nLen</name></name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>pz</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>nLen</name></name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>pz</name><index>[<expr><name><name>pVal</name><operator>-&gt;</operator><name>nLen</name></name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_JSON</name></expr>:</case>
      <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>nLen</name></name> <operator>=</operator> <call><name>getJsonValueLen</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pVal</name><operator>-&gt;</operator><name>pz</name></name> <operator>=</operator> <call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>nLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>pz</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>datum</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>nLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_DECIMAL</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_BLOB</name></expr>:</case>
      <comment type="line">// todo</comment>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nodesMergeConds</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pDst</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pSrc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pSrc</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><operator>*</operator><name>pSrc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pDst</name> <operator>=</operator> <call><name>nodesListGetNode</name><argument_list>(<argument><expr><operator>*</operator><name>pSrc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesClearList</name><argument_list>(<argument><expr><operator>*</operator><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>SLogicConditionNode</name><modifier>*</modifier></type> <name>pLogicCond</name> <init>= <expr><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_CONDITION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pLogicCond</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pLogicCond</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>TSDB_DATA_TYPE_BOOL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLogicCond</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>bytes</name></name> <operator>=</operator> <name><name>tDataTypes</name><index>[<expr><name>TSDB_DATA_TYPE_BOOL</name></expr>]</index></name><operator>.</operator><name>bytes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLogicCond</name><operator>-&gt;</operator><name>condType</name></name> <operator>=</operator> <name>LOGIC_COND_TYPE_AND</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLogicCond</name><operator>-&gt;</operator><name>pParameterList</name></name> <operator>=</operator> <operator>*</operator><name>pSrc</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pDst</name> <operator>=</operator> <operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pLogicCond</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pSrc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>dataOrderStr</name><parameter_list>(<parameter><decl><type><name>EDataOrderLevel</name></type> <name>order</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>order</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>DATA_ORDER_LEVEL_NONE</name></expr>:</case>
      <return>return <expr><literal type="string">"no order required"</literal></expr>;</return>
    <case>case <expr><name>DATA_ORDER_LEVEL_IN_BLOCK</name></expr>:</case>
      <return>return <expr><literal type="string">"in-datablock order"</literal></expr>;</return>
    <case>case <expr><name>DATA_ORDER_LEVEL_IN_GROUP</name></expr>:</case>
      <return>return <expr><literal type="string">"in-group order"</literal></expr>;</return>
    <case>case <expr><name>DATA_ORDER_LEVEL_GLOBAL</name></expr>:</case>
      <return>return <expr><literal type="string">"global order"</literal></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
</block_content>}</block></function>
</unit>
