<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/source/libs/nodes/src/nodesTraverseFuncs.c"><comment type="block">/*
 * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the GNU Affero General Public License, version 3
 * or later ("AGPL"), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"querynodes.h"</cpp:file></cpp:include>

<typedef>typedef <type><enum>enum <name>ETraversalOrder</name> <block>{
  <decl><name>TRAVERSAL_PREORDER</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>TRAVERSAL_INORDER</name></decl>,
  <decl><name>TRAVERSAL_POSTORDER</name></decl>,
}</block></enum></type> <name>ETraversalOrder</name>;</typedef>

<typedef>typedef <function_decl><type><name>EDealRes</name></type> (<modifier>*</modifier><name>FNodeDispatcher</name>)<parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>ETraversalOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function_decl><type><specifier>static</specifier> <name>EDealRes</name></type> <name>walkExpr</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>ETraversalOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>EDealRes</name></type> <name>walkExprs</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pNodeList</name></decl></parameter>, <parameter><decl><type><name>ETraversalOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>EDealRes</name></type> <name>walkPhysiPlan</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>ETraversalOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>EDealRes</name></type> <name>walkPhysiPlans</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pNodeList</name></decl></parameter>, <parameter><decl><type><name>ETraversalOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>walkNode</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>ETraversalOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>,
                         <parameter><decl><type><name>FNodeDispatcher</name></type> <name>dispatcher</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pNode</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>EDealRes</name></type> <name>res</name> <init>= <expr><name>DEAL_RES_CONTINUE</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>TRAVERSAL_PREORDER</name> <operator>==</operator> <name>order</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walker</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>DEAL_RES_CONTINUE</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>res</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>dispatcher</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>TRAVERSAL_POSTORDER</name> <operator>==</operator> <name>order</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walker</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>dispatchExpr</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>ETraversalOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>EDealRes</name></type> <name>res</name> <init>= <expr><name>DEAL_RES_CONTINUE</name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_COLUMN</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_VALUE</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_LIMIT</name></expr>:</case>
      <comment type="line">// these node types with no subnodes</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_OPERATOR</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SOperatorNode</name><modifier>*</modifier></type> <name>pOpNode</name> <init>= <expr><operator>(</operator><name>SOperatorNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pOpNode</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pOpNode</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_CONDITION</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExprs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_FUNCTION</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExprs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_REAL_TABLE</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_TEMP_TABLE</name></expr>:</case>
      <break>break;</break>  <comment type="line">// todo</comment>
    <case>case <expr><name>QUERY_NODE_JOIN_TABLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SJoinTableNode</name><modifier>*</modifier></type> <name>pJoinTableNode</name> <init>= <expr><operator>(</operator><name>SJoinTableNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pJoinTableNode</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pJoinTableNode</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pJoinTableNode</name><operator>-&gt;</operator><name>pOnCond</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_GROUPING_SET</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExprs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SGroupingSetNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_ORDER_BY_EXPR</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SOrderByExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pExpr</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_STATE_WINDOW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SStateWindowNode</name><modifier>*</modifier></type> <name>pState</name> <init>= <expr><operator>(</operator><name>SStateWindowNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pState</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pState</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_SESSION_WINDOW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SSessionWindowNode</name><modifier>*</modifier></type> <name>pSession</name> <init>= <expr><operator>(</operator><name>SSessionWindowNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pSession</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pSession</name><operator>-&gt;</operator><name>pGap</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_INTERVAL_WINDOW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SIntervalWindowNode</name><modifier>*</modifier></type> <name>pInterval</name> <init>= <expr><operator>(</operator><name>SIntervalWindowNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pInterval</name><operator>-&gt;</operator><name>pInterval</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pInterval</name><operator>-&gt;</operator><name>pOffset</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pInterval</name><operator>-&gt;</operator><name>pSliding</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pInterval</name><operator>-&gt;</operator><name>pFill</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pInterval</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_NODE_LIST</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExprs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SNodeListNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pNodeList</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_FILL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SFillNode</name><modifier>*</modifier></type> <name>pFill</name> <init>= <expr><operator>(</operator><name>SFillNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pFill</name><operator>-&gt;</operator><name>pValues</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pFill</name><operator>-&gt;</operator><name>pWStartTs</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_RAW_EXPR</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SRawExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pNode</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_TARGET</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>STargetNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pExpr</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_WHEN_THEN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SWhenThenNode</name><modifier>*</modifier></type> <name>pWhenThen</name> <init>= <expr><operator>(</operator><name>SWhenThenNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pWhenThen</name><operator>-&gt;</operator><name>pWhen</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pWhenThen</name><operator>-&gt;</operator><name>pThen</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_CASE_WHEN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SCaseWhenNode</name><modifier>*</modifier></type> <name>pCaseWhen</name> <init>= <expr><operator>(</operator><name>SCaseWhenNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pCaseWhen</name><operator>-&gt;</operator><name>pCase</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExpr</name><argument_list>(<argument><expr><name><name>pCaseWhen</name><operator>-&gt;</operator><name>pElse</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walkExprs</name><argument_list>(<argument><expr><name><name>pCaseWhen</name><operator>-&gt;</operator><name>pWhenThenList</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>walkExpr</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>ETraversalOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>walkNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>dispatchExpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>walkExprs</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pNodeList</name></decl></parameter>, <parameter><decl><type><name>ETraversalOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>node</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>node</argument>, <argument>pNodeList</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>EDealRes</name></type> <name>res</name> <init>= <expr><call><name>walkExpr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>==</operator> <name>res</name> <operator>||</operator> <name>DEAL_RES_END</name> <operator>==</operator> <name>res</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>res</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesWalkExpr</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>walkExpr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>TRAVERSAL_PREORDER</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesWalkExprs</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pNodeList</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>walkExprs</name><argument_list>(<argument><expr><name>pNodeList</name></expr></argument>, <argument><expr><name>TRAVERSAL_PREORDER</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesWalkExprPostOrder</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>walkExpr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>TRAVERSAL_POSTORDER</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesWalkExprsPostOrder</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>walkExprs</name><argument_list>(<argument><expr><name>pList</name></expr></argument>, <argument><expr><name>TRAVERSAL_POSTORDER</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>EDealRes</name></type> <name>rewriteExprs</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pNodeList</name></decl></parameter>, <parameter><decl><type><name>ETraversalOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>FNodeRewriter</name></type> <name>rewriter</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>rewriteExpr</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pRawNode</name></decl></parameter>, <parameter><decl><type><name>ETraversalOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>FNodeRewriter</name></type> <name>rewriter</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pRawNode</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <operator>*</operator><name>pRawNode</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>EDealRes</name></type> <name>res</name> <init>= <expr><name>DEAL_RES_CONTINUE</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>TRAVERSAL_PREORDER</name> <operator>==</operator> <name>order</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriter</name><argument_list>(<argument><expr><name>pRawNode</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>DEAL_RES_CONTINUE</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>res</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name> <init>= <expr><operator>*</operator><name>pRawNode</name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_COLUMN</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_VALUE</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_LIMIT</name></expr>:</case>
      <comment type="line">// these node types with no subnodes</comment>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_OPERATOR</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SOperatorNode</name><modifier>*</modifier></type> <name>pOpNode</name> <init>= <expr><operator>(</operator><name>SOperatorNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pOpNode</name><operator>-&gt;</operator><name>pLeft</name></name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pOpNode</name><operator>-&gt;</operator><name>pRight</name></name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_CONDITION</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExprs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_FUNCTION</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExprs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_REAL_TABLE</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_TEMP_TABLE</name></expr>:</case>
      <break>break;</break>  <comment type="line">// todo</comment>
    <case>case <expr><name>QUERY_NODE_JOIN_TABLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SJoinTableNode</name><modifier>*</modifier></type> <name>pJoinTableNode</name> <init>= <expr><operator>(</operator><name>SJoinTableNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pJoinTableNode</name><operator>-&gt;</operator><name>pLeft</name></name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pJoinTableNode</name><operator>-&gt;</operator><name>pRight</name></name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pJoinTableNode</name><operator>-&gt;</operator><name>pOnCond</name></name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_GROUPING_SET</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExprs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SGroupingSetNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_ORDER_BY_EXPR</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>SOrderByExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pExpr</name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_STATE_WINDOW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SStateWindowNode</name><modifier>*</modifier></type> <name>pState</name> <init>= <expr><operator>(</operator><name>SStateWindowNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pState</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pState</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_SESSION_WINDOW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SSessionWindowNode</name><modifier>*</modifier></type> <name>pSession</name> <init>= <expr><operator>(</operator><name>SSessionWindowNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pSession</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pSession</name><operator>-&gt;</operator><name>pGap</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_INTERVAL_WINDOW</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SIntervalWindowNode</name><modifier>*</modifier></type> <name>pInterval</name> <init>= <expr><operator>(</operator><name>SIntervalWindowNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pInterval</name><operator>-&gt;</operator><name>pInterval</name></name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pInterval</name><operator>-&gt;</operator><name>pOffset</name></name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pInterval</name><operator>-&gt;</operator><name>pSliding</name></name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pInterval</name><operator>-&gt;</operator><name>pFill</name></name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pInterval</name><operator>-&gt;</operator><name>pCol</name></name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_NODE_LIST</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExprs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SNodeListNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pNodeList</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_FILL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SFillNode</name><modifier>*</modifier></type> <name>pFill</name> <init>= <expr><operator>(</operator><name>SFillNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFill</name><operator>-&gt;</operator><name>pValues</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pFill</name><operator>-&gt;</operator><name>pWStartTs</name></name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_RAW_EXPR</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>SRawExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pNode</name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_TARGET</name></expr>:</case>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>STargetNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pExpr</name><operator>)</operator></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_WHEN_THEN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SWhenThenNode</name><modifier>*</modifier></type> <name>pWhenThen</name> <init>= <expr><operator>(</operator><name>SWhenThenNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWhenThen</name><operator>-&gt;</operator><name>pWhen</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWhenThen</name><operator>-&gt;</operator><name>pThen</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_CASE_WHEN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SCaseWhenNode</name><modifier>*</modifier></type> <name>pCaseWhen</name> <init>= <expr><operator>(</operator><name>SCaseWhenNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCaseWhen</name><operator>-&gt;</operator><name>pCase</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCaseWhen</name><operator>-&gt;</operator><name>pElse</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriteExprs</name><argument_list>(<argument><expr><name><name>pCaseWhen</name><operator>-&gt;</operator><name>pWhenThenList</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>DEAL_RES_END</name> <operator>!=</operator> <name>res</name> <operator>&amp;&amp;</operator> <name>TRAVERSAL_POSTORDER</name> <operator>==</operator> <name>order</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rewriter</name><argument_list>(<argument><expr><name>pRawNode</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>rewriteExprs</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pNodeList</name></decl></parameter>, <parameter><decl><type><name>ETraversalOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>FNodeRewriter</name></type> <name>rewriter</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pNode</name></decl>;</decl_stmt>
  <macro><name>FOREACH_FOR_REWRITE</name><argument_list>(<argument>pNode</argument>, <argument>pNodeList</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>EDealRes</name></type> <name>res</name> <init>= <expr><call><name>rewriteExpr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>DEAL_RES_ERROR</name> <operator>==</operator> <name>res</name> <operator>||</operator> <name>DEAL_RES_END</name> <operator>==</operator> <name>res</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>res</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesRewriteExpr</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>FNodeRewriter</name></type> <name>rewriter</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>rewriteExpr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>TRAVERSAL_PREORDER</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesRewriteExprs</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>, <parameter><decl><type><name>FNodeRewriter</name></type> <name>rewriter</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>rewriteExprs</name><argument_list>(<argument><expr><name>pList</name></expr></argument>, <argument><expr><name>TRAVERSAL_PREORDER</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesRewriteExprPostOrder</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>FNodeRewriter</name></type> <name>rewriter</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>rewriteExpr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>TRAVERSAL_POSTORDER</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesRewriteExprsPostOrder</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>, <parameter><decl><type><name>FNodeRewriter</name></type> <name>rewriter</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>rewriteExprs</name><argument_list>(<argument><expr><name>pList</name></expr></argument>, <argument><expr><name>TRAVERSAL_POSTORDER</name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesWalkSelectStmt</name><parameter_list>(<parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>ESqlClause</name></type> <name>clause</name></decl></parameter>, <parameter><decl><type><name>FNodeWalker</name></type> <name>walker</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSelect</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><name>clause</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>SQL_CLAUSE_FROM</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pFromTable</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>SQL_CLAUSE_WHERE</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesWalkExprs</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pPartitionByList</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesWalkExprs</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSubtable</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>SQL_CLAUSE_PARTITION_BY</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>SQL_CLAUSE_WINDOW</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name> <operator>&amp;&amp;</operator> <name>QUERY_NODE_INTERVAL_WINDOW</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SIntervalWindowNode</name><operator>*</operator><operator>)</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name><operator>)</operator><operator>-&gt;</operator><name>pFill</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <case>case <expr><name>SQL_CLAUSE_FILL</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesWalkExprs</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pGroupByList</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>SQL_CLAUSE_GROUP_BY</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>SQL_CLAUSE_HAVING</name></expr>:</case>
    <case>case <expr><name>SQL_CLAUSE_SELECT</name></expr>:</case>
    <case>case <expr><name>SQL_CLAUSE_DISTINCT</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesWalkExprs</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pOrderByList</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>SQL_CLAUSE_ORDER_BY</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesWalkExprs</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pProjectionList</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>nodesRewriteSelectStmt</name><parameter_list>(<parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>ESqlClause</name></type> <name>clause</name></decl></parameter>, <parameter><decl><type><name>FNodeRewriter</name></type> <name>rewriter</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSelect</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><name>clause</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>SQL_CLAUSE_FROM</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesRewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pFromTable</name></name><operator>)</operator></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesRewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pWhere</name></name><operator>)</operator></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>SQL_CLAUSE_WHERE</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesRewriteExprs</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pPartitionByList</name></name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesRewriteExprs</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesRewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pSubtable</name></name><operator>)</operator></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>SQL_CLAUSE_PARTITION_BY</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesRewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name><operator>)</operator></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>SQL_CLAUSE_WINDOW</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name> <operator>&amp;&amp;</operator> <name>QUERY_NODE_INTERVAL_WINDOW</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>nodesRewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>SIntervalWindowNode</name><operator>*</operator><operator>)</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name><operator>)</operator><operator>-&gt;</operator><name>pFill</name><operator>)</operator></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <case>case <expr><name>SQL_CLAUSE_FILL</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesRewriteExprs</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pGroupByList</name></name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>SQL_CLAUSE_GROUP_BY</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesRewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pHaving</name></name><operator>)</operator></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>SQL_CLAUSE_HAVING</name></expr>:</case>
    <case>case <expr><name>SQL_CLAUSE_SELECT</name></expr>:</case>
    <case>case <expr><name>SQL_CLAUSE_DISTINCT</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesRewriteExprs</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pOrderByList</name></name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>SQL_CLAUSE_ORDER_BY</name></expr>:</case>
      <expr_stmt><expr><call><name>nodesRewriteExprs</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pProjectionList</name></name></expr></argument>, <argument><expr><name>rewriter</name></expr></argument>, <argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return;</return>
</block_content>}</block></function>
</unit>
