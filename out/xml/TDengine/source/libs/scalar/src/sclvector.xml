<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/source/libs/scalar/src/sclvector.c"><comment type="block">/*
 * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the GNU Affero General Public License, version 3
 * or later ("AGPL"), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"filterInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"querynodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sclInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sclvector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcompare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdatablock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdataformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ttime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ttypes.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFT_COL</name></cpp:macro>  <cpp:value>((pLeftCol-&gt;info.type == TSDB_DATA_TYPE_JSON ? (void *)pLeftCol : pLeftCol-&gt;pData))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIGHT_COL</name></cpp:macro> <cpp:value>((pRightCol-&gt;info.type == TSDB_DATA_TYPE_JSON ? (void *)pRightCol : pRightCol-&gt;pData))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NULL</name></cpp:macro>                                                                              \
  <cpp:value>colDataIsNull_s(pLeft-&gt;columnData, i) || colDataIsNull_s(pRight-&gt;columnData, i) ||         \
      IS_JSON_NULL(pLeft-&gt;columnData-&gt;info.type, colDataGetVarData(pLeft-&gt;columnData, i)) || \
      IS_JSON_NULL(pRight-&gt;columnData-&gt;info.type, colDataGetVarData(pRight-&gt;columnData, i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_HELPER_NULL</name><parameter_list>(<parameter><type><name>col</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>colDataIsNull_s(col, i) || IS_JSON_NULL(col-&gt;info.type, colDataGetVarData(col, i))</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>convertNumberToNumber</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>inData</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>outData</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>inType</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>outType</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>outType</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>inType</name></expr></argument>, <argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator></expr></argument>, <argument><expr><name>int8_t</name></expr></argument>, <argument><expr><name>inType</name></expr></argument>, <argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator></expr></argument>, <argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>inType</name></expr></argument>, <argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>, <argument><expr><name>inType</name></expr></argument>, <argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>inType</name></expr></argument>, <argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator></expr></argument>, <argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>inType</name></expr></argument>, <argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator></expr></argument>, <argument><expr><name>uint16_t</name></expr></argument>, <argument><expr><name>inType</name></expr></argument>, <argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><name>inType</name></expr></argument>, <argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><name>inType</name></expr></argument>, <argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator></expr></argument>, <argument><expr><name>float</name></expr></argument>, <argument><expr><name>inType</name></expr></argument>, <argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator></expr></argument>, <argument><expr><name>double</name></expr></argument>, <argument><expr><name>inType</name></expr></argument>, <argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>convertNcharToDouble</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>inData</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>outData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><call><name>varDataTLen</name><argument_list>(<argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>   <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sclError</name><argument_list>(<argument><expr><literal type="string">"castConvert taosUcs4ToMbs error 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>taosStr2Double</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>convertBinaryToDouble</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>inData</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>outData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>varDataTLen</name><argument_list>(<argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator> <operator>=</operator> <literal type="number">0.</literal></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>inData</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>ret</name> <init>= <expr><call><name>taosStr2Double</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>outData</name><operator>)</operator> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>int64_t</name></type> (<modifier>*</modifier><name>_getBigintValue_fn_t</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><name>int64_t</name></type> <name>getVectorBigintValue_TINYINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>getVectorBigintValue_UTINYINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>getVectorBigintValue_SMALLINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>getVectorBigintValue_USMALLINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>getVectorBigintValue_INT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>getVectorBigintValue_UINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>getVectorBigintValue_BIGINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>getVectorBigintValue_UBIGINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>getVectorBigintValue_FLOAT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>getVectorBigintValue_DOUBLE</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>getVectorBigintValue_BOOL</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>

<function><type><name>int64_t</name></type> <name>getVectorBigintValue_JSON</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>colDataIsNull_var</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SColumnInfoData</name> <operator>*</operator><operator>)</operator><name>src</name><operator>)</operator></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>colDataGetVarData</name><argument_list>(<argument><expr><operator>(</operator><name>SColumnInfoData</name> <operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>out</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>data</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>data</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>  <comment type="line">// json inner type can not be BINARY</comment>
    <expr_stmt><expr><call><name>convertNcharToDouble</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>CHAR_BYTES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tTagIsJson</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_QRY_JSON_NOT_SUPPORT_ERROR</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>convertNumberToNumber</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>CHAR_BYTES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><operator>*</operator><name>data</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFn</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>srcType</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_TINYINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_TINYINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UTINYINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_UTINYINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_SMALLINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_SMALLINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_USMALLINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_USMALLINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_INT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_INT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_UINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BIGINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_BIGINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UBIGINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_UBIGINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_FLOAT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_FLOAT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_DOUBLE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_DOUBLE</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_BIGINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_BOOL</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_JSON</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorBigintValue_JSON</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>_getValueAddr_fn_t</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><name>void</name> <modifier>*</modifier></type><name>getVectorValueAddr_TINYINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>getVectorValueAddr_UTINYINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>getVectorValueAddr_SMALLINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>getVectorValueAddr_USMALLINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>getVectorValueAddr_INT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>getVectorValueAddr_UINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>getVectorValueAddr_BIGINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>getVectorValueAddr_UBIGINT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>getVectorValueAddr_FLOAT</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>getVectorValueAddr_DOUBLE</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>src</name> <operator>+</operator> <name>index</name><operator>)</operator></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>getVectorValueAddr_default</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>src</name></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name> <modifier>*</modifier></type><name>getVectorValueAddr_VAR</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><operator>(</operator><name>SColumnInfoData</name> <operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>_getValueAddr_fn_t</name></type> <name>getVectorValueAddrFn</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>srcType</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>_getValueAddr_fn_t</name></type> <name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_TINYINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_TINYINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UTINYINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_UTINYINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_SMALLINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_SMALLINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_USMALLINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_USMALLINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_INT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_INT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_UINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BIGINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_BIGINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UBIGINT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_UBIGINT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_FLOAT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_FLOAT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_DOUBLE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_DOUBLE</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_VAR</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>srcType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_VAR</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>getVectorValueAddr_default</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>void</name></type> <name>varToTimestamp</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>rowIndex</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>overflow</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>taosParseTime</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>precision</name></name></expr></argument>, <argument><expr><name>tsDaylight</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>void</name></type> <name>varToSigned</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>rowIndex</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>overflow</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>overflow</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>minValue</name> <init>= <expr><name><name>tDataTypes</name><index>[<expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>minValue</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>maxValue</name> <init>= <expr><name><name>tDataTypes</name><index>[<expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>maxValue</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>value</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator><call><name>taosStr2Int64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;</operator> <name>maxValue</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name>minValue</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int8_t</name></type> <name>value</name> <init>= <expr><operator>(</operator><name>int8_t</name><operator>)</operator><call><name>taosStr2Int8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int16_t</name></type> <name>value</name> <init>= <expr><operator>(</operator><name>int16_t</name><operator>)</operator><call><name>taosStr2Int16</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>colDataAppendInt16</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>value</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>taosStr2Int32</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>colDataAppendInt32</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>value</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator><call><name>taosStr2Int64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>void</name></type> <name>varToUnsigned</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>rowIndex</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>overflow</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>overflow</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>minValue</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>tDataTypes</name><index>[<expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>minValue</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>maxValue</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>tDataTypes</name><index>[<expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr>]</index></name><operator>.</operator><name>maxValue</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>value</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>taosStr2UInt64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;</operator> <name>maxValue</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name>minValue</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>value</name> <init>= <expr><operator>(</operator><name>uint8_t</name><operator>)</operator><call><name>taosStr2UInt8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint16_t</name></type> <name>value</name> <init>= <expr><operator>(</operator><name>uint16_t</name><operator>)</operator><call><name>taosStr2UInt16</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>colDataAppendInt16</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>taosStr2UInt32</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>colDataAppendInt32</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>value</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>taosStr2UInt64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>void</name></type> <name>varToFloat</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>rowIndex</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>overflow</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>TSDB_DATA_TYPE_FLOAT</name> <operator>==</operator> <name><name>pOut</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>float</name></type> <name>value</name> <init>= <expr><call><name>taosStr2Float</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>colDataAppendFloat</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><call><name>taosStr2Double</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>colDataAppendDouble</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>void</name></type> <name>varToBool</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>rowIndex</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>overflow</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>value</name> <init>= <expr><call><name>taosStr2Int64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>    <name>v</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>value</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>void</name></type> <name>varToNchar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>rowIndex</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>overflow</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>inputLen</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>outputMaxLen</name> <init>= <expr><operator>(</operator><name>inputLen</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>TSDB_NCHAR_SIZE</name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>outputMaxLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>=
      <expr><call><name>taosMbsToUcs4</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>inputLen</name></expr></argument>, <argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>outputMaxLen</name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sclError</name><argument_list>(<argument><expr><literal type="string">"failed to convert to NCHAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>void</name></type> <name>ncharToVar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>rowIndex</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>overflow</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>inputLen</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>inputLen</name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// TODO opt performance, tmp is not needed.</comment>
<function><type><name>int32_t</name></type> <name>vectorConvertFromVarData</name><parameter_list>(<parameter><decl><type><name>SSclVectorConvCtx</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>overflow</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>vton</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>_bufConverteFunc</name></type> <name>func</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_DATA_TYPE_BOOL</name> <operator>==</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>outType</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <name>varToBool</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IS_SIGNED_NUMERIC_TYPE</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>outType</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <name>varToSigned</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IS_UNSIGNED_NUMERIC_TYPE</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>outType</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <name>varToUnsigned</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IS_FLOAT_TYPE</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>outType</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <name>varToFloat</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pCtx</name><operator>-&gt;</operator><name>outType</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>  <comment type="line">// nchar -&gt; binary</comment>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <name>ncharToVar</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>vton</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pCtx</name><operator>-&gt;</operator><name>outType</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>  <comment type="line">// binary -&gt; nchar</comment>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <name>varToNchar</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>vton</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>TSDB_DATA_TYPE_TIMESTAMP</name> <operator>==</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>outType</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <name>varToTimestamp</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>sclError</name><argument_list>(<argument><expr><literal type="string">"invalid convert outType:%d"</literal></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>outType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_APP_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>colDataGetVarData</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>convertType</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_JSON</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>data</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>data</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>data</name> <operator>+=</operator> <name>CHAR_BYTES</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>convertType</name> <operator>=</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tTagIsJson</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_QRY_JSON_NOT_SUPPORT_ERROR</name></expr>;</expr_stmt>
        <return>return <expr><name>terrno</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>convertNumberToNumber</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>CHAR_BYTES</name></expr></argument>, <argument><expr><call><name>colDataGetNumData</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>data</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>outType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>bufSize</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>bytes</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><call><name>varDataTLen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sclError</name><argument_list>(<argument><expr><literal type="string">"out of memory in vectorConvertFromVarData"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>vton</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>varDataTLen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>TSDB_DATA_TYPE_VARCHAR</name> <operator>==</operator> <name>convertType</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>TSDB_DATA_TYPE_NCHAR</name> <operator>==</operator> <name>convertType</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>bufSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>sclError</name><argument_list>(<argument><expr><literal type="string">"castConvert taosUcs4ToMbs error 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>TSDB_CODE_APP_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>overflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>double</name></type> <name>getVectorDoubleValue_JSON</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>colDataGetVarData</name><argument_list>(<argument><expr><operator>(</operator><name>SColumnInfoData</name> <operator>*</operator><operator>)</operator><name>src</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>out</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>data</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>out</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>data</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>  <comment type="line">// json inner type can not be BINARY</comment>
    <expr_stmt><expr><call><name>convertNcharToDouble</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>CHAR_BYTES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>tTagIsJson</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_QRY_JSON_NOT_SUPPORT_ERROR</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>convertNumberToNumber</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <name>CHAR_BYTES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><operator>*</operator><name>data</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type><name>ncharTobinary</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list> <block>{<block_content>  <comment type="line">// todo need to remove , if tobinary is nchar</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>inputLen</name> <init>= <expr><call><name>varDataTLen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>void</name>   <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>inputLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sclError</name><argument_list>(<argument><expr><literal type="string">"charset:%s to %s. val:%s convert ncharTobinary failed."</literal></expr></argument>, <argument><expr><name>DEFAULT_UNICODE_ENCODEC</name></expr></argument>, <argument><expr><name>tsCharset</name></expr></argument>,
             <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>convertJsonValue</name><parameter_list>(<parameter><decl><type><name>__compar_fn_t</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>optr</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>typeLeft</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>typeRight</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pLeftData</name></decl></parameter>,
                      <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pRightData</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pLeftOut</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pRightOut</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>freeLeft</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>freeRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_JSON_CONTAINS</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>typeLeft</name> <operator>!=</operator> <name>TSDB_DATA_TYPE_JSON</name> <operator>&amp;&amp;</operator> <name>typeRight</name> <operator>!=</operator> <name>TSDB_DATA_TYPE_JSON</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>typeLeft</name> <operator>==</operator> <name>TSDB_DATA_TYPE_JSON</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tTagIsJson</name><argument_list>(<argument><expr><operator>*</operator><name>pLeftData</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_QRY_JSON_NOT_SUPPORT_ERROR</name></expr>;</expr_stmt>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>typeLeft</name> <operator>=</operator> <operator>*</operator><operator>*</operator><name>pLeftData</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>pLeftData</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>typeRight</name> <operator>==</operator> <name>TSDB_DATA_TYPE_JSON</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>tTagIsJson</name><argument_list>(<argument><expr><operator>*</operator><name>pRightData</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_QRY_JSON_NOT_SUPPORT_ERROR</name></expr>;</expr_stmt>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>typeRight</name> <operator>=</operator> <operator>*</operator><operator>*</operator><name>pRightData</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>pRightData</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_LIKE</name> <operator>||</operator> <name>optr</name> <operator>==</operator> <name>OP_TYPE_NOT_LIKE</name> <operator>||</operator> <name>optr</name> <operator>==</operator> <name>OP_TYPE_MATCH</name> <operator>||</operator> <name>optr</name> <operator>==</operator> <name>OP_TYPE_NMATCH</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>typeLeft</name> <operator>!=</operator> <name>TSDB_DATA_TYPE_NCHAR</name> <operator>&amp;&amp;</operator> <name>typeLeft</name> <operator>!=</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// if types can not comparable</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IS_NUMERIC_TYPE</name><argument_list>(<argument><expr><name>typeLeft</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NUMERIC_TYPE</name><argument_list>(<argument><expr><name>typeRight</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
      <operator>(</operator><call><name>IS_NUMERIC_TYPE</name><argument_list>(<argument><expr><name>typeRight</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NUMERIC_TYPE</name><argument_list>(<argument><expr><name>typeLeft</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
      <operator>(</operator><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name>typeLeft</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name>typeRight</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
      <operator>(</operator><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name>typeRight</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name>typeLeft</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
      <operator>(</operator><operator>(</operator><name>typeLeft</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>typeRight</name> <operator>!=</operator> <name>TSDB_DATA_TYPE_BOOL</name><operator>)</operator><operator>)</operator> <operator>||</operator>
      <operator>(</operator><operator>(</operator><name>typeRight</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>typeLeft</name> <operator>!=</operator> <name>TSDB_DATA_TYPE_BOOL</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>typeLeft</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NULL</name> <operator>||</operator> <name>typeRight</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type> <name>type</name> <init>= <expr><call><name>vectorGetConvertType</name><argument_list>(<argument><expr><name>typeLeft</name></expr></argument>, <argument><expr><name>typeRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>fp</name> <operator>=</operator> <call><name>filterGetCompFunc</name><argument_list>(<argument><expr><name>typeLeft</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>fp</name> <operator>=</operator> <call><name>filterGetCompFunc</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_NUMERIC_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>typeLeft</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">//      convertNcharToDouble(*pLeftData, pLeftOut);</comment>
      <comment type="line">//      *pLeftData = pLeftOut;</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>typeLeft</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">//      convertBinaryToDouble(*pLeftData, pLeftOut);</comment>
      <comment type="line">//      *pLeftData = pLeftOut;</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>typeLeft</name> <operator>!=</operator> <name>type</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>convertNumberToNumber</name><argument_list>(<argument><expr><operator>*</operator><name>pLeftData</name></expr></argument>, <argument><expr><name>pLeftOut</name></expr></argument>, <argument><expr><name>typeLeft</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pLeftData</name> <operator>=</operator> <name>pLeftOut</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>typeRight</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">//      convertNcharToDouble(*pRightData, pRightOut);</comment>
      <comment type="line">//      *pRightData = pRightOut;</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>typeRight</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">//      convertBinaryToDouble(*pRightData, pRightOut);</comment>
      <comment type="line">//      *pRightData = pRightOut;</comment>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>typeRight</name> <operator>!=</operator> <name>type</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>convertNumberToNumber</name><argument_list>(<argument><expr><operator>*</operator><name>pRightData</name></expr></argument>, <argument><expr><name>pRightOut</name></expr></argument>, <argument><expr><name>typeRight</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pRightData</name> <operator>=</operator> <name>pRightOut</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>typeLeft</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pLeftData</name> <operator>=</operator> <call><name>ncharTobinary</name><argument_list>(<argument><expr><operator>*</operator><name>pLeftData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>freeLeft</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>typeRight</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pRightData</name> <operator>=</operator> <call><name>ncharTobinary</name><argument_list>(<argument><expr><operator>*</operator><name>pRightData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>freeRight</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>vectorConvertToVarData</name><parameter_list>(<parameter><decl><type><name>SSclVectorConvCtx</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputCol</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pIn</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>             <name><name>tmp</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_SIGNED_NUMERIC_TYPE</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name> <operator>||</operator>
      <name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>int64_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>sprintf</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRId64</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pCtx</name><operator>-&gt;</operator><name>outType</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>varToNchar</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>tmp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IS_UNSIGNED_NUMERIC_TYPE</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>uint64_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>sprintf</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pCtx</name><operator>-&gt;</operator><name>outType</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>varToNchar</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>tmp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IS_FLOAT_TYPE</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>double</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>sprintf</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%lf"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pCtx</name><operator>-&gt;</operator><name>outType</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>varToNchar</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>tmp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>sclError</name><argument_list>(<argument><expr><literal type="string">"not supported input type:%d"</literal></expr></argument>, <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>inType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_APP_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// TODO opt performance</comment>
<function><type><name>int32_t</name></type> <name>vectorConvertSingleColImpl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SScalarParam</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>overflow</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>startIndex</name></decl></parameter>,
                                   <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputCol</name> <init>= <expr><name><name>pIn</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pInputCol</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sclError</name><argument_list>(<argument><expr><literal type="string">"input column is NULL, hashFilter %p"</literal></expr></argument>, <argument><expr><name><name>pIn</name><operator>-&gt;</operator><name>pHashFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_APP_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>           <name>rstart</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>startIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>startIndex</name> <operator>&lt;</operator> <name><name>pIn</name><operator>-&gt;</operator><name>numOfRows</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>startIndex</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>           <name>rend</name> <init>= <expr><ternary><condition><expr><name>numOfRows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>rstart</name> <operator>+</operator> <name>numOfRows</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>rstart</name> <operator>+</operator> <name><name>pIn</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SSclVectorConvCtx</name></type> <name>cCtx</name> <init>= <expr><block>{<expr><name>pIn</name></expr>, <expr><name>pOut</name></expr>, <expr><name>rstart</name></expr>, <expr><name>rend</name></expr>, <expr><name><name>pInputCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr>, <expr><name><name>pOutputCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>vectorConvertFromVarData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cCtx</name></expr></argument>, <argument><expr><name>overflow</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>overflow</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>==</operator> <name><name>pIn</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_SIGNED_NUMERIC_TYPE</name><argument_list>(<argument><expr><name><name>cCtx</name><operator>.</operator><name>outType</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>minValue</name> <init>= <expr><name><name>tDataTypes</name><index>[<expr><name><name>cCtx</name><operator>.</operator><name>outType</name></name></expr>]</index></name><operator>.</operator><name>minValue</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>maxValue</name> <init>= <expr><name><name>tDataTypes</name><index>[<expr><name><name>cCtx</name><operator>.</operator><name>outType</name></name></expr>]</index></name><operator>.</operator><name>maxValue</name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>double</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;</operator> <name>maxValue</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name>minValue</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IS_UNSIGNED_NUMERIC_TYPE</name><argument_list>(<argument><expr><name><name>cCtx</name><operator>.</operator><name>outType</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>minValue</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>tDataTypes</name><index>[<expr><name><name>cCtx</name><operator>.</operator><name>outType</name></name></expr>]</index></name><operator>.</operator><name>minValue</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>maxValue</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>tDataTypes</name><index>[<expr><name><name>cCtx</name><operator>.</operator><name>outType</name></name></expr>]</index></name><operator>.</operator><name>maxValue</name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>double</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;</operator> <name>maxValue</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name>minValue</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>overflow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pIn</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name><name>cCtx</name><operator>.</operator><name>outType</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>cCtx</name><operator>.</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>cCtx</name><operator>.</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>bool</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>cCtx</name><operator>.</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>cCtx</name><operator>.</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>int8_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>int8_t</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>cCtx</name><operator>.</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>cCtx</name><operator>.</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>int16_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>colDataAppendInt16</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>cCtx</name><operator>.</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>cCtx</name><operator>.</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>int32_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>colDataAppendInt32</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>cCtx</name><operator>.</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>cCtx</name><operator>.</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>int64_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>cCtx</name><operator>.</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>cCtx</name><operator>.</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>uint8_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>cCtx</name><operator>.</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>cCtx</name><operator>.</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>uint16_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>uint16_t</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>colDataAppendInt16</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>cCtx</name><operator>.</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>cCtx</name><operator>.</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>colDataAppendInt32</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>cCtx</name><operator>.</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>cCtx</name><operator>.</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>uint64_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>cCtx</name><operator>.</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>cCtx</name><operator>.</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>float</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>float</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>colDataAppendFloat</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>cCtx</name><operator>.</operator><name>startIndex</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>cCtx</name><operator>.</operator><name>endIndex</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pInputCol</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>double</name></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>inType</name></name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>colDataAppendDouble</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_BINARY</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_NCHAR</name></expr>:</case> <block>{<block_content>
      <return>return <expr><call><name>vectorConvertToVarData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cCtx</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <default>default:</default>
      <expr_stmt><expr><call><name>sclError</name><argument_list>(<argument><expr><literal type="string">"invalid convert output type:%d"</literal></expr></argument>, <argument><expr><name><name>cCtx</name><operator>.</operator><name>outType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_APP_ERROR</name></expr>;</return>
  </block_content>}</block></switch>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>int8_t</name></type> <name><name>gConvertTypes</name><index>[<expr><name>TSDB_DATA_TYPE_BLOB</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>TSDB_DATA_TYPE_BLOB</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
    <comment type="block">/*         NULL BOOL TINY SMAL INT  BIG  FLOA DOUB VARC TIME NCHA UTIN USMA UINT UBIG JSON VARB DECI BLOB */</comment>
    <comment type="block">/*NULL*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*BOOL*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*TINY*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*SMAL*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*INT */</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*BIGI*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*FLOA*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*DOUB*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*VARC*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*TIME*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">9</literal></expr>,  <expr><literal type="number">9</literal></expr>,  <expr><literal type="number">9</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*NCHA*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">7</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*UTIN*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*USMA*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*UINT*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">14</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*UBIG*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*JSON*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*VARB*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*DECI*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <comment type="block">/*BLOB*/</comment> <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int32_t</name></type> <name>vectorGetConvertType</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>type1</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>type2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>type1</name> <operator>==</operator> <name>type2</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type1</name> <operator>&lt;</operator> <name>type2</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name><name>gConvertTypes</name><index>[<expr><name>type1</name></expr>]</index><index>[<expr><name>type2</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name><name>gConvertTypes</name><index>[<expr><name>type2</name></expr>]</index><index>[<expr><name>type1</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>vectorConvertSingleCol</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>startIndex</name></decl></parameter>,
                               <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SDataType</name></type> <name>t</name> <init>= <expr><block>{<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>type</name></expr>, <expr><operator>.</operator><name>bytes</name> <operator>=</operator> <name><name>tDataTypes</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>bytes</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>input</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>sclCreateColumnInfoData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><name><name>input</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>vectorConvertSingleColImpl</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>vectorConvertCols</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeftOut</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRightOut</name></decl></parameter>,
                          <parameter><decl><type><name>int32_t</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>leftType</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>rightType</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>leftType</name> <operator>==</operator> <name>rightType</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>param1</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>paramOut1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>param2</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>paramOut2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>       <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>leftType</name> <operator>&lt;</operator> <name>rightType</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>param1</name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>param2</name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>paramOut1</name> <operator>=</operator> <name>pLeftOut</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>paramOut2</name> <operator>=</operator> <name>pRightOut</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>param1</name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>param2</name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>paramOut1</name> <operator>=</operator> <name>pRightOut</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>paramOut2</name> <operator>=</operator> <name>pLeftOut</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <decl_stmt><decl><type><name>int8_t</name></type> <name>type</name> <init>= <expr><call><name>vectorGetConvertType</name><argument_list>(<argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>param1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>param2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>param1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>vectorConvertSingleCol</name><argument_list>(<argument><expr><name>param1</name></expr></argument>, <argument><expr><name>paramOut1</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>param2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>vectorConvertSingleCol</name><argument_list>(<argument><expr><name>param2</name></expr></argument>, <argument><expr><name>paramOut2</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<enum>enum <block>{
  <decl><name>VECTOR_DO_CONVERT</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,
  <decl><name>VECTOR_UN_CONVERT</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,
}</block>;</enum>

<comment type="line">// TODO not correct for descending order scan</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vectorMathAddHelper</name><parameter_list>(<parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name></decl></parameter>,
                                <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnLeft</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnRight</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="line">// Set pLeft-&gt;numOfRows NULL value</comment>
    <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>vectorMathTsAddHelper</name><parameter_list>(<parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name></decl></parameter>,
                                  <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnLeft</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnRight</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="line">// Set pLeft-&gt;numOfRows NULL value</comment>
    <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator>
          <call><name>taosTimeAdd</name><argument_list>(<argument><expr><call><name>getVectorBigintValueFnLeft</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getVectorBigintValueFnRight</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>scale</name></name></expr></argument>, <argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>precision</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SColumnInfoData</name> <modifier>*</modifier></type><name>vectorConvertVarToDouble</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>converted</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SScalarParam</name></type>     <name>output</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pCol</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>TSDB_DATA_TYPE_JSON</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>vectorConvertSingleCol</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>converted</name> <operator>=</operator> <name>VECTOR_DO_CONVERT</name></expr>;</expr_stmt>

    <return>return <expr><name><name>output</name><operator>.</operator><name>columnData</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>converted</name> <operator>=</operator> <name>VECTOR_UN_CONVERT</name></expr>;</expr_stmt>

  <return>return <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>doReleaseVec</name><parameter_list>(<parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>VECTOR_DO_CONVERT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataDestroy</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorMathAdd</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>step</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>          <name>leftConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rightConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name> <operator>&amp;&amp;</operator> <call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
      <operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name> <operator>&amp;&amp;</operator> <call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
      <operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name> <operator>&amp;&amp;</operator> <call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name> <operator>&amp;&amp;</operator>
       <call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="line">// timestamp plus duration</comment>
    <decl_stmt><decl><type><name>int64_t</name>             <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnLeft</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnRight</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>vectorMathTsAddHelper</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>vectorMathTsAddHelper</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>vectorMathTsAddHelper</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>vectorMathTsAddHelper</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>)</condition> <block>{<block_content>
      <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>IS_NULL</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorBigintValueFnLeft</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>getVectorBigintValueFnRight</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>double</name>              <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnLeft</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnRight</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>)</condition> <block>{<block_content>
      <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>IS_NULL</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>vectorMathAddHelper</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>vectorMathAddHelper</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>leftConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>rightConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// TODO not correct for descending order scan</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vectorMathSubHelper</name><parameter_list>(<parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name></decl></parameter>,
                                <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>factor</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnLeft</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnRight</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="line">// Set pLeft-&gt;numOfRows NULL value</comment>
    <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <operator>(</operator><call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>vectorMathTsSubHelper</name><parameter_list>(<parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name></decl></parameter>,
                                  <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>factor</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnLeft</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnRight</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="line">// Set pLeft-&gt;numOfRows NULL value</comment>
    <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator>
          <call><name>taosTimeAdd</name><argument_list>(<argument><expr><call><name>getVectorBigintValueFnLeft</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><call><name>getVectorBigintValueFnRight</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>scale</name></name></expr></argument>, <argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>precision</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorMathSub</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>step</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>          <name>leftConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rightConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name> <operator>&amp;&amp;</operator> <call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_BIGINT</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name> <operator>&amp;&amp;</operator>
       <call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_BIGINT</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="line">// timestamp minus duration</comment>
    <decl_stmt><decl><type><name>int64_t</name>             <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnLeft</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnRight</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>vectorMathTsSubHelper</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>vectorMathTsSubHelper</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>vectorMathTsSubHelper</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>)</condition> <block>{<block_content>
      <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>IS_NULL</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorBigintValueFnLeft</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>getVectorBigintValueFnRight</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>double</name>              <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnLeft</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnRight</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>)</condition> <block>{<block_content>
      <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>IS_NULL</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>vectorMathSubHelper</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>vectorMathSubHelper</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>leftConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>rightConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// TODO not correct for descending order scan</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vectorMathMultiplyHelper</name><parameter_list>(<parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name></decl></parameter>,
                                     <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnLeft</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnRight</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="line">// Set pLeft-&gt;numOfRows NULL value</comment>
    <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorMathMultiply</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>step</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>          <name>leftConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rightConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnLeft</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnRight</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>IS_NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>vectorMathMultiplyHelper</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>vectorMathMultiplyHelper</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>leftConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>rightConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorMathDivide</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>step</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>          <name>leftConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rightConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnLeft</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnRight</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>IS_NULL</name> <operator>||</operator> <operator>(</operator><call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="line">// divide by 0 check</comment>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="line">// Set pLeft-&gt;numOfRows NULL value</comment>
      <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="line">// divide by 0 check</comment>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>(</operator><call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="line">// Set pLeft-&gt;numOfRows NULL value (divde by 0 check)</comment>
      <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>leftConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>rightConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorMathRemainder</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>step</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>          <name>leftConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rightConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnLeft</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnRight</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>IS_NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>double</name></type> <name>lx</name> <init>= <expr><call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>rx</name> <init>= <expr><call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>lx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>lx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>rx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>rx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>FLT_EQUAL</name><argument_list>(<argument><expr><name>rx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <name>lx</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><name>lx</name> <operator>/</operator> <name>rx</name><operator>)</operator><operator>)</operator> <operator>*</operator> <name>rx</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>lx</name> <init>= <expr><call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="line">// Set pLeft-&gt;numOfRows NULL value</comment>
      <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>double</name></type> <name>rx</name> <init>= <expr><call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>rx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>rx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>FLT_EQUAL</name><argument_list>(<argument><expr><name>rx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <name>lx</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><name>lx</name> <operator>/</operator> <name>rx</name><operator>)</operator><operator>)</operator> <operator>*</operator> <name>rx</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>rx</name> <init>= <expr><call><name>getVectorDoubleValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>FLT_EQUAL</name><argument_list>(<argument><expr><name>rx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="line">// Set pLeft-&gt;numOfRows NULL value</comment>
      <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>double</name></type> <name>lx</name> <init>= <expr><call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>lx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>lx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <name>lx</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><name>lx</name> <operator>/</operator> <name>rx</name><operator>)</operator><operator>)</operator> <operator>*</operator> <name>rx</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>leftConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>rightConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorMathMinus</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>step</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>          <name>leftConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getVectorDoubleValueFnLeft</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>result</name> <init>= <expr><call><name>getVectorDoubleValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>result</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><name>result</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>leftConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorAssign</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfQualified</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfQualified</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfQualified</name></name> <operator>=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfQualified</name></name> <operator>*</operator> <name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>vectorBitAndHelper</name><parameter_list>(<parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name></decl></parameter>,
                               <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnLeft</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnRight</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="line">// Set pLeft-&gt;numOfRows NULL value</comment>
    <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorBigintValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>getVectorBigintValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorBitAnd</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>step</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>          <name>leftConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rightConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnLeft</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnRight</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>IS_NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorBigintValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>getVectorBigintValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>vectorBitAndHelper</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>vectorBitAndHelper</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>leftConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>rightConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>vectorBitOrHelper</name><parameter_list>(<parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name></decl></parameter>,
                              <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnLeft</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnRight</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="line">// Set pLeft-&gt;numOfRows NULL value</comment>
    <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>rx</name> <init>= <expr><call><name>getVectorBigintValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorBigintValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>|</operator> <name>rx</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorBitOr</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>step</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>          <name>leftConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rightConvert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pLeftCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pRightCol</name> <init>= <expr><call><name>vectorConvertVarToDouble</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightConvert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnLeft</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pLeftCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getBigintValue_fn_t</name></type> <name>getVectorBigintValueFnRight</name> <init>= <expr><call><name>getVectorBigintValueFn</name><argument_list>(<argument><expr><name><name>pRightCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputCol</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr><operator>,</operator> <expr><name>output</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>IS_NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>  <comment type="line">// TODO set null or ignore</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>getVectorBigintValueFnLeft</name><argument_list>(<argument><expr><name>LEFT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>getVectorBigintValueFnRight</name><argument_list>(<argument><expr><name>RIGHT_COL</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>vectorBitOrHelper</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>vectorBitOrHelper</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pLeftCol</name></expr></argument>, <argument><expr><name>leftConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>doReleaseVec</name><argument_list>(<argument><expr><name>pRightCol</name></expr></argument>, <argument><expr><name>rightConvert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>doVectorCompareImpl</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>startIndex</name></decl></parameter>,
                            <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>__compar_fn_t</name></type> <name>fp</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>optr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name>   <modifier>*</modifier></type><name>pRes</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_MATHABLE_TYPE</name><argument_list>(<argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_MATHABLE_TYPE</name><argument_list>(<argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>hasNull</name></name> <operator>||</operator> <name><name>pRight</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>hasNull</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>leftIndex</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>rightIndex</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pLeftData</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>leftIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pRightData</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rightIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>pRes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>filterDoCompare</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>, <argument><expr><name>pLeftData</name></expr></argument>, <argument><expr><name>pRightData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pRes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>++</operator><name>num</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>leftIndex</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>rightIndex</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>leftIndex</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>colDataIsNull_f</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>rightIndex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>pRes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pLeftData</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>leftIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pRightData</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rightIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>pRes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>filterDoCompare</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>, <argument><expr><name>pLeftData</name></expr></argument>, <argument><expr><name>pRightData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pRes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>++</operator><name>num</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="line">//  if (GET_PARAM_TYPE(pLeft) == TSDB_DATA_TYPE_JSON || GET_PARAM_TYPE(pRight) == TSDB_DATA_TYPE_JSON) {</comment>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <name>startIndex</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>leftIndex</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>rightIndex</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>leftIndex</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rightIndex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pLeftData</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>leftIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pRightData</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>rightIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>leftOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>rightOut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>bool</name></type>    <name>freeLeft</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>bool</name></type>    <name>freeRight</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>bool</name></type>    <name>isJsonnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><call><name>convertJsonValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fp</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeftData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRightData</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>leftOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isJsonnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>freeLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>freeRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>isJsonnull</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pLeftData</name> <operator>||</operator> <operator>!</operator><name>pRightData</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>filterDoCompare</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>, <argument><expr><name>pLeftData</name></expr></argument>, <argument><expr><name>pRightData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>++</operator><name>num</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>freeLeft</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name>pLeftData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>freeRight</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name>pRightData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>doVectorCompare</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>startIndex</name></decl></parameter>,
                     <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>optr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>       <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>       <name>step</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>       <name>lType</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>       <name>rType</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>__compar_fn_t</name></type> <name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>       <name>compRows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>lType</name> <operator>==</operator> <name>rType</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>filterGetCompFunc</name><argument_list>(<argument><expr><name>lType</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>filterGetCompFuncEx</name><argument_list>(<argument><expr><name>lType</name></expr></argument>, <argument><expr><name>rType</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>startIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>compRows</name> <operator>=</operator> <name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>compRows</name> <operator>=</operator> <name>startIndex</name> <operator>+</operator> <name>numOfRows</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>startIndex</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pRight</name><operator>-&gt;</operator><name>pHashFilter</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pLeftData</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>bool</name></type>  <name>res</name> <init>= <expr><call><name>filterDoCompare</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>, <argument><expr><name>pLeftData</name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>pHashFilter</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfQualified</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="line">// normal compare</comment>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfQualified</name></name> <operator>=</operator> <call><name>doVectorCompareImpl</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>compRows</name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorCompareImpl</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>startIndex</name></decl></parameter>,
                       <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>optr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SScalarParam</name></type>  <name>pLeftOut</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SScalarParam</name></type>  <name>pRightOut</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>param1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>param2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>SCL_NO_NEED_CONVERT_COMPARISION</name><argument_list>(<argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>optr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>param1</name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>param2</name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>vectorConvertCols</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeftOut</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRightOut</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pLeftOut</name><operator>.</operator><name>columnData</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>param1</name> <operator>=</operator> <operator>&amp;</operator><name>pLeftOut</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>param1</name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pRightOut</name><operator>.</operator><name>columnData</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>param2</name> <operator>=</operator> <operator>&amp;</operator><name>pRightOut</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>param2</name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>doVectorCompare</name><argument_list>(<argument><expr><name>param1</name></expr></argument>, <argument><expr><name>param2</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sclFreeParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pLeftOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sclFreeParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pRightOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorCompare</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>optr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompareImpl</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>optr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorGreater</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompare</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>OP_TYPE_GREATER_THAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorGreaterEqual</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompare</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>OP_TYPE_GREATER_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorLower</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompare</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>OP_TYPE_LOWER_THAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorLowerEqual</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompare</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>OP_TYPE_LOWER_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorEqual</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompare</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>OP_TYPE_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorNotEqual</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompare</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>OP_TYPE_NOT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorIn</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompare</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>OP_TYPE_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorNotIn</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompare</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>OP_TYPE_NOT_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorLike</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompare</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>OP_TYPE_LIKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorNotLike</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompare</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>OP_TYPE_NOT_LIKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorMatch</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompare</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>OP_TYPE_MATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorNotMatch</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorCompare</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>_ord</name></expr></argument>, <argument><expr><name>OP_TYPE_NMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorIsNull</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>int8_t</name></type> <name>v</name> <init>= <expr><ternary><condition><expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorNotNull</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>int8_t</name></type> <name>v</name> <init>= <expr><ternary><condition><expr><call><name>IS_HELPER_NULL</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorIsTrue</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>vectorConvertSingleColImpl</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int8_t</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>colDataAppendInt8</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>colDataClearNull_f</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>nullbitmap</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>hasNull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>STagVal</name></type> <name>getJsonValue</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isExist</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>STagVal</name></type> <name>val</name> <init>= <expr><block>{<expr><operator>.</operator><name>pKey</name> <operator>=</operator> <name>key</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>json</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>tTagIsJson</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>STag</name> <operator>*</operator><operator>)</operator><name>json</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_QRY_JSON_NOT_SUPPORT_ERROR</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isExist</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>isExist</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>val</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>bool</name></type> <name>find</name> <init>= <expr><call><name>tTagGet</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>STag</name> <operator>*</operator><operator>)</operator><name>json</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="line">// json value is null and not exist is different</comment>
  <if_stmt><if>if <condition>(<expr><name>isExist</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>isExist</name> <operator>=</operator> <name>find</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorJsonContains</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>step</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pRightData</name> <init>= <expr><call><name>colDataGetVarData</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>jsonKey</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRightData</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>jsonKey</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>pRightData</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRightData</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>isExist</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>colDataIsNull_var</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pLeftData</name> <init>= <expr><call><name>colDataGetVarData</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>getJsonValue</name><argument_list>(<argument><expr><name>pLeftData</name></expr></argument>, <argument><expr><name>jsonKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isExist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>isExist</name><operator>)</operator></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>jsonKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>vectorJsonArrow</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>_ord</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputCol</name> <init>= <expr><name><name>pOut</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>step</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>_ord</name><operator>)</operator> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <call><name>TMAX</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pRightData</name> <init>= <expr><call><name>colDataGetVarData</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>jsonKey</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRightData</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>jsonKey</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>pRightData</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRightData</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>pLeft</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_var</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataSetNull_var</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pOutputCol</name><operator>-&gt;</operator><name>hasNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pLeftData</name> <init>= <expr><call><name>colDataGetVarData</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>isExist</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>STagVal</name></type> <name>value</name> <init>= <expr><call><name>getJsonValue</name><argument_list>(<argument><expr><name>pLeftData</name></expr></argument>, <argument><expr><name>jsonKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isExist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>data</name> <init>= <expr><ternary><condition><expr><name>isExist</name></expr> ?</condition><then> <expr><call><name>tTagValToData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputCol</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isExist</name> <operator>&amp;&amp;</operator> <call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>data</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>jsonKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>_bin_scalar_fn_t</name></type> <name>getBinScalarOperatorFn</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>binFunctionId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>binFunctionId</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OP_TYPE_ADD</name></expr>:</case>
      <return>return <expr><name>vectorMathAdd</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_SUB</name></expr>:</case>
      <return>return <expr><name>vectorMathSub</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_MULTI</name></expr>:</case>
      <return>return <expr><name>vectorMathMultiply</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_DIV</name></expr>:</case>
      <return>return <expr><name>vectorMathDivide</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_REM</name></expr>:</case>
      <return>return <expr><name>vectorMathRemainder</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_MINUS</name></expr>:</case>
      <return>return <expr><name>vectorMathMinus</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_ASSIGN</name></expr>:</case>
      <return>return <expr><name>vectorAssign</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_GREATER_THAN</name></expr>:</case>
      <return>return <expr><name>vectorGreater</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_GREATER_EQUAL</name></expr>:</case>
      <return>return <expr><name>vectorGreaterEqual</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_LOWER_THAN</name></expr>:</case>
      <return>return <expr><name>vectorLower</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_LOWER_EQUAL</name></expr>:</case>
      <return>return <expr><name>vectorLowerEqual</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_EQUAL</name></expr>:</case>
      <return>return <expr><name>vectorEqual</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_NOT_EQUAL</name></expr>:</case>
      <return>return <expr><name>vectorNotEqual</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_IN</name></expr>:</case>
      <return>return <expr><name>vectorIn</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_NOT_IN</name></expr>:</case>
      <return>return <expr><name>vectorNotIn</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_LIKE</name></expr>:</case>
      <return>return <expr><name>vectorLike</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_NOT_LIKE</name></expr>:</case>
      <return>return <expr><name>vectorNotLike</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_MATCH</name></expr>:</case>
      <return>return <expr><name>vectorMatch</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_NMATCH</name></expr>:</case>
      <return>return <expr><name>vectorNotMatch</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_IS_NULL</name></expr>:</case>
      <return>return <expr><name>vectorIsNull</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_IS_NOT_NULL</name></expr>:</case>
      <return>return <expr><name>vectorNotNull</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_BIT_AND</name></expr>:</case>
      <return>return <expr><name>vectorBitAnd</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_BIT_OR</name></expr>:</case>
      <return>return <expr><name>vectorBitOr</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_IS_TRUE</name></expr>:</case>
      <return>return <expr><name>vectorIsTrue</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_JSON_GET_VALUE</name></expr>:</case>
      <return>return <expr><name>vectorJsonArrow</name></expr>;</return>
    <case>case <expr><name>OP_TYPE_JSON_CONTAINS</name></expr>:</case>
      <return>return <expr><name>vectorJsonContains</name></expr>;</return>
    <default>default:</default>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>
</unit>
