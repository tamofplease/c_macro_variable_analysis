<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/source/libs/scalar/src/sclfunc.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cJSON.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"function.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scalar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sclInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sclvector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdatablock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tjson.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ttime.h"</cpp:file></cpp:include>

<typedef>typedef <function_decl><type><name>float</name></type> (<modifier>*</modifier><name>_float_fn</name>)<parameter_list>(<parameter><decl><type><name>float</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>double</name></type> (<modifier>*</modifier><name>_double_fn</name>)<parameter_list>(<parameter><decl><type><name>double</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>double</name></type> (<modifier>*</modifier><name>_double_fn_2</name>)<parameter_list>(<parameter><decl><type><name>double</name></type></decl></parameter>, <parameter><decl><type><name>double</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>_conv_fn</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>_trim_fn</name>)<parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int32_t</name></type></decl></parameter>, <parameter><decl><type><name>int32_t</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>int16_t</name></type> (<modifier>*</modifier><name>_len_fn</name>)<parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int32_t</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block" format="doxygen">/** Math functions **/</comment>
<function><type><specifier>static</specifier> <name>double</name></type> <name>tlog</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>log</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type> <name>tlog2</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>base</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>a</name> <init>= <expr><call><name>log</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>b</name> <init>= <expr><call><name>log</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>a</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>b</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>INFINITY</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>a</name> <operator>/</operator> <name>b</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>absFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>-</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>-</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>-</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>-</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>-</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>-</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TSDB_DATA_TYPE_NULL</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAssign</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doScalarFunctionUnique</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>, <parameter><decl><type><name>_double_fn</name></type> <name>valFn</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name>getValueFn</name> <init>= <expr><call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_NULL_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>result</name> <init>= <expr><call><name>valFn</name><argument_list>(<argument><expr><call><name>getValueFn</name><argument_list>(<argument><expr><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doScalarFunctionUnique2</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>,
                                       <parameter><decl><type><name>_double_fn_2</name></type> <name>valFn</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name>     <modifier>*</modifier></type><name><name>pInputData</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name>     <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_getDoubleValue_fn_t</name></type> <name><name>getValueFn</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>inputNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>columnData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>getValueFn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>getVectorDoubleValueFn</name><argument_list>(<argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type>  <name>result</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>bool</name></type> <name>hasNullType</name> <init>= <expr><operator>(</operator><call><name>IS_NULL_TYPE</name><argument_list>(<argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_NULL_TYPE</name><argument_list>(<argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfRows</name> <init>= <expr><call><name>TMAX</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name> <operator>==</operator> <name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>hasNullType</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <macro><name>valFn</name><argument_list>(<argument>getValueFn[<literal type="number">0</literal>](pInputData[<literal type="number">0</literal>]-&gt;pData, i)</argument>, <argument>getValueFn[<literal type="number">1</literal>](pInputData[<literal type="number">1</literal>]-&gt;pData, i)</argument>)</argument_list></macro></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="line">// left operand is constant</comment>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name>hasNullType</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <macro><name>valFn</name><argument_list>(<argument>getValueFn[<literal type="number">0</literal>](pInputData[<literal type="number">0</literal>]-&gt;pData, <literal type="number">0</literal>)</argument>, <argument>getValueFn[<literal type="number">1</literal>](pInputData[<literal type="number">1</literal>]-&gt;pData, i)</argument>)</argument_list></macro></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name>hasNullType</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <macro><name>valFn</name><argument_list>(<argument>getValueFn[<literal type="number">0</literal>](pInputData[<literal type="number">0</literal>]-&gt;pData, i)</argument>, <argument>getValueFn[<literal type="number">1</literal>](pInputData[<literal type="number">1</literal>]-&gt;pData, <literal type="number">0</literal>)</argument>)</argument_list></macro></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name>numOfRows</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>, <parameter><decl><type><name>_float_fn</name></type> <name>f1</name></decl></parameter>,
                                <parameter><decl><type><name>_double_fn</name></type> <name>d1</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>f1</name><argument_list>(<argument><expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>d1</name><argument_list>(<argument><expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TSDB_DATA_TYPE_NULL</name></expr>:</case> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAssign</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** String functions **/</comment>
<function><type><specifier>static</specifier> <name>int16_t</name></type> <name>tlength</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int16_t</name></type> <name>tcharlength</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="line">// NCHAR</comment>
    <return>return <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>TSDB_NCHAR_SIZE</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>tltrim</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>charLen</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfSpaces</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>charLen</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>numOfSpaces</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="line">// NCHAR</comment>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>charLen</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>iswspace</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>numOfSpaces</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>resLen</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>resLen</name> <operator>=</operator> <name>charLen</name> <operator>-</operator> <name>numOfSpaces</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>numOfSpaces</name></expr></argument>, <argument><expr><name>resLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>resLen</name> <operator>=</operator> <operator>(</operator><name>charLen</name> <operator>-</operator> <name>numOfSpaces</name><operator>)</operator> <operator>*</operator> <name>TSDB_NCHAR_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>numOfSpaces</name> <operator>*</operator> <name>TSDB_NCHAR_SIZE</name></expr></argument>, <argument><expr><name>resLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>resLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>trtrim</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>charLen</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfSpaces</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name>charLen</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>numOfSpaces</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="line">// NCHAR</comment>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name>charLen</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>iswspace</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>numOfSpaces</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>resLen</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>resLen</name> <operator>=</operator> <name>charLen</name> <operator>-</operator> <name>numOfSpaces</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>resLen</name> <operator>=</operator> <operator>(</operator><name>charLen</name> <operator>-</operator> <name>numOfSpaces</name><operator>)</operator> <operator>*</operator> <name>TSDB_NCHAR_SIZE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>resLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>resLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doLengthFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>, <parameter><decl><type><name>_len_fn</name></type> <name>lenFn</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pOutputData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_BIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lenFn</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>concatCopyHelper</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>output</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasNchar</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>dataLen</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>hasNchar</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>TdUcs4</name> <modifier>*</modifier></type><name>newBuf</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><operator>(</operator><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>TSDB_NCHAR_SIZE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>ret</name> <init>= <expr><call><name>taosMbsToUcs4</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>newBuf</name></expr></argument>, <argument><expr><operator>(</operator><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>TSDB_NCHAR_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>newBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>*</operator><name>dataLen</name></expr></argument>, <argument><expr><name>newBuf</name></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>TSDB_NCHAR_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>dataLen</name> <operator>+=</operator> <call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>TSDB_NCHAR_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>newBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>*</operator><name>dataLen</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>dataLen</name> <operator>+=</operator> <call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>getNumOfNullEntries</name><parameter_list>(<parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pColumnInfoData</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfNulls</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pColumnInfoData</name><operator>-&gt;</operator><name>hasNull</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>numOfNulls</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pColumnInfoData</name><operator>-&gt;</operator><name>varmeta</name><operator>.</operator><name>offset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>numOfNulls</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>numOfNulls</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>concatFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>           <name>ret</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier><modifier>*</modifier></type><name>pInputData</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>inputNum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SColumnInfoData</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name>  <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier><modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>             <modifier>*</modifier></type><name>outputBuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>inputLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfRows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>    <name>hasNchar</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pOutput</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>inputNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfRows</name> <operator>&gt;</operator> <name>numOfRows</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>numOfRows</name> <operator>=</operator> <name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>inputNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>columnData</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>factor</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>hasNchar</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>factor</name> <operator>=</operator> <name>TSDB_NCHAR_SIZE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfNulls</name> <init>= <expr><call><name>getNumOfNullEntries</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfRows</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>inputLen</name> <operator>+=</operator> <operator>(</operator><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>varmeta</name><operator>.</operator><name>length</name></name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name><operator>)</operator> <operator>*</operator> <name>factor</name> <operator>*</operator> <operator>(</operator><name>numOfRows</name> <operator>-</operator> <name>numOfNulls</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>inputLen</name> <operator>+=</operator> <operator>(</operator><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>varmeta</name><operator>.</operator><name>length</name></name> <operator>-</operator> <operator>(</operator><name>numOfRows</name> <operator>-</operator> <name>numOfNulls</name><operator>)</operator> <operator>*</operator> <name>VARSTR_HEADER_SIZE</name><operator>)</operator> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>outputLen</name> <init>= <expr><name>inputLen</name> <operator>+</operator> <name>numOfRows</name> <operator>*</operator> <name>VARSTR_HEADER_SIZE</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>outputBuf</name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>outputLen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><name>outputBuf</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>hasNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>inputNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_NULL_TYPE</name><argument_list>(<argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hasNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>hasNull</name></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int16_t</name></type> <name>dataLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>inputNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>rowIdx</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfRows</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>k</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>input</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>rowIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>concatCopyHelper</name><argument_list>(<argument><expr><name><name>input</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>hasNchar</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
        <goto>goto <name>DONE</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>output</name> <operator>+=</operator> <call><name>varDataTLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name>numOfRows</name></expr>;</expr_stmt>

<label><name>DONE</name>:</label>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>outputBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>concatWsFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>           <name>ret</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier><modifier>*</modifier></type><name>pInputData</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>inputNum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SColumnInfoData</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name>  <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier><modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>             <modifier>*</modifier></type><name>outputBuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>inputLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfRows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>    <name>hasNchar</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pOutput</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>inputNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfRows</name> <operator>&gt;</operator> <name>numOfRows</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>numOfRows</name> <operator>=</operator> <name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>inputNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>columnData</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>factor</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>hasNchar</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>factor</name> <operator>=</operator> <name>TSDB_NCHAR_SIZE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfNulls</name> <init>= <expr><call><name>getNumOfNullEntries</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// calculate required separator space</comment>
      <expr_stmt><expr><name>inputLen</name> <operator>+=</operator>
          <operator>(</operator><name><name>pInputData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>varmeta</name><operator>.</operator><name>length</name></name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>numOfRows</name> <operator>-</operator> <name>numOfNulls</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>inputNum</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfRows</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>inputLen</name> <operator>+=</operator> <operator>(</operator><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>varmeta</name><operator>.</operator><name>length</name></name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>numOfRows</name> <operator>-</operator> <name>numOfNulls</name><operator>)</operator> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>inputLen</name> <operator>+=</operator> <operator>(</operator><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>varmeta</name><operator>.</operator><name>length</name></name> <operator>-</operator> <operator>(</operator><name>numOfRows</name> <operator>-</operator> <name>numOfNulls</name><operator>)</operator> <operator>*</operator> <name>VARSTR_HEADER_SIZE</name><operator>)</operator> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>outputLen</name> <init>= <expr><name>inputLen</name> <operator>+</operator> <name>numOfRows</name> <operator>*</operator> <name>VARSTR_HEADER_SIZE</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>outputBuf</name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>outputLen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><name>outputBuf</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_NULL_TYPE</name><argument_list>(<argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int16_t</name></type> <name>dataLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>hasNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>inputNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_NULL_TYPE</name><argument_list>(<argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>hasNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>int32_t</name></type> <name>rowIdx</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfRows</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>k</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>input</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>rowIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>concatCopyHelper</name><argument_list>(<argument><expr><name><name>input</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>hasNchar</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
        <goto>goto <name>DONE</name>;</goto>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>inputNum</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// insert the separator</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInputData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>concatCopyHelper</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>hasNchar</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <goto>goto <name>DONE</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>hasNull</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>output</name> <operator>+=</operator> <call><name>varDataTLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name>numOfRows</name></expr>;</expr_stmt>

<label><name>DONE</name>:</label>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>outputBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doCaseConvFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>, <parameter><decl><type><name>_conv_fn</name></type> <name>convFn</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>outputLen</name> <init>= <expr><name><name>pInputData</name><operator>-&gt;</operator><name>varmeta</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>outputBuf</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>outputLen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>output</name> <init>= <expr><name>outputBuf</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name></expr>)</condition> <block>{<block_content>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>j</name><operator>)</operator> <operator>=</operator> <call><name>convFn</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>j</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="line">// NCHAR</comment>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name> <operator>/</operator> <name>TSDB_NCHAR_SIZE</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>j</name><operator>)</operator> <operator>=</operator> <call><name>convFn</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>j</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>output</name> <operator>+=</operator> <call><name>varDataTLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>outputBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doTrimFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>, <parameter><decl><type><name>_trim_fn</name></type> <name>trimFn</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>outputLen</name> <init>= <expr><name><name>pInputData</name><operator>-&gt;</operator><name>varmeta</name><operator>.</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>outputBuf</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>outputLen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>output</name> <init>= <expr><name>outputBuf</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>charLen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name><operator>)</operator></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><name>len</name> <operator>/</operator> <name>TSDB_NCHAR_SIZE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>trimFn</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>charLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>output</name> <operator>+=</operator> <call><name>varDataTLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>outputBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>substrFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>subPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>subPos</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>subLen</name> <init>= <expr><name>INT16_MAX</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>inputNum</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>subLen</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>subLen</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name><operator>)</operator></expr> ?</condition><then> <expr><name>subLen</name></expr> </then><else>: <expr><name>subLen</name> <operator>*</operator> <name>TSDB_NCHAR_SIZE</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>outputLen</name> <init>= <expr><name><name>pInputData</name><operator>-&gt;</operator><name>varmeta</name><operator>.</operator><name>length</name></name> <operator>*</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>outputBuf</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>outputLen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>output</name> <init>= <expr><name>outputBuf</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>startPosBytes</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>subPos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>startPosBytes</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name><operator>)</operator></expr> ?</condition><then> <expr><name>subPos</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name>subPos</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>TSDB_NCHAR_SIZE</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>startPosBytes</name> <operator>=</operator> <call><name>TMIN</name><argument_list>(<argument><expr><name>startPosBytes</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>startPosBytes</name> <operator>=</operator>
          <ternary><condition><expr><operator>(</operator><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name><operator>)</operator></expr> ?</condition><then> <expr><name>len</name> <operator>+</operator> <name>subPos</name></expr> </then><else>: <expr><name>len</name> <operator>+</operator> <name>subPos</name> <operator>*</operator> <name>TSDB_NCHAR_SIZE</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>startPosBytes</name> <operator>=</operator> <call><name>TMAX</name><argument_list>(<argument><expr><name>startPosBytes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>resLen</name> <init>= <expr><call><name>TMIN</name><argument_list>(<argument><expr><name>subLen</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>startPosBytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>resLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>startPosBytes</name></expr></argument>, <argument><expr><name>resLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>resLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>output</name> <operator>+=</operator> <call><name>varDataTLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>outputBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** Conversion functions **/</comment>
<function><type><name>int32_t</name></type> <name>castFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>inputType</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>inputLen</name> <init>= <expr><call><name>GET_PARAM_BYTES</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>outputType</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOutput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>outputLen</name> <init>= <expr><call><name>GET_PARAM_BYTES</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOutput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>convBuf</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name>inputLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>output</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>outputLen</name> <operator>+</operator> <name>TSDB_NCHAR_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>    <name><name>buf</name><index>[<expr><literal type="number">400</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>convBuf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>output</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    <goto>goto <name>_end</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>outputType</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Int8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name><name>convBuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Int8</name><argument_list>(<argument><expr><name>convBuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><name>int8_t</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Int16</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>convBuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Int16</name><argument_list>(<argument><expr><name>convBuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><name>int16_t</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Int32</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name><name>convBuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Int32</name><argument_list>(<argument><expr><name>convBuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><name>int32_t</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Int64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>convBuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Int64</name><argument_list>(<argument><expr><name>convBuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2UInt8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>convBuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2UInt8</name><argument_list>(<argument><expr><name>convBuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2UInt16</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>convBuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2UInt16</name><argument_list>(<argument><expr><name>convBuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><name>uint16_t</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2UInt32</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>convBuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2UInt32</name><argument_list>(<argument><expr><name>convBuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2UInt64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name><name>convBuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2UInt64</name><argument_list>(<argument><expr><name>convBuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Float</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>convBuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Float</name><argument_list>(<argument><expr><name>convBuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><name>float</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Double</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>convBuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Double</name><argument_list>(<argument><expr><name>convBuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><name>double</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Int8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>convBuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <call><name>taosStr2Int8</name><argument_list>(<argument><expr><name>convBuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>timeVal</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name> <operator>||</operator> <name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int64_t</name></type> <name>timePrec</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>timePrec</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>= <expr><call><name>convertStringToTimestamp</name><argument_list>(<argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>timePrec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>output</name> <operator>=</operator> <name>timeVal</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>output</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_BINARY</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name></expr>)</condition> <block>{<block_content>
          <comment type="line">// NOTE: sprintf will append '\0' at the end of string</comment>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>sprintf</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>outputLen</name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name><operator>)</operator></expr></argument>,
                                <argument><expr><ternary><condition><expr><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>input</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>TMIN</name><argument_list>(<argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>outputLen</name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>taosUcs4ToMbs</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>TMIN</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>outputLen</name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>convBuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>NUM_TO_STRING</name><argument_list>(<argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>outputLen</name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name><operator>)</operator> <operator>&gt;</operator> <name>len</name></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><operator>(</operator><name>outputLen</name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_NCHAR</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>outputCharLen</name> <init>= <expr><operator>(</operator><name>outputLen</name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name><operator>)</operator> <operator>/</operator> <name>TSDB_NCHAR_SIZE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>outputCharLen</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>input</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>taosMbsToUcs4</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>outputLen</name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BINARY</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><name>outputCharLen</name> <operator>&gt;</operator> <call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>outputCharLen</name></expr></else></ternary></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>taosMbsToUcs4</name><argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>outputLen</name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>TMIN</name><argument_list>(<argument><expr><name>outputLen</name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>NUM_TO_STRING</name><argument_list>(<argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><name>outputCharLen</name> <operator>&gt;</operator> <name>len</name></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><name>outputCharLen</name></expr></else></ternary></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>taosMbsToUcs4</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>outputLen</name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
            <goto>goto <name>_end</name>;</goto>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// for constant conversion, need to set proper length of pOutput description</comment>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>outputLen</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>bytes</name></name> <operator>=</operator> <name>len</name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
        <goto>goto <name>_end</name>;</goto>
      </block_content>}</block>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>

<label><name>_end</name>:</label>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>convBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>toISO8601Function</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>bool</name></type>    <name>tzPresent</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>inputNum</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>    <name><name>tz</name><index>[<expr><literal type="number">20</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>tzLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tzPresent</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>tzLen</name> <operator>=</operator> <call><name>varDataLen</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tz</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tzLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>  <name><name>fraction</name><index>[<expr><literal type="number">20</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>  <name>hasFraction</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NUM_TO_STRING</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fraction</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>tsDigits</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>fraction</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name></type>    <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>timeVal</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>timeVal</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>&gt;</operator> <name>TSDB_TIME_PRECISION_SEC_DIGITS</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MILLI_DIGITS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MICRO_DIGITS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <operator>(</operator><literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO_DIGITS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <operator>(</operator><literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>hasFraction</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>fraction</name></expr></argument>, <argument><expr><name>fraction</name> <operator>+</operator> <name>TSDB_TIME_PRECISION_SEC_DIGITS</name></expr></argument>, <argument><expr><name>TSDB_TIME_PRECISION_SEC_DIGITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type> <name>tmInfo</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>taosLocalTime</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>time_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>timeVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strftime</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%Y-%m-%dT%H:%M:%S"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// add timezone string</comment>
    <if_stmt><if>if <condition>(<expr><name>tzLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>tzLen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>tzLen</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>hasFraction</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>fracLen</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>fraction</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tzInfo</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'z'</literal> <operator>||</operator> <name><name>buf</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'Z'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>tzInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>tzInfo</name> <operator>+</operator> <name>fracLen</name></expr></argument>, <argument><expr><name>tzInfo</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tzInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>tzInfo</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>tzInfo</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>tzInfo</name> <operator>+</operator> <name>fracLen</name></expr></argument>, <argument><expr><name>tzInfo</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tzInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <comment type="line">// search '-' backwards</comment>
          <expr_stmt><expr><name>tzInfo</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>tzInfo</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>tzInfo</name> <operator>+</operator> <name>fracLen</name></expr></argument>, <argument><expr><name>tzInfo</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tzInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>

      <decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><name>fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tzInfo</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>fracLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>len</name> <operator>+=</operator> <name>fracLen</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>toUnixtimestampFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>timePrec</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>timePrec</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>timeVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>= <expr><call><name>convertStringToTimestamp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>timePrec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>timeVal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>toJsonFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><name>TSDB_MAX_JSON_TAG_LEN</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SArray</name> <modifier>*</modifier></type><name>pTagVals</name> <init>= <expr><call><name>taosArrayInit</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STagVal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>STag</name>   <modifier>*</modifier></type><name>pTag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>tTagNew</name><argument_list>(<argument><expr><name>pTagVals</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name> <init>= <expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name> <operator>+</operator> <name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>varmeta</name><operator>.</operator><name>offset</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>(</operator><name>TSDB_MAX_JSON_TAG_LEN</name> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name><operator>)</operator> <operator>/</operator> <name>TSDB_NCHAR_SIZE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosArrayDestroy</name><argument_list>(<argument><expr><name>pTagVals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp</name><index>[<expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>parseJsontoTagData</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>pTagVals</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTag</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>tTagNew</name><argument_list>(<argument><expr><name>pTagVals</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pTag</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tTagFree</name><argument_list>(<argument><expr><name>pTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosArrayDestroy</name><argument_list>(<argument><expr><name>pTagVals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** Time functions **/</comment>
<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>offsetFromTz</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>timezone</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>factor</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>minStr</name> <init>= <expr><operator>&amp;</operator><name><name>timezone</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>minutes</name> <init>= <expr><call><name>taosStr2Int64</name><argument_list>(<argument><expr><name>minStr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>minStr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>minStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>hours</name> <init>= <expr><call><name>taosStr2Int64</name><argument_list>(<argument><expr><name>timezone</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>seconds</name> <init>= <expr><name>hours</name> <operator>*</operator> <literal type="number">3600</literal> <operator>+</operator> <name>minutes</name> <operator>*</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>

  <return>return <expr><name>seconds</name> <operator>*</operator> <name>factor</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>timeTruncateFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int64_t</name></type> <name>timeUnit</name></decl>, <decl><type ref="prev"/><name>timePrec</name></decl>, <decl><type ref="prev"/><name>timeVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>    <name>ignoreTz</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>    <name><name>timezone</name><index>[<expr><literal type="number">20</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>timeUnit</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>timePrecIdx</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>, <decl><type ref="prev"/><name>timeZoneIdx</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>inputNum</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>timePrecIdx</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>timeZoneIdx</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>ignoreTz</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>timePrec</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><name>timePrecIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><name>timePrecIdx</name></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>timezone</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><name>timeZoneIdx</name></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><name>timeZoneIdx</name></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int64_t</name></type> <name>factor</name> <init>= <expr><call><name>TSDB_TICK_PER_SECOND</name><argument_list>(<argument><expr><name>timePrec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>unit</name> <init>= <expr><name>timeUnit</name> <operator>*</operator> <literal type="number">1000</literal> <operator>/</operator> <name>factor</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <comment type="block">/* datetime format strings */</comment>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>= <expr><call><name>convertStringToTimestamp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>TSDB_TIME_PRECISION_NANO</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <comment type="line">// If converted value is less than 10digits in second, use value in second instead</comment>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>timeValSec</name> <init>= <expr><name>timeVal</name> <operator>/</operator> <literal type="number">1000000000</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>timeValSec</name> <operator>&lt;</operator> <literal type="number">1000000000</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeValSec</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BIGINT</name></expr>)</condition> <block>{<block_content> <comment type="block">/* unix timestamp */</comment>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>timeVal</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>)</condition> <block>{<block_content> <comment type="block">/* timestamp column*/</comment>
      <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>timeVal</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>timeValSec</name> <init>= <expr><name>timeVal</name> <operator>/</operator> <name>factor</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>timeValSec</name> <operator>&lt;</operator> <literal type="number">1000000000</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeValSec</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">20</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NUM_TO_STRING</name><argument_list>(<argument><expr><name>TSDB_DATA_TYPE_BIGINT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeVal</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>tsDigits</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>unit</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><literal type="number">0</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1u or 1b */</comment>
        <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>timePrec</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO</name> <operator>&amp;&amp;</operator> <name>timeUnit</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>&lt;=</operator> <name>TSDB_TIME_PRECISION_SEC_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="number">1</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1a */</comment>
        <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MILLI_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MICRO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000000</literal> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>&lt;=</operator> <name>TSDB_TIME_PRECISION_SEC_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="number">1000</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1s */</comment>
        <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MILLI_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MICRO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000000</literal> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000000000</literal> <operator>*</operator> <literal type="number">1000000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>&lt;=</operator> <name>TSDB_TIME_PRECISION_SEC_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="number">60000</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1m */</comment>
        <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MILLI_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000</literal> <operator>/</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MICRO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000000</literal> <operator>/</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000000000</literal> <operator>/</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">1000000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>&lt;=</operator> <name>TSDB_TIME_PRECISION_SEC_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <name>factor</name> <operator>/</operator> <name>factor</name> <operator>/</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="number">3600000</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1h */</comment>
        <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MILLI_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000</literal> <operator>/</operator> <literal type="number">3600</literal> <operator>*</operator> <literal type="number">3600</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MICRO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000000</literal> <operator>/</operator> <literal type="number">3600</literal> <operator>*</operator> <literal type="number">3600</literal> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000000000</literal> <operator>/</operator> <literal type="number">3600</literal> <operator>*</operator> <literal type="number">3600</literal> <operator>*</operator> <literal type="number">1000000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>&lt;=</operator> <name>TSDB_TIME_PRECISION_SEC_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <name>factor</name> <operator>/</operator> <name>factor</name> <operator>/</operator> <literal type="number">3600</literal> <operator>*</operator> <literal type="number">3600</literal> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="number">86400000</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1d */</comment>
        <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MILLI_DIGITS</name></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>ignoreTz</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>-</operator> <operator>(</operator><name>timeVal</name> <operator>+</operator> <call><name>offsetFromTz</name><argument_list>(<argument><expr><name>timezone</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator> <operator>(</operator><literal type="number">86400L</literal> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000</literal> <operator>/</operator> <literal type="number">86400</literal> <operator>*</operator> <literal type="number">86400</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MICRO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>ignoreTz</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>-</operator> <operator>(</operator><name>timeVal</name> <operator>+</operator> <call><name>offsetFromTz</name><argument_list>(<argument><expr><name>timezone</name></expr></argument>, <argument><expr><literal type="number">1000000</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator> <operator>(</operator><literal type="number">86400L</literal> <operator>*</operator> <literal type="number">1000000</literal><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000000</literal> <operator>/</operator> <literal type="number">86400</literal> <operator>*</operator> <literal type="number">86400</literal> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>ignoreTz</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>-</operator> <operator>(</operator><name>timeVal</name> <operator>+</operator> <call><name>offsetFromTz</name><argument_list>(<argument><expr><name>timezone</name></expr></argument>, <argument><expr><literal type="number">1000000000</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator> <operator>(</operator><literal type="number">86400L</literal> <operator>*</operator> <literal type="number">1000000000</literal><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000000000</literal> <operator>/</operator> <literal type="number">86400</literal> <operator>*</operator> <literal type="number">86400</literal> <operator>*</operator> <literal type="number">1000000000</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>&lt;=</operator> <name>TSDB_TIME_PRECISION_SEC_DIGITS</name></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>ignoreTz</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <operator>(</operator><name>timeVal</name> <operator>-</operator> <operator>(</operator><name>timeVal</name> <operator>+</operator> <call><name>offsetFromTz</name><argument_list>(<argument><expr><name>timezone</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>%</operator> <operator>(</operator><literal type="number">86400L</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <name>factor</name> <operator>/</operator> <name>factor</name> <operator>/</operator> <literal type="number">86400</literal> <operator>*</operator> <literal type="number">86400</literal> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="number">604800000</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1w */</comment>
        <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MILLI_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000</literal> <operator>/</operator> <literal type="number">604800</literal> <operator>*</operator> <literal type="number">604800</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MICRO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000000</literal> <operator>/</operator> <literal type="number">604800</literal> <operator>*</operator> <literal type="number">604800</literal> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000000000</literal> <operator>/</operator> <literal type="number">604800</literal> <operator>*</operator> <literal type="number">604800</literal> <operator>*</operator> <literal type="number">1000000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>&lt;=</operator> <name>TSDB_TIME_PRECISION_SEC_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <name>factor</name> <operator>/</operator> <name>factor</name> <operator>/</operator> <literal type="number">604800</literal> <operator>*</operator> <literal type="number">604800</literal> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>

    <comment type="line">// truncate the timestamp to db precision</comment>
    <switch>switch <condition>(<expr><name>timePrec</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>TSDB_TIME_PRECISION_MILLI</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MICRO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_TIME_PRECISION_MICRO</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MILLI_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_TIME_PRECISION_NANO</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MICRO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MILLI_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>timeVal</name> <operator>=</operator> <name>timeVal</name> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>timeVal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>timeDiffFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>timeUnit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>timePrec</name></decl>, <decl><type ref="prev"/><name><name>timeVal</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>inputNum</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>timeUnit</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>timePrec</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>timePrec</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <decl_stmt><decl><type><name>int64_t</name></type> <name>factor</name> <init>= <expr><call><name>TSDB_TICK_PER_SECOND</name><argument_list>(<argument><expr><name>timePrec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfRows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>inputNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfRows</name> <operator>&gt;</operator> <name>numOfRows</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>numOfRows</name> <operator>=</operator> <name><name>pInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfRows</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>hasNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>hasNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>int32_t</name></type> <name>rowIdx</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>pInput</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>numOfRows</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>input</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>columnData</name></expr></argument>, <argument><expr><name>rowIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <comment type="block">/* datetime format strings */</comment>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>= <expr><call><name>convertStringToTimestamp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>TSDB_TIME_PRECISION_NANO</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>hasNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BIGINT</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>)</condition> <block>{<block_content> <comment type="block">/* unix timestamp or ts column*/</comment>
        <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>int64_t</name></type> <name>timeValSec</name> <init>= <expr><name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name> <operator>/</operator> <name>factor</name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>timeValSec</name> <operator>&lt;</operator> <literal type="number">1000000000</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>timeValSec</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">20</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NUM_TO_STRING</name><argument_list>(<argument><expr><name>TSDB_DATA_TYPE_BIGINT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>tsDigits</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>tsDigits</name> <operator>&lt;=</operator> <name>TSDB_TIME_PRECISION_SEC_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name> <operator>*</operator> <literal type="number">1000000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MILLI_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_MICRO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsDigits</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO_DIGITS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>timeVal</name><index>[<expr><name>k</name></expr>]</index></name> <operator>*</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name>hasNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>hasNull</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>result</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>timeVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <name><name>timeVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name><name>timeVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>timeVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name><name>timeVal</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>timeVal</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>timeUnit</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="line">// if no time unit given use db precision</comment>
      <switch>switch <condition>(<expr><name>timePrec</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TSDB_TIME_PRECISION_MILLI</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>TSDB_TIME_PRECISION_MICRO</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>TSDB_TIME_PRECISION_NANO</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
      </block_content>}</block></switch>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>unit</name> <init>= <expr><name>timeUnit</name> <operator>*</operator> <literal type="number">1000</literal> <operator>/</operator> <name>factor</name></expr></init></decl>;</decl_stmt>
      <switch>switch <condition>(<expr><name>unit</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><literal type="number">0</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1u or 1b */</comment>
          <if_stmt><if>if <condition>(<expr><name>timePrec</name> <operator>==</operator> <name>TSDB_TIME_PRECISION_NANO</name> <operator>&amp;&amp;</operator> <name>timeUnit</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="number">1</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1a */</comment>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="number">1000</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1s */</comment>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">1000000000</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="number">60000</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1m */</comment>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">1000000000</literal> <operator>/</operator> <literal type="number">60</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="number">3600000</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1h */</comment>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">1000000000</literal> <operator>/</operator> <literal type="number">3600</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="number">86400000</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1d */</comment>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">1000000000</literal> <operator>/</operator> <literal type="number">86400</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="number">604800000</literal></expr>:</case> <block>{<block_content> <comment type="block">/* 1w */</comment>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">1000000000</literal> <operator>/</operator> <literal type="number">604800</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <default>default:</default> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block>
      </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name>numOfRows</name></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nowFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>timePrec</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>timePrec</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int64_t</name></type> <name>ts</name> <init>= <expr><call><name>taosGetTimestamp</name><argument_list>(<argument><expr><name>timePrec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>todayFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>timePrec</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>timePrec</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int64_t</name></type> <name>ts</name> <init>= <expr><call><name>taosGetTimestampToday</name><argument_list>(<argument><expr><name>timePrec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>timezoneFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>output</name><index>[<expr><name>TD_TIMEZONE_LEN</name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tsTimezoneStr</name></expr></argument>, <argument><expr><name>TD_TIMEZONE_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tsTimezoneStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>atanFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doScalarFunctionUnique</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>atan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>sinFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doScalarFunctionUnique</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>sin</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>cosFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doScalarFunctionUnique</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>cos</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tanFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doScalarFunctionUnique</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>tan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>asinFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doScalarFunctionUnique</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>asin</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>acosFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doScalarFunctionUnique</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>acos</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>powFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doScalarFunctionUnique2</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>pow</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>logFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>inputNum</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>doScalarFunctionUnique</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>tlog</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>doScalarFunctionUnique2</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>tlog2</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>sqrtFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doScalarFunctionUnique</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>sqrt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>ceilFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>ceilf</name></expr></argument>, <argument><expr><name>ceil</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>floorFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>floorf</name></expr></argument>, <argument><expr><name>floor</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>roundFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>roundf</name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>lowerFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINDOWS</name></cpp:ifdef>
  <return>return <expr><call><name>doCaseConvFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>towlower</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>doCaseConvFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>tolower</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>upperFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINDOWS</name></cpp:ifdef>
  <return>return <expr><call><name>doCaseConvFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>towupper</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>doCaseConvFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>toupper</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>ltrimFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doTrimFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>tltrim</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>rtrimFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doTrimFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>trtrim</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>lengthFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doLengthFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>tlength</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>charLengthFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doLengthFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>tcharlength</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void reverseCopy(char* dest, const char* src, int16_t type, int32_t numOfRows) {
  switch(type) {
    case TSDB_DATA_TYPE_TINYINT:
    case TSDB_DATA_TYPE_UTINYINT:{
      int8_t* p = (int8_t*) dest;
      int8_t* pSrc = (int8_t*) src;

      for(int32_t i = 0; i &lt; numOfRows; ++i) {
        p[i] = pSrc[numOfRows - i - 1];
      }
      return;
    }

    case TSDB_DATA_TYPE_SMALLINT:
    case TSDB_DATA_TYPE_USMALLINT:{
      int16_t* p = (int16_t*) dest;
      int16_t* pSrc = (int16_t*) src;

      for(int32_t i = 0; i &lt; numOfRows; ++i) {
        p[i] = pSrc[numOfRows - i - 1];
      }
      return;
    }
    case TSDB_DATA_TYPE_INT:
    case TSDB_DATA_TYPE_UINT: {
      int32_t* p = (int32_t*) dest;
      int32_t* pSrc = (int32_t*) src;

      for(int32_t i = 0; i &lt; numOfRows; ++i) {
        p[i] = pSrc[numOfRows - i - 1];
      }
      return;
    }
    case TSDB_DATA_TYPE_BIGINT:
    case TSDB_DATA_TYPE_UBIGINT: {
      int64_t* p = (int64_t*) dest;
      int64_t* pSrc = (int64_t*) src;

      for(int32_t i = 0; i &lt; numOfRows; ++i) {
        p[i] = pSrc[numOfRows - i - 1];
      }
      return;
    }
    case TSDB_DATA_TYPE_FLOAT: {
      float* p = (float*) dest;
      float* pSrc = (float*) src;

      for(int32_t i = 0; i &lt; numOfRows; ++i) {
        p[i] = pSrc[numOfRows - i - 1];
      }
      return;
    }
    case TSDB_DATA_TYPE_DOUBLE: {
      double* p = (double*) dest;
      double* pSrc = (double*) src;

      for(int32_t i = 0; i &lt; numOfRows; ++i) {
        p[i] = pSrc[numOfRows - i - 1];
      }
      return;
    }
    default: assert(0);
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>bool</name></type> <name>getTimePseudoFuncEnv</name><parameter_list>(<parameter><function_decl><type><name>SFunctionNode</name> <modifier>*</modifier></type><name>UNUSED_PARAM</name><parameter_list>(<parameter><decl><type><name>pFunc</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>SFuncExecEnv</name> <modifier>*</modifier></type><name>pEnv</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pEnv</name><operator>-&gt;</operator><name>calcMemSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>qStartTsFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>inputNum</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>qEndTsFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>inputNum</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>winDurFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>inputNum</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>winStartTsFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>inputNum</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>winEndTsFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>inputNum</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><call><name>colDataGetData</name><argument_list>(<argument><expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>qTbnameFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>inputNum</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><call><name>colDataGetVarData</name><argument_list>(<argument><expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>colDataAppendNItems</name><argument_list>(<argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></argument>, <argument><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>+=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/** Aggregation functions **/</comment>
<function><type><name>int32_t</name></type> <name>countScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>out</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>sumScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>    <name>hasNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hasNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_SIGNED_NUMERIC_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_TINYINT</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_SMALLINT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_INT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BIGINT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IS_UNSIGNED_NUMERIC_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UTINYINT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_USMALLINT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UINT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UBIGINT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IS_FLOAT_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_FLOAT</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_DOUBLE</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>hasNull</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doMinMaxScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isMinFunc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>bool</name></type> <name>hasNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>isMinFunc</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>SET_TYPED_DATA_MAX</name><argument_list>(<argument><expr><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>SET_TYPED_DATA_MIN</name><argument_list>(<argument><expr><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hasNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <operator>*</operator><name>out</name><operator>)</operator> <operator>^</operator> <name>isMinFunc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <operator>*</operator><name>out</name><operator>)</operator> <operator>^</operator> <name>isMinFunc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <operator>*</operator><name>out</name><operator>)</operator> <operator>^</operator> <name>isMinFunc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <operator>*</operator><name>out</name><operator>)</operator> <operator>^</operator> <name>isMinFunc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <operator>*</operator><name>out</name><operator>)</operator> <operator>^</operator> <name>isMinFunc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <operator>*</operator><name>out</name><operator>)</operator> <operator>^</operator> <name>isMinFunc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <operator>*</operator><name>out</name><operator>)</operator> <operator>^</operator> <name>isMinFunc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <operator>*</operator><name>out</name><operator>)</operator> <operator>^</operator> <name>isMinFunc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <operator>*</operator><name>out</name><operator>)</operator> <operator>^</operator> <name>isMinFunc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <operator>*</operator><name>out</name><operator>)</operator> <operator>^</operator> <name>isMinFunc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>hasNull</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>minScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doMinMaxScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>maxScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>doMinMaxScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>avgScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>    <name>hasNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hasNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int8_t</name>  <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint8_t</name>  <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>+=</operator> <name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>hasNull</name> <operator>||</operator> <operator>(</operator><name>count</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IS_SIGNED_NUMERIC_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>out</name> <operator>=</operator> <operator>*</operator><name>out</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>count</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IS_UNSIGNED_NUMERIC_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>out</name> <operator>=</operator> <operator>*</operator><name>out</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>count</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IS_FLOAT_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>out</name> <operator>=</operator> <operator>*</operator><name>out</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>count</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>stddevScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// int64_t count = 0, sum = 0, qSum = 0;</comment>
  <decl_stmt><decl><type><name>bool</name></type> <name>hasNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hasNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    switch(type) {
      case TSDB_DATA_TYPE_TINYINT: {
        int8_t *in  = (int8_t *)pInputData-&gt;pData;
        sum += in[i];
        qSum += in[i] * in[i];
        count++;
        break;
      }
      case TSDB_DATA_TYPE_SMALLINT: {
        int16_t *in  = (int16_t *)pInputData-&gt;pData;
        sum += in[i];
        qSum += in[i] * in[i];
        count++;
        break;
      }
      case TSDB_DATA_TYPE_INT: {
        int32_t *in  = (int32_t *)pInputData-&gt;pData;
        sum += in[i];
        qSum += in[i] * in[i];
        count++;
        break;
      }
      case TSDB_DATA_TYPE_BIGINT: {
        int64_t *in  = (int64_t *)pInputData-&gt;pData;
        sum += in[i];
        qSum += in[i] * in[i];
        count++;
        break;
      }
      case TSDB_DATA_TYPE_UTINYINT: {
        uint8_t *in  = (uint8_t *)pInputData-&gt;pData;
        sum += in[i];
        qSum += in[i] * in[i];
        count++;
        break;
      }
      case TSDB_DATA_TYPE_USMALLINT: {
        uint16_t *in  = (uint16_t *)pInputData-&gt;pData;
        sum += in[i];
        qSum += in[i] * in[i];
        count++;
        break;
      }
      case TSDB_DATA_TYPE_UINT: {
        uint32_t *in  = (uint32_t *)pInputData-&gt;pData;
        sum += in[i];
        qSum += in[i] * in[i];
        count++;
        break;
      }
      case TSDB_DATA_TYPE_UBIGINT: {
        uint64_t *in  = (uint64_t *)pInputData-&gt;pData;
        sum += in[i];
        qSum += in[i] * in[i];
        count++;
        break;
      }
      case TSDB_DATA_TYPE_FLOAT: {
        float *in  = (float *)pInputData-&gt;pData;
        sum += in[i];
        qSum += in[i] * in[i];
        count++;
        break;
      }
      case TSDB_DATA_TYPE_DOUBLE: {
        double *in  = (double *)pInputData-&gt;pData;
        sum += in[i];
        qSum += in[i] * in[i];
        count++;
        break;
      }
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></for>

  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>hasNull</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    double avg = 0;
    if (IS_SIGNED_NUMERIC_TYPE(type)) {
      avg = (int64_t)sum / (double)count;
      *out =  sqrt(fabs((int64_t)qSum / ((double)count) - avg * avg));
    } else if (IS_UNSIGNED_NUMERIC_TYPE(type)) {
      avg = (uint64_t)sum / (double)count;
      *out =  sqrt(fabs((uint64_t)qSum / ((double)count) - avg * avg));
    } else if (IS_FLOAT_TYPE(type)) {
      avg = (double)sum / (double)count;
      *out =  sqrt(fabs((double)qSum / ((double)count) - avg * avg));
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEASTSQR_CAL</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>index</name></type></parameter>, <parameter><type><name>step</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>do {                                     \
    (p)[0][0] += (double)(x) * (x);        \
    (p)[0][1] += (double)(x);              \
    (p)[0][2] += (double)(x) * (y)[index]; \
    (p)[1][2] += (y)[index];               \
    (x) += step;                           \
  } while (0)</cpp:value></cpp:define>

<function><type><name>int32_t</name></type> <name>leastSQRScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name></type> <name>startVal</name></decl>, <decl><type ref="prev"/><name>stepVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name><name>matrix</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>startVal</name></expr></argument>, <argument><expr><name>double</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>stepVal</name></expr></argument>, <argument><expr><name>double</name></expr></argument>, <argument><expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int8_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LEASTSQR_CAL</name><argument_list>(<argument><expr><name>matrix</name></expr></argument>, <argument><expr><name>startVal</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>stepVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int16_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LEASTSQR_CAL</name><argument_list>(<argument><expr><name>matrix</name></expr></argument>, <argument><expr><name>startVal</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>stepVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LEASTSQR_CAL</name><argument_list>(<argument><expr><name>matrix</name></expr></argument>, <argument><expr><name>startVal</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>stepVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LEASTSQR_CAL</name><argument_list>(<argument><expr><name>matrix</name></expr></argument>, <argument><expr><name>startVal</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>stepVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LEASTSQR_CAL</name><argument_list>(<argument><expr><name>matrix</name></expr></argument>, <argument><expr><name>startVal</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>stepVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LEASTSQR_CAL</name><argument_list>(<argument><expr><name>matrix</name></expr></argument>, <argument><expr><name>startVal</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>stepVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LEASTSQR_CAL</name><argument_list>(<argument><expr><name>matrix</name></expr></argument>, <argument><expr><name>startVal</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>stepVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LEASTSQR_CAL</name><argument_list>(<argument><expr><name>matrix</name></expr></argument>, <argument><expr><name>startVal</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>stepVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LEASTSQR_CAL</name><argument_list>(<argument><expr><name>matrix</name></expr></argument>, <argument><expr><name>startVal</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>stepVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LEASTSQR_CAL</name><argument_list>(<argument><expr><name>matrix</name></expr></argument>, <argument><expr><name>startVal</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>stepVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>

  <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>matrix</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>count</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>matrix</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>matrix</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>double</name></type> <name>matrix00</name> <init>= <expr><name><name>matrix</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>matrix</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name><name>matrix</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name><name>matrix</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>matrix02</name> <init>= <expr><name><name>matrix</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>matrix</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name><name>matrix</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name><name>matrix</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>matrix12</name> <init>= <expr><name><name>matrix</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name>matrix02</name> <operator>*</operator> <operator>(</operator><name><name>matrix</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <name>matrix00</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>matrix02</name> <operator>/=</operator> <name>matrix00</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>matrix12</name> <operator>/=</operator> <name><name>matrix</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name></type>   <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>snprintf</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>, <argument><expr><literal type="string">"{slop:%.6lf, intercept:%.6lf}"</literal></expr></argument>, <argument><expr><name>matrix02</name></expr></argument>,
                          <argument><expr><name>matrix12</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>percentileScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name></type> <name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>   <name>hasNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hasNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>double</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>hasNull</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>apercentileScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>percentileScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>spreadScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SET_DOUBLE_VAL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>min</name></expr></argument>, <argument><expr><name>DBL_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SET_DOUBLE_VAL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>max</name></expr></argument>, <argument><expr><operator>-</operator><name>DBL_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>bool</name></type> <name>hasNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hasNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><name><name>pInputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>double</name></type> <name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>double</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;</operator> <call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>min</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>SET_DOUBLE_VAL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>min</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>val</name> <operator>&gt;</operator> <call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>max</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>SET_DOUBLE_VAL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>max</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>hasNull</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>result</name> <init>= <expr><name>max</name> <operator>-</operator> <name>min</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>nonCalcScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>    <name>hasNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hasNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name><name>pOutputData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>hasNull</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>derivativeScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>nonCalcScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>irateScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>nonCalcScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>diffScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>nonCalcScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>twaScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>avgScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>mavgScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>avgScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>hllScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>countScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>csumScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>sumScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{
  <decl><name>STATE_OPER_INVALID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <decl><name>STATE_OPER_LT</name></decl>,
  <decl><name>STATE_OPER_GT</name></decl>,
  <decl><name>STATE_OPER_LE</name></decl>,
  <decl><name>STATE_OPER_GE</name></decl>,
  <decl><name>STATE_OPER_NE</name></decl>,
  <decl><name>STATE_OPER_EQ</name></decl>,
}</block></enum></type> <name>EStateOperType</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_COMP</name><parameter_list>(<parameter><type><name>_op</name></type></parameter>, <parameter><type><name>_lval</name></type></parameter>, <parameter><type><name>_rval</name></type></parameter>, <parameter><type><name>_rtype</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>STATE_COMP_IMPL(_op, _lval, GET_STATE_VAL(_rval, _rtype))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_STATE_VAL</name><parameter_list>(<parameter><type><name>_val</name></type></parameter>, <parameter><type><name>_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((_type == TSDB_DATA_TYPE_BIGINT) ? (*(int64_t *)_val) : (*(double *)_val))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATE_COMP_IMPL</name><parameter_list>(<parameter><type><name>_op</name></type></parameter>, <parameter><type><name>_lval</name></type></parameter>, <parameter><type><name>_rval</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>do {                                     \
    switch (_op) {                         \
      case STATE_OPER_LT:                  \
        return ((_lval) &lt; (_rval));        \
        break;                             \
      case STATE_OPER_GT:                  \
        return ((_lval) &gt; (_rval));        \
        break;                             \
      case STATE_OPER_LE:                  \
        return ((_lval) &lt;= (_rval));       \
        break;                             \
      case STATE_OPER_GE:                  \
        return ((_lval) &gt;= (_rval));       \
        break;                             \
      case STATE_OPER_NE:                  \
        return ((_lval) != (_rval));       \
        break;                             \
      case STATE_OPER_EQ:                  \
        return ((_lval) == (_rval));       \
        break;                             \
      default:                             \
        break;                             \
    }                                      \
  } while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int8_t</name></type> <name>getStateOpType</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>opStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type> <name>opType</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>opStr</name></expr></argument>, <argument><expr><literal type="string">"LT"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>opType</name> <operator>=</operator> <name>STATE_OPER_LT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>opStr</name></expr></argument>, <argument><expr><literal type="string">"GT"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>opType</name> <operator>=</operator> <name>STATE_OPER_GT</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>opStr</name></expr></argument>, <argument><expr><literal type="string">"LE"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>opType</name> <operator>=</operator> <name>STATE_OPER_LE</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>opStr</name></expr></argument>, <argument><expr><literal type="string">"GE"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>opType</name> <operator>=</operator> <name>STATE_OPER_GE</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>opStr</name></expr></argument>, <argument><expr><literal type="string">"NE"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>opType</name> <operator>=</operator> <name>STATE_OPER_NE</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>opStr</name></expr></argument>, <argument><expr><literal type="string">"EQ"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>opType</name> <operator>=</operator> <name>STATE_OPER_EQ</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>opType</name> <operator>=</operator> <name>STATE_OPER_INVALID</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>opType</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>checkStateOp</name><parameter_list>(<parameter><decl><type><name>int8_t</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pCol</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pCondParam</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>param</name> <init>= <expr><name><name>pCondParam</name><operator>-&gt;</operator><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>paramType</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pCondParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name><name>pCol</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int8_t</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>STATE_COMP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>paramType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>STATE_COMP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>paramType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int16_t</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>STATE_COMP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>paramType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint16_t</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>STATE_COMP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>paramType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>STATE_COMP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>paramType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>STATE_COMP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>paramType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>STATE_COMP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>paramType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>uint64_t</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>STATE_COMP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>paramType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>float</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>STATE_COMP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>paramType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>STATE_COMP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>paramType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>stateCountScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int8_t</name></type>  <name>op</name> <init>= <expr><call><name>getStateOpType</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type>    <name>ret</name> <init>= <expr><call><name>checkStateOp</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>out</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>out</name> <operator>=</operator> <operator>++</operator><name>count</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>stateDurationScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int8_t</name></type> <name>op</name> <init>= <expr><call><name>getStateOpType</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>bool</name></type>    <name>ret</name> <init>= <expr><call><name>checkStateOp</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>out</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>out</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{ <decl><name>UNKNOWN_BIN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>USER_INPUT_BIN</name></decl>, <decl><name>LINEAR_BIN</name></decl>, <decl><name>LOG_BIN</name></decl> }</block></enum></type> <name>EHistoBinType</name>;</typedef>

<function><type><specifier>static</specifier> <name>int8_t</name></type> <name>getHistogramBinType</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>binTypeStr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type> <name>binType</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>binTypeStr</name></expr></argument>, <argument><expr><literal type="string">"user_input"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>binType</name> <operator>=</operator> <name>USER_INPUT_BIN</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>binTypeStr</name></expr></argument>, <argument><expr><literal type="string">"linear_bin"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>binType</name> <operator>=</operator> <name>LINEAR_BIN</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>binTypeStr</name></expr></argument>, <argument><expr><literal type="string">"log_bin"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>binType</name> <operator>=</operator> <name>LOG_BIN</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>binType</name> <operator>=</operator> <name>UNKNOWN_BIN</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>binType</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SHistoFuncBin</name> <block>{
  <decl_stmt><decl><type><name>double</name></type>  <name>lower</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type>  <name>upper</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>count</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type>  <name>percentage</name></decl>;</decl_stmt>
}</block></struct></type> <name>SHistoFuncBin</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>getHistogramBinDesc</name><parameter_list>(<parameter><decl><type><name>SHistoFuncBin</name> <modifier>*</modifier><modifier>*</modifier></type><name>bins</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>binNum</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>binDescStr</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>binType</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type> <name>normalized</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>cJSON</name>  <modifier>*</modifier></type><name>binDesc</name> <init>= <expr><call><name>cJSON_Parse</name><argument_list>(<argument><expr><name>binDescStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfBins</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name> <modifier>*</modifier></type><name>intervals</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>cJSON_IsObject</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <comment type="block">/* linaer/log bins */</comment>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfParams</name> <init>= <expr><call><name>cJSON_GetArraySize</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>startIndex</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>numOfParams</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>cJSON</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><call><name>cJSON_GetObjectItem</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>, <argument><expr><literal type="string">"start"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cJSON</name> <modifier>*</modifier></type><name>factor</name> <init>= <expr><call><name>cJSON_GetObjectItem</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>, <argument><expr><literal type="string">"factor"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cJSON</name> <modifier>*</modifier></type><name>width</name> <init>= <expr><call><name>cJSON_GetObjectItem</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>, <argument><expr><literal type="string">"width"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cJSON</name> <modifier>*</modifier></type><name>count</name> <init>= <expr><call><name>cJSON_GetObjectItem</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cJSON</name> <modifier>*</modifier></type><name>infinity</name> <init>= <expr><call><name>cJSON_GetObjectItem</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>, <argument><expr><literal type="string">"infinity"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cJSON_IsNumber</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>cJSON_IsNumber</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>cJSON_IsBool</name><argument_list>(<argument><expr><name>infinity</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>count</name><operator>-&gt;</operator><name>valueint</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>count</name><operator>-&gt;</operator><name>valueint</name></name> <operator>&gt;</operator> <literal type="number">1000</literal></expr>)</condition> <block>{<block_content>  <comment type="line">// limit count to 1000</comment>
      <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>start</name><operator>-&gt;</operator><name>valuedouble</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>width</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>isinf</name><argument_list>(<argument><expr><name><name>width</name><operator>-&gt;</operator><name>valuedouble</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>factor</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>isinf</name><argument_list>(<argument><expr><name><name>factor</name><operator>-&gt;</operator><name>valuedouble</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><name>count</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>isinf</name><argument_list>(<argument><expr><name><name>count</name><operator>-&gt;</operator><name>valuedouble</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>counter</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>count</name><operator>-&gt;</operator><name>valueint</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>infinity</name><operator>-&gt;</operator><name>valueint</name></name> <operator>==</operator> <name>false</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>numOfBins</name> <operator>=</operator> <name>counter</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>numOfBins</name> <operator>=</operator> <name>counter</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>intervals</name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>numOfBins</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>cJSON_IsNumber</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>factor</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>binType</name> <operator>==</operator> <name>LINEAR_BIN</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// linear bin process</comment>
      <if_stmt><if>if <condition>(<expr><name><name>width</name><operator>-&gt;</operator><name>valuedouble</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>intervals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>counter</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>intervals</name><index>[<expr><name>startIndex</name></expr>]</index></name> <operator>=</operator> <name><name>start</name><operator>-&gt;</operator><name>valuedouble</name></name> <operator>+</operator> <name>i</name> <operator>*</operator> <name><name>width</name><operator>-&gt;</operator><name>valuedouble</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>intervals</name><index>[<expr><name>startIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>intervals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>startIndex</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cJSON_IsNumber</name><argument_list>(<argument><expr><name>factor</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>width</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>binType</name> <operator>==</operator> <name>LOG_BIN</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// log bin process</comment>
      <if_stmt><if>if <condition>(<expr><name><name>start</name><operator>-&gt;</operator><name>valuedouble</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>intervals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>factor</name><operator>-&gt;</operator><name>valuedouble</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>factor</name><operator>-&gt;</operator><name>valuedouble</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>factor</name><operator>-&gt;</operator><name>valuedouble</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>intervals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>counter</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>intervals</name><index>[<expr><name>startIndex</name></expr>]</index></name> <operator>=</operator> <name><name>start</name><operator>-&gt;</operator><name>valuedouble</name></name> <operator>*</operator> <call><name>pow</name><argument_list>(<argument><expr><name><name>factor</name><operator>-&gt;</operator><name>valuedouble</name></name></expr></argument>, <argument><expr><name>i</name> <operator>*</operator> <literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>intervals</name><index>[<expr><name>startIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>intervals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>startIndex</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>intervals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>infinity</name><operator>-&gt;</operator><name>valueint</name></name> <operator>==</operator> <name>true</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>intervals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><name>INFINITY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>intervals</name><index>[<expr><name>numOfBins</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>INFINITY</name></expr>;</expr_stmt>
      <comment type="line">// in case of desc bin orders, -inf/inf should be swapped</comment>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>numOfBins</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>intervals</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>intervals</name><index>[<expr><name>numOfBins</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>intervals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>intervals</name><index>[<expr><name>numOfBins</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>cJSON_IsArray</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <comment type="block">/* user input bins */</comment>
    <if_stmt><if>if <condition>(<expr><name>binType</name> <operator>!=</operator> <name>USER_INPUT_BIN</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>numOfBins</name> <operator>=</operator> <call><name>cJSON_GetArraySize</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>intervals</name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>numOfBins</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>cJSON</name> <modifier>*</modifier></type><name>bin</name> <init>= <expr><name><name>binDesc</name><operator>-&gt;</operator><name>child</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>bin</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>intervals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>bin</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>intervals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>valuedouble</name></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cJSON_IsNumber</name><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>intervals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>intervals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name><name>intervals</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>intervals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>bin</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>binNum</name> <operator>=</operator> <name>numOfBins</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>bins</name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>numOfBins</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SHistoFuncBin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>binNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>bins</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index><operator>.</operator><name>lower</name> <operator>=</operator> <ternary><condition><expr><name><name>intervals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>intervals</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr> ?</condition><then> <expr><name><name>intervals</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>intervals</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>bins</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index><operator>.</operator><name>upper</name> <operator>=</operator> <ternary><condition><expr><name><name>intervals</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>intervals</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>intervals</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>intervals</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>bins</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>intervals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cJSON_Delete</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>histogramScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SHistoFuncBin</name> <modifier>*</modifier></type><name>bins</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>        <name>numOfBins</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>        <name>totalCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>binTypeStr</name> <init>= <expr><call><name>strndup</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type> <name>binType</name> <init>= <expr><call><name>getHistogramBinType</name><argument_list>(<argument><expr><name>binTypeStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>binTypeStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>binDesc</name> <init>= <expr><call><name>strndup</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name><name>pInput</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>normalized</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pInput</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name><name>columnData</name><operator>-&gt;</operator><name>pData</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getHistogramBinDesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bins</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numOfBins</name></expr></argument>, <argument><expr><name>binDesc</name></expr></argument>, <argument><expr><name>binType</name></expr></argument>, <argument><expr><operator>(</operator><name>bool</name><operator>)</operator><name>normalized</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>binDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>v</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GET_TYPED_DATA</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>double</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numOfBins</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <name><name>bins</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>lower</name> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;=</operator> <name><name>bins</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>upper</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>bins</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>totalCount</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>normalized</name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numOfBins</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>totalCount</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>bins</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>percentage</name> <operator>=</operator> <name><name>bins</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>totalCount</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>bins</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>percentage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>colInfoDataEnsureCapacity</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>numOfBins</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numOfBins</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>    <name><name>buf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>normalized</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"{\"lower_bin\":%g, \"upper_bin\":%g, \"count\":%"</literal> <name>PRId64</name> <literal type="string">"}"</literal></expr></argument>, <argument><expr><name><name>bins</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>lower</name></expr></argument>,
                    <argument><expr><name><name>bins</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>upper</name></expr></argument>, <argument><expr><name><name>bins</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"{\"lower_bin\":%g, \"upper_bin\":%g, \"count\":%lf}"</literal></expr></argument>, <argument><expr><name><name>bins</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>lower</name></expr></argument>,
                    <argument><expr><name><name>bins</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>upper</name></expr></argument>, <argument><expr><name><name>bins</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>percentage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>bins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name>numOfBins</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>selectScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pInputData</name> <init>= <expr><name><name>pInput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnInfoData</name> <modifier>*</modifier></type><name>pOutputData</name> <init>= <expr><name><name>pOutput</name><operator>-&gt;</operator><name>columnData</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>GET_PARAM_TYPE</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pInputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pOutputData</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>topBotScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>selectScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>firstLastScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>selectScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>sampleScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>selectScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>tailScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>selectScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>uniqueScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>selectScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>modeScalarFunction</name><parameter_list>(<parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pInput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>inputNum</name></decl></parameter>, <parameter><decl><type><name>SScalarParam</name> <modifier>*</modifier></type><name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>selectScalarFunction</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>inputNum</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
