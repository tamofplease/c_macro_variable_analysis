<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/source/libs/index/src/indexFilter.c"><comment type="block">/*
 * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the GNU Affero General Public License, version 3
 * or later ("AGPL"), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"indexComm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"indexInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"querynodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scalar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdatablock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vnode.h"</cpp:file></cpp:include>

<comment type="line">// clang-format off</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIF_ERR_RET</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int32_t _code = c; if (_code != TSDB_CODE_SUCCESS) { terrno = _code; return _code; } } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIF_RET</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int32_t _code = c; if (_code != TSDB_CODE_SUCCESS) { terrno = _code; } return _code; } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIF_ERR_JRET</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { code = c; if (code != TSDB_CODE_SUCCESS) { terrno = code; goto _return; } } while (0)</cpp:value></cpp:define>
<comment type="line">// clang-format on</comment>

<typedef>typedef <type><union>union <block>{
  <decl_stmt><decl><type><name>uint8_t</name></type>  <name>u8</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>u16</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>u32</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>u64</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int8_t</name></type>  <name>i8</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>i16</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>i32</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>i64</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type>  <name>f</name></decl>;</decl_stmt>
}</block></union></type> <name>SDataTypeBuf</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIF_DATA_CONVERT</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>val</name></type></parameter>, <parameter><type><name>dst</name></type></parameter>)</parameter_list></cpp:macro>       \
  <cpp:value>do {                                         \
    if (type == TSDB_DATA_TYPE_DOUBLE)         \
      dst = GET_DOUBLE_VAL(val);               \
    else if (type == TSDB_DATA_TYPE_BIGINT)    \
      dst = *(int64_t *)val;                   \
    else if (type == TSDB_DATA_TYPE_INT)       \
      dst = *(int32_t *)val;                   \
    else if (type == TSDB_DATA_TYPE_SMALLINT)  \
      dst = *(int16_t *)val;                   \
    else if (type == TSDB_DATA_TYPE_TINYINT)   \
      dst = *(int8_t *)val;                    \
    else if (type == TSDB_DATA_TYPE_UTINYINT)  \
      dst = *(uint8_t *)val;                   \
    else if (type == TSDB_DATA_TYPE_USMALLINT) \
      dst = *(uint16_t *)val;                  \
    else if (type == TSDB_DATA_TYPE_UINT)      \
      dst = *(uint32_t *)val;                  \
    else if (type == TSDB_DATA_TYPE_UBIGINT)   \
      dst = *(uint64_t *)val;                  \
  } while (0);</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>SIFParam</name> <block>{
  <decl_stmt><decl><type><name>SHashObj</name> <modifier>*</modifier></type><name>pFilter</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SArray</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>condValue</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SIdxFltStatus</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type>       <name>colValType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>col_id_t</name></type>      <name>colId</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type>       <name>suid</name></decl>;</decl_stmt>  <comment type="line">// add later</comment>
  <decl_stmt><decl><type><name>char</name></type>          <name><name>dbName</name><index>[<expr><name>TSDB_DB_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>          <name><name>colName</name><index>[<expr><name>TSDB_COL_NAME_LEN</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SIndexMetaArg</name></type> <name>arg</name></decl>;</decl_stmt>
}</block></struct></type> <name>SIFParam</name>;</typedef>

<typedef>typedef <type><struct>struct <name>SIFCtx</name> <block>{
  <decl_stmt><decl><type><name>int32_t</name></type>       <name>code</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SHashObj</name>     <modifier>*</modifier></type><name>pRes</name></decl>;</decl_stmt>    <comment type="block">/* element is SIFParam */</comment>
  <decl_stmt><decl><type><name>bool</name></type>          <name>noExec</name></decl>;</decl_stmt>  <comment type="line">// true: just iterate condition tree, and add hint to executor plan</comment>
  <decl_stmt><decl><type><name>SIndexMetaArg</name></type> <name>arg</name></decl>;</decl_stmt>
}</block></struct></type> <name>SIFCtx</name>;</typedef>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifGetFuncFromSql</name><parameter_list>(<parameter><decl><type><name>EOperatorType</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>EIndexQueryType</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>OP_TYPE_GREATER_THAN</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <name>QUERY_GREATER_THAN</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>src</name> <operator>==</operator> <name>OP_TYPE_GREATER_EQUAL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <name>QUERY_GREATER_EQUAL</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>src</name> <operator>==</operator> <name>OP_TYPE_LOWER_THAN</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <name>QUERY_LESS_THAN</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>src</name> <operator>==</operator> <name>OP_TYPE_LOWER_EQUAL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <name>QUERY_LESS_EQUAL</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>src</name> <operator>==</operator> <name>OP_TYPE_EQUAL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <name>QUERY_TERM</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>src</name> <operator>==</operator> <name>OP_TYPE_LIKE</name> <operator>||</operator> <name>src</name> <operator>==</operator> <name>OP_TYPE_MATCH</name> <operator>||</operator> <name>src</name> <operator>==</operator> <name>OP_TYPE_NMATCH</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <name>QUERY_REGEX</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>src</name> <operator>==</operator> <name>OP_TYPE_JSON_CONTAINS</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <name>QUERY_PREFIX</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>int32_t</name></type> (<modifier>*</modifier><name>sif_func_t</name>)<parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>rigth</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>sif_func_t</name></type> <name>sifNullFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>void</name></type> <name>sifFreeParam</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>param</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>taosArrayDestroy</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>condValue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>pFilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifGetOperParamNum</name><parameter_list>(<parameter><decl><type><name>EOperatorType</name></type> <name>ty</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>OP_TYPE_IS_NULL</name> <operator>==</operator> <name>ty</name> <operator>||</operator> <name>OP_TYPE_IS_NOT_NULL</name> <operator>==</operator> <name>ty</name> <operator>||</operator> <name>OP_TYPE_IS_TRUE</name> <operator>==</operator> <name>ty</name> <operator>||</operator> <name>OP_TYPE_IS_NOT_TRUE</name> <operator>==</operator> <name>ty</name> <operator>||</operator>
      <name>OP_TYPE_IS_FALSE</name> <operator>==</operator> <name>ty</name> <operator>||</operator> <name>OP_TYPE_IS_NOT_FALSE</name> <operator>==</operator> <name>ty</name> <operator>||</operator> <name>OP_TYPE_IS_UNKNOWN</name> <operator>==</operator> <name>ty</name> <operator>||</operator>
      <name>OP_TYPE_IS_NOT_UNKNOWN</name> <operator>==</operator> <name>ty</name> <operator>||</operator> <name>OP_TYPE_MINUS</name> <operator>==</operator> <name>ty</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifValidOp</name><parameter_list>(<parameter><decl><type><name>EOperatorType</name></type> <name>ty</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ty</name> <operator>&gt;=</operator> <name>OP_TYPE_ADD</name> <operator>&amp;&amp;</operator> <name>ty</name> <operator>&lt;=</operator> <name>OP_TYPE_BIT_OR</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>ty</name> <operator>==</operator> <name>OP_TYPE_IN</name> <operator>||</operator> <name>ty</name> <operator>==</operator> <name>OP_TYPE_NOT_IN</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>ty</name> <operator>==</operator> <name>OP_TYPE_LIKE</name> <operator>||</operator> <name>ty</name> <operator>==</operator> <name>OP_TYPE_NOT_LIKE</name> <operator>||</operator> <name>ty</name> <operator>==</operator> <name>OP_TYPE_MATCH</name> <operator>||</operator> <name>ty</name> <operator>==</operator> <name>OP_TYPE_NMATCH</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifValidColumn</name><parameter_list>(<parameter><decl><type><name>SColumnNode</name> <modifier>*</modifier></type><name>cn</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// add more check</comment>
  <if_stmt><if>if <condition>(<expr><name>cn</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cn</name><operator>-&gt;</operator><name>colType</name></name> <operator>!=</operator> <name>COLUMN_TYPE_TAG</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>SIdxFltStatus</name></type> <name>sifMergeCond</name><parameter_list>(<parameter><decl><type><name>ELogicConditionType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>SIdxFltStatus</name></type> <name>ls</name></decl></parameter>, <parameter><decl><type><name>SIdxFltStatus</name></type> <name>rs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// enh rule later</comment>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>LOGIC_COND_TYPE_AND</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ls</name> <operator>==</operator> <name>SFLT_NOT_INDEX</name> <operator>||</operator> <name>rs</name> <operator>==</operator> <name>SFLT_NOT_INDEX</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>ls</name> <operator>==</operator> <name>SFLT_NOT_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>rs</name></expr>;</return></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>ls</name></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>SFLT_COARSE_INDEX</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>LOGIC_COND_TYPE_OR</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>SFLT_COARSE_INDEX</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>LOGIC_COND_TYPE_NOT</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>SFLT_NOT_INDEX</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SFLT_NOT_INDEX</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifGetValueFromNode</name><parameter_list>(<parameter><decl><type><name>SNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// covert data From snode;</comment>
  <decl_stmt><decl><type><name>SValueNode</name> <modifier>*</modifier></type><name>vn</name> <init>= <expr><operator>(</operator><name>SValueNode</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier></type><name>pData</name> <init>= <expr><call><name>nodesGetValueFromNode</name><argument_list>(<argument><expr><name>vn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SDataType</name> <modifier>*</modifier></type><name>pType</name> <init>= <expr><operator>&amp;</operator><name><name>vn</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>type</name> <init>= <expr><name><name>pType</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>valLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>dataLen</name> <init>= <expr><call><name>varDataTLen</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_JSON</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pData</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dataLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>pData</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dataLen</name> <operator>=</operator> <call><name>varDataTLen</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>pData</name> <operator>==</operator> <name>TSDB_DATA_TYPE_DOUBLE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dataLen</name> <operator>=</operator> <name>LONG_BYTES</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>pData</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dataLen</name> <operator>=</operator> <name>CHAR_BYTES</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>dataLen</name> <operator>+=</operator> <name>CHAR_BYTES</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>valLen</name> <operator>=</operator> <name>dataLen</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>valLen</name> <operator>=</operator> <name><name>pType</name><operator>-&gt;</operator><name>bytes</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>valLen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tv</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>valLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>tv</name></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifInitJsonParam</name><parameter_list>(<parameter><decl><type><name>SNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>SIFCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SOperatorNode</name> <modifier>*</modifier></type><name>nd</name> <init>= <expr><operator>(</operator><name>SOperatorNode</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>nodeType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>QUERY_NODE_OPERATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SColumnNode</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><operator>(</operator><name>SColumnNode</name> <operator>*</operator><operator>)</operator><name><name>nd</name><operator>-&gt;</operator><name>pLeft</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SValueNode</name>  <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator><name>SValueNode</name> <operator>*</operator><operator>)</operator><name><name>nd</name><operator>-&gt;</operator><name>pRight</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>colId</name></name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>colId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>colValType</name></name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>literal</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>literal</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>literal</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>colValType</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>typeData</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>SFLT_COARSE_INDEX</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sifInitParam</name><parameter_list>(<parameter><decl><type><name>SNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>SIFCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>SFLT_COARSE_INDEX</name></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_VALUE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SValueNode</name> <modifier>*</modifier></type><name>vn</name> <init>= <expr><operator>(</operator><name>SValueNode</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>vn</name><operator>-&gt;</operator><name>typeData</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>vn</name><operator>-&gt;</operator><name>literal</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>vn</name><operator>-&gt;</operator><name>literal</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><call><name>sifGetValueFromNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>colId</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>colValType</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name><name>vn</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>vn</name><operator>-&gt;</operator><name>literal</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>vn</name><operator>-&gt;</operator><name>literal</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><name><name>vn</name><operator>-&gt;</operator><name>literal</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>vn</name><operator>-&gt;</operator><name>literal</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_COLUMN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SColumnNode</name> <modifier>*</modifier></type><name>cn</name> <init>= <expr><operator>(</operator><name>SColumnNode</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
      <comment type="block">/*only support tag column*/</comment>
      <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><call><name>sifValidColumn</name><argument_list>(<argument><expr><name>cn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>colId</name></name> <operator>=</operator> <name><name>cn</name><operator>-&gt;</operator><name>colId</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>colValType</name></name> <operator>=</operator> <name><name>cn</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cn</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><name><name>cn</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cn</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_NODE_LIST</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SNodeListNode</name> <modifier>*</modifier></type><name>nl</name> <init>= <expr><operator>(</operator><name>SNodeListNode</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>nl</name><operator>-&gt;</operator><name>pNodeList</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>indexError</name><argument_list>(<argument><expr><literal type="string">"invalid length for node:%p, length: %d"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>nl</name><operator>-&gt;</operator><name>pNodeList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><call><name>scalarGenerateSetFromList</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>nl</name><operator>-&gt;</operator><name>dataType</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>taosHashPut</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pRes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>param</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>pFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>indexError</name><argument_list>(<argument><expr><literal type="string">"taosHashPut nodeList failed, size:%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>param</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_FUNCTION</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_OPERATOR</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_LOGIC_CONDITION</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><operator>(</operator><name>SIFParam</name> <operator>*</operator><operator>)</operator><call><name>taosHashGet</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pRes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>res</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>indexError</name><argument_list>(<argument><expr><literal type="string">"no result for node, type:%d, node:%p"</literal></expr></argument>, <argument><expr><call><name>nodeType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><name>TSDB_CODE_APP_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>param</name> <operator>=</operator> <operator>*</operator><name>res</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sifInitOperParams</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier><modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>SOperatorNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>SIFCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>nParam</name> <init>= <expr><call><name>sifGetOperParamNum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>opType</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>||</operator> <operator>(</operator><name>nParam</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>pRight</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>indexError</name><argument_list>(<argument><expr><literal type="string">"invalid operation node, left: %p, rigth: %p"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>opType</name></name> <operator>==</operator> <name>OP_TYPE_JSON_GET_VALUE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>pLeft</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>QUERY_NODE_COLUMN</name><operator>)</operator> <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>pRight</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>QUERY_NODE_VALUE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SColumnNode</name> <modifier>*</modifier></type><name>cn</name> <init>= <expr><operator>(</operator><name>SColumnNode</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>pLeft</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cn</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_JSON</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>paramList</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>nParam</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SIFParam</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>paramList</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>QUERY_NODE_OPERATOR</name> <operator>&amp;&amp;</operator>
      <operator>(</operator><operator>(</operator><operator>(</operator><name>SOperatorNode</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>pLeft</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>opType</name> <operator>==</operator> <name>OP_TYPE_JSON_GET_VALUE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name> <modifier>*</modifier></type><name>interNode</name> <init>= <expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>pLeft</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SIF_ERR_JRET</name><argument_list>(<argument><expr><call><name>sifInitJsonParam</name><argument_list>(<argument><expr><name>interNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>paramList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nParam</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>SIF_ERR_JRET</name><argument_list>(<argument><expr><call><name>sifInitParam</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>paramList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>paramList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>colValType</name> <operator>=</operator> <name>TSDB_DATA_TYPE_JSON</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>params</name> <operator>=</operator> <name>paramList</name></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>SIF_ERR_JRET</name><argument_list>(<argument><expr><call><name>sifInitParam</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>paramList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nParam</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>SIF_ERR_JRET</name><argument_list>(<argument><expr><call><name>sifInitParam</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>paramList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// if (paramList[0].colValType == TSDB_DATA_TYPE_JSON &amp;&amp;</comment>
      <comment type="line">//    ((SOperatorNode *)(node))-&gt;opType == OP_TYPE_JSON_CONTAINS) {</comment>
      <comment type="line">//  return TSDB_CODE_OUT_OF_MEMORY;</comment>
      <comment type="line">//}</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>params</name> <operator>=</operator> <name>paramList</name></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
<label><name>_return</name>:</label>
  <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParam</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sifFreeParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>paramList</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>paramList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SIF_RET</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sifInitParamList</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier><modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name> <modifier>*</modifier></type><name>nodeList</name></decl></parameter>, <parameter><decl><type><name>SIFCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>   <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>tParams</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name><name>nodeList</name><operator>-&gt;</operator><name>length</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SIFParam</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tParams</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>indexError</name><argument_list>(<argument><expr><literal type="string">"failed to calloc, nodeList: %p"</literal></expr></argument>, <argument><expr><name>nodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SListCell</name> <modifier>*</modifier></type><name>cell</name> <init>= <expr><name><name>nodeList</name><operator>-&gt;</operator><name>pHead</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>nodeList</name><operator>-&gt;</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>cell</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>cell</name><operator>-&gt;</operator><name>pNode</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>SIF_ERR_JRET</name><argument_list>(<argument><expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>SIF_ERR_JRET</name><argument_list>(<argument><expr><call><name>sifInitParam</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tParams</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>params</name> <operator>=</operator> <name>tParams</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>

<label><name>_return</name>:</label>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>tParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SIF_RET</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sifExecFunction</name><parameter_list>(<parameter><decl><type><name>SFunctionNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>SIFCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>indexError</name><argument_list>(<argument><expr><literal type="string">"index-filter not support buildin function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>FilterFunc</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name>dtype</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int</name></type> <name>sifGreaterThan</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name>dtype</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>__compar_fn_t</name></type> <name>func</name> <init>= <expr><call><name>getComparFunc</name><argument_list>(<argument><expr><name>dtype</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>tDoCompare</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>QUERY_GREATER_THAN</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int</name></type> <name>sifGreaterEqual</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name>dtype</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>__compar_fn_t</name></type> <name>func</name> <init>= <expr><call><name>getComparFunc</name><argument_list>(<argument><expr><name>dtype</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>tDoCompare</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>QUERY_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int</name></type> <name>sifLessEqual</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name>dtype</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>__compar_fn_t</name></type> <name>func</name> <init>= <expr><call><name>getComparFunc</name><argument_list>(<argument><expr><name>dtype</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>tDoCompare</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>QUERY_LESS_EQUAL</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int</name></type> <name>sifLessThan</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name>dtype</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>__compar_fn_t</name></type> <name>func</name> <init>= <expr><call><name>getComparFunc</name><argument_list>(<argument><expr><name>dtype</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tDoCompare</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>QUERY_LESS_THAN</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int</name></type> <name>sifEqual</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int16_t</name></type> <name>dtype</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>__compar_fn_t</name></type> <name>func</name> <init>= <expr><call><name>getComparFunc</name><argument_list>(<argument><expr><name>dtype</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">//__compar_fn_t func = idxGetCompar(dtype);</comment>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tDoCompare</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>QUERY_TERM</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>FilterFunc</name></type> <name>sifGetFilterFunc</name><parameter_list>(<parameter><decl><type><name>EIndexQueryType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>reverse</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>QUERY_LESS_EQUAL</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>QUERY_LESS_THAN</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>reverse</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>reverse</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>QUERY_LESS_EQUAL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>sifLessEqual</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>QUERY_LESS_THAN</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>sifLessThan</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>QUERY_GREATER_EQUAL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>sifGreaterEqual</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>QUERY_GREATER_THAN</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>sifGreaterThan</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>QUERY_TERM</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>sifEqual</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sifSetFltParam</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SDataTypeBuf</name> <modifier>*</modifier></type><name>typedata</name></decl></parameter>, <parameter><decl><type><name>SMetaFltParam</name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type> <name>ltype</name> <init>= <expr><name><name>left</name><operator>-&gt;</operator><name>colValType</name></name></expr></init></decl>, <decl><type ref="prev"/><name>rtype</name> <init>= <expr><name><name>right</name><operator>-&gt;</operator><name>colValType</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>TSDB_DATA_TYPE_FLOAT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>float</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SIF_DATA_CONVERT</name><argument_list>(<argument><expr><name>rtype</name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>typedata</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>typedata</name><operator>-&gt;</operator><name>f</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>TSDB_DATA_TYPE_DOUBLE</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SIF_DATA_CONVERT</name><argument_list>(<argument><expr><name>rtype</name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>typedata</name><operator>-&gt;</operator><name>d</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>typedata</name><operator>-&gt;</operator><name>d</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BIGINT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>i64</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SIF_DATA_CONVERT</name><argument_list>(<argument><expr><name>rtype</name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>, <argument><expr><name>i64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>typedata</name><operator>-&gt;</operator><name>i64</name></name> <operator>=</operator> <name>i64</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>typedata</name><operator>-&gt;</operator><name>i64</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>TSDB_DATA_TYPE_INT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>i32</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SIF_DATA_CONVERT</name><argument_list>(<argument><expr><name>rtype</name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>, <argument><expr><name>i32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>typedata</name><operator>-&gt;</operator><name>i32</name></name> <operator>=</operator> <name>i32</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>typedata</name><operator>-&gt;</operator><name>i32</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>TSDB_DATA_TYPE_SMALLINT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int16_t</name></type> <name>i16</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SIF_DATA_CONVERT</name><argument_list>(<argument><expr><name>rtype</name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>, <argument><expr><name>i16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>typedata</name><operator>-&gt;</operator><name>i16</name></name> <operator>=</operator> <name>i16</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>typedata</name><operator>-&gt;</operator><name>i16</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>TSDB_DATA_TYPE_TINYINT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int8_t</name></type> <name>i8</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <macro><name>SIF_DATA_CONVERT</name><argument_list>(<argument>rtype</argument>, <argument>right-&gt;condValue</argument>, <argument>i8</argument>)</argument_list></macro>
    <expr_stmt><expr><name><name>typedata</name><operator>-&gt;</operator><name>i8</name></name> <operator>=</operator> <name>i8</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>typedata</name><operator>-&gt;</operator><name>i8</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UBIGINT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>u64</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SIF_DATA_CONVERT</name><argument_list>(<argument><expr><name>rtype</name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>, <argument><expr><name>u64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>typedata</name><operator>-&gt;</operator><name>u64</name></name> <operator>=</operator> <name>u64</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>typedata</name><operator>-&gt;</operator><name>u64</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UINT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>u32</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SIF_DATA_CONVERT</name><argument_list>(<argument><expr><name>rtype</name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>, <argument><expr><name>u32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>typedata</name><operator>-&gt;</operator><name>u32</name></name> <operator>=</operator> <name>u32</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>typedata</name><operator>-&gt;</operator><name>u32</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>TSDB_DATA_TYPE_USMALLINT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>u16</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SIF_DATA_CONVERT</name><argument_list>(<argument><expr><name>rtype</name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>, <argument><expr><name>u16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>typedata</name><operator>-&gt;</operator><name>u16</name></name> <operator>=</operator> <name>u16</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>typedata</name><operator>-&gt;</operator><name>u16</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ltype</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UTINYINT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>u8</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SIF_DATA_CONVERT</name><argument_list>(<argument><expr><name>rtype</name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>, <argument><expr><name>u8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>typedata</name><operator>-&gt;</operator><name>u8</name></name> <operator>=</operator> <name>u8</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>typedata</name><operator>-&gt;</operator><name>u8</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sifDoIndex</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>operType</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type>             <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SIndexMetaArg</name>  <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>&amp;</operator><name><name>output</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>EIndexQueryType</name></type> <name>qtype</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><call><name>sifGetFuncFromSql</name><argument_list>(<argument><expr><name>operType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>left</name><operator>-&gt;</operator><name>colValType</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_JSON</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SIndexTerm</name> <modifier>*</modifier></type><name>tm</name> <init>= <expr><call><name>indexTermCreate</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>suid</name></name></expr></argument>, <argument><expr><name>DEFAULT</name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>colValType</name></name></expr></argument>, <argument><expr><name><name>left</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>left</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>tm</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>SIndexMultiTermQuery</name> <modifier>*</modifier></type><name>mtm</name> <init>= <expr><call><name>indexMultiTermQueryCreate</name><argument_list>(<argument><expr><name>MUST</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>indexMultiTermQueryAdd</name><argument_list>(<argument><expr><name>mtm</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>indexJsonSearch</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>ivtIdx</name></name></expr></argument>, <argument><expr><name>mtm</name></expr></argument>, <argument><expr><name><name>output</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>indexMultiTermQueryDestroy</name><argument_list>(<argument><expr><name>mtm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>       <name>reverse</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FilterFunc</name></type> <name>filterFunc</name> <init>= <expr><call><name>sifGetFilterFunc</name><argument_list>(<argument><expr><name>qtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reverse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>SMetaFltParam</name></type> <name>param</name> <init>= <expr><block>{<expr><operator>.</operator><name>suid</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>suid</name></name></expr>,
                           <expr><operator>.</operator><name>cid</name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>colId</name></name></expr>,
                           <expr><operator>.</operator><name>type</name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>colValType</name></name></expr>,
                           <expr><operator>.</operator><name>val</name> <operator>=</operator> <name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr>,
                           <expr><operator>.</operator><name>reverse</name> <operator>=</operator> <name>reverse</name></expr>,
                           <expr><operator>.</operator><name>filterFunc</name> <operator>=</operator> <name>filterFunc</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>SDataTypeBuf</name></type> <name>typedata</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typedata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>typedata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name><name>left</name><operator>-&gt;</operator><name>colValType</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name><name>right</name><operator>-&gt;</operator><name>colValType</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>NUM_TO_STRING</name><argument_list>(<argument><expr><name><name>right</name><operator>-&gt;</operator><name>colValType</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>condValue</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>varDataSetLen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>param</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>sifSetFltParam</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typedata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>metaFilterTableIds</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>metaEx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name><name>output</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifLessThanFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_LOWER_THAN</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifLessEqualFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_LOWER_EQUAL</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifGreaterThanFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_GREATER_THAN</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifGreaterEqualFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_GREATER_EQUAL</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifEqualFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_EQUAL</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifNotEqualFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_NOT_EQUAL</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifInFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_IN</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifNotInFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_NOT_IN</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifLikeFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_LIKE</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifNotLikeFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_NOT_LIKE</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifMatchFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_MATCH</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifNotMatchFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_NMATCH</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifJsonContains</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name>OP_TYPE_JSON_CONTAINS</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sifDoIndex</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifJsonGetValue</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>rigth</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// return 0</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifDefaultFunc</name><parameter_list>(<parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// add more except</comment>
  <return>return <expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FORCE_INLINE</name> <name>int32_t</name></type> <name>sifGetOperFn</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>funcId</name></decl></parameter>, <parameter><decl><type><name>sif_func_t</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>SIdxFltStatus</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// impl later</comment>
  <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SFLT_ACCURATE_INDEX</name></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>funcId</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OP_TYPE_GREATER_THAN</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifGreaterThanFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_GREATER_EQUAL</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifGreaterEqualFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_LOWER_THAN</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifLessThanFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_LOWER_EQUAL</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifLessEqualFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_EQUAL</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifEqualFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_NOT_EQUAL</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifNotEqualFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_IN</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifInFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_NOT_IN</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifNotInFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_LIKE</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifLikeFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_NOT_LIKE</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifNotLikeFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_MATCH</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifMatchFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_NMATCH</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifNotMatchFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_JSON_CONTAINS</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SFLT_ACCURATE_INDEX</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifJsonContains</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>OP_TYPE_JSON_GET_VALUE</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SFLT_ACCURATE_INDEX</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifJsonGetValue</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <default>default:</default>
      <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>sifNullFunc</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sifExecOper</name><parameter_list>(<parameter><decl><type><name>SOperatorNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>SIFCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>sifValidOp</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>opType</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_QRY_INVALID_INPUT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>nParam</name> <init>= <expr><call><name>sifGetOperParamNum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>opType</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>nParam</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>opType</name></name> <operator>==</operator> <name>OP_TYPE_JSON_GET_VALUE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><call><name>sifInitOperParams</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>status</name> <operator>==</operator> <name>SFLT_NOT_INDEX</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>nParam</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>status</name> <operator>==</operator> <name>SFLT_NOT_INDEX</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
    <goto>goto <name>_return</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// ugly code, refactor later</comment>
  <expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>sif_func_t</name></type> <name>operFn</name> <init>= <expr><name>sifNullFunc</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>noExec</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>SIF_ERR_JRET</name><argument_list>(<argument><expr><call><name>sifGetOperFn</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>opType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>operFn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>output</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SIF_ERR_JRET</name><argument_list>(<argument><expr><call><name>operFn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name>nParam</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="line">// ugly code, refactor later</comment>
    <if_stmt><if>if <condition>(<expr><name>nParam</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>status</name> <operator>==</operator> <name>SFLT_NOT_INDEX</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
      <goto>goto <name>_return</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>SIF_ERR_JRET</name><argument_list>(<argument><expr><call><name>sifGetOperFn</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>opType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>operFn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>output</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<label><name>_return</name>:</label>
  <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParam</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sifFreeParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sifExecLogic</name><parameter_list>(<parameter><decl><type><name>SLogicConditionNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>SIFCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>pParameterList</name></name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>pParameterList</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>indexError</name><argument_list>(<argument><expr><literal type="string">"invalid logic parameter list, list:%p, paramNum:%d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>,
               <argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>pParameterList</name></name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>pParameterList</name><operator>-&gt;</operator><name>length</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>   <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><call><name>sifInitParamList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>noExec</name></name> <operator>==</operator> <name>false</name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>m</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>pParameterList</name><operator>-&gt;</operator><name>length</name></name></expr>;</condition> <incr><expr><name>m</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>condType</name></name> <operator>==</operator> <name>LOGIC_COND_TYPE_AND</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosArrayAddAll</name><argument_list>(<argument><expr><name><name>output</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name><name>params</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>condType</name></name> <operator>==</operator> <name>LOGIC_COND_TYPE_OR</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosArrayAddAll</name><argument_list>(<argument><expr><name><name>output</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name><name>params</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>condType</name></name> <operator>==</operator> <name>LOGIC_COND_TYPE_NOT</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// taosArrayAddAll(output-&gt;result, params[m].result);</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>taosArraySort</name><argument_list>(<argument><expr><name><name>output</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>idxUidCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosArrayRemoveDuplicate</name><argument_list>(<argument><expr><name><name>output</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>idxUidCompare</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>m</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>pParameterList</name><operator>-&gt;</operator><name>length</name></name></expr>;</condition> <incr><expr><name>m</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <call><name>sifMergeCond</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>condType</name></name></expr></argument>, <argument><expr><name><name>output</name><operator>-&gt;</operator><name>status</name></name></expr></argument>, <argument><expr><name><name>params</name><index>[<expr><name>m</name></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// taosArrayDestroy(params[m].result);</comment>
      <comment type="line">// params[m].result = NULL;</comment>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
<label><name>_return</name>:</label>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SIF_RET</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>sifWalkFunction</name><parameter_list>(<parameter><decl><type><name>SNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SFunctionNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name> <operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SIFParam</name></type>       <name>output</name> <init>= <expr><block>{<expr><operator>.</operator><name>result</name> <operator>=</operator> <macro><name>taosArrayInit</name><argument_list>(<argument><literal type="number">8</literal></argument>, <argument>sizeof(uint64_t)</argument>)</argument_list></macro></expr>}</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SIFCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name>context</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <call><name>sifExecFunction</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>code</name></name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sifFreeParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>taosHashPut</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pRes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNode</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>sifWalkLogic</name><parameter_list>(<parameter><decl><type><name>SNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicConditionNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>SLogicConditionNode</name> <operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SIFParam</name></type> <name>output</name> <init>= <expr><block>{<expr><operator>.</operator><name>result</name> <operator>=</operator> <macro><name>taosArrayInit</name><argument_list>(<argument><literal type="number">8</literal></argument>, <argument>sizeof(uint64_t)</argument>)</argument_list></macro></expr>}</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SIFCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name>context</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <call><name>sifExecLogic</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>code</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sifFreeParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>taosHashPut</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pRes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNode</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>sifWalkOper</name><parameter_list>(<parameter><decl><type><name>SNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SOperatorNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>SOperatorNode</name> <operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SIFParam</name></type>       <name>output</name> <init>= <expr><block>{<expr><operator>.</operator><name>result</name> <operator>=</operator> <call><name>taosArrayInit</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>, <expr><operator>.</operator><name>status</name> <operator>=</operator> <name>SFLT_COARSE_INDEX</name></expr>}</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SIFCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name>context</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <call><name>sifExecOper</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>code</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sifFreeParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>taosHashPut</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>pRes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNode</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>EDealRes</name></type> <name>sifCalcWalker</name><parameter_list>(<parameter><decl><type><name>SNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_VALUE</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>QUERY_NODE_NODE_LIST</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator>
      <name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SIFCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>SIFCtx</name> <operator>*</operator><operator>)</operator><name>context</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_FUNCTION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>sifWalkFunction</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_CONDITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>sifWalkLogic</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_OPERATOR</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="line">// indexInfo("node type for index filter, type: %d", nodeType(node));</comment>
    <return>return <expr><call><name>sifWalkOper</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// indexError("invalid node type for index filter calculating, type:%d", nodeType(node));</comment>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>TSDB_CODE_QRY_INVALID_INPUT</name></expr>;</expr_stmt>
  <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>sifFreeRes</name><parameter_list>(<parameter><decl><type><name>SHashObj</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pIter</name> <init>= <expr><call><name>taosHashIterate</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>pIter</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>pIter</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sifFreeParam</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pIter</name> <operator>=</operator> <call><name>taosHashIterate</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>pIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sifCalculate</name><parameter_list>(<parameter><decl><type><name>SNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>pDst</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>pNode</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>pDst</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SIFCtx</name></type>  <name>ctx</name> <init>= <expr><block>{<expr><operator>.</operator><name>code</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>noExec</name> <operator>=</operator> <name>false</name></expr>, <expr><operator>.</operator><name>arg</name> <operator>=</operator> <name><name>pDst</name><operator>-&gt;</operator><name>arg</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pRes</name></name> <operator>=</operator> <call><name>taosHashInit</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name>taosGetDefaultHashFunction</name><argument_list>(<argument><expr><name>TSDB_DATA_TYPE_BIGINT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>HASH_NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>ctx</name><operator>.</operator><name>pRes</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>indexError</name><argument_list>(<argument><expr><literal type="string">"index-filter failed to taosHashInit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>nodesWalkExprPostOrder</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>sifCalcWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>code</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sifFreeRes</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>pRes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>ctx</name><operator>.</operator><name>code</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>pDst</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><operator>(</operator><name>SIFParam</name> <operator>*</operator><operator>)</operator><call><name>taosHashGet</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>pRes</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pNode</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>indexError</name><argument_list>(<argument><expr><literal type="string">"no valid res in hash, node:(%p), type(%d)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pNode</name></expr></argument>, <argument><expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><name>TSDB_CODE_APP_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>result</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>taosArrayAddAll</name><argument_list>(<argument><expr><name><name>pDst</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>sifFreeParam</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosHashRemove</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>pRes</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pNode</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sifFreeRes</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>pRes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sifGetFltHint</name><parameter_list>(<parameter><decl><type><name>SNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><name>SIdxFltStatus</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>pNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_QRY_INVALID_INPUT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SIFCtx</name></type> <name>ctx</name> <init>= <expr><block>{<expr><operator>.</operator><name>code</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>noExec</name> <operator>=</operator> <name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>pRes</name></name> <operator>=</operator> <call><name>taosHashInit</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name>taosGetDefaultHashFunction</name><argument_list>(<argument><expr><name>TSDB_DATA_TYPE_BIGINT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>HASH_NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>ctx</name><operator>.</operator><name>pRes</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>indexError</name><argument_list>(<argument><expr><literal type="string">"index-filter failed to taosHashInit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>nodesWalkExprPostOrder</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>sifCalcWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>code</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sifFreeRes</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>pRes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>ctx</name><operator>.</operator><name>code</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><operator>(</operator><name>SIFParam</name> <operator>*</operator><operator>)</operator><call><name>taosHashGet</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>pRes</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pNode</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>indexError</name><argument_list>(<argument><expr><literal type="string">"no valid res in hash, node:(%p), type(%d)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pNode</name></expr></argument>, <argument><expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SIF_ERR_RET</name><argument_list>(<argument><expr><name>TSDB_CODE_APP_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sifFreeParam</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosHashRemove</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>pRes</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pNode</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>taosHashIterate</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>pRes</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>iter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SIFParam</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>SIFParam</name> <operator>*</operator><operator>)</operator><name>iter</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sifFreeParam</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>taosHashIterate</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>pRes</name></name></expr></argument>, <argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>pRes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>doFilterTag</name><parameter_list>(<parameter><decl><type><name>SNode</name> <modifier>*</modifier></type><name>pFilterNode</name></decl></parameter>, <parameter><decl><type><name>SIndexMetaArg</name> <modifier>*</modifier></type><name>metaArg</name></decl></parameter>, <parameter><decl><type><name>SArray</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>SIdxFltStatus</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SIdxFltStatus</name></type> <name>st</name> <init>= <expr><call><name>idxGetFltStatus</name><argument_list>(<argument><expr><name>pFilterNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>st</name> <operator>==</operator> <name>SFLT_NOT_INDEX</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>st</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SFilterInfo</name> <modifier>*</modifier></type><name>filter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SArray</name>  <modifier>*</modifier></type><name>output</name> <init>= <expr><call><name>taosArrayInit</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SIFParam</name></type> <name>param</name> <init>= <expr><block>{<expr><operator>.</operator><name>arg</name> <operator>=</operator> <operator>*</operator><name>metaArg</name></expr>, <expr><operator>.</operator><name>result</name> <operator>=</operator> <name>output</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>code</name> <init>= <expr><call><name>sifCalculate</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name> <operator>*</operator><operator>)</operator><name>pFilterNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sifFreeParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>taosArrayAddAll</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sifFreeParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>st</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SIdxFltStatus</name></type> <name>idxGetFltStatus</name><parameter_list>(<parameter><decl><type><name>SNode</name> <modifier>*</modifier></type><name>pFilterNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SIdxFltStatus</name></type> <name>st</name> <init>= <expr><name>SFLT_NOT_INDEX</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>pFilterNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>SFLT_NOT_INDEX</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sifGetFltHint</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name> <operator>*</operator><operator>)</operator><name>pFilterNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>st</name> <operator>=</operator> <name>SFLT_NOT_INDEX</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>st</name></expr>;</return>
</block_content>}</block></function>
</unit>
