<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/source/libs/executor/src/executorimpl.c"><comment type="block">/*
 * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the GNU Affero General Public License, version 3
 * or later ("AGPL"), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"function.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"functionMgt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"querynodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tfill.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tname.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdatablock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tglobal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tmsg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ttime.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executorimpl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcompare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ttypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vnode.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_MAIN_SCAN</name><parameter_list>(<parameter><type><name>runtime</name></type></parameter>)</parameter_list></cpp:macro>          <cpp:value>((runtime)-&gt;scanFlag == MAIN_SCAN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_REVERSE_SCAN_FLAG</name><parameter_list>(<parameter><type><name>runtime</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((runtime)-&gt;scanFlag = REVERSE_SCAN)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_FORWARD_DIRECTION_FACTOR</name><parameter_list>(<parameter><type><name>ord</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((ord) == TSDB_ORDER_ASC) ? QUERY_ASC_FORWARD_STEP : QUERY_DESC_FORWARD_STEP)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static UNUSED_FUNC void *u_malloc (size_t __size) {
  uint32_t v = taosRand();

  if (v % 1000 &lt;= 0) {
    return NULL;
  } else {
    return taosMemoryMalloc(__size);
  }
}

static UNUSED_FUNC void* u_calloc(size_t num, size_t __size) {
  uint32_t v = taosRand();
  if (v % 1000 &lt;= 0) {
    return NULL;
  } else {
    return taosMemoryCalloc(num, __size);
  }
}

static UNUSED_FUNC void* u_realloc(void* p, size_t __size) {
  uint32_t v = taosRand();
  if (v % 5 &lt;= 1) {
    return NULL;
  } else {
    return taosMemoryRealloc(p, __size);
  }
}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>calloc</name></cpp:macro>  <cpp:value>u_calloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc</name></cpp:macro>  <cpp:value>u_malloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>realloc</name></cpp:macro> <cpp:value>u_realloc</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEAR_QUERY_STATUS</name><parameter_list>(<parameter><type><name>q</name></type></parameter>, <parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>((q)-&gt;status &amp;= (~(st)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUERY_IS_INTERVAL_QUERY</name><parameter_list>(<parameter><type><name>_q</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((_q)-&gt;interval.interval &gt; 0)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>SAggOperatorInfo</name> <block>{
  <decl_stmt><decl><type><name>SOptrBasicInfo</name></type>   <name>binfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SAggSupporter</name></type>    <name>aggSup</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>STableQueryInfo</name><modifier>*</modifier></type> <name>current</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type>         <name>groupId</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SGroupResInfo</name></type>    <name>groupResInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SExprSupp</name></type>        <name>scalarExprSup</name></decl>;</decl_stmt>
}</block></struct></type> <name>SAggOperatorInfo</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setBlockSMAInfo</name><parameter_list>(<parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>, <parameter><decl><type><name>SExprInfo</name><modifier>*</modifier></type> <name>pExpr</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>releaseQueryBuf</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>numOfTables</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>    <name>destroyAggOperatorInfo</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>param</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>    <name>initCtxOutputBuffer</name><parameter_list>(<parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>    <name>doSetTableGroupOutputBuf</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfOutput</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>groupId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>    <name>doApplyScalarCalculation</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>scanFlag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>doInitAggInfoSup</name><parameter_list>(<parameter><decl><type><name>SAggSupporter</name><modifier>*</modifier></type> <name>pAggSup</name></decl></parameter>, <parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfOutput</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keyBufSize</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pKey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>    <name>extractQualifiedTupleByFilterResult</name><parameter_list>(<parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SColumnInfoData</name><modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keep</name></decl></parameter>,
                                                   <parameter><decl><type><name>int32_t</name></type> <name>status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>doSetInputDataBlock</name><parameter_list>(<parameter><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pExprSup</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>scanFlag</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>createDummyCol</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>setOperatorCompleted</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>OP_EXEC_DONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pOperator</name><operator>-&gt;</operator><name>pTaskInfo</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>totalCost</name></name> <operator>=</operator> <operator>(</operator><call><name>taosGetTimestampUs</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>pOperator</name><operator>-&gt;</operator><name>pTaskInfo</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>start</name></name><operator>)</operator> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setTaskStatus</name><argument_list>(<argument><expr><name><name>pOperator</name><operator>-&gt;</operator><name>pTaskInfo</name></name></expr></argument>, <argument><expr><name>TASK_COMPLETED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setOperatorInfo</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>blocking</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>status</name></decl></parameter>,
                     <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>, <parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>operatorType</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>blocking</name></name> <operator>=</operator> <name>blocking</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <name>pInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>pTaskInfo</name></name> <operator>=</operator> <name>pTaskInfo</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>optrDummyOpenFn</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>OPTR_SET_OPENED</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>openCost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SOperatorFpSet</name></type> <name>createOperatorFpSet</name><parameter_list>(<parameter><decl><type><name>__optr_open_fn_t</name></type> <name>openFn</name></decl></parameter>, <parameter><decl><type><name>__optr_fn_t</name></type> <name>nextFn</name></decl></parameter>, <parameter><decl><type><name>__optr_fn_t</name></type> <name>cleanup</name></decl></parameter>,
                                   <parameter><decl><type><name>__optr_close_fn_t</name></type> <name>closeFn</name></decl></parameter>, <parameter><decl><type><name>__optr_reqBuf_fn_t</name></type> <name>reqBufFn</name></decl></parameter>,
                                   <parameter><decl><type><name>__optr_explain_fn_t</name></type> <name>explain</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SOperatorFpSet</name></type> <name>fpSet</name> <init>= <expr><block>{
      <expr><operator>.</operator><name>_openFn</name> <operator>=</operator> <name>openFn</name></expr>,
      <expr><operator>.</operator><name>getNextFn</name> <operator>=</operator> <name>nextFn</name></expr>,
      <expr><operator>.</operator><name>cleanupFn</name> <operator>=</operator> <name>cleanup</name></expr>,
      <expr><operator>.</operator><name>closeFn</name> <operator>=</operator> <name>closeFn</name></expr>,
      <expr><operator>.</operator><name>reqBufFn</name> <operator>=</operator> <name>reqBufFn</name></expr>,
      <expr><operator>.</operator><name>getExplainFn</name> <operator>=</operator> <name>explain</name></expr>,
  }</block></expr></init></decl>;</decl_stmt>

  <return>return <expr><name>fpSet</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>doCopyToSDataBlock</name><parameter_list>(<parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pSup</name></decl></parameter>, <parameter><decl><type><name>SDiskbasedBuf</name><modifier>*</modifier></type> <name>pBuf</name></decl></parameter>,
                                  <parameter><decl><type><name>SGroupResInfo</name><modifier>*</modifier></type> <name>pGroupResInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>SResultRow</name><modifier>*</modifier></type> <name>getNewResultRow</name><parameter_list>(<parameter><decl><type><name>SDiskbasedBuf</name><modifier>*</modifier></type> <name>pResultBuf</name></decl></parameter>, <parameter><decl><type><name>int32_t</name><modifier>*</modifier></type> <name>currentPageId</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>interBufSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SFilePage</name><modifier>*</modifier></type> <name>pData</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// in the first scan, new space needed for results</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>pageId</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>currentPageId</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>getNewBufPage</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pageId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SFilePage</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>getBufPage</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><operator>*</operator><name>currentPageId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pageId</name> <operator>=</operator> <operator>*</operator><name>currentPageId</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pData</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>interBufSize</name> <operator>&gt;</operator> <call><name>getBufPageSize</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="line">// release current page first, and prepare the next one</comment>
      <expr_stmt><expr><call><name>releaseBufPage</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>getNewBufPage</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pageId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>pData</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SFilePage</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>pData</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>setBufPageDirty</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// set the number of rows in current disk page</comment>
  <decl_stmt><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pResultRow</name> <init>= <expr><operator>(</operator><name>SResultRow</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pData</name> <operator>+</operator> <name><name>pData</name><operator>-&gt;</operator><name>num</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pResultRow</name><operator>-&gt;</operator><name>pageId</name></name> <operator>=</operator> <name>pageId</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pResultRow</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>pData</name><operator>-&gt;</operator><name>num</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>currentPageId</name> <operator>=</operator> <name>pageId</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>num</name></name> <operator>+=</operator> <name>interBufSize</name></expr>;</expr_stmt>
  <return>return <expr><name>pResultRow</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * the struct of key in hash table
 * +----------+---------------+
 * | group id |   key data    |
 * | 8 bytes  | actual length |
 * +----------+---------------+
 */</comment>
<function><type><name>SResultRow</name><modifier>*</modifier></type> <name>doSetResultOutBufByKey</name><parameter_list>(<parameter><decl><type><name>SDiskbasedBuf</name><modifier>*</modifier></type> <name>pResultBuf</name></decl></parameter>, <parameter><decl><type><name>SResultRowInfo</name><modifier>*</modifier></type> <name>pResultRowInfo</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>pData</name></decl></parameter>,
                                   <parameter><decl><type><name>int16_t</name></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>masterscan</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>isIntervalQuery</name></decl></parameter>, <parameter><decl><type><name>SAggSupporter</name><modifier>*</modifier></type> <name>pSup</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>SET_RES_WINDOW_KEY</name><argument_list>(<argument><expr><name><name>pSup</name><operator>-&gt;</operator><name>keyBuf</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>SResultRowPosition</name><modifier>*</modifier></type> <name>p1</name> <init>=
      <expr><operator>(</operator><name>SResultRowPosition</name><operator>*</operator><operator>)</operator><call><name>tSimpleHashGet</name><argument_list>(<argument><expr><name><name>pSup</name><operator>-&gt;</operator><name>pResultRowHashTable</name></name></expr></argument>, <argument><expr><name><name>pSup</name><operator>-&gt;</operator><name>keyBuf</name></name></expr></argument>, <argument><expr><call><name>GET_RES_WINDOW_KEY_LEN</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pResult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// in case of repeat scan/reverse scan, no new time window added.</comment>
  <if_stmt><if>if <condition>(<expr><name>isIntervalQuery</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>masterscan</name> <operator>&amp;&amp;</operator> <name>p1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="line">// the *p1 may be NULL in case of sliding+offset exists.</comment>
      <expr_stmt><expr><name>pResult</name> <operator>=</operator> <call><name>getResultRowByPos</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pResult</name><operator>-&gt;</operator><name>pageId</name></name> <operator>==</operator> <name><name>p1</name><operator>-&gt;</operator><name>pageId</name></name> <operator>&amp;&amp;</operator> <name><name>pResult</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <name><name>p1</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="line">// In case of group by column query, the required SResultRow object must be existInCurrentResusltRowInfo in the</comment>
    <comment type="line">// pResultRowInfo object.</comment>
    <if_stmt><if>if <condition>(<expr><name>p1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// todo</comment>
      <expr_stmt><expr><name>pResult</name> <operator>=</operator> <call><name>getResultRowByPos</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pResult</name><operator>-&gt;</operator><name>pageId</name></name> <operator>==</operator> <name><name>p1</name><operator>-&gt;</operator><name>pageId</name></name> <operator>&amp;&amp;</operator> <name><name>pResult</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <name><name>p1</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="line">// 1. close current opened time window</comment>
  <if_stmt><if>if <condition>(<expr><name><name>pResultRowInfo</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>pageId</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>pResult</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>pResult</name><operator>-&gt;</operator><name>pageId</name></name> <operator>!=</operator> <name><name>pResultRowInfo</name><operator>-&gt;</operator><name>cur</name><operator>.</operator><name>pageId</name></name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SResultRowPosition</name></type> <name>pos</name> <init>= <expr><name><name>pResultRowInfo</name><operator>-&gt;</operator><name>cur</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SFilePage</name><modifier>*</modifier></type>         <name>pPage</name> <init>= <expr><call><name>getBufPage</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><name><name>pos</name><operator>.</operator><name>pageId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>releaseBufPage</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// allocate a new buffer page</comment>
  <if_stmt><if>if <condition>(<expr><name>pResult</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pSup</name><operator>-&gt;</operator><name>resultRowSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pResult</name> <operator>=</operator> <call><name>getNewResultRow</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSup</name><operator>-&gt;</operator><name>currentPageId</name></name></expr></argument>, <argument><expr><name><name>pSup</name><operator>-&gt;</operator><name>resultRowSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// add a new result set for a new group</comment>
    <decl_stmt><decl><type><name>SResultRowPosition</name></type> <name>pos</name> <init>= <expr><block>{<expr><operator>.</operator><name>pageId</name> <operator>=</operator> <name><name>pResult</name><operator>-&gt;</operator><name>pageId</name></name></expr>, <expr><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>pResult</name><operator>-&gt;</operator><name>offset</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tSimpleHashPut</name><argument_list>(<argument><expr><name><name>pSup</name><operator>-&gt;</operator><name>pResultRowHashTable</name></name></expr></argument>, <argument><expr><name><name>pSup</name><operator>-&gt;</operator><name>keyBuf</name></name></expr></argument>, <argument><expr><call><name>GET_RES_WINDOW_KEY_LEN</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>,
                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SResultRowPosition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// 2. set the new time window to be the new active time window</comment>
  <expr_stmt><expr><name><name>pResultRowInfo</name><operator>-&gt;</operator><name>cur</name></name> <operator>=</operator> <operator>(</operator><name>SResultRowPosition</name><operator>)</operator><block>{<expr><operator>.</operator><name>pageId</name> <operator>=</operator> <name><name>pResult</name><operator>-&gt;</operator><name>pageId</name></name></expr>, <expr><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>pResult</name><operator>-&gt;</operator><name>offset</name></name></expr>}</block></expr>;</expr_stmt>

  <comment type="line">// too many time window in query</comment>
  <if_stmt><if>if <condition>(<expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>execModel</name></name> <operator>==</operator> <name>OPTR_EXEC_MODEL_BATCH</name> <operator>&amp;&amp;</operator>
      <call><name>tSimpleHashGetSize</name><argument_list>(<argument><expr><name><name>pSup</name><operator>-&gt;</operator><name>pResultRowHashTable</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAX_INTERVAL_TIME_WINDOW</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>T_LONG_JMP</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><name>TSDB_CODE_QRY_TOO_MANY_TIMEWINDOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pResult</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// a new buffer page for each table. Needs to opt this design</comment>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>addNewWindowResultBuf</name><parameter_list>(<parameter><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pWindowRes</name></decl></parameter>, <parameter><decl><type><name>SDiskbasedBuf</name><modifier>*</modifier></type> <name>pResultBuf</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pWindowRes</name><operator>-&gt;</operator><name>pageId</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SFilePage</name><modifier>*</modifier></type> <name>pData</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// in the first scan, new space needed for results</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>pageId</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SArray</name><modifier>*</modifier></type> <name>list</name> <init>= <expr><call><name>getDataBufPagesIdList</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>taosArrayGetSize</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>getNewBufPage</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pageId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SFilePage</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>SPageInfo</name><modifier>*</modifier></type> <name>pi</name> <init>= <expr><call><name>getLastPageInfo</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>getBufPage</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><call><name>getPageId</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pageId</name> <operator>=</operator> <call><name>getPageId</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pData</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>size</name> <operator>&gt;</operator> <call><name>getBufPageSize</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="line">// release current page first, and prepare the next one</comment>
      <expr_stmt><expr><call><name>releaseBufPageInfo</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>getNewBufPage</name><argument_list>(<argument><expr><name>pResultBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pageId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>pData</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SFilePage</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>pData</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// set the number of rows in current disk page</comment>
  <if_stmt><if>if <condition>(<expr><name><name>pWindowRes</name><operator>-&gt;</operator><name>pageId</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="line">// not allocated yet, allocate new buffer</comment>
    <expr_stmt><expr><name><name>pWindowRes</name><operator>-&gt;</operator><name>pageId</name></name> <operator>=</operator> <name>pageId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWindowRes</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>pData</name><operator>-&gt;</operator><name>num</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pData</name><operator>-&gt;</operator><name>num</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pWindowRes</name><operator>-&gt;</operator><name>pageId</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="line">//  query_range_start, query_range_end, window_duration, window_start, window_end</comment>
<function><type><name>void</name></type> <name>initExecTimeWindowInfo</name><parameter_list>(<parameter><decl><type><name>SColumnInfoData</name><modifier>*</modifier></type> <name>pColData</name></decl></parameter>, <parameter><decl><type><name>STimeWindow</name><modifier>*</modifier></type> <name>pQueryWindow</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pColData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pColData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>bytes</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>colInfoDataEnsureCapacity</name><argument_list>(<argument><expr><name>pColData</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name>pColData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pQueryWindow</name><operator>-&gt;</operator><name>skey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name>pColData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pQueryWindow</name><operator>-&gt;</operator><name>ekey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int64_t</name></type> <name>interval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name>pColData</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// this value may be variable in case of 'n' and 'y'.</comment>
  <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name>pColData</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pQueryWindow</name><operator>-&gt;</operator><name>skey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name>pColData</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pQueryWindow</name><operator>-&gt;</operator><name>ekey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>bool</name></type>    <name>hasAgg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>startOffset</name></decl>;</decl_stmt>
}</block></struct></type> <name>SFunctionCtxStatus</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>functionCtxSave</name><parameter_list>(<parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>, <parameter><decl><type><name>SFunctionCtxStatus</name><modifier>*</modifier></type> <name>pStatus</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pStatus</name><operator>-&gt;</operator><name>hasAgg</name></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>colDataSMAIsSet</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pStatus</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pStatus</name><operator>-&gt;</operator><name>startOffset</name></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>startRowIndex</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>functionCtxRestore</name><parameter_list>(<parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>, <parameter><decl><type><name>SFunctionCtxStatus</name><modifier>*</modifier></type> <name>pStatus</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>colDataSMAIsSet</name></name> <operator>=</operator> <name><name>pStatus</name><operator>-&gt;</operator><name>hasAgg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pStatus</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>startRowIndex</name></name> <operator>=</operator> <name><name>pStatus</name><operator>-&gt;</operator><name>startOffset</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>applyAggFunctionOnPartialTuples</name><parameter_list>(<parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>taskInfo</name></decl></parameter>, <parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>, <parameter><decl><type><name>SColumnInfoData</name><modifier>*</modifier></type> <name>pTimeWindowData</name></decl></parameter>,
                                     <parameter><decl><type><name>int32_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>forwardStep</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfTotal</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numOfOutput</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
    <comment type="line">// keep it temporarily</comment>
    <decl_stmt><decl><type><name>SFunctionCtxStatus</name></type> <name>status</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>functionCtxSave</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>input</name><operator>.</operator><name>startRowIndex</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>input</name><operator>.</operator><name>numOfRows</name></name> <operator>=</operator> <name>forwardStep</name></expr>;</expr_stmt>

    <comment type="line">// not a whole block involved in query processing, statistics data can not be used</comment>
    <comment type="line">// NOTE: the original value of isSet have been changed here</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>input</name><operator>.</operator><name>colDataSMAIsSet</name></name> <operator>&amp;&amp;</operator> <name>forwardStep</name> <operator>&lt;</operator> <name>numOfTotal</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>input</name><operator>.</operator><name>colDataSMAIsSet</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fmIsWindowPseudoColumnFunc</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>functionId</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>SResultRowEntryInfo</name><modifier>*</modifier></type> <name>pEntryInfo</name> <init>= <expr><call><name>GET_RES_INFO</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><call><name>GET_ROWCELL_INTERBUF</name><argument_list>(<argument><expr><name>pEntryInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>SColumnInfoData</name></type> <name>idata</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>idata</name><operator>.</operator><name>info</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>TSDB_DATA_TYPE_BIGINT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>idata</name><operator>.</operator><name>info</name><operator>.</operator><name>bytes</name></name> <operator>=</operator> <name><name>tDataTypes</name><index>[<expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>]</index></name><operator>.</operator><name>bytes</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>idata</name><operator>.</operator><name>pData</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>SScalarParam</name></type> <name>out</name> <init>= <expr><block>{<expr><operator>.</operator><name>columnData</name> <operator>=</operator> <operator>&amp;</operator><name>idata</name></expr>}</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SScalarParam</name></type> <name>tw</name> <init>= <expr><block>{<expr><operator>.</operator><name>numOfRows</name> <operator>=</operator> <literal type="number">5</literal></expr>, <expr><operator>.</operator><name>columnData</name> <operator>=</operator> <name>pTimeWindowData</name></expr>}</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><call><name><name>sfp</name><operator>.</operator><name>process</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>tw</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pEntryInfo</name><operator>-&gt;</operator><name>numOfRes</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>functionNeedToExecute</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>fpSet</name><operator>.</operator><name>process</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><call><name><name>fpSet</name><operator>.</operator><name>process</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"%s apply functions error, code: %s"</literal></expr></argument>, <argument><expr><call><name>GET_TASKID</name><argument_list>(<argument><expr><name>taskInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tstrerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>taskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>T_LONG_JMP</name><argument_list>(<argument><expr><name><name>taskInfo</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="line">// restore it</comment>
      <expr_stmt><expr><call><name>functionCtxRestore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>doSetInputDataBlockInfo</name><parameter_list>(<parameter><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pExprSup</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>order</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name> <init>= <expr><name><name>pExprSup</name><operator>-&gt;</operator><name>pCtx</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pExprSup</name><operator>-&gt;</operator><name>numOfExprs</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>order</name> <operator>=</operator> <name>order</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>input</name><operator>.</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setBlockSMAInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pExprSup</name><operator>-&gt;</operator><name>pExprInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSrcBlock</name> <operator>=</operator> <name>pBlock</name></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setInputDataBlock</name><parameter_list>(<parameter><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pExprSup</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>scanFlag</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>createDummyCol</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>pBlockAgg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>doSetInputDataBlockInfo</name><argument_list>(<argument><expr><name>pExprSup</name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name>order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>doSetInputDataBlock</name><argument_list>(<argument><expr><name>pExprSup</name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>scanFlag</name></expr></argument>, <argument><expr><name>createDummyCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doCreateConstantValColumnInfo</name><parameter_list>(<parameter><decl><type><name>SInputColumnInfoData</name><modifier>*</modifier></type> <name>pInput</name></decl></parameter>, <parameter><decl><type><name>SFunctParam</name><modifier>*</modifier></type> <name>pFuncParam</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>paramIndex</name></decl></parameter>,
                                             <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnInfoData</name><modifier>*</modifier></type> <name>pColInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pInput</name><operator>-&gt;</operator><name>pData</name><index>[<expr><name>paramIndex</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pColInfo</name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SColumnInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pColInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Set the correct column info (data type and bytes)</comment>
    <expr_stmt><expr><name><name>pColInfo</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>pFuncParam</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>nType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pColInfo</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>bytes</name></name> <operator>=</operator> <name><name>pFuncParam</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>nLen</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>pData</name><index>[<expr><name>paramIndex</name></expr>]</index></name> <operator>=</operator> <name>pColInfo</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>pColInfo</name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>pData</name><index>[<expr><name>paramIndex</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>colInfoDataEnsureCapacity</name><argument_list>(<argument><expr><name>pColInfo</name></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int8_t</name></type> <name>type</name> <init>= <expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>nType</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BIGINT</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_UBIGINT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>v</name> <init>= <expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendInt64</name><argument_list>(<argument><expr><name>pColInfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_DOUBLE</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>v</name> <init>= <expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>d</name></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppendDouble</name><argument_list>(<argument><expr><name>pColInfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_VARCHAR</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>tmp</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>nLen</name></name> <operator>+</operator> <name>VARSTR_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>STR_WITH_SIZE_TO_VARSTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>pz</name></name></expr></argument>, <argument><expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>nLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pColInfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doSetInputDataBlock</name><parameter_list>(<parameter><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pExprSup</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>scanFlag</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>createDummyCol</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>         <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name> <init>= <expr><name><name>pExprSup</name><operator>-&gt;</operator><name>pCtx</name></name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pExprSup</name><operator>-&gt;</operator><name>numOfExprs</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>order</name> <operator>=</operator> <name>order</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>input</name><operator>.</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pSrcBlock</name> <operator>=</operator> <name>pBlock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>scanFlag</name> <operator>=</operator> <name>scanFlag</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>SInputColumnInfoData</name><modifier>*</modifier></type> <name>pInput</name> <init>= <expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>input</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>uid</name></name> <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>uid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>colDataSMAIsSet</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>SExprInfo</name><modifier>*</modifier></type> <name>pOneExpr</name> <init>= <expr><operator>&amp;</operator><name><name>pExprSup</name><operator>-&gt;</operator><name>pExprInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pOneExpr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>numOfParams</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>SFunctParam</name><modifier>*</modifier></type> <name>pFuncParam</name> <init>= <expr><operator>&amp;</operator><name><name>pOneExpr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pParam</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>FUNC_PARAM_TYPE_COLUMN</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>slotId</name> <init>= <expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>pCol</name><operator>-&gt;</operator><name>slotId</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>pData</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>taosArrayGet</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>, <argument><expr><name>slotId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>totalRows</name></name> <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>startRowIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="line">// NOTE: the last parameter is the primary timestamp column</comment>
        <comment type="line">// todo: refactor this</comment>
        <if_stmt><if>if <condition>(<expr><call><name>fmIsImplicitTsFunc</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>functionId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>j</name> <operator>==</operator> <name><name>pOneExpr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>numOfParams</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>pPTS</name></name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>pData</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>  <comment type="line">// in case of merge function, this is not always the ts column data.</comment>
          <comment type="line">//          ASSERT(pInput-&gt;pPTS-&gt;info.type == TSDB_DATA_TYPE_TIMESTAMP);</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pInput</name><operator>-&gt;</operator><name>pData</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>FUNC_PARAM_TYPE_VALUE</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// todo avoid case: top(k, 12), 12 is the value parameter.</comment>
        <comment type="line">// sum(11), 11 is also the value parameter.</comment>
        <if_stmt><if>if <condition>(<expr><name>createDummyCol</name> <operator>&amp;&amp;</operator> <name><name>pOneExpr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>numOfParams</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>totalRows</name></name> <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>startRowIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

          <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>doCreateConstantValColumnInfo</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>pFuncParam</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>code</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doAggregateImpl</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name><operator>.</operator><name>numOfExprs</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>functionNeedToExecute</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="line">// todo add a dummy funtion to avoid process check</comment>
      <if_stmt><if>if <condition>(<expr><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>fpSet</name><operator>.</operator><name>process</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><call><name><name>fpSet</name><operator>.</operator><name>process</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"%s aggregate function error happens, code: %s"</literal></expr></argument>, <argument><expr><call><name>GET_TASKID</name><argument_list>(<argument><expr><name><name>pOperator</name><operator>-&gt;</operator><name>pTaskInfo</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tstrerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>code</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>functionNeedToExecute</name><parameter_list>(<parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>SResultRowEntryInfo</name></name><modifier>*</modifier></type> <name>pResInfo</name> <init>= <expr><call><name>GET_RES_INFO</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// in case of timestamp column, always generated results.</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>functionId</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>functionId</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>functionId</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pCtx</name><operator>-&gt;</operator><name>scanFlag</name></name> <operator>==</operator> <name>REPEAT_SCAN</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>fmIsRepeatScanFunc</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>functionId</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isRowEntryCompleted</name><argument_list>(<argument><expr><name>pResInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doCreateConstantValColumnAggInfo</name><parameter_list>(<parameter><decl><type><name>SInputColumnInfoData</name><modifier>*</modifier></type> <name>pInput</name></decl></parameter>, <parameter><decl><type><name>SFunctParam</name><modifier>*</modifier></type> <name>pFuncParam</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>type</name></decl></parameter>,
                                                <parameter><decl><type><name>int32_t</name></type> <name>paramIndex</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pInput</name><operator>-&gt;</operator><name>pData</name><index>[<expr><name>paramIndex</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>pData</name><index>[<expr><name>paramIndex</name></expr>]</index></name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SColumnInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pInput</name><operator>-&gt;</operator><name>pData</name><index>[<expr><name>paramIndex</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Set the correct column info (data type and bytes)</comment>
    <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>pData</name><index>[<expr><name>paramIndex</name></expr>]</index></name><operator>-&gt;</operator><name><name>info</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>pData</name><index>[<expr><name>paramIndex</name></expr>]</index></name><operator>-&gt;</operator><name><name>info</name><operator>.</operator><name>bytes</name></name> <operator>=</operator> <name><name>tDataTypes</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>bytes</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SColumnDataAgg</name><modifier>*</modifier></type> <name>da</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pInput</name><operator>-&gt;</operator><name>pColumnDataAgg</name><index>[<expr><name>paramIndex</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>da</name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SColumnDataAgg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>pColumnDataAgg</name><index>[<expr><name>paramIndex</name></expr>]</index></name> <operator>=</operator> <name>da</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>da</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>da</name> <operator>=</operator> <name><name>pInput</name><operator>-&gt;</operator><name>pColumnDataAgg</name><index>[<expr><name>paramIndex</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_VAR_DATA_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BIGINT</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>v</name> <init>= <expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>da</name> <operator>=</operator> <operator>(</operator><name>SColumnDataAgg</name><operator>)</operator><block>{<expr><operator>.</operator><name>numOfNull</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>min</name> <operator>=</operator> <name>v</name></expr>, <expr><operator>.</operator><name>max</name> <operator>=</operator> <name>v</name></expr>, <expr><operator>.</operator><name>sum</name> <operator>=</operator> <name>v</name> <operator>*</operator> <name>numOfRows</name></expr>}</block></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_DOUBLE</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>v</name> <init>= <expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>d</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>da</name> <operator>=</operator> <operator>(</operator><name>SColumnDataAgg</name><operator>)</operator><block>{<expr><operator>.</operator><name>numOfNull</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>da</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>da</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>da</name><operator>-&gt;</operator><name>sum</name></name> <operator>=</operator> <name>v</name> <operator>*</operator> <name>numOfRows</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name></expr>)</condition> <block>{<block_content>  <comment type="line">// todo validate this data type</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>v</name> <init>= <expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>i</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>da</name> <operator>=</operator> <operator>(</operator><name>SColumnDataAgg</name><operator>)</operator><block>{<expr><operator>.</operator><name>numOfNull</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>da</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>da</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>da</name><operator>-&gt;</operator><name>sum</name></name> <operator>=</operator> <name>v</name> <operator>*</operator> <name>numOfRows</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>)</condition> <block>{<block_content>
    <comment type="line">// do nothing</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setBlockSMAInfo</name><parameter_list>(<parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>, <parameter><decl><type><name>SExprInfo</name><modifier>*</modifier></type> <name>pExprInfo</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfRows</name> <init>= <expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SInputColumnInfoData</name><modifier>*</modifier></type> <name>pInput</name> <init>= <expr><operator>&amp;</operator><name><name>pCtx</name><operator>-&gt;</operator><name>input</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name>numOfRows</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>totalRows</name></name> <operator>=</operator> <name>numOfRows</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>pBlockAgg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>colDataSMAIsSet</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pExprInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>numOfParams</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>SFunctParam</name><modifier>*</modifier></type> <name>pFuncParam</name> <init>= <expr><operator>&amp;</operator><name><name>pExprInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pParam</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>FUNC_PARAM_TYPE_COLUMN</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>slotId</name> <init>= <expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>pCol</name><operator>-&gt;</operator><name>slotId</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>pColumnDataAgg</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>pBlockAgg</name><index>[<expr><name>slotId</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pInput</name><operator>-&gt;</operator><name>pColumnDataAgg</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>colDataSMAIsSet</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Here we set the column info data since the data type for each column data is required, but</comment>
        <comment type="line">// the data in the corresponding SColumnInfoData will not be used.</comment>
        <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>pData</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>taosArrayGet</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>, <argument><expr><name>slotId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>FUNC_PARAM_TYPE_VALUE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>doCreateConstantValColumnAggInfo</name><argument_list>(<argument><expr><name>pInput</name></expr></argument>, <argument><expr><name>pFuncParam</name></expr></argument>, <argument><expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>nType</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>pInput</name><operator>-&gt;</operator><name>colDataSMAIsSet</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>isTaskKilled</name><parameter_list>(<parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><operator>(</operator><literal type="number">0</literal> <operator>!=</operator> <name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setTaskKilled</name><parameter_list>(<parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>rspCode</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>rspCode</name></expr>;</expr_stmt> </block_content>}</block></function>

<comment type="line" format="doxygen">/////////////////////////////////////////////////////////////////////////////////////////////</comment>
<function><type><name>STimeWindow</name></type> <name>getAlignQueryTimeWindow</name><parameter_list>(<parameter><decl><type><name>SInterval</name><modifier>*</modifier></type> <name>pInterval</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>precision</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>STimeWindow</name></type> <name>win</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>win</name><operator>.</operator><name>skey</name></name> <operator>=</operator> <call><name>taosTimeTruncate</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>pInterval</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * if the realSkey &gt; INT64_MAX - pInterval-&gt;interval, the query duration between
   * realSkey and realEkey must be less than one interval.Therefore, no need to adjust the query ranges.
   */</comment>
  <expr_stmt><expr><name><name>win</name><operator>.</operator><name>ekey</name></name> <operator>=</operator> <call><name>taosTimeAdd</name><argument_list>(<argument><expr><name><name>win</name><operator>.</operator><name>skey</name></name></expr></argument>, <argument><expr><name><name>pInterval</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>, <argument><expr><name><name>pInterval</name><operator>-&gt;</operator><name>intervalUnit</name></name></expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>win</name><operator>.</operator><name>ekey</name></name> <operator>&lt;</operator> <name><name>win</name><operator>.</operator><name>skey</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>win</name><operator>.</operator><name>ekey</name></name> <operator>=</operator> <name>INT64_MAX</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>win</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>loadDataBlockOnDemand</name><parameter_list>(<parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>, <parameter><decl><type><name>STableScanInfo</name><modifier>*</modifier></type> <name>pTableScanInfo</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>,
                              <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>BLK_DATA_NOT_LOAD</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pBlockAgg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <comment type="line">//  int64_t groupId = pRuntimeEnv-&gt;current-&gt;groupIndex;</comment>
  <comment type="line">//  bool    ascQuery = QUERY_IS_ASC_QUERY(pQueryAttr);</comment>

  <decl_stmt><decl><type><name>STaskCostInfo</name><modifier>*</modifier></type> <name>pCost</name> <init>= <expr><operator>&amp;</operator><name><name>pTaskInfo</name><operator>-&gt;</operator><name>cost</name></name></expr></init></decl>;</decl_stmt>

<comment type="line">//  pCost-&gt;totalBlocks += 1;</comment>
<comment type="line">//  pCost-&gt;totalRows += pBlock-&gt;info.rows;</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  <comment type="line">// Calculate all time windows that are overlapping or contain current data block.</comment>
  <comment type="line">// If current data block is contained by all possible time window, do not load current data block.</comment>
  if (<comment type="block">/*pQueryAttr-&gt;pFilters || */</comment>pQueryAttr-&gt;groupbyColumn || pQueryAttr-&gt;sw.gap &gt; 0 ||
      (QUERY_IS_INTERVAL_QUERY(pQueryAttr) &amp;&amp; overlapWithTimeWindow(pTaskInfo, &amp;pBlock-&gt;info))) {
    (*status) = BLK_DATA_DATA_LOAD;
  }

  <comment type="line">// check if this data block is required to load</comment>
  if ((*status) != BLK_DATA_DATA_LOAD) {
    bool needFilter = true;

    <comment type="line">// the pCtx[i] result is belonged to previous time window since the outputBuf has not been set yet,</comment>
    <comment type="line">// the filter result may be incorrect. So in case of interval query, we need to set the correct time output buffer</comment>
    if (QUERY_IS_INTERVAL_QUERY(pQueryAttr)) {
      SResultRow* pResult = NULL;

      bool  masterScan = IS_MAIN_SCAN(pRuntimeEnv);
      TSKEY k = ascQuery? pBlock-&gt;info.window.skey : pBlock-&gt;info.window.ekey;

      STimeWindow win = getActiveTimeWindow(pTableScanInfo-&gt;pResultRowInfo, k, pQueryAttr);
      if (pQueryAttr-&gt;pointInterpQuery) {
        needFilter = chkWindowOutputBufByKey(pRuntimeEnv, pTableScanInfo-&gt;pResultRowInfo, &amp;win, masterScan, &amp;pResult, groupId,
                                    pTableScanInfo-&gt;pCtx, pTableScanInfo-&gt;numOfOutput,
                                    pTableScanInfo-&gt;rowEntryInfoOffset);
      } else {
        if (setResultOutputBufByKey(pRuntimeEnv, pTableScanInfo-&gt;pResultRowInfo, pBlock-&gt;info.id.uid, &amp;win, masterScan, &amp;pResult, groupId,
                                    pTableScanInfo-&gt;pCtx, pTableScanInfo-&gt;numOfOutput,
                                    pTableScanInfo-&gt;rowEntryInfoOffset) != TSDB_CODE_SUCCESS) {
          T_LONG_JMP(pRuntimeEnv-&gt;env, TSDB_CODE_OUT_OF_MEMORY);
        }
      }
    } else if (pQueryAttr-&gt;stableQuery &amp;&amp; (!pQueryAttr-&gt;tsCompQuery) &amp;&amp; (!pQueryAttr-&gt;diffQuery)) { <comment type="line">// stable aggregate, not interval aggregate or normal column aggregate</comment>
      doSetTableGroupOutputBuf(pRuntimeEnv, pTableScanInfo-&gt;pResultRowInfo, pTableScanInfo-&gt;pCtx,
                               pTableScanInfo-&gt;rowEntryInfoOffset, pTableScanInfo-&gt;numOfOutput,
                               pRuntimeEnv-&gt;current-&gt;groupIndex);
    }

    if (needFilter) {
      (*status) = doFilterByBlockTimeWindow(pTableScanInfo, pBlock);
    } else {
      (*status) = BLK_DATA_DATA_LOAD;
    }
  }

  SDataBlockInfo* pBlockInfo = &amp;pBlock-&gt;info;
<comment type="line">//  *status = updateBlockLoadStatus(pRuntimeEnv-&gt;pQueryAttr, *status);</comment>

  if ((*status) == BLK_DATA_NOT_LOAD || (*status) == BLK_DATA_FILTEROUT) {
    <comment type="line">//qDebug("QInfo:0x%"PRIx64" data block discard, brange:%" PRId64 "-%" PRId64 ", rows:%d", pQInfo-&gt;qId, pBlockInfo-&gt;window.skey,</comment>
<comment type="line">//           pBlockInfo-&gt;window.ekey, pBlockInfo-&gt;rows);</comment>
    pCost-&gt;skipBlocks += 1;
  } else if ((*status) == BLK_DATA_SMA_LOAD) {
    <comment type="line">// this function never returns error?</comment>
    pCost-&gt;loadBlockStatis += 1;
<comment type="line">//    tsdbRetrieveDatablockSMA(pTableScanInfo-&gt;pTsdbReadHandle, &amp;pBlock-&gt;pBlockAgg);</comment>

    if (pBlock-&gt;pBlockAgg == NULL) {  <comment type="line">// data block statistics does not exist, load data block</comment>
<comment type="line">//      pBlock-&gt;pDataBlock = tsdbRetrieveDataBlock(pTableScanInfo-&gt;pTsdbReadHandle, NULL);</comment>
      pCost-&gt;totalCheckedRows += pBlock-&gt;info.rows;
    }
  } else {
    assert((*status) == BLK_DATA_DATA_LOAD);

    <comment type="line">// load the data block statistics to perform further filter</comment>
    pCost-&gt;loadBlockStatis += 1;
<comment type="line">//    tsdbRetrieveDatablockSMA(pTableScanInfo-&gt;pTsdbReadHandle, &amp;pBlock-&gt;pBlockAgg);</comment>

    if (pQueryAttr-&gt;topBotQuery &amp;&amp; pBlock-&gt;pBlockAgg != NULL) {
      { <comment type="line">// set previous window</comment>
        if (QUERY_IS_INTERVAL_QUERY(pQueryAttr)) {
          SResultRow* pResult = NULL;

          bool  masterScan = IS_MAIN_SCAN(pRuntimeEnv);
          TSKEY k = ascQuery? pBlock-&gt;info.window.skey : pBlock-&gt;info.window.ekey;

          STimeWindow win = getActiveTimeWindow(pTableScanInfo-&gt;pResultRowInfo, k, pQueryAttr);
          if (setResultOutputBufByKey(pRuntimeEnv, pTableScanInfo-&gt;pResultRowInfo, pBlock-&gt;info.id.uid, &amp;win, masterScan, &amp;pResult, groupId,
                                      pTableScanInfo-&gt;pCtx, pTableScanInfo-&gt;numOfOutput,
                                      pTableScanInfo-&gt;rowEntryInfoOffset) != TSDB_CODE_SUCCESS) {
            T_LONG_JMP(pRuntimeEnv-&gt;env, TSDB_CODE_OUT_OF_MEMORY);
          }
        }
      }
      bool load = false;
      for (int32_t i = 0; i &lt; pQueryAttr-&gt;numOfOutput; ++i) {
        int32_t functionId = pTableScanInfo-&gt;pCtx[i].functionId;
        if (functionId == FUNCTION_TOP || functionId == FUNCTION_BOTTOM) {
<comment type="line">//          load = topbot_datablock_filter(&amp;pTableScanInfo-&gt;pCtx[i], (char*)&amp;(pBlock-&gt;pBlockAgg[i].min),</comment>
<comment type="line">//                                         (char*)&amp;(pBlock-&gt;pBlockAgg[i].max));</comment>
          if (!load) { <comment type="line">// current block has been discard due to filter applied</comment>
            pCost-&gt;skipBlocks += 1;
            <comment type="line">//qDebug("QInfo:0x%"PRIx64" data block discard, brange:%" PRId64 "-%" PRId64 ", rows:%d", pQInfo-&gt;qId,</comment>
<comment type="line">//                   pBlockInfo-&gt;window.skey, pBlockInfo-&gt;window.ekey, pBlockInfo-&gt;rows);</comment>
            (*status) = BLK_DATA_FILTEROUT;
            return TSDB_CODE_SUCCESS;
          }
        }
      }
    }

    <comment type="line">// current block has been discard due to filter applied</comment>
<comment type="line">//    if (!doFilterByBlockSMA(pRuntimeEnv, pBlock-&gt;pBlockAgg, pTableScanInfo-&gt;pCtx, pBlockInfo-&gt;rows)) {</comment>
<comment type="line">//      pCost-&gt;skipBlocks += 1;</comment>
<comment type="line">//      qDebug("QInfo:0x%"PRIx64" data block discard, brange:%" PRId64 "-%" PRId64 ", rows:%d", pQInfo-&gt;qId, pBlockInfo-&gt;window.skey,</comment>
<comment type="line">//             pBlockInfo-&gt;window.ekey, pBlockInfo-&gt;rows);</comment>
<comment type="line">//      (*status) = BLK_DATA_FILTEROUT;</comment>
<comment type="line">//      return TSDB_CODE_SUCCESS;</comment>
<comment type="line">//    }</comment>

    pCost-&gt;totalCheckedRows += pBlockInfo-&gt;rows;
    pCost-&gt;loadBlocks += 1;
<comment type="line">//    pBlock-&gt;pDataBlock = tsdbRetrieveDataBlock(pTableScanInfo-&gt;pTsdbReadHandle, NULL);</comment>
<comment type="line">//    if (pBlock-&gt;pDataBlock == NULL) {</comment>
<comment type="line">//      return terrno;</comment>
<comment type="line">//    }</comment>

<comment type="line">//    if (pQueryAttr-&gt;pFilters != NULL) {</comment>
<comment type="line">//      filterSetColFieldData(pQueryAttr-&gt;pFilters, taosArrayGetSize(pBlock-&gt;pDataBlock), pBlock-&gt;pDataBlock);</comment>
<comment type="line">//    }</comment>

<comment type="line">//    if (pQueryAttr-&gt;pFilters != NULL || pRuntimeEnv-&gt;pTsBuf != NULL) {</comment>
<comment type="line">//      filterColRowsInDataBlock(pRuntimeEnv, pBlock, ascQuery);</comment>
<comment type="line">//    }</comment>
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setTaskStatus</name><parameter_list>(<parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>TASK_NOT_COMPLETED</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="line">// QUERY_NOT_COMPLETED is not compatible with any other status, so clear its position first</comment>
    <expr_stmt><expr><call><name>CLEAR_QUERY_STATUS</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>, <argument><expr><name>TASK_NOT_COMPLETED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>status</name></name> <operator>|=</operator> <name>status</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setResultRowInitCtx</name><parameter_list>(<parameter><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pResult</name></decl></parameter>, <parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfOutput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name><modifier>*</modifier></type> <name>rowEntryInfoOffset</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>init</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfOutput</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resultInfo</name> <operator>=</operator> <call><name>getResultEntryInfo</name><argument_list>(<argument><expr><name>pResult</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>rowEntryInfoOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>init</name></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name><name>struct</name> <name>SResultRowEntryInfo</name></name><modifier>*</modifier></type> <name>pResInfo</name> <init>= <expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resultInfo</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isRowEntryCompleted</name><argument_list>(<argument><expr><name>pResInfo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isRowEntryInitialized</name><argument_list>(<argument><expr><name>pResInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fmIsWindowPseudoColumnFunc</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>functionId</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pResInfo</name><operator>-&gt;</operator><name>initialized</name></name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>functionId</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name><name>fpSet</name><operator>.</operator><name>init</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pResInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>pResInfo</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>init</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>doFilter</name><parameter_list>(<parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><name>SFilterInfo</name><modifier>*</modifier></type> <name>pFilterInfo</name></decl></parameter>, <parameter><decl><type><name>SColMatchInfo</name><modifier>*</modifier></type> <name>pColMatchInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>pFilterInfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SFilterColumnParam</name></type> <name>param1</name> <init>= <expr><block>{<expr><operator>.</operator><name>numOfCols</name> <operator>=</operator> <call><name>taosArrayGetSize</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>)</argument_list></call></expr>, <expr><operator>.</operator><name>pDataBlock</name> <operator>=</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>            <name>code</name> <init>= <expr><call><name>filterSetDataFromSlotId</name><argument_list>(<argument><expr><name>pFilterInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SColumnInfoData</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>          <name>status</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="line">// todo the keep seems never to be True??</comment>
  <decl_stmt><decl><type><name>bool</name></type> <name>keep</name> <init>= <expr><call><name>filterExecute</name><argument_list>(<argument><expr><name>pFilterInfo</name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>param1</name><operator>.</operator><name>numOfCols</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>extractQualifiedTupleByFilterResult</name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>keep</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>pColMatchInfo</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>taosArrayGetSize</name><argument_list>(<argument><expr><name><name>pColMatchInfo</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>SColMatchItem</name><modifier>*</modifier></type> <name>pInfo</name> <init>= <expr><call><name>taosArrayGet</name><argument_list>(<argument><expr><name><name>pColMatchInfo</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pInfo</name><operator>-&gt;</operator><name>colId</name></name> <operator>==</operator> <name>PRIMARYKEY_TIMESTAMP_COL_ID</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>SColumnInfoData</name><modifier>*</modifier></type> <name>pColData</name> <init>= <expr><call><name>taosArrayGet</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>dstSlotId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pColData</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>blockDataUpdateTsWindow</name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>dstSlotId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>colDataDestroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>extractQualifiedTupleByFilterResult</name><parameter_list>(<parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SColumnInfoData</name><modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keep</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>keep</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>totalRows</name> <init>= <expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>FILTER_RESULT_ALL_QUALIFIED</name></expr>)</condition> <block>{<block_content>
    <comment type="line">// here nothing needs to be done</comment>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>status</name> <operator>==</operator> <name>FILTER_RESULT_NONE_QUALIFIED</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>px</name> <init>= <expr><call><name>createOneDataBlock</name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>numOfCols</name> <init>= <expr><call><name>taosArrayGetSize</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfCols</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>SColumnInfoData</name><modifier>*</modifier></type> <name>pSrc</name> <init>= <expr><call><name>taosArrayGet</name><argument_list>(<argument><expr><name><name>px</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SColumnInfoData</name><modifier>*</modifier></type> <name>pDst</name> <init>= <expr><call><name>taosArrayGet</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// it is a reserved column for scalar function, and no data in this column yet.</comment>
      <if_stmt><if>if <condition>(<expr><name><name>pDst</name><operator>-&gt;</operator><name>pData</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pSrc</name><operator>-&gt;</operator><name>pData</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>colInfoDataCleanup</name><argument_list>(<argument><expr><name>pDst</name></expr></argument>, <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfRows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>totalRows</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>int8_t</name><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pData</name></name><operator>)</operator><index>[<expr><name>j</name></expr>]</index> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>colDataIsNull_s</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppendNULL</name><argument_list>(<argument><expr><name>pDst</name></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pDst</name></expr></argument>, <argument><expr><name>numOfRows</name></expr></argument>, <argument><expr><call><name>colDataGetData</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>numOfRows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></for>

      <comment type="line">// todo this value can be assigned directly</comment>
      <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>==</operator> <name>totalRows</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>numOfRows</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>==</operator> <name>numOfRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>blockDataDestroy</name><argument_list>(<argument><expr><name>px</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// fix memory leak</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>doSetTableGroupOutputBuf</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfOutput</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>groupId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// for simple group by query without interval, all the tables belong to one group result.</comment>
  <decl_stmt><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type>    <name>pTaskInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>pTaskInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SAggOperatorInfo</name><modifier>*</modifier></type> <name>pAggInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SResultRowInfo</name><modifier>*</modifier></type> <name>pResultRowInfo</name> <init>= <expr><operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>binfo</name><operator>.</operator><name>resultRowInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name><operator>.</operator><name>pCtx</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name><modifier>*</modifier></type>        <name>rowEntryInfoOffset</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name><operator>.</operator><name>rowEntryInfoOffset</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pResultRow</name> <init>= <expr><call><name>doSetResultOutBufByKey</name><argument_list>(<argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aggSup</name><operator>.</operator><name>pResultBuf</name></name></expr></argument>, <argument><expr><name>pResultRowInfo</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>groupId</name></expr></argument>,
                                                  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>aggSup</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pResultRow</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * not assign result buffer yet, add new result buffer
   * all group belong to one result set, and each group result has different group id so set the id to be one
   */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>pResultRow</name><operator>-&gt;</operator><name>pageId</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>=
        <expr><call><name>addNewWindowResultBuf</name><argument_list>(<argument><expr><name>pResultRow</name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aggSup</name><operator>.</operator><name>pResultBuf</name></name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>binfo</name><operator>.</operator><name>pRes</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rowSize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>setResultRowInitCtx</name><argument_list>(<argument><expr><name>pResultRow</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>numOfOutput</name></expr></argument>, <argument><expr><name>rowEntryInfoOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setExecutionContext</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfOutput</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>groupId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SAggOperatorInfo</name><modifier>*</modifier></type> <name>pAggInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>UINT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>pAggInfo</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>groupId</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>doSetTableGroupOutputBuf</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>, <argument><expr><name>numOfOutput</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// record the current active group id</comment>
  <expr_stmt><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name>groupId</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>doUpdateNumOfRows</name><parameter_list>(<parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>, <parameter><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pRow</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfExprs</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>int32_t</name><modifier>*</modifier></type> <name>rowEntryOffset</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>returnNotNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numOfExprs</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SResultRowEntryInfo</name><modifier>*</modifier></type> <name>pResInfo</name> <init>= <expr><call><name>getResultEntryInfo</name><argument_list>(<argument><expr><name>pRow</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>rowEntryOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isRowEntryInitialized</name><argument_list>(<argument><expr><name>pResInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&lt;</operator> <name><name>pResInfo</name><operator>-&gt;</operator><name>numOfRes</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>pResInfo</name><operator>-&gt;</operator><name>numOfRes</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fmIsNotNullOutputFunc</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>functionId</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>returnNotNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <comment type="line">// if all expr skips all blocks, e.g. all null inputs for max function, output one row in final result.</comment>
  <comment type="line">//  except for first/last, which require not null output, output no rows</comment>
  <if_stmt><if>if <condition>(<expr><name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>returnNotNull</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>doCopyResultToDataBlock</name><parameter_list>(<parameter><decl><type><name>SExprInfo</name><modifier>*</modifier></type> <name>pExprInfo</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfExprs</name></decl></parameter>, <parameter><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pRow</name></decl></parameter>, <parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>,
                                    <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int32_t</name><modifier>*</modifier></type> <name>rowEntryOffset</name></decl></parameter>, <parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numOfExprs</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>slotId</name> <init>= <expr><name><name>pExprInfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>base</name><operator>.</operator><name>resSchema</name><operator>.</operator><name>slotId</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>resultInfo</name> <operator>=</operator> <call><name>getResultEntryInfo</name><argument_list>(<argument><expr><name>pRow</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>rowEntryOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>fpSet</name><operator>.</operator><name>finalize</name></name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>_function</name><operator>.</operator><name>functionName</name></name></expr></argument>, <argument><expr><literal type="string">"_group_key"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// for groupkey along with functions that output multiple lines(e.g. Histogram)</comment>
        <comment type="line">// need to match groupkey result for each output row of that function.</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>resultInfo</name><operator>-&gt;</operator><name>numOfRes</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>resultInfo</name><operator>-&gt;</operator><name>numOfRes</name></name> <operator>=</operator> <name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><call><name><name>fpSet</name><operator>.</operator><name>finalize</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>TAOS_FAILED</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"%s build result data block error, code %s"</literal></expr></argument>, <argument><expr><call><name>GET_TASKID</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tstrerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>T_LONG_JMP</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>_function</name><operator>.</operator><name>functionName</name></name></expr></argument>, <argument><expr><literal type="string">"_select_value"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// do nothing</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="line">// expand the result into multiple rows. E.g., _wstart, top(k, 20)</comment>
      <comment type="line">// the _wstart needs to copy to 20 following rows, since the results of top-k expands to 20 different rows.</comment>
      <decl_stmt><decl><type><name>SColumnInfoData</name><modifier>*</modifier></type> <name>pColInfoData</name> <init>= <expr><call><name>taosArrayGet</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>, <argument><expr><name>slotId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>            <name>in</name> <init>= <expr><call><name>GET_ROWCELL_INTERBUF</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>resultInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pColInfoData</name></expr></argument>, <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>+</operator> <name>k</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>resultInfo</name><operator>-&gt;</operator><name>isNullRes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// todo refactor. SResultRow has direct pointer in miainfo</comment>
<function><type><name>int32_t</name></type> <name>finalizeResultRows</name><parameter_list>(<parameter><decl><type><name>SDiskbasedBuf</name><modifier>*</modifier></type> <name>pBuf</name></decl></parameter>, <parameter><decl><type><name>SResultRowPosition</name><modifier>*</modifier></type> <name>resultRowPosition</name></decl></parameter>, <parameter><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pSup</name></decl></parameter>,
                           <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SFilePage</name><modifier>*</modifier></type>  <name>page</name> <init>= <expr><call><name>getBufPage</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name><name>resultRowPosition</name><operator>-&gt;</operator><name>pageId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pRow</name> <init>= <expr><operator>(</operator><name>SResultRow</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page</name> <operator>+</operator> <name><name>resultRowPosition</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>pCtx</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SExprInfo</name><modifier>*</modifier></type>      <name>pExprInfo</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>pExprInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int32_t</name><modifier>*</modifier></type>  <name>rowEntryOffset</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>rowEntryInfoOffset</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>doUpdateNumOfRows</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>, <argument><expr><name><name>pSup</name><operator>-&gt;</operator><name>numOfExprs</name></name></expr></argument>, <argument><expr><name>rowEntryOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>releaseBufPage</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>size</name> <init>= <expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>capacity</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>+</operator> <name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&gt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <name>size</name> <operator>*</operator> <literal type="number">1.25</literal></expr>;</expr_stmt>
  </block_content>}</block></while>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>blockDataEnsureCapacity</name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>TAOS_FAILED</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>releaseBufPage</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"%s ensure result data capacity failed, code %s"</literal></expr></argument>, <argument><expr><call><name>GET_TASKID</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tstrerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>T_LONG_JMP</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>doCopyResultToDataBlock</name><argument_list>(<argument><expr><name>pExprInfo</name></expr></argument>, <argument><expr><name><name>pSup</name><operator>-&gt;</operator><name>numOfExprs</name></name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name>rowEntryOffset</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>releaseBufPage</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>doCopyToSDataBlock</name><parameter_list>(<parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pSup</name></decl></parameter>, <parameter><decl><type><name>SDiskbasedBuf</name><modifier>*</modifier></type> <name>pBuf</name></decl></parameter>,
                           <parameter><decl><type><name>SGroupResInfo</name><modifier>*</modifier></type> <name>pGroupResInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExprInfo</name><modifier>*</modifier></type>      <name>pExprInfo</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>pExprInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>         <name>numOfExprs</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>numOfExprs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name><modifier>*</modifier></type>        <name>rowEntryOffset</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>rowEntryInfoOffset</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>pCtx</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfRows</name> <init>= <expr><call><name>getNumOfTotalRes</name><argument_list>(<argument><expr><name>pGroupResInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SResKeyPos</name><modifier>*</modifier></type> <name>pPos</name> <init>= <expr><call><name>taosArrayGetP</name><argument_list>(<argument><expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>pRows</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SFilePage</name><modifier>*</modifier></type>  <name>page</name> <init>= <expr><call><name>getBufPage</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name><name>pPos</name><operator>-&gt;</operator><name>pos</name><operator>.</operator><name>pageId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pRow</name> <init>= <expr><operator>(</operator><name>SResultRow</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page</name> <operator>+</operator> <name><name>pPos</name><operator>-&gt;</operator><name>pos</name><operator>.</operator><name>offset</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>doUpdateNumOfRows</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>, <argument><expr><name>numOfExprs</name></expr></argument>, <argument><expr><name>rowEntryOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// no results, continue to check the next one</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>index</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releaseBufPage</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <name><name>pPos</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="line">// current value belongs to different group, it can't be packed into one datablock</comment>
      <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>!=</operator> <name><name>pPos</name><operator>-&gt;</operator><name>groupId</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>releaseBufPage</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>+</operator> <name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&gt;</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>capacity</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releaseBufPage</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>index</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>doCopyResultToDataBlock</name><argument_list>(<argument><expr><name>pExprInfo</name></expr></argument>, <argument><expr><name>numOfExprs</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name>rowEntryOffset</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>releaseBufPage</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>qDebug</name><argument_list>(<argument><expr><literal type="string">"%s result generated, rows:%d, groupId:%"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><call><name>GET_TASKID</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr></argument>,
         <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>blockDataUpdateTsWindow</name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>doBuildStreamResBlock</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><name>SOptrBasicInfo</name><modifier>*</modifier></type> <name>pbInfo</name></decl></parameter>, <parameter><decl><type><name>SGroupResInfo</name><modifier>*</modifier></type> <name>pGroupResInfo</name></decl></parameter>,
                           <parameter><decl><type><name>SDiskbasedBuf</name><modifier>*</modifier></type> <name>pBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>pTaskInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SSDataBlock</name><modifier>*</modifier></type>   <name>pBlock</name> <init>= <expr><name><name>pbInfo</name><operator>-&gt;</operator><name>pRes</name></name></expr></init></decl>;</decl_stmt>

  <comment type="line">// set output datablock version</comment>
  <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name><name>pTaskInfo</name><operator>-&gt;</operator><name>version</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>blockDataCleanup</name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasRemainResults</name><argument_list>(<argument><expr><name>pGroupResInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// clear the existed group id</comment>
  <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>pbInfo</name><operator>-&gt;</operator><name>mergeResultBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>doCopyToSDataBlock</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>pGroupResInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>tbname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>streamStateGetParName</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>streamInfo</name><operator>.</operator><name>pState</name></name></expr></argument>, <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tbname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>parTbName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>parTbName</name></name></expr></argument>, <argument><expr><name>tbname</name></expr></argument>, <argument><expr><name>TSDB_TABLE_NAME_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>tdbFree</name><argument_list>(<argument><expr><name>tbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>doBuildResultDatablock</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><name>SOptrBasicInfo</name><modifier>*</modifier></type> <name>pbInfo</name></decl></parameter>, <parameter><decl><type><name>SGroupResInfo</name><modifier>*</modifier></type> <name>pGroupResInfo</name></decl></parameter>,
                            <parameter><decl><type><name>SDiskbasedBuf</name><modifier>*</modifier></type> <name>pBuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>pTaskInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SSDataBlock</name><modifier>*</modifier></type>   <name>pBlock</name> <init>= <expr><name><name>pbInfo</name><operator>-&gt;</operator><name>pRes</name></name></expr></init></decl>;</decl_stmt>

  <comment type="line">// set output datablock version</comment>
  <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name><name>pTaskInfo</name><operator>-&gt;</operator><name>version</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>blockDataCleanup</name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasRemainResults</name><argument_list>(<argument><expr><name>pGroupResInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// clear the existed group id</comment>
  <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pbInfo</name><operator>-&gt;</operator><name>mergeResultBlock</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>doCopyToSDataBlock</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>pGroupResInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <while>while <condition>(<expr><call><name>hasRemainResults</name><argument_list>(<argument><expr><name>pGroupResInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>doCopyToSDataBlock</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>pGroupResInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>&gt;=</operator> <name><name>pOperator</name><operator>-&gt;</operator><name>resultInfo</name><operator>.</operator><name>threshold</name></name></expr>)</condition> <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>

      <comment type="line">// clearing group id to continue to merge data that belong to different groups</comment>
      <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="line">// clear the group id info in SSDataBlock, since the client does not need it</comment>
    <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// static TSKEY doSkipIntervalProcess(STaskRuntimeEnv* pRuntimeEnv, STimeWindow* win, SDataBlockInfo* pBlockInfo,</comment>
<comment type="line">// STableQueryInfo* pTableQueryInfo) {</comment>
<comment type="line">//   STaskAttr *pQueryAttr = pRuntimeEnv-&gt;pQueryAttr;</comment>
<comment type="line">//   SResultRowInfo *pWindowResInfo = &amp;pRuntimeEnv-&gt;resultRowInfo;</comment>
<comment type="line">//</comment>
<comment type="line">//   assert(pQueryAttr-&gt;limit.offset == 0);</comment>
<comment type="line">//   STimeWindow tw = *win;</comment>
<comment type="line">//   getNextTimeWindow(pQueryAttr, &amp;tw);</comment>
<comment type="line">//</comment>
<comment type="line">//   if ((tw.skey &lt;= pBlockInfo-&gt;window.ekey &amp;&amp; QUERY_IS_ASC_QUERY(pQueryAttr)) ||</comment>
<comment type="line">//       (tw.ekey &gt;= pBlockInfo-&gt;window.skey &amp;&amp; !QUERY_IS_ASC_QUERY(pQueryAttr))) {</comment>
<comment type="line">//</comment>
<comment type="line">//     // load the data block and check data remaining in current data block</comment>
<comment type="line">//     // TODO optimize performance</comment>
<comment type="line">//     SArray *         pDataBlock = tsdbRetrieveDataBlock(pRuntimeEnv-&gt;pTsdbReadHandle, NULL);</comment>
<comment type="line">//     SColumnInfoData *pColInfoData = taosArrayGet(pDataBlock, 0);</comment>
<comment type="line">//</comment>
<comment type="line">//     tw = *win;</comment>
<comment type="line">//     int32_t startPos =</comment>
<comment type="line">//         getNextQualifiedWindow(pQueryAttr, &amp;tw, pBlockInfo, pColInfoData-&gt;pData, binarySearchForKey, -1);</comment>
<comment type="line">//     assert(startPos &gt;= 0);</comment>
<comment type="line">//</comment>
<comment type="line">//     // set the abort info</comment>
<comment type="line">//     pQueryAttr-&gt;pos = startPos;</comment>
<comment type="line">//</comment>
<comment type="line">//     // reset the query start timestamp</comment>
<comment type="line">//     pTableQueryInfo-&gt;win.skey = ((TSKEY *)pColInfoData-&gt;pData)[startPos];</comment>
<comment type="line">//     pQueryAttr-&gt;window.skey = pTableQueryInfo-&gt;win.skey;</comment>
<comment type="line">//     TSKEY key = pTableQueryInfo-&gt;win.skey;</comment>
<comment type="line">//</comment>
<comment type="line">//     pWindowResInfo-&gt;prevSKey = tw.skey;</comment>
<comment type="line">//     int32_t index = pRuntimeEnv-&gt;resultRowInfo.curIndex;</comment>
<comment type="line">//</comment>
<comment type="line">//     int32_t numOfRes = tableApplyFunctionsOnBlock(pRuntimeEnv, pBlockInfo, NULL, binarySearchForKey, pDataBlock);</comment>
<comment type="line">//     pRuntimeEnv-&gt;resultRowInfo.curIndex = index;  // restore the window index</comment>
<comment type="line">//</comment>
<comment type="line">//     //qDebug("QInfo:0x%"PRIx64" check data block, brange:%" PRId64 "-%" PRId64 ", numOfRows:%d, numOfRes:%d,</comment>
<comment type="line">//     lastKey:%" PRId64,</comment>
<comment type="line">//            GET_TASKID(pRuntimeEnv), pBlockInfo-&gt;window.skey, pBlockInfo-&gt;window.ekey, pBlockInfo-&gt;rows, numOfRes,</comment>
<comment type="line">//            pQueryAttr-&gt;current-&gt;lastKey);</comment>
<comment type="line">//</comment>
<comment type="line">//     return key;</comment>
<comment type="line">//   } else {  // do nothing</comment>
<comment type="line">//     pQueryAttr-&gt;window.skey      = tw.skey;</comment>
<comment type="line">//     pWindowResInfo-&gt;prevSKey = tw.skey;</comment>
<comment type="line">//     pTableQueryInfo-&gt;lastKey = tw.skey;</comment>
<comment type="line">//</comment>
<comment type="line">//     return tw.skey;</comment>
<comment type="line">//   }</comment>
<comment type="line">//</comment>
<comment type="line">//   return true;</comment>
<comment type="line">// }</comment>

<comment type="line">// static bool skipTimeInterval(STaskRuntimeEnv *pRuntimeEnv, TSKEY* start) {</comment>
<comment type="line">//   STaskAttr *pQueryAttr = pRuntimeEnv-&gt;pQueryAttr;</comment>
<comment type="line">//   if (QUERY_IS_ASC_QUERY(pQueryAttr)) {</comment>
<comment type="line">//     assert(*start &lt;= pRuntimeEnv-&gt;current-&gt;lastKey);</comment>
<comment type="line">//   } else {</comment>
<comment type="line">//     assert(*start &gt;= pRuntimeEnv-&gt;current-&gt;lastKey);</comment>
<comment type="line">//   }</comment>
<comment type="line">//</comment>
<comment type="line">//   // if queried with value filter, do NOT forward query start position</comment>
<comment type="line">//   if (pQueryAttr-&gt;limit.offset &lt;= 0 || pQueryAttr-&gt;numOfFilterCols &gt; 0 || pRuntimeEnv-&gt;pTsBuf != NULL ||</comment>
<comment type="line">//   pRuntimeEnv-&gt;pFillInfo != NULL) {</comment>
<comment type="line">//     return true;</comment>
<comment type="line">//   }</comment>
<comment type="line">//</comment>
<comment type="line">//   /*</comment>
<comment type="line">//    * 1. for interval without interpolation query we forward pQueryAttr-&gt;interval.interval at a time for</comment>
<comment type="line">//    *    pQueryAttr-&gt;limit.offset times. Since hole exists, pQueryAttr-&gt;interval.interval*pQueryAttr-&gt;limit.offset</comment>
<comment type="line">//    value is</comment>
<comment type="line">//    *    not valid. otherwise, we only forward pQueryAttr-&gt;limit.offset number of points</comment>
<comment type="line">//    */</comment>
<comment type="line">//   assert(pRuntimeEnv-&gt;resultRowInfo.prevSKey == TSKEY_INITIAL_VAL);</comment>
<comment type="line">//</comment>
<comment type="line">//   STimeWindow w = TSWINDOW_INITIALIZER;</comment>
<comment type="line">//   bool ascQuery = QUERY_IS_ASC_QUERY(pQueryAttr);</comment>
<comment type="line">//</comment>
<comment type="line">//   SResultRowInfo *pWindowResInfo = &amp;pRuntimeEnv-&gt;resultRowInfo;</comment>
<comment type="line">//   STableQueryInfo *pTableQueryInfo = pRuntimeEnv-&gt;current;</comment>
<comment type="line">//</comment>
<comment type="line">//   SDataBlockInfo blockInfo = SDATA_BLOCK_INITIALIZER;</comment>
<comment type="line">//   while (tsdbNextDataBlock(pRuntimeEnv-&gt;pTsdbReadHandle)) {</comment>
<comment type="line">//     tsdbRetrieveDataBlockInfo(pRuntimeEnv-&gt;pTsdbReadHandle, &amp;blockInfo);</comment>
<comment type="line">//</comment>
<comment type="line">//     if (QUERY_IS_ASC_QUERY(pQueryAttr)) {</comment>
<comment type="line">//       if (pWindowResInfo-&gt;prevSKey == TSKEY_INITIAL_VAL) {</comment>
<comment type="line">//         getAlignQueryTimeWindow(pQueryAttr, blockInfo.window.skey, blockInfo.window.skey, pQueryAttr-&gt;window.ekey,</comment>
<comment type="line">//         &amp;w); pWindowResInfo-&gt;prevSKey = w.skey;</comment>
<comment type="line">//       }</comment>
<comment type="line">//     } else {</comment>
<comment type="line">//       getAlignQueryTimeWindow(pQueryAttr, blockInfo.window.ekey, pQueryAttr-&gt;window.ekey, blockInfo.window.ekey, &amp;w);</comment>
<comment type="line">//       pWindowResInfo-&gt;prevSKey = w.skey;</comment>
<comment type="line">//     }</comment>
<comment type="line">//</comment>
<comment type="line">//     // the first time window</comment>
<comment type="line">//     STimeWindow win = getActiveTimeWindow(pWindowResInfo, pWindowResInfo-&gt;prevSKey, pQueryAttr);</comment>
<comment type="line">//</comment>
<comment type="line">//     while (pQueryAttr-&gt;limit.offset &gt; 0) {</comment>
<comment type="line">//       STimeWindow tw = win;</comment>
<comment type="line">//</comment>
<comment type="line">//       if ((win.ekey &lt;= blockInfo.window.ekey &amp;&amp; ascQuery) || (win.ekey &gt;= blockInfo.window.skey &amp;&amp; !ascQuery)) {</comment>
<comment type="line">//         pQueryAttr-&gt;limit.offset -= 1;</comment>
<comment type="line">//         pWindowResInfo-&gt;prevSKey = win.skey;</comment>
<comment type="line">//</comment>
<comment type="line">//         // current time window is aligned with blockInfo.window.ekey</comment>
<comment type="line">//         // restart it from next data block by set prevSKey to be TSKEY_INITIAL_VAL;</comment>
<comment type="line">//         if ((win.ekey == blockInfo.window.ekey &amp;&amp; ascQuery) || (win.ekey == blockInfo.window.skey &amp;&amp; !ascQuery)) {</comment>
<comment type="line">//           pWindowResInfo-&gt;prevSKey = TSKEY_INITIAL_VAL;</comment>
<comment type="line">//         }</comment>
<comment type="line">//       }</comment>
<comment type="line">//</comment>
<comment type="line">//       if (pQueryAttr-&gt;limit.offset == 0) {</comment>
<comment type="line">//         *start = doSkipIntervalProcess(pRuntimeEnv, &amp;win, &amp;blockInfo, pTableQueryInfo);</comment>
<comment type="line">//         return true;</comment>
<comment type="line">//       }</comment>
<comment type="line">//</comment>
<comment type="line">//       // current window does not ended in current data block, try next data block</comment>
<comment type="line">//       getNextTimeWindow(pQueryAttr, &amp;tw);</comment>
<comment type="line">//</comment>
<comment type="line">//       /*</comment>
<comment type="line">//        * If the next time window still starts from current data block,</comment>
<comment type="line">//        * load the primary timestamp column first, and then find the start position for the next queried time window.</comment>
<comment type="line">//        * Note that only the primary timestamp column is required.</comment>
<comment type="line">//        * TODO: Optimize for this cases. All data blocks are not needed to be loaded, only if the first actually</comment>
<comment type="line">//        required</comment>
<comment type="line">//        * time window resides in current data block.</comment>
<comment type="line">//        */</comment>
<comment type="line">//       if ((tw.skey &lt;= blockInfo.window.ekey &amp;&amp; ascQuery) || (tw.ekey &gt;= blockInfo.window.skey &amp;&amp; !ascQuery)) {</comment>
<comment type="line">//</comment>
<comment type="line">//         SArray *pDataBlock = tsdbRetrieveDataBlock(pRuntimeEnv-&gt;pTsdbReadHandle, NULL);</comment>
<comment type="line">//         SColumnInfoData *pColInfoData = taosArrayGet(pDataBlock, 0);</comment>
<comment type="line">//</comment>
<comment type="line">//         if ((win.ekey &gt; blockInfo.window.ekey &amp;&amp; ascQuery) || (win.ekey &lt; blockInfo.window.skey &amp;&amp; !ascQuery)) {</comment>
<comment type="line">//           pQueryAttr-&gt;limit.offset -= 1;</comment>
<comment type="line">//         }</comment>
<comment type="line">//</comment>
<comment type="line">//         if (pQueryAttr-&gt;limit.offset == 0) {</comment>
<comment type="line">//           *start = doSkipIntervalProcess(pRuntimeEnv, &amp;win, &amp;blockInfo, pTableQueryInfo);</comment>
<comment type="line">//           return true;</comment>
<comment type="line">//         } else {</comment>
<comment type="line">//           tw = win;</comment>
<comment type="line">//           int32_t startPos =</comment>
<comment type="line">//               getNextQualifiedWindow(pQueryAttr, &amp;tw, &amp;blockInfo, pColInfoData-&gt;pData, binarySearchForKey, -1);</comment>
<comment type="line">//           assert(startPos &gt;= 0);</comment>
<comment type="line">//</comment>
<comment type="line">//           // set the abort info</comment>
<comment type="line">//           pQueryAttr-&gt;pos = startPos;</comment>
<comment type="line">//           pTableQueryInfo-&gt;lastKey = ((TSKEY *)pColInfoData-&gt;pData)[startPos];</comment>
<comment type="line">//           pWindowResInfo-&gt;prevSKey = tw.skey;</comment>
<comment type="line">//           win = tw;</comment>
<comment type="line">//         }</comment>
<comment type="line">//       } else {</comment>
<comment type="line">//         break;  // offset is not 0, and next time window begins or ends in the next block.</comment>
<comment type="line">//       }</comment>
<comment type="line">//     }</comment>
<comment type="line">//   }</comment>
<comment type="line">//</comment>
<comment type="line">//   // check for error</comment>
<comment type="line">//   if (terrno != TSDB_CODE_SUCCESS) {</comment>
<comment type="line">//     T_LONG_JMP(pRuntimeEnv-&gt;env, terrno);</comment>
<comment type="line">//   }</comment>
<comment type="line">//</comment>
<comment type="line">//   return true;</comment>
<comment type="line">// }</comment>

<function><type><name>int32_t</name></type> <name>appendDownstream</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier><modifier>*</modifier></type> <name>pDownstream</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pDownstream</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>numOfDownstream</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDownstream</name></name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>num</name> <operator>*</operator> <name>POINTER_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>pDownstream</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pDownstream</name></name></expr></argument>, <argument><expr><name>pDownstream</name></expr></argument>, <argument><expr><name>num</name> <operator>*</operator> <name>POINTER_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>numOfDownstream</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>getTableScanInfo</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><name>int32_t</name><modifier>*</modifier></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>int32_t</name><modifier>*</modifier></type> <name>scanFlag</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// todo add more information about exchange operation</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>operatorType</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_EXCHANGE</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_SYSTABLE_SCAN</name> <operator>||</operator>
      <name>type</name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SCAN</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_TAG_SCAN</name> <operator>||</operator>
      <name>type</name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_BLOCK_DIST_SCAN</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_LAST_ROW_SCAN</name> <operator>||</operator>
      <name>type</name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_TABLE_COUNT_SCAN</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>order</name> <operator>=</operator> <name>TSDB_ORDER_ASC</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>scanFlag</name> <operator>=</operator> <name>MAIN_SCAN</name></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_TABLE_SCAN</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>STableScanInfo</name><modifier>*</modifier></type> <name>pTableScanInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>order</name> <operator>=</operator> <name><name>pTableScanInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>cond</name><operator>.</operator><name>order</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>scanFlag</name> <operator>=</operator> <name><name>pTableScanInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>scanFlag</name></name></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_TABLE_MERGE_SCAN</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>STableMergeScanInfo</name><modifier>*</modifier></type> <name>pTableScanInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>order</name> <operator>=</operator> <name><name>pTableScanInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>cond</name><operator>.</operator><name>order</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>scanFlag</name> <operator>=</operator> <name><name>pTableScanInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>scanFlag</name></name></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pOperator</name><operator>-&gt;</operator><name>pDownstream</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pOperator</name><operator>-&gt;</operator><name>pDownstream</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>TSDB_CODE_INVALID_PARA</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><call><name>getTableScanInfo</name><argument_list>(<argument><expr><name><name>pOperator</name><operator>-&gt;</operator><name>pDownstream</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>scanFlag</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createDataBlockForEmptyInput</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppBlock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tsCountAlwaysReturnValue</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>downstream</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>pDownstream</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>downstream</name><operator>-&gt;</operator><name>operatorType</name></name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_PARTITION</name> <operator>||</operator>
      <operator>(</operator><name><name>downstream</name><operator>-&gt;</operator><name>operatorType</name></name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_TABLE_SCAN</name> <operator>&amp;&amp;</operator>
       <operator>(</operator><operator>(</operator><name>STableScanInfo</name> <operator>*</operator><operator>)</operator><name><name>downstream</name><operator>-&gt;</operator><name>info</name></name><operator>)</operator><operator>-&gt;</operator><name>hasGroupByTag</name> <operator>==</operator> <name>true</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name><operator>.</operator><name>pCtx</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>hasCountFunc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name><operator>.</operator><name>numOfExprs</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pName</name> <init>= <expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>_function</name><operator>.</operator><name>functionName</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>pName</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>pName</name></expr></argument>, <argument><expr><literal type="string">"hyperloglog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>pName</name></expr></argument>, <argument><expr><literal type="string">"_hyperloglog_partial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>pName</name></expr></argument>, <argument><expr><literal type="string">"_hyperloglog_merge"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hasCountFunc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasCountFunc</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name> <init>= <expr><call><name>createDataBlock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>capacity</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name><operator>.</operator><name>numOfExprs</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SColumnInfoData</name></type> <name>colInfo</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>colInfo</name><operator>.</operator><name>hasNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>colInfo</name><operator>.</operator><name>info</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>TSDB_DATA_TYPE_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>colInfo</name><operator>.</operator><name>info</name><operator>.</operator><name>bytes</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>SExprInfo</name><modifier>*</modifier></type> <name>pOneExpr</name> <init>= <expr><operator>&amp;</operator><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name><operator>.</operator><name>pExprInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pOneExpr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>numOfParams</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>SFunctParam</name><modifier>*</modifier></type> <name>pFuncParam</name> <init>= <expr><operator>&amp;</operator><name><name>pOneExpr</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pParam</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>FUNC_PARAM_TYPE_COLUMN</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>slotId</name> <init>= <expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>pCol</name><operator>-&gt;</operator><name>slotId</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfCols</name> <init>= <expr><call><name>taosArrayGetSize</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>slotId</name> <operator>&gt;=</operator> <name>numOfCols</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>taosArrayEnsureCap</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>, <argument><expr><name>slotId</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><name>numOfCols</name></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>slotId</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>taosArrayPush</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pFuncParam</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>FUNC_PARAM_TYPE_VALUE</name></expr>)</condition> <block>{<block_content>
        <comment type="line">// do nothing</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>blockDataEnsureCapacity</name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppBlock</name> <operator>=</operator> <name>pBlock</name></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>destroyDataBlockForEmptyInput</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>blockAllocated</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppBlock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>blockAllocated</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>blockDataDestroy</name><argument_list>(<argument><expr><operator>*</operator><name>ppBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppBlock</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// this is a blocking operator</comment>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doOpenAggregateOptr</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>OPTR_IS_OPENED</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type>    <name>pTaskInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>pTaskInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SAggOperatorInfo</name><modifier>*</modifier></type> <name>pAggInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SExprSupp</name><modifier>*</modifier></type>     <name>pSup</name> <init>= <expr><operator>&amp;</operator><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>downstream</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>pDownstream</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int64_t</name></type> <name>st</name> <init>= <expr><call><name>taosGetTimestampUs</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>order</name> <init>= <expr><name>TSDB_ORDER_ASC</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>scanFlag</name> <init>= <expr><name>MAIN_SCAN</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>bool</name></type>    <name>hasValidBlock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>    <name>blockAllocated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name> <init>= <expr><call><name><name>downstream</name><operator>-&gt;</operator><name>fpSet</name><operator>.</operator><name>getNextFn</name></name><argument_list>(<argument><expr><name>downstream</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>pBlock</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasValidBlock</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>createDataBlockForEmptyInput</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pBlock</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>blockAllocated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>hasValidBlock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>getTableScanInfo</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>order</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scanFlag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>destroyDataBlockForEmptyInput</name><argument_list>(<argument><expr><name>blockAllocated</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>T_LONG_JMP</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// there is an scalar expression that needs to be calculated before apply the group aggregation.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>scalarExprSup</name><operator>.</operator><name>pExprInfo</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>blockAllocated</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pSup1</name> <init>= <expr><operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>scalarExprSup</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>projectApplyFunctions</name><argument_list>(<argument><expr><name><name>pSup1</name><operator>-&gt;</operator><name>pExprInfo</name></name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name><name>pSup1</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name><name>pSup1</name><operator>-&gt;</operator><name>numOfExprs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>destroyDataBlockForEmptyInput</name><argument_list>(<argument><expr><name>blockAllocated</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>T_LONG_JMP</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// the pDataBlock are always the same one, no need to call this again</comment>
    <expr_stmt><expr><call><name>setExecutionContext</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>, <argument><expr><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name><operator>.</operator><name>numOfExprs</name></name></expr></argument>, <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setInputDataBlock</name><argument_list>(<argument><expr><name>pSup</name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>scanFlag</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>doAggregateImpl</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>, <argument><expr><name><name>pSup</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>destroyDataBlockForEmptyInput</name><argument_list>(<argument><expr><name>blockAllocated</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>T_LONG_JMP</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>destroyDataBlockForEmptyInput</name><argument_list>(<argument><expr><name>blockAllocated</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  </block_content>}</block></while>

  <comment type="line">// the downstream operator may return with error code, so let's check the code before generating results.</comment>
  <if_stmt><if>if <condition>(<expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>T_LONG_JMP</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>initGroupedResultInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>groupResInfo</name></name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aggSup</name><operator>.</operator><name>pResultRowHashTable</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OPTR_SET_OPENED</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>openCost</name></name> <operator>=</operator> <operator>(</operator><call><name>taosGetTimestampUs</name><argument_list>()</argument_list></call> <operator>-</operator> <name>st</name><operator>)</operator> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
  <return>return <expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SSDataBlock</name><modifier>*</modifier></type> <name>getAggregateResult</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SAggOperatorInfo</name><modifier>*</modifier></type> <name>pAggInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SOptrBasicInfo</name><modifier>*</modifier></type>   <name>pInfo</name> <init>= <expr><operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>binfo</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pOperator</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>OP_EXEC_DONE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>pTaskInfo</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <call><name><name>pOperator</name><operator>-&gt;</operator><name>fpSet</name><operator>.</operator><name>_openFn</name></name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>setOperatorCompleted</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>blockDataEnsureCapacity</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pRes</name></name></expr></argument>, <argument><expr><name><name>pOperator</name><operator>-&gt;</operator><name>resultInfo</name><operator>.</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>doBuildResultDatablock</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>groupResInfo</name></name></expr></argument>, <argument><expr><name><name>pAggInfo</name><operator>-&gt;</operator><name>aggSup</name><operator>.</operator><name>pResultBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>doFilter</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pRes</name></name></expr></argument>, <argument><expr><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name><operator>.</operator><name>pFilterInfo</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasRemainResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAggInfo</name><operator>-&gt;</operator><name>groupResInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>setOperatorCompleted</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pInfo</name><operator>-&gt;</operator><name>pRes</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <decl_stmt><decl><type><name>size_t</name></type> <name>rows</name> <init>= <expr><call><name>blockDataGetNumOfRows</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pRes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>resultInfo</name><operator>.</operator><name>totalRows</name></name> <operator>+=</operator> <name>rows</name></expr>;</expr_stmt>

  <return>return <expr><ternary><condition><expr><operator>(</operator><name>rows</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>pInfo</name><operator>-&gt;</operator><name>pRes</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>destroyExprInfo</name><parameter_list>(<parameter><decl><type><name>SExprInfo</name><modifier>*</modifier></type> <name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfExprs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfExprs</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SExprInfo</name><modifier>*</modifier></type> <name>pExprInfo</name> <init>= <expr><operator>&amp;</operator><name><name>pExpr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pExprInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>numOfParams</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>pExprInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pParam</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>FUNC_PARAM_TYPE_COLUMN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pExprInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pParam</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pExprInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pParam</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>FUNC_PARAM_TYPE_VALUE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosVariantDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pExprInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pParam</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name><name>pExprInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name><name>pExprInfo</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>destroyOperatorInfo</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>pOperator</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pOperator</name><operator>-&gt;</operator><name>fpSet</name><operator>.</operator><name>closeFn</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name><name>pOperator</name><operator>-&gt;</operator><name>fpSet</name><operator>.</operator><name>closeFn</name></name><argument_list>(<argument><expr><name><name>pOperator</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pOperator</name><operator>-&gt;</operator><name>pDownstream</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pOperator</name><operator>-&gt;</operator><name>numOfDownstream</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>destroyOperatorInfo</name><argument_list>(<argument><expr><name><name>pOperator</name><operator>-&gt;</operator><name>pDownstream</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pOperator</name><operator>-&gt;</operator><name>pDownstream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>numOfDownstream</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>cleanupExprSupp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// each operator should be set their own function to return total cost buffer</comment>
<function><type><name>int32_t</name></type> <name>optrDefaultBufFn</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pOperator</name><operator>-&gt;</operator><name>blocking</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>getBufferPgSize</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>rowSize</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>defaultPgsz</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name><modifier>*</modifier></type> <name>defaultBufsz</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>defaultPgsz</name> <operator>=</operator> <literal type="number">4096</literal></expr>;</expr_stmt>
  <while>while <condition>(<expr><operator>*</operator><name>defaultPgsz</name> <operator>&lt;</operator> <name>rowSize</name> <operator>*</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>defaultPgsz</name> <operator>&lt;&lt;=</operator> <literal type="number">1u</literal></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="line">// The default buffer for each operator in query is 10MB.</comment>
  <comment type="line">// at least four pages need to be in buffer</comment>
  <comment type="line">// TODO: make this variable to be configurable.</comment>
  <expr_stmt><expr><operator>*</operator><name>defaultBufsz</name> <operator>=</operator> <literal type="number">4096</literal> <operator>*</operator> <literal type="number">2560</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>defaultBufsz</name><operator>)</operator> <operator>&lt;=</operator> <operator>(</operator><operator>*</operator><name>defaultPgsz</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>defaultBufsz</name><operator>)</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>defaultPgsz</name><operator>)</operator> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>doInitAggInfoSup</name><parameter_list>(<parameter><decl><type><name>SAggSupporter</name><modifier>*</modifier></type> <name>pAggSup</name></decl></parameter>, <parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfOutput</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keyBufSize</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pKey</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>_hash_fn_t</name></type> <name>hashFn</name> <init>= <expr><call><name>taosGetDefaultHashFunction</name><argument_list>(<argument><expr><name>TSDB_DATA_TYPE_BINARY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pAggSup</name><operator>-&gt;</operator><name>currentPageId</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAggSup</name><operator>-&gt;</operator><name>resultRowSize</name></name> <operator>=</operator> <call><name>getResultRowSize</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>numOfOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAggSup</name><operator>-&gt;</operator><name>keyBuf</name></name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>keyBufSize</name> <operator>+</operator> <name>POINTER_BYTES</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAggSup</name><operator>-&gt;</operator><name>pResultRowHashTable</name></name> <operator>=</operator> <call><name>tSimpleHashInit</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>hashFn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pAggSup</name><operator>-&gt;</operator><name>keyBuf</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pAggSup</name><operator>-&gt;</operator><name>pResultRowHashTable</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>uint32_t</name></type> <name>defaultPgsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>defaultBufsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>getBufferPgSize</name><argument_list>(<argument><expr><name><name>pAggSup</name><operator>-&gt;</operator><name>resultRowSize</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defaultPgsz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defaultBufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>osTempSpaceAvailable</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_NO_AVAIL_DISK</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"Init stream agg supporter failed since %s, %s"</literal></expr></argument>, <argument><expr><call><name>terrstr</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createDiskbasedBuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAggSup</name><operator>-&gt;</operator><name>pResultBuf</name></name></expr></argument>, <argument><expr><name>defaultPgsz</name></expr></argument>, <argument><expr><name>defaultBufsz</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>tsTempDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"Create agg result buf failed since %s, %s"</literal></expr></argument>, <argument><expr><call><name>tstrerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>cleanupAggSup</name><parameter_list>(<parameter><decl><type><name>SAggSupporter</name><modifier>*</modifier></type> <name>pAggSup</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pAggSup</name><operator>-&gt;</operator><name>keyBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tSimpleHashCleanup</name><argument_list>(<argument><expr><name><name>pAggSup</name><operator>-&gt;</operator><name>pResultRowHashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>destroyDiskbasedBuf</name><argument_list>(<argument><expr><name><name>pAggSup</name><operator>-&gt;</operator><name>pResultBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>initAggSup</name><parameter_list>(<parameter><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pSup</name></decl></parameter>, <parameter><decl><type><name>SAggSupporter</name><modifier>*</modifier></type> <name>pAggSup</name></decl></parameter>, <parameter><decl><type><name>SExprInfo</name><modifier>*</modifier></type> <name>pExprInfo</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfCols</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keyBufSize</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pkey</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>initExprSupp</name><argument_list>(<argument><expr><name>pSup</name></expr></argument>, <argument><expr><name>pExprInfo</name></expr></argument>, <argument><expr><name>numOfCols</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>doInitAggInfoSup</name><argument_list>(<argument><expr><name>pAggSup</name></expr></argument>, <argument><expr><name><name>pSup</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name>numOfCols</name></expr></argument>, <argument><expr><name>keyBufSize</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfCols</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>pSup</name><operator>-&gt;</operator><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>saveHandle</name><operator>.</operator><name>pBuf</name></name> <operator>=</operator> <name><name>pAggSup</name><operator>-&gt;</operator><name>pResultBuf</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>initResultSizeInfo</name><parameter_list>(<parameter><decl><type><name>SResultInfo</name><modifier>*</modifier></type> <name>pResultInfo</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfRows</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>numOfRows</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pResultInfo</name><operator>-&gt;</operator><name>capacity</name></name> <operator>=</operator> <name>numOfRows</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pResultInfo</name><operator>-&gt;</operator><name>threshold</name></name> <operator>=</operator> <name>numOfRows</name> <operator>*</operator> <literal type="number">0.75</literal></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pResultInfo</name><operator>-&gt;</operator><name>threshold</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pResultInfo</name><operator>-&gt;</operator><name>threshold</name></name> <operator>=</operator> <name>numOfRows</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>initBasicInfo</name><parameter_list>(<parameter><decl><type><name>SOptrBasicInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pRes</name></name> <operator>=</operator> <name>pBlock</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>initResultRowInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>resultRowInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>destroySqlFunctionCtx</name><parameter_list>(<parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>pCtx</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfOutput</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numOfParams</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>taosVariantDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>param</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>subsidiaries</name><operator>.</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>subsidiaries</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>input</name><operator>.</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>input</name><operator>.</operator><name>pColumnDataAgg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>initExprSupp</name><parameter_list>(<parameter><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pSup</name></decl></parameter>, <parameter><decl><type><name>SExprInfo</name><modifier>*</modifier></type> <name>pExprInfo</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pSup</name><operator>-&gt;</operator><name>pExprInfo</name></name> <operator>=</operator> <name>pExprInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSup</name><operator>-&gt;</operator><name>numOfExprs</name></name> <operator>=</operator> <name>numOfExpr</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pSup</name><operator>-&gt;</operator><name>pExprInfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pSup</name><operator>-&gt;</operator><name>pCtx</name></name> <operator>=</operator> <call><name>createSqlFunctionCtx</name><argument_list>(<argument><expr><name>pExprInfo</name></expr></argument>, <argument><expr><name>numOfExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSup</name><operator>-&gt;</operator><name>rowEntryInfoOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pSup</name><operator>-&gt;</operator><name>pCtx</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>cleanupExprSupp</name><parameter_list>(<parameter><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pSupp</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>destroySqlFunctionCtx</name><argument_list>(<argument><expr><name><name>pSupp</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name><name>pSupp</name><operator>-&gt;</operator><name>numOfExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pSupp</name><operator>-&gt;</operator><name>pExprInfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>destroyExprInfo</name><argument_list>(<argument><expr><name><name>pSupp</name><operator>-&gt;</operator><name>pExprInfo</name></name></expr></argument>, <argument><expr><name><name>pSupp</name><operator>-&gt;</operator><name>numOfExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pSupp</name><operator>-&gt;</operator><name>pExprInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pSupp</name><operator>-&gt;</operator><name>pFilterInfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>filterFreeInfo</name><argument_list>(<argument><expr><name><name>pSupp</name><operator>-&gt;</operator><name>pFilterInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSupp</name><operator>-&gt;</operator><name>pFilterInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name><name>pSupp</name><operator>-&gt;</operator><name>rowEntryInfoOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>createAggregateOperatorInfo</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>downstream</name></decl></parameter>, <parameter><decl><type><name>SAggPhysiNode</name><modifier>*</modifier></type> <name>pAggNode</name></decl></parameter>,
                                           <parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SAggOperatorInfo</name><modifier>*</modifier></type> <name>pInfo</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SAggOperatorInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type>    <name>pOperator</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SOperatorInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>pInfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>pOperator</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <goto>goto <name>_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pResBlock</name> <init>= <expr><call><name>createDataBlockFromDescNode</name><argument_list>(<argument><expr><name><name>pAggNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pOutputDataBlockDesc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>initBasicInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>binfo</name></name></expr></argument>, <argument><expr><name>pResBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>size_t</name></type> <name>keyBufSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>POINTER_BYTES</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>initResultSizeInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOperator</name><operator>-&gt;</operator><name>resultInfo</name></name></expr></argument>, <argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>    <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SExprInfo</name><modifier>*</modifier></type> <name>pExprInfo</name> <init>= <expr><call><name>createExprInfo</name><argument_list>(<argument><expr><name><name>pAggNode</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><name><name>pAggNode</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>code</name> <init>= <expr><call><name>initAggSup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>aggSup</name></name></expr></argument>, <argument><expr><name>pExprInfo</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>keyBufSize</name></expr></argument>, <argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <goto>goto <name>_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>    <name>numOfScalarExpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SExprInfo</name><modifier>*</modifier></type> <name>pScalarExprInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pAggNode</name><operator>-&gt;</operator><name>pExprs</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pScalarExprInfo</name> <operator>=</operator> <call><name>createExprInfo</name><argument_list>(<argument><expr><name><name>pAggNode</name><operator>-&gt;</operator><name>pExprs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numOfScalarExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>initExprSupp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>scalarExprSup</name></name></expr></argument>, <argument><expr><name>pScalarExprInfo</name></expr></argument>, <argument><expr><name>numOfScalarExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <goto>goto <name>_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>filterInitFromNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pAggNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name><operator>.</operator><name>pFilterInfo</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <goto>goto <name>_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>binfo</name><operator>.</operator><name>mergeResultBlock</name></name> <operator>=</operator> <name><name>pAggNode</name><operator>-&gt;</operator><name>mergeDataBlock</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>setOperatorInfo</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>, <argument><expr><literal type="string">"TableAggregate"</literal></expr></argument>, <argument><expr><name>QUERY_NODE_PHYSICAL_PLAN_HASH_AGG</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>OP_NOT_OPENED</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>,
                  <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>fpSet</name></name> <operator>=</operator> <call><name>createOperatorFpSet</name><argument_list>(<argument><expr><name>doOpenAggregateOptr</name></expr></argument>, <argument><expr><name>getAggregateResult</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>destroyAggOperatorInfo</name></expr></argument>, <argument><expr><name>optrDefaultBufFn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>downstream</name><operator>-&gt;</operator><name>operatorType</name></name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_TABLE_SCAN</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>STableScanInfo</name><modifier>*</modifier></type> <name>pTableScanInfo</name> <init>= <expr><name><name>downstream</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pTableScanInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pdInfo</name><operator>.</operator><name>pExprSup</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTableScanInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pdInfo</name><operator>.</operator><name>pAggSup</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>aggSup</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>appendDownstream</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>downstream</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <goto>goto <name>_error</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pOperator</name></expr>;</return>

<label><name>_error</name>:</label>
  <if_stmt><if>if <condition>(<expr><name>pInfo</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>destroyAggOperatorInfo</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>pOperator</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>cleanupExprSupp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pOperator</name><operator>-&gt;</operator><name>exprSupp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name>pOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>cleanupBasicInfo</name><parameter_list>(<parameter><decl><type><name>SOptrBasicInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pInfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pRes</name></name> <operator>=</operator> <call><name>blockDataDestroy</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pRes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>freeItem</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pItem</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>p</name> <init>= <expr><name>pItem</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>destroyAggOperatorInfo</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SAggOperatorInfo</name><modifier>*</modifier></type> <name>pInfo</name> <init>= <expr><operator>(</operator><name>SAggOperatorInfo</name><operator>*</operator><operator>)</operator><name>param</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>cleanupBasicInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>binfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>cleanupAggSup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>aggSup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cleanupExprSupp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>scalarExprSup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cleanupGroupResInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>groupResInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SExecTaskInfo</name><modifier>*</modifier></type> <name>createExecTaskInfo</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>queryId</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>taskId</name></decl></parameter>, <parameter><decl><type><name>EOPTR_EXEC_MODEL</name></type> <name>model</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>dbFName</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SExecTaskInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>pTaskInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>setTaskStatus</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>, <argument><expr><name>TASK_NOT_COMPLETED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>schemaInfo</name><operator>.</operator><name>dbname</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>dbFName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>queryId</name></name> <operator>=</operator> <name>queryId</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>execModel</name></name> <operator>=</operator> <name>model</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>pTableInfoList</name></name> <operator>=</operator> <call><name>tableListCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>stopInfo</name><operator>.</operator><name>pStopInfo</name></name> <operator>=</operator> <call><name>taosArrayInit</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SExchangeOpStopInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>pResultBlockList</name></name> <operator>=</operator> <call><name>taosArrayInit</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="string">"TID:0x%"</literal> <name>PRIx64</name> <literal type="string">" QID:0x%"</literal> <name>PRIx64</name></expr></argument>, <argument><expr><name>taskId</name></expr></argument>, <argument><expr><name>queryId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

  <return>return <expr><name>pTaskInfo</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>SSchemaWrapper</name><modifier>*</modifier></type> <name>extractQueriedColumnSchema</name><parameter_list>(<parameter><decl><type><name>SScanPhysiNode</name><modifier>*</modifier></type> <name>pScanNode</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>int32_t</name></type> <name>extractTableSchemaInfo</name><parameter_list>(<parameter><decl><type><name>SReadHandle</name><modifier>*</modifier></type> <name>pHandle</name></decl></parameter>, <parameter><decl><type><name>SScanPhysiNode</name><modifier>*</modifier></type> <name>pScanNode</name></decl></parameter>, <parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SMetaReader</name></type> <name>mr</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>metaReaderInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mr</name></expr></argument>, <argument><expr><name><name>pHandle</name><operator>-&gt;</operator><name>meta</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>metaGetTableEntryByUidCache</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mr</name></expr></argument>, <argument><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"failed to get the table meta, uid:0x%"</literal> <name>PRIx64</name> <literal type="string">", suid:0x%"</literal> <name>PRIx64</name> <literal type="string">", %s"</literal></expr></argument>, <argument><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>, <argument><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>suid</name></name></expr></argument>,
           <argument><expr><call><name>GET_TASKID</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>metaReaderClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>terrno</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SSchemaInfo</name><modifier>*</modifier></type> <name>pSchemaInfo</name> <init>= <expr><operator>&amp;</operator><name><name>pTaskInfo</name><operator>-&gt;</operator><name>schemaInfo</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pSchemaInfo</name><operator>-&gt;</operator><name>tablename</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>mr</name><operator>.</operator><name>me</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>mr</name><operator>.</operator><name>me</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>TSDB_SUPER_TABLE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pSchemaInfo</name><operator>-&gt;</operator><name>sw</name></name> <operator>=</operator> <call><name>tCloneSSchemaWrapper</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mr</name><operator>.</operator><name>me</name><operator>.</operator><name>stbEntry</name><operator>.</operator><name>schemaRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSchemaInfo</name><operator>-&gt;</operator><name>tversion</name></name> <operator>=</operator> <name><name>mr</name><operator>.</operator><name>me</name><operator>.</operator><name>stbEntry</name><operator>.</operator><name>schemaTag</name><operator>.</operator><name>version</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>mr</name><operator>.</operator><name>me</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>TSDB_CHILD_TABLE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>tDecoderClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mr</name><operator>.</operator><name>coder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>tb_uid_t</name></type> <name>suid</name> <init>= <expr><name><name>mr</name><operator>.</operator><name>me</name><operator>.</operator><name>ctbEntry</name><operator>.</operator><name>suid</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>metaGetTableEntryByUidCache</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mr</name></expr></argument>, <argument><expr><name>suid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSchemaInfo</name><operator>-&gt;</operator><name>sw</name></name> <operator>=</operator> <call><name>tCloneSSchemaWrapper</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mr</name><operator>.</operator><name>me</name><operator>.</operator><name>stbEntry</name><operator>.</operator><name>schemaRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSchemaInfo</name><operator>-&gt;</operator><name>tversion</name></name> <operator>=</operator> <name><name>mr</name><operator>.</operator><name>me</name><operator>.</operator><name>stbEntry</name><operator>.</operator><name>schemaTag</name><operator>.</operator><name>version</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>pSchemaInfo</name><operator>-&gt;</operator><name>sw</name></name> <operator>=</operator> <call><name>tCloneSSchemaWrapper</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mr</name><operator>.</operator><name>me</name><operator>.</operator><name>ntbEntry</name><operator>.</operator><name>schemaRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>metaReaderClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pSchemaInfo</name><operator>-&gt;</operator><name>qsw</name></name> <operator>=</operator> <call><name>extractQueriedColumnSchema</name><argument_list>(<argument><expr><name>pScanNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SSchemaWrapper</name><modifier>*</modifier></type> <name>extractQueriedColumnSchema</name><parameter_list>(<parameter><decl><type><name>SScanPhysiNode</name><modifier>*</modifier></type> <name>pScanNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfCols</name> <init>= <expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfTags</name> <init>= <expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SSchemaWrapper</name><modifier>*</modifier></type> <name>pqSw</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSchemaWrapper</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pqSw</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>numOfCols</name> <operator>+</operator> <name>numOfTags</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SSchema</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfCols</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>STargetNode</name><modifier>*</modifier></type> <name>pNode</name> <init>= <expr><operator>(</operator><name>STargetNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pColNode</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name><name>pNode</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>SSchema</name><modifier>*</modifier></type> <name>pSchema</name> <init>= <expr><operator>&amp;</operator><name><name>pqSw</name><operator>-&gt;</operator><name>pSchema</name><index>[<expr><name><name>pqSw</name><operator>-&gt;</operator><name>nCols</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pSchema</name><operator>-&gt;</operator><name>colId</name></name> <operator>=</operator> <name><name>pColNode</name><operator>-&gt;</operator><name>colId</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSchema</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>pColNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSchema</name><operator>-&gt;</operator><name>bytes</name></name> <operator>=</operator> <name><name>pColNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>bytes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tstrncpy</name><argument_list>(<argument><expr><name><name>pSchema</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>pColNode</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><call><name>tListLen</name><argument_list>(<argument><expr><name><name>pSchema</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="line">// this the tags and pseudo function columns, we only keep the tag columns</comment>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfTags</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>STargetNode</name><modifier>*</modifier></type> <name>pNode</name> <init>= <expr><operator>(</operator><name>STargetNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>type</name> <init>= <expr><call><name>nodeType</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>QUERY_NODE_COLUMN</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pColNode</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name><name>pNode</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>SSchema</name><modifier>*</modifier></type> <name>pSchema</name> <init>= <expr><operator>&amp;</operator><name><name>pqSw</name><operator>-&gt;</operator><name>pSchema</name><index>[<expr><name><name>pqSw</name><operator>-&gt;</operator><name>nCols</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pSchema</name><operator>-&gt;</operator><name>colId</name></name> <operator>=</operator> <name><name>pColNode</name><operator>-&gt;</operator><name>colId</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSchema</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>pColNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSchema</name><operator>-&gt;</operator><name>bytes</name></name> <operator>=</operator> <name><name>pColNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>bytes</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>tstrncpy</name><argument_list>(<argument><expr><name><name>pSchema</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>pColNode</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><call><name>tListLen</name><argument_list>(<argument><expr><name><name>pSchema</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>pqSw</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cleanupTableSchemaInfo</name><parameter_list>(<parameter><decl><type><name>SSchemaInfo</name><modifier>*</modifier></type> <name>pSchemaInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pSchemaInfo</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pSchemaInfo</name><operator>-&gt;</operator><name>tablename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tDeleteSSchemaWrapper</name><argument_list>(<argument><expr><name><name>pSchemaInfo</name><operator>-&gt;</operator><name>sw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tDeleteSSchemaWrapper</name><argument_list>(<argument><expr><name><name>pSchemaInfo</name><operator>-&gt;</operator><name>qsw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cleanupStreamInfo</name><parameter_list>(<parameter><decl><type><name>SStreamTaskInfo</name><modifier>*</modifier></type> <name>pStreamInfo</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>tDeleteSSchemaWrapper</name><argument_list>(<argument><expr><name><name>pStreamInfo</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>bool</name></type> <name>groupbyTbname</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pGroupList</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>bytbname</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name>pGroupList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name>pGroupList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QUERY_NODE_FUNCTION</name></expr>)</condition> <block>{<block_content>
      <comment type="line">// partition by tbname/group by tbname</comment>
      <expr_stmt><expr><name>bytbname</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator>struct <name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><operator>-&gt;</operator><name>functionName</name></expr></argument>, <argument><expr><literal type="string">"tbname"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>bytbname</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>createOperatorTree</name><parameter_list>(<parameter><decl><type><name>SPhysiNode</name><modifier>*</modifier></type> <name>pPhyNode</name></decl></parameter>, <parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>, <parameter><decl><type><name>SReadHandle</name><modifier>*</modifier></type> <name>pHandle</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTagCond</name></decl></parameter>,
                                  <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTagIndexCond</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pUser</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>         <name>type</name> <init>= <expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pPhyNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>STableListInfo</name><modifier>*</modifier></type> <name>pTableListInfo</name> <init>= <expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>pTableInfoList</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>     <name>idstr</name> <init>= <expr><call><name>GET_TASKID</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pChildren</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_TABLE_SCAN</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>STableScanPhysiNode</name><modifier>*</modifier></type> <name>pTableScanNode</name> <init>= <expr><operator>(</operator><name>STableScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>

      <comment type="line">// NOTE: this is an patch to fix the physical plan</comment>
      <comment type="line">// TODO remove it later</comment>
      <if_stmt><if>if <condition>(<expr><name><name>pTableScanNode</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>node</name><operator>.</operator><name>pLimit</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pTableScanNode</name><operator>-&gt;</operator><name>groupSort</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>=
          <expr><call><name>createScanTableListInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTableScanNode</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>, <argument><expr><name><name>pTableScanNode</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>, <argument><expr><name><name>pTableScanNode</name><operator>-&gt;</operator><name>groupSort</name></name></expr></argument>, <argument><expr><name>pHandle</name></expr></argument>,
                                  <argument><expr><name>pTableListInfo</name></expr></argument>, <argument><expr><name>pTagCond</name></expr></argument>, <argument><expr><name>pTagIndexCond</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"failed to createScanTableListInfo, code:%s, %s"</literal></expr></argument>, <argument><expr><call><name>tstrerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>extractTableSchemaInfo</name><argument_list>(<argument><expr><name>pHandle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTableScanNode</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>terrno</name></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>pOperator</name> <operator>=</operator> <call><name>createTableScanOperatorInfo</name><argument_list>(<argument><expr><name>pTableScanNode</name></expr></argument>, <argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pOperator</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>terrno</name></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>STableScanInfo</name><modifier>*</modifier></type> <name>pScanInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>pRecoder</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pScanInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>readRecorder</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_TABLE_MERGE_SCAN</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>STableMergeScanPhysiNode</name><modifier>*</modifier></type> <name>pTableScanNode</name> <init>= <expr><operator>(</operator><name>STableMergeScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>createScanTableListInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTableScanNode</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>, <argument><expr><name><name>pTableScanNode</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>pHandle</name></expr></argument>,
                                             <argument><expr><name>pTableListInfo</name></expr></argument>, <argument><expr><name>pTagCond</name></expr></argument>, <argument><expr><name>pTagIndexCond</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"failed to createScanTableListInfo, code: %s"</literal></expr></argument>, <argument><expr><call><name>tstrerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>extractTableSchemaInfo</name><argument_list>(<argument><expr><name>pHandle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTableScanNode</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>terrno</name></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>pOperator</name> <operator>=</operator> <call><name>createTableMergeScanOperatorInfo</name><argument_list>(<argument><expr><name>pTableScanNode</name></expr></argument>, <argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pOperator</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>terrno</name></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>STableScanInfo</name><modifier>*</modifier></type> <name>pScanInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>pRecoder</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>pScanInfo</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>readRecorder</name></name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_EXCHANGE</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>pOperator</name> <operator>=</operator> <call><name>createExchangeOperatorInfo</name><argument_list>(<argument><expr><ternary><condition><expr><name>pHandle</name></expr> ?</condition><then> <expr><name><name>pHandle</name><operator>-&gt;</operator><name>pMsgCb</name><operator>-&gt;</operator><name>clientRpc</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><operator>(</operator><name>SExchangePhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>,
                                             <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SCAN</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>STableScanPhysiNode</name><modifier>*</modifier></type> <name>pTableScanNode</name> <init>= <expr><operator>(</operator><name>STableScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pHandle</name><operator>-&gt;</operator><name>vnode</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>=
            <expr><call><name>createScanTableListInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTableScanNode</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>, <argument><expr><name><name>pTableScanNode</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>, <argument><expr><name><name>pTableScanNode</name><operator>-&gt;</operator><name>groupSort</name></name></expr></argument>,
                                    <argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>pTableListInfo</name></expr></argument>, <argument><expr><name>pTagCond</name></expr></argument>, <argument><expr><name>pTagIndexCond</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"failed to createScanTableListInfo, code: %s"</literal></expr></argument>, <argument><expr><call><name>tstrerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>sz</name> <init>= <expr><call><name>tableListGetSize</name><argument_list>(<argument><expr><name>pTableListInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>qDebug</name><argument_list>(<argument><expr><literal type="string">"create stream task, total:%d"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>STableKeyInfo</name><modifier>*</modifier></type> <name>pKeyInfo</name> <init>= <expr><call><name>tableListGetInfo</name><argument_list>(<argument><expr><name>pTableListInfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>qDebug</name><argument_list>(<argument><expr><literal type="string">"add table uid:%"</literal> <name>PRIu64</name> <literal type="string">", gid:%"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>, <argument><expr><name><name>pKeyInfo</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>schemaInfo</name><operator>.</operator><name>qsw</name></name> <operator>=</operator> <call><name>extractQueriedColumnSchema</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTableScanNode</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOperator</name> <operator>=</operator> <call><name>createStreamScanOperatorInfo</name><argument_list>(<argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>pTableScanNode</name></expr></argument>, <argument><expr><name>pTagCond</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_SYSTABLE_SCAN</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>SSystemTableScanPhysiNode</name><modifier>*</modifier></type> <name>pSysScanPhyNode</name> <init>= <expr><operator>(</operator><name>SSystemTableScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pOperator</name> <operator>=</operator> <call><name>createSysTableScanOperatorInfo</name><argument_list>(<argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>pSysScanPhyNode</name></expr></argument>, <argument><expr><name>pUser</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_TABLE_COUNT_SCAN</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>STableCountScanPhysiNode</name><modifier>*</modifier></type> <name>pTblCountScanNode</name> <init>= <expr><operator>(</operator><name>STableCountScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pOperator</name> <operator>=</operator> <call><name>createTableCountScanOperatorInfo</name><argument_list>(<argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>pTblCountScanNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_TAG_SCAN</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>STagScanPhysiNode</name><modifier>*</modifier></type> <name>pScanPhyNode</name> <init>= <expr><operator>(</operator><name>STagScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>createScanTableListInfo</name><argument_list>(<argument><expr><name>pScanPhyNode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>pTableListInfo</name></expr></argument>, <argument><expr><name>pTagCond</name></expr></argument>,
                                             <argument><expr><name>pTagIndexCond</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"failed to getTableList, code: %s"</literal></expr></argument>, <argument><expr><call><name>tstrerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>pOperator</name> <operator>=</operator> <call><name>createTagScanOperatorInfo</name><argument_list>(<argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>pScanPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_BLOCK_DIST_SCAN</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>SBlockDistScanPhysiNode</name><modifier>*</modifier></type> <name>pBlockNode</name> <init>= <expr><operator>(</operator><name>SBlockDistScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>pBlockNode</name><operator>-&gt;</operator><name>tableType</name></name> <operator>==</operator> <name>TSDB_SUPER_TABLE</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>SArray</name><modifier>*</modifier></type> <name>pList</name> <init>= <expr><call><name>taosArrayInit</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STableKeyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>vnodeGetAllTableList</name><argument_list>(<argument><expr><name><name>pHandle</name><operator>-&gt;</operator><name>vnode</name></name></expr></argument>, <argument><expr><name><name>pBlockNode</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>terrno</name></expr>;</expr_stmt>
          <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>size_t</name></type> <name>num</name> <init>= <expr><call><name>taosArrayGetSize</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>STableKeyInfo</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><call><name>taosArrayGet</name><argument_list>(<argument><expr><name>pList</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>tableListAddTableInfo</name><argument_list>(<argument><expr><name>pTableListInfo</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>taosArrayDestroy</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="line">// Create group with only one table</comment>
        <expr_stmt><expr><call><name>tableListAddTableInfo</name><argument_list>(<argument><expr><name>pTableListInfo</name></expr></argument>, <argument><expr><name><name>pBlockNode</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>pOperator</name> <operator>=</operator> <call><name>createDataBlockInfoScanOperator</name><argument_list>(<argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>pBlockNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_LAST_ROW_SCAN</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>SLastRowScanPhysiNode</name><modifier>*</modifier></type> <name>pScanNode</name> <init>= <expr><operator>(</operator><name>SLastRowScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>createScanTableListInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pScanNode</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>, <argument><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>pTableListInfo</name></expr></argument>,
                                             <argument><expr><name>pTagCond</name></expr></argument>, <argument><expr><name>pTagIndexCond</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>extractTableSchemaInfo</name><argument_list>(<argument><expr><name>pHandle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pScanNode</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>pOperator</name> <operator>=</operator> <call><name>createCacherowsScanOperator</name><argument_list>(<argument><expr><name>pScanNode</name></expr></argument>, <argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_PROJECT</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>pOperator</name> <operator>=</operator> <call><name>createProjectOperatorInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>SProjectPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>pOperator</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pOperator</name><operator>-&gt;</operator><name>resultDataBlockId</name></name> <operator>=</operator> <name><name>pPhyNode</name><operator>-&gt;</operator><name>pOutputDataBlockDesc</name><operator>-&gt;</operator><name>dataBlockId</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>pOperator</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>size_t</name></type>          <name>size</name> <init>= <expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SOperatorInfo</name><modifier>*</modifier><modifier>*</modifier></type> <name>ops</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>POINTER_BYTES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>ops</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SPhysiNode</name><modifier>*</modifier></type> <name>pChildNode</name> <init>= <expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pPhyNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ops</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>createOperatorTree</name><argument_list>(<argument><expr><name>pChildNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>, <argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name>pTagCond</name></expr></argument>, <argument><expr><name>pTagIndexCond</name></expr></argument>, <argument><expr><name>pUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ops</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <decl_stmt><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_PROJECT</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createProjectOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>SProjectPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_HASH_AGG</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SAggPhysiNode</name><modifier>*</modifier></type> <name>pAggNode</name> <init>= <expr><operator>(</operator><name>SAggPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pAggNode</name><operator>-&gt;</operator><name>pGroupKeys</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createGroupOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pAggNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createAggregateOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pAggNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_HASH_INTERVAL</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SIntervalPhysiNode</name><modifier>*</modifier></type> <name>pIntervalPhyNode</name> <init>= <expr><operator>(</operator><name>SIntervalPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>isStream</name> <init>= <expr><operator>(</operator><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_INTERVAL</name> <operator>==</operator> <name>type</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createIntervalOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pIntervalPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>, <argument><expr><name>isStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_INTERVAL</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createStreamIntervalOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_ALIGNED_INTERVAL</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SMergeAlignedIntervalPhysiNode</name><modifier>*</modifier></type> <name>pIntervalPhyNode</name> <init>= <expr><operator>(</operator><name>SMergeAlignedIntervalPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createMergeAlignedIntervalOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pIntervalPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_INTERVAL</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SMergeIntervalPhysiNode</name><modifier>*</modifier></type> <name>pIntervalPhyNode</name> <init>= <expr><operator>(</operator><name>SMergeIntervalPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createMergeIntervalOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pIntervalPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SEMI_INTERVAL</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>children</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createStreamFinalIntervalOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_FINAL_INTERVAL</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>children</name> <init>= <expr><name><name>pHandle</name><operator>-&gt;</operator><name>numOfVgroups</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createStreamFinalIntervalOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_SORT</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createSortOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>SSortPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_GROUP_SORT</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createGroupSortOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>SGroupSortPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SMergePhysiNode</name><modifier>*</modifier></type> <name>pMergePhyNode</name> <init>= <expr><operator>(</operator><name>SMergePhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createMultiwayMergeOperatorInfo</name><argument_list>(<argument><expr><name>ops</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>pMergePhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_SESSION</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SSessionWinodwPhysiNode</name><modifier>*</modifier></type> <name>pSessionNode</name> <init>= <expr><operator>(</operator><name>SSessionWinodwPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createSessionAggOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pSessionNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SESSION</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createStreamSessionAggOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SEMI_SESSION</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>children</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createStreamFinalSessionAggOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_FINAL_SESSION</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>children</name> <init>= <expr><name><name>pHandle</name><operator>-&gt;</operator><name>numOfVgroups</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createStreamFinalSessionAggOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_PARTITION</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createPartitionOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>SPartitionPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_PARTITION</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createStreamPartitionOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>SStreamPartitionPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_STATE</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SStateWinodwPhysiNode</name><modifier>*</modifier></type> <name>pStateNode</name> <init>= <expr><operator>(</operator><name>SStateWinodwPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createStatewindowOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pStateNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_STATE</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createStreamStateAggOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_MERGE_JOIN</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createMergeJoinOperatorInfo</name><argument_list>(<argument><expr><name>ops</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>(</operator><name>SSortMergeJoinPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_FILL</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createFillOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>SFillPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_STREAM_FILL</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createStreamFillOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>SStreamFillPhysiNode</name><operator>*</operator><operator>)</operator><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_INDEF_ROWS_FUNC</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createIndefinitOutputOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_INTERP_FUNC</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pOptr</name> <operator>=</operator> <call><name>createTimeSliceOperatorInfo</name><argument_list>(<argument><expr><name><name>ops</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pPhyNode</name></expr></argument>, <argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pOptr</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pOptr</name><operator>-&gt;</operator><name>resultDataBlockId</name></name> <operator>=</operator> <name><name>pPhyNode</name><operator>-&gt;</operator><name>pOutputDataBlockDesc</name><operator>-&gt;</operator><name>dataBlockId</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>pOptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>extractTbscanInStreamOpTree</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><name>STableScanInfo</name><modifier>*</modifier><modifier>*</modifier></type> <name>ppInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pOperator</name><operator>-&gt;</operator><name>operatorType</name></name> <operator>!=</operator> <name>QUERY_NODE_PHYSICAL_PLAN_STREAM_SCAN</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pOperator</name><operator>-&gt;</operator><name>numOfDownstream</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"failed to find stream scan operator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_APP_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pOperator</name><operator>-&gt;</operator><name>numOfDownstream</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"join not supported for stream block scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_APP_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>extractTbscanInStreamOpTree</name><argument_list>(<argument><expr><name><name>pOperator</name><operator>-&gt;</operator><name>pDownstream</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ppInfo</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>SStreamScanInfo</name><modifier>*</modifier></type> <name>pInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>info</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pTableScanOp</name><operator>-&gt;</operator><name>operatorType</name></name> <operator>==</operator> <name>QUERY_NODE_PHYSICAL_PLAN_TABLE_SCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppInfo</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pTableScanOp</name><operator>-&gt;</operator><name>info</name></name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>extractTableScanNode</name><parameter_list>(<parameter><decl><type><name>SPhysiNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>STableScanPhysiNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>ppNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_PHYSICAL_PLAN_TABLE_SCAN</name> <operator>==</operator> <name><name>pNode</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppNode</name> <operator>=</operator> <operator>(</operator><name>STableScanPhysiNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_APP_ERROR</name></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name>TSDB_CODE_APP_ERROR</name></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>SPhysiNode</name><modifier>*</modifier></type> <name>pChildNode</name> <init>= <expr><operator>(</operator><name>SPhysiNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>extractTableScanNode</name><argument_list>(<argument><expr><name>pChildNode</name></expr></argument>, <argument><expr><name>ppNode</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
int32_t rebuildReader(SOperatorInfo* pOperator, SSubplan* plan, SReadHandle* pHandle, int64_t uid, int64_t ts) {
  STableScanInfo* pTableScanInfo = NULL;
  if (extractTbscanInStreamOpTree(pOperator, &amp;pTableScanInfo) &lt; 0) {
    return -1;
  }

  STableScanPhysiNode* pNode = NULL;
  if (extractTableScanNode(plan-&gt;pNode, &amp;pNode) &lt; 0) {
    ASSERT(0);
  }

  tsdbReaderClose(pTableScanInfo-&gt;dataReader);

  STableListInfo info = {0};
  pTableScanInfo-&gt;dataReader = doCreateDataReader(pNode, pHandle, &amp;info, NULL);
  if (pTableScanInfo-&gt;dataReader == NULL) {
    ASSERT(0);
    qError("failed to create data reader");
    return TSDB_CODE_APP_ERROR;
  }
  <comment type="line">// TODO: set uid and ts to data reader</comment>
  return 0;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int32_t</name></type> <name>createDataSinkParam</name><parameter_list>(<parameter><decl><type><name>SDataSinkNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier><modifier>*</modifier></type> <name>pParam</name></decl></parameter>, <parameter><decl><type><name>qTaskInfo_t</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>, <parameter><decl><type><name>SReadHandle</name><modifier>*</modifier></type> <name>readHandle</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTask</name> <init>= <expr><operator>*</operator><operator>(</operator><name>SExecTaskInfo</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pTaskInfo</name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name><name>pNode</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_QUERY_INSERT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SInserterParam</name><modifier>*</modifier></type> <name>pInserterParam</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SInserterParam</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pInserterParam</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pInserterParam</name><operator>-&gt;</operator><name>readHandle</name></name> <operator>=</operator> <name>readHandle</name></expr>;</expr_stmt>

      <expr_stmt><expr><operator>*</operator><name>pParam</name> <operator>=</operator> <name>pInserterParam</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_PHYSICAL_PLAN_DELETE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SDeleterParam</name><modifier>*</modifier></type> <name>pDeleterParam</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SDeleterParam</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pDeleterParam</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>tbNum</name> <init>= <expr><call><name>tableListGetSize</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pTableInfoList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pDeleterParam</name><operator>-&gt;</operator><name>suid</name></name> <operator>=</operator> <call><name>tableListGetSuid</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pTableInfoList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// TODO extract uid list</comment>
      <expr_stmt><expr><name><name>pDeleterParam</name><operator>-&gt;</operator><name>pUidList</name></name> <operator>=</operator> <call><name>taosArrayInit</name><argument_list>(<argument><expr><name>tbNum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pDeleterParam</name><operator>-&gt;</operator><name>pUidList</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pDeleterParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tbNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>STableKeyInfo</name><modifier>*</modifier></type> <name>pTable</name> <init>= <expr><call><name>tableListGetInfo</name><argument_list>(<argument><expr><name><name>pTask</name><operator>-&gt;</operator><name>pTableInfoList</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>taosArrayPush</name><argument_list>(<argument><expr><name><name>pDeleterParam</name><operator>-&gt;</operator><name>pUidList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pTable</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>

      <expr_stmt><expr><operator>*</operator><name>pParam</name> <operator>=</operator> <name>pDeleterParam</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>createExecTaskInfoImpl</name><parameter_list>(<parameter><decl><type><name>SSubplan</name><modifier>*</modifier></type> <name>pPlan</name></decl></parameter>, <parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>, <parameter><decl><type><name>SReadHandle</name><modifier>*</modifier></type> <name>pHandle</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>taskId</name></decl></parameter>,
                               <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>sql</name></decl></parameter>, <parameter><decl><type><name>EOPTR_EXEC_MODEL</name></type> <name>model</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>queryId</name> <init>= <expr><name><name>pPlan</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>queryId</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pTaskInfo</name> <operator>=</operator> <call><name>createExecTaskInfo</name><argument_list>(<argument><expr><name>queryId</name></expr></argument>, <argument><expr><name>taskId</name></expr></argument>, <argument><expr><name>model</name></expr></argument>, <argument><expr><name><name>pPlan</name><operator>-&gt;</operator><name>dbFName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pTaskInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <goto>goto <name>_complete</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>pHandle</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/*(*pTaskInfo)-&gt;streamInfo.fillHistoryVer1 = pHandle-&gt;fillHistoryVer1;*/</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pHandle</name><operator>-&gt;</operator><name>pStateBackend</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pTaskInfo</name><operator>)</operator><operator>-&gt;</operator><name><name>streamInfo</name><operator>.</operator><name>pState</name></name></name> <operator>=</operator> <name><name>pHandle</name><operator>-&gt;</operator><name>pStateBackend</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pTaskInfo</name><operator>)</operator><operator>-&gt;</operator><name>sql</name></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sql</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pTaskInfo</name><operator>)</operator><operator>-&gt;</operator><name>pSubplan</name></name> <operator>=</operator> <name>pPlan</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pTaskInfo</name><operator>)</operator><operator>-&gt;</operator><name>pRoot</name></name> <operator>=</operator>
      <call><name>createOperatorTree</name><argument_list>(<argument><expr><name><name>pPlan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><operator>*</operator><name>pTaskInfo</name></expr></argument>, <argument><expr><name>pHandle</name></expr></argument>, <argument><expr><name><name>pPlan</name><operator>-&gt;</operator><name>pTagCond</name></name></expr></argument>, <argument><expr><name><name>pPlan</name><operator>-&gt;</operator><name>pTagIndexCond</name></name></expr></argument>, <argument><expr><name><name>pPlan</name><operator>-&gt;</operator><name>user</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><operator>(</operator><operator>*</operator><name>pTaskInfo</name><operator>)</operator><operator>-&gt;</operator><name>pRoot</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>terrno</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>pTaskInfo</name><operator>)</operator><operator>-&gt;</operator><name>code</name></name></expr>;</expr_stmt>
    <goto>goto <name>_complete</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pTaskInfo</name><operator>)</operator><operator>-&gt;</operator><name><name>cost</name><operator>.</operator><name>created</name></name></name> <operator>=</operator> <call><name>taosGetTimestampUs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>

<label><name>_complete</name>:</label>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>doDestroyTask</name><argument_list>(<argument><expr><operator>*</operator><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>terrno</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>freeBlock</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pParam</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name> <init>= <expr><operator>*</operator><operator>(</operator><name>SSDataBlock</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pParam</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>blockDataDestroy</name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>doDestroyTask</name><parameter_list>(<parameter><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type> <name>pTaskInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>qDebug</name><argument_list>(<argument><expr><literal type="string">"%s execTask is freed"</literal></expr></argument>, <argument><expr><call><name>GET_TASKID</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>pTableInfoList</name></name> <operator>=</operator> <call><name>tableListDestroy</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>pTableInfoList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>destroyOperatorInfo</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>pRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cleanupTableSchemaInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTaskInfo</name><operator>-&gt;</operator><name>schemaInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>cleanupStreamInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pTaskInfo</name><operator>-&gt;</operator><name>streamInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pTaskInfo</name><operator>-&gt;</operator><name>localFetch</name><operator>.</operator><name>localExec</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pTaskInfo</name><operator>-&gt;</operator><name>pSubplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>taosArrayDestroyEx</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>pResultBlockList</name></name></expr></argument>, <argument><expr><name>freeBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosArrayDestroy</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>stopInfo</name><operator>.</operator><name>pStopInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFreeClear</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>getQuerySupportBufSize</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>numOfTables</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>s1</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>STableQueryInfo</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <comment type="line">//  size_t s3 = sizeof(STableCheckInfo);  buffer consumption in tsdb</comment>
  <return>return <expr><operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><name>s1</name> <operator>*</operator> <literal type="number">1.5</literal> <operator>*</operator> <name>numOfTables</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>checkForQueryBuf</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>numOfTables</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>t</name> <init>= <expr><call><name>getQuerySupportBufSize</name><argument_list>(<argument><expr><name>numOfTables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>tsQueryBufferSizeBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsQueryBufferSizeBytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>s</name> <init>= <expr><name>tsQueryBufferSizeBytes</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int64_t</name></type> <name>remain</name> <init>= <expr><name>s</name> <operator>-</operator> <name>t</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>remain</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>atomic_val_compare_exchange_64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsQueryBufferSizeBytes</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>remain</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>s</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>TSDB_CODE_QRY_NOT_ENOUGH_BUFFER</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// disable query processing if the value of tsQueryBufferSize is zero.</comment>
  <return>return <expr><name>TSDB_CODE_QRY_NOT_ENOUGH_BUFFER</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>releaseQueryBuf</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>numOfTables</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>tsQueryBufferSizeBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int64_t</name></type> <name>t</name> <init>= <expr><call><name>getQuerySupportBufSize</name><argument_list>(<argument><expr><name>numOfTables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// restore value is not enough buffer available</comment>
  <expr_stmt><expr><call><name>atomic_add_fetch_64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsQueryBufferSizeBytes</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>getOperatorExplainExecInfo</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>operatorInfo</name></decl></parameter>, <parameter><decl><type><name>SArray</name><modifier>*</modifier></type> <name>pExecInfoList</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExplainExecInfo</name></type>  <name>execInfo</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SExplainExecInfo</name><modifier>*</modifier></type> <name>pExplainInfo</name> <init>= <expr><call><name>taosArrayPush</name><argument_list>(<argument><expr><name>pExecInfoList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>execInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pExplainInfo</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>=</operator> <name><name>operatorInfo</name><operator>-&gt;</operator><name>resultInfo</name><operator>.</operator><name>totalRows</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExplainInfo</name><operator>-&gt;</operator><name>startupCost</name></name> <operator>=</operator> <name><name>operatorInfo</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>openCost</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExplainInfo</name><operator>-&gt;</operator><name>totalCost</name></name> <operator>=</operator> <name><name>operatorInfo</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>totalCost</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExplainInfo</name><operator>-&gt;</operator><name>verboseLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExplainInfo</name><operator>-&gt;</operator><name>verboseInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>operatorInfo</name><operator>-&gt;</operator><name>fpSet</name><operator>.</operator><name>getExplainFn</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>=
        <expr><call><name><name>operatorInfo</name><operator>-&gt;</operator><name>fpSet</name><operator>.</operator><name>getExplainFn</name></name><argument_list>(<argument><expr><name>operatorInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pExplainInfo</name><operator>-&gt;</operator><name>verboseInfo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pExplainInfo</name><operator>-&gt;</operator><name>verboseLen</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"%s operator getExplainFn failed, code:%s"</literal></expr></argument>, <argument><expr><call><name>GET_TASKID</name><argument_list>(<argument><expr><name><name>operatorInfo</name><operator>-&gt;</operator><name>pTaskInfo</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tstrerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>operatorInfo</name><operator>-&gt;</operator><name>numOfDownstream</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>getOperatorExplainExecInfo</name><argument_list>(<argument><expr><name><name>operatorInfo</name><operator>-&gt;</operator><name>pDownstream</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pExecInfoList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TSDB_CODE_SUCCESS</name></expr>)</condition> <block>{<block_content>
      <comment type="line">//      taosMemoryFreeClear(*pRes);</comment>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>setOutputBuf</name><parameter_list>(<parameter><decl><type><name>SStreamState</name><modifier>*</modifier></type> <name>pState</name></decl></parameter>, <parameter><decl><type><name>STimeWindow</name><modifier>*</modifier></type> <name>win</name></decl></parameter>, <parameter><decl><type><name>SResultRow</name><modifier>*</modifier><modifier>*</modifier></type> <name>pResult</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>tableGroupId</name></decl></parameter>,
                     <parameter><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>numOfOutput</name></decl></parameter>, <parameter><decl><type><name>int32_t</name><modifier>*</modifier></type> <name>rowEntryInfoOffset</name></decl></parameter>, <parameter><decl><type><name>SAggSupporter</name><modifier>*</modifier></type> <name>pAggSup</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SWinKey</name></type> <name>key</name> <init>= <expr><block>{
      <expr><operator>.</operator><name>ts</name> <operator>=</operator> <name><name>win</name><operator>-&gt;</operator><name>skey</name></name></expr>,
      <expr><operator>.</operator><name>groupId</name> <operator>=</operator> <name>tableGroupId</name></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>   <name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>size</name> <init>= <expr><name><name>pAggSup</name><operator>-&gt;</operator><name>resultRowSize</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>streamStateAddIfNotExist</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <operator>(</operator><name>SResultRow</name><operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>pResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// set time window for current result</comment>
  <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pResult</name><operator>)</operator><operator>-&gt;</operator><name>win</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>win</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setResultRowInitCtx</name><argument_list>(<argument><expr><operator>*</operator><name>pResult</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>numOfOutput</name></expr></argument>, <argument><expr><name>rowEntryInfoOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>releaseOutputBuf</name><parameter_list>(<parameter><decl><type><name>SStreamState</name><modifier>*</modifier></type> <name>pState</name></decl></parameter>, <parameter><decl><type><name>SWinKey</name><modifier>*</modifier></type> <name>pKey</name></decl></parameter>, <parameter><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pResult</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>streamStateReleaseBuf</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>pResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>saveOutputBuf</name><parameter_list>(<parameter><decl><type><name>SStreamState</name><modifier>*</modifier></type> <name>pState</name></decl></parameter>, <parameter><decl><type><name>SWinKey</name><modifier>*</modifier></type> <name>pKey</name></decl></parameter>, <parameter><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pResult</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>resSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>streamStatePut</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>pResult</name></expr></argument>, <argument><expr><name>resSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>buildDataBlockFromGroupRes</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><name>SStreamState</name><modifier>*</modifier></type> <name>pState</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>, <parameter><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pSup</name></decl></parameter>,
                                   <parameter><decl><type><name>SGroupResInfo</name><modifier>*</modifier></type> <name>pGroupResInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type>  <name>pTaskInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>pTaskInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SExprInfo</name><modifier>*</modifier></type>      <name>pExprInfo</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>pExprInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>         <name>numOfExprs</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>numOfExprs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name><modifier>*</modifier></type>        <name>rowEntryOffset</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>rowEntryInfoOffset</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>pCtx</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfRows</name> <init>= <expr><call><name>getNumOfTotalRes</name><argument_list>(<argument><expr><name>pGroupResInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SResKeyPos</name><modifier>*</modifier></type> <name>pPos</name> <init>= <expr><call><name>taosArrayGetP</name><argument_list>(<argument><expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>pRows</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type>     <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type>       <name>pVal</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SWinKey</name></type>     <name>key</name> <init>= <expr><block>{
            <expr><operator>.</operator><name>ts</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>TSKEY</name><operator>*</operator><operator>)</operator><name><name>pPos</name><operator>-&gt;</operator><name>key</name></name></expr>,
            <expr><operator>.</operator><name>groupId</name> <operator>=</operator> <name><name>pPos</name><operator>-&gt;</operator><name>groupId</name></name></expr>,
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>streamStateGet</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>code</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pRow</name> <init>= <expr><operator>(</operator><name>SResultRow</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>doUpdateNumOfRows</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>, <argument><expr><name>numOfExprs</name></expr></argument>, <argument><expr><name>rowEntryOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// no results, continue to check the next one</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>index</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releaseOutputBuf</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <name><name>pPos</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>tbname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>streamStateGetParName</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>streamInfo</name><operator>.</operator><name>pState</name></name></expr></argument>, <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tbname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>parTbName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>parTbName</name></name></expr></argument>, <argument><expr><name>tbname</name></expr></argument>, <argument><expr><name>TSDB_TABLE_NAME_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>tdbFree</name><argument_list>(<argument><expr><name>tbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="line">// current value belongs to different group, it can't be packed into one datablock</comment>
      <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>!=</operator> <name><name>pPos</name><operator>-&gt;</operator><name>groupId</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>releaseOutputBuf</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>+</operator> <name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&gt;</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>capacity</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releaseOutputBuf</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>index</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numOfExprs</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>slotId</name> <init>= <expr><name><name>pExprInfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>base</name><operator>.</operator><name>resSchema</name><operator>.</operator><name>slotId</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>resultInfo</name> <operator>=</operator> <call><name>getResultEntryInfo</name><argument_list>(<argument><expr><name>pRow</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>rowEntryOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>fpSet</name><operator>.</operator><name>finalize</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>code1</name> <init>= <expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><call><name><name>fpSet</name><operator>.</operator><name>finalize</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>TAOS_FAILED</name><argument_list>(<argument><expr><name>code1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"%s build result data block error, code %s"</literal></expr></argument>, <argument><expr><call><name>GET_TASKID</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tstrerror</name><argument_list>(<argument><expr><name>code1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>T_LONG_JMP</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><name>code1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>_function</name><operator>.</operator><name>functionName</name></name></expr></argument>, <argument><expr><literal type="string">"_select_value"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// do nothing, todo refactor</comment>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// expand the result into multiple rows. E.g., _wstart, top(k, 20)</comment>
        <comment type="line">// the _wstart needs to copy to 20 following rows, since the results of top-k expands to 20 different rows.</comment>
        <decl_stmt><decl><type><name>SColumnInfoData</name><modifier>*</modifier></type> <name>pColInfoData</name> <init>= <expr><call><name>taosArrayGet</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>, <argument><expr><name>slotId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>            <name>in</name> <init>= <expr><call><name>GET_ROWCELL_INTERBUF</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>resultInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pColInfoData</name></expr></argument>, <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>+</operator> <name>k</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>resultInfo</name><operator>-&gt;</operator><name>isNullRes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releaseOutputBuf</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>blockDataUpdateTsWindow</name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>saveSessionDiscBuf</name><parameter_list>(<parameter><decl><type><name>SStreamState</name><modifier>*</modifier></type> <name>pState</name></decl></parameter>, <parameter><decl><type><name>SSessionKey</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>streamStateSessionPut</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releaseOutputBuf</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>SResultRow</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>buildSessionResultDataBlock</name><parameter_list>(<parameter><decl><type><name>SOperatorInfo</name><modifier>*</modifier></type> <name>pOperator</name></decl></parameter>, <parameter><decl><type><name>SStreamState</name><modifier>*</modifier></type> <name>pState</name></decl></parameter>, <parameter><decl><type><name>SSDataBlock</name><modifier>*</modifier></type> <name>pBlock</name></decl></parameter>,
                                    <parameter><decl><type><name>SExprSupp</name><modifier>*</modifier></type> <name>pSup</name></decl></parameter>, <parameter><decl><type><name>SGroupResInfo</name><modifier>*</modifier></type> <name>pGroupResInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExecTaskInfo</name><modifier>*</modifier></type>  <name>pTaskInfo</name> <init>= <expr><name><name>pOperator</name><operator>-&gt;</operator><name>pTaskInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SExprInfo</name><modifier>*</modifier></type>      <name>pExprInfo</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>pExprInfo</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>         <name>numOfExprs</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>numOfExprs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name><modifier>*</modifier></type>        <name>rowEntryOffset</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>rowEntryInfoOffset</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SqlFunctionCtx</name><modifier>*</modifier></type> <name>pCtx</name> <init>= <expr><name><name>pSup</name><operator>-&gt;</operator><name>pCtx</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>numOfRows</name> <init>= <expr><call><name>getNumOfTotalRes</name><argument_list>(<argument><expr><name>pGroupResInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfRows</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>SSessionKey</name><modifier>*</modifier></type> <name>pKey</name> <init>= <expr><call><name>taosArrayGet</name><argument_list>(<argument><expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>pRows</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type>      <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type>        <name>pVal</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type>      <name>code</name> <init>= <expr><call><name>streamStateSessionGet</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>code</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <comment type="line">// coverity scan</comment>
      <expr_stmt><expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>index</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>SResultRow</name><modifier>*</modifier></type> <name>pRow</name> <init>= <expr><operator>(</operator><name>SResultRow</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>doUpdateNumOfRows</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>, <argument><expr><name>numOfExprs</name></expr></argument>, <argument><expr><name>rowEntryOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// no results, continue to check the next one</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>index</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releaseOutputBuf</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <name><name>pKey</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>tbname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>streamStateGetParName</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>streamInfo</name><operator>.</operator><name>pState</name></name></expr></argument>, <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tbname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>parTbName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>parTbName</name></name></expr></argument>, <argument><expr><name>tbname</name></expr></argument>, <argument><expr><name>TSDB_TABLE_NAME_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>tdbFree</name><argument_list>(<argument><expr><name>tbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <comment type="line">// current value belongs to different group, it can't be packed into one datablock</comment>
      <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>!=</operator> <name><name>pKey</name><operator>-&gt;</operator><name>groupId</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>releaseOutputBuf</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>+</operator> <name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name> <operator>&gt;</operator> <name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>capacity</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releaseOutputBuf</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pGroupResInfo</name><operator>-&gt;</operator><name>index</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numOfExprs</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>slotId</name> <init>= <expr><name><name>pExprInfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>base</name><operator>.</operator><name>resSchema</name><operator>.</operator><name>slotId</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>resultInfo</name> <operator>=</operator> <call><name>getResultEntryInfo</name><argument_list>(<argument><expr><name>pRow</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>rowEntryOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>fpSet</name><operator>.</operator><name>finalize</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>code1</name> <init>= <expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><call><name><name>fpSet</name><operator>.</operator><name>finalize</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>TAOS_FAILED</name><argument_list>(<argument><expr><name>code1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>qError</name><argument_list>(<argument><expr><literal type="string">"%s build result data block error, code %s"</literal></expr></argument>, <argument><expr><call><name>GET_TASKID</name><argument_list>(<argument><expr><name>pTaskInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tstrerror</name><argument_list>(<argument><expr><name>code1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>T_LONG_JMP</name><argument_list>(<argument><expr><name><name>pTaskInfo</name><operator>-&gt;</operator><name>env</name></name></expr></argument>, <argument><expr><name>code1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>pExpr</name><operator>-&gt;</operator><name>pExpr</name><operator>-&gt;</operator><name>_function</name><operator>.</operator><name>functionName</name></name></expr></argument>, <argument><expr><literal type="string">"_select_value"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// do nothing, todo refactor</comment>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// expand the result into multiple rows. E.g., _wstart, top(k, 20)</comment>
        <comment type="line">// the _wstart needs to copy to 20 following rows, since the results of top-k expands to 20 different rows.</comment>
        <decl_stmt><decl><type><name>SColumnInfoData</name><modifier>*</modifier></type> <name>pColInfoData</name> <init>= <expr><call><name>taosArrayGet</name><argument_list>(<argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>pDataBlock</name></name></expr></argument>, <argument><expr><name>slotId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>            <name>in</name> <init>= <expr><call><name>GET_ROWCELL_INTERBUF</name><argument_list>(<argument><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>resultInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
          <expr_stmt><expr><call><name>colDataAppend</name><argument_list>(<argument><expr><name>pColInfoData</name></expr></argument>, <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>+</operator> <name>k</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name><name>pCtx</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>resultInfo</name><operator>-&gt;</operator><name>isNullRes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>pBlock</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>pRow</name><operator>-&gt;</operator><name>numOfRows</name></name></expr>;</expr_stmt>
    <comment type="line">// saveSessionDiscBuf(pState, pKey, pVal, size);</comment>
    <expr_stmt><expr><call><name>releaseOutputBuf</name><argument_list>(<argument><expr><name>pState</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>blockDataUpdateTsWindow</name><argument_list>(<argument><expr><name>pBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>
</unit>
