<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/source/libs/planner/src/planUtil.c"><comment type="block">/*
 * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the GNU Affero General Public License, version 3
 * or later ("AGPL"), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"functionMgt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planInt.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>getUsageErrFormat</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>errCode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>errCode</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_CODE_PLAN_EXPECTED_TS_EQUAL</name></expr>:</case>
      <return>return <expr><literal type="string">"left.ts = right.ts is expected in join expression"</literal></expr>;</return>
    <case>case <expr><name>TSDB_CODE_PLAN_NOT_SUPPORT_CROSS_JOIN</name></expr>:</case>
      <return>return <expr><literal type="string">"not support cross join"</literal></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><literal type="string">"Unknown error"</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>generateUsageErrMsg</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>pBuf</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>errCode</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>vArgList</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vArgList</name></expr></argument>, <argument><expr><name>errCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>getUsageErrFormat</name><argument_list>(<argument><expr><name>errCode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vArgList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vArgList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errCode</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SCreateColumnCxt</name> <block>{
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>errCode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl>;</decl_stmt>
}</block></struct></type> <name>SCreateColumnCxt</name>;</typedef>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>doCreateColumn</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SCreateColumnCxt</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><operator>(</operator><name>SCreateColumnCxt</name><operator>*</operator><operator>)</operator><name>pContext</name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_COLUMN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pCol</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><operator>(</operator><ternary><condition><expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <call><name>nodesListAppend</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>DEAL_RES_IGNORE_CHILD</name></expr> </then><else>: <expr><name>DEAL_RES_ERROR</name></expr></else></ternary><operator>)</operator></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_OPERATOR</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_LOGIC_CONDITION</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_FUNCTION</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_CASE_WHEN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SExprNode</name><modifier>*</modifier></type>   <name>pExpr</name> <init>= <expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_COLUMN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pCol</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>resType</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>aliasName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>(</operator><ternary><condition><expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pList</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pCol</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>DEAL_RES_IGNORE_CHILD</name></expr>
                                                                                    </then><else>: <expr><name>DEAL_RES_ERROR</name></expr></else></ternary><operator>)</operator></expr>;</return>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>createColumnByRewriteExprs</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pExprs</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pList</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SCreateColumnCxt</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>, <expr><operator>.</operator><name>pList</name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pList</name> <operator>?</operator> <call><name>nodesMakeList</name><argument_list>()</argument_list></call> <operator>:</operator> <operator>*</operator><name>pList</name><operator>)</operator></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>pList</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>nodesWalkExprs</name><argument_list>(<argument><expr><name>pExprs</name></expr></argument>, <argument><expr><name>doCreateColumn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pList</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pList</name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>createColumnByRewriteExpr</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pExpr</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pList</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SCreateColumnCxt</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>, <expr><operator>.</operator><name>pList</name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pList</name> <operator>?</operator> <call><name>nodesMakeList</name><argument_list>()</argument_list></call> <operator>:</operator> <operator>*</operator><name>pList</name><operator>)</operator></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>pList</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>doCreateColumn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pList</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pList</name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>pList</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>replaceLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pOld</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNew</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pParent</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pOld-&gt;pParent-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pOld</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>REPLACE_NODE</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name><name>pOld</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>TSDB_CODE_PLAN_INTERNAL_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustScanDataRequirement</name><parameter_list>(<parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>SCAN_TYPE_TABLE</name> <operator>!=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>scanType</name></name> <operator>&amp;&amp;</operator> <name>SCAN_TYPE_TABLE_MERGE</name> <operator>!=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>scanType</name></name><operator>)</operator> <operator>||</operator>
      <name>DATA_ORDER_LEVEL_GLOBAL</name> <operator>==</operator> <name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// The lowest sort level of scan output data is DATA_ORDER_LEVEL_IN_BLOCK</comment>
  <if_stmt><if>if <condition>(<expr><name>requirement</name> <operator>&lt;</operator> <name>DATA_ORDER_LEVEL_IN_BLOCK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>requirement</name> <operator>=</operator> <name>DATA_ORDER_LEVEL_IN_BLOCK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>DATA_ORDER_LEVEL_IN_BLOCK</name> <operator>==</operator> <name>requirement</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanType</name></name> <operator>=</operator> <name>SCAN_TYPE_TABLE</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>TSDB_SUPER_TABLE</name> <operator>==</operator> <name><name>pScan</name><operator>-&gt;</operator><name>tableType</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanType</name></name> <operator>=</operator> <name>SCAN_TYPE_TABLE_MERGE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustJoinDataRequirement</name><parameter_list>(<parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// The lowest sort level of join input and output data is DATA_ORDER_LEVEL_GLOBAL</comment>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustAggDataRequirement</name><parameter_list>(<parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// The sort level of agg with group by output data can only be DATA_ORDER_LEVEL_NONE</comment>
  <if_stmt><if>if <condition>(<expr><name>requirement</name> <operator>&gt;</operator> <name>DATA_ORDER_LEVEL_NONE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>NULL</name> <operator>!=</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name> <operator>||</operator> <operator>!</operator><name><name>pAgg</name><operator>-&gt;</operator><name>onlyHasKeepOrderFunc</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>planError</name><argument_list>(
        <argument><expr><literal type="string">"The output of aggregate cannot meet the requirements(%s) of the upper operator. "</literal>
        <literal type="string">"Illegal statement, should be intercepted in parser"</literal></expr></argument>,
        <argument><expr><call><name>dataOrderStr</name><argument_list>(<argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_PLAN_INTERNAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pAgg</name><operator>-&gt;</operator><name>hasTimeLineFunc</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <ternary><condition><expr><name>requirement</name> <operator>&lt;</operator> <name>DATA_ORDER_LEVEL_IN_GROUP</name></expr> ?</condition><then> <expr><name>DATA_ORDER_LEVEL_IN_GROUP</name></expr> </then><else>: <expr><name>requirement</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustProjectDataRequirement</name><parameter_list>(<parameter><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProject</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustIntervalDataRequirement</name><parameter_list>(<parameter><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWindow</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// The lowest sort level of interval output data is DATA_ORDER_LEVEL_IN_GROUP</comment>
  <if_stmt><if>if <condition>(<expr><name>requirement</name> <operator>&lt;</operator> <name>DATA_ORDER_LEVEL_IN_GROUP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>requirement</name> <operator>=</operator> <name>DATA_ORDER_LEVEL_IN_GROUP</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// The sort level of interval input data is always DATA_ORDER_LEVEL_IN_BLOCK</comment>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustSessionDataRequirement</name><parameter_list>(<parameter><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWindow</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>requirement</name> <operator>&lt;=</operator> <name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustStateDataRequirement</name><parameter_list>(<parameter><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWindow</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>requirement</name> <operator>&lt;=</operator> <name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustWindowDataRequirement</name><parameter_list>(<parameter><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWindow</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>pWindow</name><operator>-&gt;</operator><name>winType</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>WINDOW_TYPE_INTERVAL</name></expr>:</case>
      <return>return <expr><call><name>adjustIntervalDataRequirement</name><argument_list>(<argument><expr><name>pWindow</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>WINDOW_TYPE_SESSION</name></expr>:</case>
      <return>return <expr><call><name>adjustSessionDataRequirement</name><argument_list>(<argument><expr><name>pWindow</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>WINDOW_TYPE_STATE</name></expr>:</case>
      <return>return <expr><call><name>adjustStateDataRequirement</name><argument_list>(<argument><expr><name>pWindow</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>TSDB_CODE_PLAN_INTERNAL_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustFillDataRequirement</name><parameter_list>(<parameter><decl><type><name>SFillLogicNode</name><modifier>*</modifier></type> <name>pFill</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>requirement</name> <operator>&lt;=</operator> <name><name>pFill</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pFill</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFill</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustSortDataRequirement</name><parameter_list>(<parameter><decl><type><name>SSortLogicNode</name><modifier>*</modifier></type> <name>pSort</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustPartitionDataRequirement</name><parameter_list>(<parameter><decl><type><name>SPartitionLogicNode</name><modifier>*</modifier></type> <name>pPart</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>DATA_ORDER_LEVEL_GLOBAL</name> <operator>==</operator> <name>requirement</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>planError</name><argument_list>(
        <argument><expr><literal type="string">"The output of partition cannot meet the requirements(%s) of the upper operator. "</literal>
        <literal type="string">"Illegal statement, should be intercepted in parser"</literal></expr></argument>,
        <argument><expr><call><name>dataOrderStr</name><argument_list>(<argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_PLAN_INTERNAL_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pPart</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPart</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator>
      <operator>(</operator><ternary><condition><expr><name>requirement</name> <operator>&gt;=</operator> <name>DATA_ORDER_LEVEL_IN_BLOCK</name></expr> ?</condition><then> <expr><name>DATA_ORDER_LEVEL_GLOBAL</name></expr> </then><else>: <expr><name>DATA_ORDER_LEVEL_NONE</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustIndefRowsDataRequirement</name><parameter_list>(<parameter><decl><type><name>SIndefRowsFuncLogicNode</name><modifier>*</modifier></type> <name>pIndef</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>requirement</name> <operator>&lt;=</operator> <name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>adjustInterpDataRequirement</name><parameter_list>(<parameter><decl><type><name>SInterpFuncLogicNode</name><modifier>*</modifier></type> <name>pInterp</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>requirement</name> <operator>&lt;=</operator> <name><name>pInterp</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pInterp</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInterp</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>requirement</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>adjustLogicNodeDataRequirement</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>EDataOrderLevel</name></type> <name>requirement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustScanDataRequirement</name><argument_list>(<argument><expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_JOIN</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustJoinDataRequirement</name><argument_list>(<argument><expr><operator>(</operator><name>SJoinLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustAggDataRequirement</name><argument_list>(<argument><expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustProjectDataRequirement</name><argument_list>(<argument><expr><operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_VNODE_MODIFY</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_EXCHANGE</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_MERGE</name></expr>:</case>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustWindowDataRequirement</name><argument_list>(<argument><expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_FILL</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustFillDataRequirement</name><argument_list>(<argument><expr><operator>(</operator><name>SFillLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SORT</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustSortDataRequirement</name><argument_list>(<argument><expr><operator>(</operator><name>SSortLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustPartitionDataRequirement</name><argument_list>(<argument><expr><operator>(</operator><name>SPartitionLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_INDEF_ROWS_FUNC</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustIndefRowsDataRequirement</name><argument_list>(<argument><expr><operator>(</operator><name>SIndefRowsFuncLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_INTERP_FUNC</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustInterpDataRequirement</name><argument_list>(<argument><expr><operator>(</operator><name>SInterpFuncLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>, <argument><expr><name>requirement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustLogicNodeDataRequirement</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>requireDataOrder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>
</unit>
