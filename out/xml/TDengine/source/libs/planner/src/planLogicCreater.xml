<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/source/libs/planner/src/planLogicCreater.c"><comment type="block">/*
 * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the GNU Affero General Public License, version 3
 * or later ("AGPL"), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planInt.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"functionMgt.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>SLogicPlanContext</name> <block>{
  <decl_stmt><decl><type><name>SPlanContext</name><modifier>*</modifier></type> <name>pPlanCxt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type>   <name>pCurrRoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>          <name>hasScan</name></decl>;</decl_stmt>
}</block></struct></type> <name>SLogicPlanContext</name>;</typedef>

<typedef>typedef <function_decl><type><name>int32_t</name></type> (<modifier>*</modifier><name>FCreateLogicNode</name>)<parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>int32_t</name></type> (<modifier>*</modifier><name>FCreateSelectLogicNode</name>)<parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>int32_t</name></type> (<modifier>*</modifier><name>FCreateSetOpLogicNode</name>)<parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>SSetOperator</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>int32_t</name></type> (<modifier>*</modifier><name>FCreateDeleteLogicNode</name>)<parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>SDeleteStmt</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>int32_t</name></type> (<modifier>*</modifier><name>FCreateInsertLogicNode</name>)<parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>SInsertStmt</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>doCreateLogicNodeByTable</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTable</name></decl></parameter>,
                                        <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32_t</name></type> <name>createQueryLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pStmt</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct <name>SRewriteExprCxt</name> <block>{
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>errCode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pExprs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name><modifier>*</modifier></type>      <name>pOutputs</name></decl>;</decl_stmt>
}</block></struct></type> <name>SRewriteExprCxt</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setColumnInfo</name><parameter_list>(<parameter><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name></decl></parameter>, <parameter><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>pFunc</name><operator>-&gt;</operator><name>funcType</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>FUNCTION_TYPE_TBNAME</name></expr>:</case>
      <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colType</name></name> <operator>=</operator> <name>COLUMN_TYPE_TBNAME</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FUNCTION_TYPE_WSTART</name></expr>:</case>
      <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colId</name></name> <operator>=</operator> <name>PRIMARYKEY_TIMESTAMP_COL_ID</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colType</name></name> <operator>=</operator> <name>COLUMN_TYPE_WINDOW_START</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FUNCTION_TYPE_WEND</name></expr>:</case>
      <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colId</name></name> <operator>=</operator> <name>PRIMARYKEY_TIMESTAMP_COL_ID</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colType</name></name> <operator>=</operator> <name>COLUMN_TYPE_WINDOW_END</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FUNCTION_TYPE_WDURATION</name></expr>:</case>
      <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colType</name></name> <operator>=</operator> <name>COLUMN_TYPE_WINDOW_DURATION</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>FUNCTION_TYPE_GROUP_KEY</name></expr>:</case>
      <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colType</name></name> <operator>=</operator> <name>COLUMN_TYPE_GROUP_KEY</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>doRewriteExpr</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SRewriteExprCxt</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><operator>(</operator><name>SRewriteExprCxt</name><operator>*</operator><operator>)</operator><name>pContext</name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><operator>*</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_COLUMN</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>pOutputs</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pExpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <macro><name>FOREACH</name><argument_list>(<argument>pExpr</argument>, <argument>pCxt-&gt;pExprs</argument>)</argument_list></macro> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_GROUPING_SET</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>nodesListGetNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SGroupingSetNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>*</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pOutputs</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_OPERATOR</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_LOGIC_CONDITION</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_FUNCTION</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_CASE_WHEN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pExpr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <macro><name>FOREACH</name><argument_list>(<argument>pExpr</argument>, <argument>pCxt-&gt;pExprs</argument>)</argument_list></macro> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_GROUPING_SET</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>pExpr</name> <operator>=</operator> <call><name>nodesListGetNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SGroupingSetNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><operator>*</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_COLUMN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pCol</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <decl_stmt><decl><type><name>SExprNode</name><modifier>*</modifier></type> <name>pToBeRewrittenExpr</name> <init>= <expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>pNode</name><operator>)</operator></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name></name> <operator>=</operator> <name><name>pToBeRewrittenExpr</name><operator>-&gt;</operator><name>resType</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><name><name>pToBeRewrittenExpr</name><operator>-&gt;</operator><name>aliasName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_FUNCTION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>setColumnInfo</name><argument_list>(<argument><expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pExpr</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>*</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>pNode</name> <operator>=</operator> <operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pCol</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>pOutputs</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pOutputs</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <return>return <expr><name>DEAL_RES_IGNORE_CHILD</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>++</operator><name>index</name></expr>;</expr_stmt>
      </block_content>}</block>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>doNameExpr</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_OPERATOR</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_LOGIC_CONDITION</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_FUNCTION</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name><name>aliasName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>, <argument><expr><literal type="string">"#expr_%p"</literal></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>DEAL_RES_IGNORE_CHILD</name></expr>;</return>
    </block_content>}</block>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteExprForSelect</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pExpr</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>ESqlClause</name></type> <name>clause</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>doNameExpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SRewriteExprCxt</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>, <expr><operator>.</operator><name>pExprs</name> <operator>=</operator> <name>NULL</name></expr>, <expr><operator>.</operator><name>pOutputs</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cxt</name><operator>.</operator><name>pExprs</name></name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesRewriteSelectStmt</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>doRewriteExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesClearList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pExprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>cloneRewriteExprs</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pExprs</name></decl></parameter>, <parameter><decl><type><name>bool</name><modifier>*</modifier></type> <name>pOutputs</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pRewriteExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pExpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pExpr</argument>, <argument>pExprs</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pOutputs</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><name>pRewriteExpr</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><operator>*</operator><name>pRewriteExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteExprsForSelect</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pExprs</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>ESqlClause</name></type> <name>clause</name></decl></parameter>,
                                     <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pRewriteExprs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>nodesWalkExprs</name><argument_list>(<argument><expr><name>pExprs</name></expr></argument>, <argument><expr><name>doNameExpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SRewriteExprCxt</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>, <expr><operator>.</operator><name>pExprs</name> <operator>=</operator> <name>pExprs</name></expr>, <expr><operator>.</operator><name>pOutputs</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>pRewriteExprs</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>pOutputs</name></name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name>pExprs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>pOutputs</name></name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>nodesRewriteSelectStmt</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>doRewriteExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name><name>cxt</name><operator>.</operator><name>errCode</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>pRewriteExprs</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name> <operator>=</operator> <call><name>cloneRewriteExprs</name><argument_list>(<argument><expr><name>pExprs</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>pOutputs</name></name></expr></argument>, <argument><expr><name>pRewriteExprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pOutputs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteExpr</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pExprs</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pTarget</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>nodesWalkExprs</name><argument_list>(<argument><expr><name>pExprs</name></expr></argument>, <argument><expr><name>doNameExpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SRewriteExprCxt</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>, <expr><operator>.</operator><name>pExprs</name> <operator>=</operator> <name>pExprs</name></expr>, <expr><operator>.</operator><name>pOutputs</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesRewriteExpr</name><argument_list>(<argument><expr><name>pTarget</name></expr></argument>, <argument><expr><name>doRewriteExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteExprs</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pExprs</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTarget</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>nodesWalkExprs</name><argument_list>(<argument><expr><name>pExprs</name></expr></argument>, <argument><expr><name>doNameExpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SRewriteExprCxt</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>, <expr><operator>.</operator><name>pExprs</name> <operator>=</operator> <name>pExprs</name></expr>, <expr><operator>.</operator><name>pOutputs</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesRewriteExprs</name><argument_list>(<argument><expr><name>pTarget</name></expr></argument>, <argument><expr><name>doRewriteExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOldRoot</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNewRoot</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pNewRoot</name><operator>-&gt;</operator><name>pChildren</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pNewRoot</name><operator>-&gt;</operator><name>pChildren</name></name> <operator>=</operator> <call><name>nodesMakeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pNewRoot</name><operator>-&gt;</operator><name>pChildren</name></name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <call><name>nodesListAppend</name><argument_list>(<argument><expr><name><name>pNewRoot</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><operator>*</operator><name>pOldRoot</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pOldRoot</name><operator>)</operator><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pNewRoot</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pOldRoot</name> <operator>=</operator> <name>pNewRoot</name></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createRootLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pStmt</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>precision</name></decl></parameter>, <parameter><decl><type><name>FCreateLogicNode</name></type> <name>func</name></decl></parameter>,
                                   <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pRoot</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>func</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>pNode</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>precision</name></name> <operator>=</operator> <name>precision</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pCurrRoot</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createSelectRootLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>FCreateSelectLogicNode</name></type> <name>func</name></decl></parameter>,
                                         <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pRoot</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>createRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>precision</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FCreateLogicNode</name><operator>)</operator><name>func</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EScanType</name></type> <name>getScanType</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pScanPseudoCols</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pScanCols</name></decl></parameter>,
                             <parameter><decl><type><name>int8_t</name></type> <name>tableType</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tagScan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>topicQuery</name></name> <operator>||</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>SCAN_TYPE_STREAM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_SYSTEM_TABLE</name> <operator>==</operator> <name>tableType</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>SCAN_TYPE_SYSTEM_TABLE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>tagScan</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>SCAN_TYPE_TAG</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pScanCols</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pScanPseudoCols</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>SCAN_TYPE_TABLE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><name>FUNCTION_TYPE_BLOCK_DIST_INFO</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name>pScanPseudoCols</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>funcType</name></expr>
               ?</condition><then> <expr><name>SCAN_TYPE_BLOCK_INFO</name></expr>
               </then><else>: <expr><name>SCAN_TYPE_TABLE</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SCAN_TYPE_TABLE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>createFirstCol</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>tableId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SSchema</name><modifier>*</modifier></type> <name>pSchema</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_COLUMN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pCol</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>pSchema</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>bytes</name></name> <operator>=</operator> <name><name>pSchema</name><operator>-&gt;</operator><name>bytes</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>tableId</name></name> <operator>=</operator> <name>tableId</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colId</name></name> <operator>=</operator> <name><name>pSchema</name><operator>-&gt;</operator><name>colId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colType</name></name> <operator>=</operator> <name>COLUMN_TYPE_COLUMN</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><name><name>pSchema</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pCol</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>addPrimaryKeyCol</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>tableId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SSchema</name><modifier>*</modifier></type> <name>pSchema</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pCols</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type>   <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pCol</argument>, <argument>*pCols</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>PRIMARYKEY_TIMESTAMP_COL_ID</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pCol</name><operator>)</operator><operator>-&gt;</operator><name>colId</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><name>pCols</name></expr></argument>, <argument><expr><call><name>createFirstCol</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>pSchema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>addSystableFirstCol</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>tableId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SSchema</name><modifier>*</modifier></type> <name>pSchema</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pCols</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><operator>*</operator><name>pCols</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><name>pCols</name></expr></argument>, <argument><expr><call><name>createFirstCol</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>pSchema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>addDefaultScanCol</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>STableMeta</name><modifier>*</modifier></type> <name>pMeta</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pCols</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>TSDB_SYSTEM_TABLE</name> <operator>==</operator> <name><name>pMeta</name><operator>-&gt;</operator><name>tableType</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>addSystableFirstCol</name><argument_list>(<argument><expr><name><name>pMeta</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>, <argument><expr><name><name>pMeta</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name>pCols</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>addPrimaryKeyCol</name><argument_list>(<argument><expr><name><name>pMeta</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>, <argument><expr><name><name>pMeta</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>, <argument><expr><name>pCols</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>makeScanLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SRealTableNode</name><modifier>*</modifier></type> <name>pRealTable</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasRepeatScanFuncs</name></decl></parameter>,
                                 <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pScan</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr></argument>, <argument><expr><name><name>pRealTable</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pSmaIndexes</name></name></expr></argument>, <argument><expr><name><name>pRealTable</name><operator>-&gt;</operator><name>pSmaIndexes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>tableId</name></name> <operator>=</operator> <name><name>pRealTable</name><operator>-&gt;</operator><name>pMeta</name><operator>-&gt;</operator><name>uid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>stableId</name></name> <operator>=</operator> <name><name>pRealTable</name><operator>-&gt;</operator><name>pMeta</name><operator>-&gt;</operator><name>suid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>tableType</name></name> <operator>=</operator> <name><name>pRealTable</name><operator>-&gt;</operator><name>pMeta</name><operator>-&gt;</operator><name>tableType</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>hasRepeatScanFuncs</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanRange</name></name> <operator>=</operator> <name>TSWINDOW_INITIALIZER</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>tableName</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>TSDB_TABLE_NAME_T</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>tableName</name><operator>.</operator><name>acctId</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>acctId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>tableName</name><operator>.</operator><name>dbname</name></name></expr></argument>, <argument><expr><name><name>pRealTable</name><operator>-&gt;</operator><name>table</name><operator>.</operator><name>dbName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>tableName</name><operator>.</operator><name>tname</name></name></expr></argument>, <argument><expr><name><name>pRealTable</name><operator>-&gt;</operator><name>table</name><operator>.</operator><name>tableName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>showRewrite</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>showRewrite</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>ratio</name></name> <operator>=</operator> <name><name>pRealTable</name><operator>-&gt;</operator><name>ratio</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>dataRequired</name></name> <operator>=</operator> <name>FUNC_DATA_REQUIRED_DATA_LOAD</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>cacheLastMode</name></name> <operator>=</operator> <name><name>pRealTable</name><operator>-&gt;</operator><name>cacheLastMode</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pScan</name></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>needScanDefaultCol</name><parameter_list>(<parameter><decl><type><name>EScanType</name></type> <name>scanType</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>SCAN_TYPE_TABLE_COUNT</name> <operator>!=</operator> <name>scanType</name></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createScanLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SRealTableNode</name><modifier>*</modifier></type> <name>pRealTable</name></decl></parameter>,
                                   <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>         <name>code</name> <init>= <expr><call><name>makeScanLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pRealTable</name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>hasRepeatScanFuncs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <name>GROUP_ACTION_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_IN_BLOCK</name></expr>;</expr_stmt>

  <comment type="line">// set columns to scan</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesCollectColumns</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_FROM</name></expr></argument>, <argument><expr><name><name>pRealTable</name><operator>-&gt;</operator><name>table</name><operator>.</operator><name>tableAlias</name></name></expr></argument>, <argument><expr><name>COLLECT_COL_TYPE_COL</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesCollectColumns</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_FROM</name></expr></argument>, <argument><expr><name><name>pRealTable</name><operator>-&gt;</operator><name>table</name><operator>.</operator><name>tableAlias</name></name></expr></argument>, <argument><expr><name>COLLECT_COL_TYPE_TAG</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesCollectFuncs</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_FROM</name></expr></argument>, <argument><expr><name>fmIsScanPseudoColumnFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// rewrite the expression in subsequent clauses</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExprsForSelect</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_FROM</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanType</name></name> <operator>=</operator> <call><name>getScanType</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>tableType</name></name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>tagScan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pScanCols</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>hasNormalCols</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <call><name>needScanDefaultCol</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanType</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>addDefaultScanCol</name><argument_list>(<argument><expr><name><name>pRealTable</name><operator>-&gt;</operator><name>pMeta</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// set output</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pScan</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>hasScan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createSubqueryLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>STempTableNode</name><modifier>*</modifier></type> <name>pTable</name></decl></parameter>,
                                       <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>createQueryLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>pSubquery</name></name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createJoinLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SJoinTableNode</name><modifier>*</modifier></type> <name>pJoinTable</name></decl></parameter>,
                                   <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name> <init>= <expr><operator>(</operator><name>SJoinLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_JOIN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pJoin</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>joinType</name></name> <operator>=</operator> <name><name>pJoinTable</name><operator>-&gt;</operator><name>joinType</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>isSingleTableJoin</name></name> <operator>=</operator> <name><name>pJoinTable</name><operator>-&gt;</operator><name>table</name><operator>.</operator><name>singleTable</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>inputTsOrder</name></name> <operator>=</operator> <name>ORDER_ASC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <name>GROUP_ACTION_CLEAR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_GLOBAL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_GLOBAL</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// set left and right node</comment>
  <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name> <operator>=</operator> <call><name>nodesMakeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pLeft</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>doCreateLogicNodeByTable</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name><name>pJoinTable</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pRight</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>doCreateLogicNodeByTable</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name><name>pJoinTable</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// set on conditions</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pJoinTable</name><operator>-&gt;</operator><name>pOnCond</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pJoinTable</name><operator>-&gt;</operator><name>pOnCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// set the output</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListStrictAppendList</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>, <argument><expr><call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pRight</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pJoin</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>doCreateLogicNodeByTable</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTable</name></decl></parameter>,
                                        <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_REAL_TABLE</name></expr>:</case>
      <return>return <expr><call><name>createScanLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><operator>(</operator><name>SRealTableNode</name><operator>*</operator><operator>)</operator><name>pTable</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_TEMP_TABLE</name></expr>:</case>
      <return>return <expr><call><name>createSubqueryLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><operator>(</operator><name>STempTableNode</name><operator>*</operator><operator>)</operator><name>pTable</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_JOIN_TABLE</name></expr>:</case>
      <return>return <expr><call><name>createJoinLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><operator>(</operator><name>SJoinTableNode</name><operator>*</operator><operator>)</operator><name>pTable</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createLogicNodeByTable</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTable</name></decl></parameter>,
                                      <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>doCreateLogicNodeByTable</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pConditions</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pWhere</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pWhere</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pConditions</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>precision</name></name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>precision</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pCurrRoot</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SColumnNode</name><modifier>*</modifier></type> <name>createColumnByExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pStmtName</name></decl></parameter>, <parameter><decl><type><name>SExprNode</name><modifier>*</modifier></type> <name>pExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_COLUMN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pCol</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>resType</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>aliasName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>pStmtName</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>tableAlias</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>tableAlias</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>pStmtName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pCol</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>createGroupingSetNode</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SGroupingSetNode</name><modifier>*</modifier></type> <name>pGroupingSet</name> <init>= <expr><operator>(</operator><name>SGroupingSetNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_GROUPING_SET</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pGroupingSet</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pGroupingSet</name><operator>-&gt;</operator><name>groupingSetType</name></name> <operator>=</operator> <name>GP_TYPE_NORMAL</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pGroupingSet</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pGroupingSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pGroupingSet</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EGroupAction</name></type> <name>getGroupAction</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pSlimit</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>GROUP_ACTION_KEEP</name></expr>
                                                                                              </then><else>: <expr><name>GROUP_ACTION_NONE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDataOrderLevel</name></type> <name>getRequireDataOrder</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>needTimeline</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>needTimeline</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pPartitionByList</name></name></expr> ?</condition><then> <expr><name>DATA_ORDER_LEVEL_IN_GROUP</name></expr> </then><else>: <expr><name>DATA_ORDER_LEVEL_GLOBAL</name></expr></else></ternary><operator>)</operator></expr>
                      </then><else>: <expr><name>DATA_ORDER_LEVEL_NONE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createAggLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pSelect</name><operator>-&gt;</operator><name>hasAggFuncs</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pGroupByList</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name> <init>= <expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pAgg</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>hasLastRow</name></name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>hasLastRowFunc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>hasLast</name></name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>hasLastFunc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>hasTimeLineFunc</name></name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>hasTimeLineFunc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>onlyHasKeepOrderFunc</name></name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>onlyHasKeepOrderFunc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <call><name>getGroupAction</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <call><name>getRequireDataOrder</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>hasTimeLineFunc</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pAgg</name><operator>-&gt;</operator><name>onlyHasKeepOrderFunc</name></name></expr> ?</condition><then> <expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name></expr> </then><else>: <expr><name>DATA_ORDER_LEVEL_NONE</name></expr></else></ternary></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// set grouyp keys, agg funcs and having conditions</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesCollectFuncs</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_GROUP_BY</name></expr></argument>, <argument><expr><name>fmIsAggFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// rewrite the expression in subsequent clauses</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExprsForSelect</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_GROUP_BY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pGroupByList</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pGroupByList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// rewrite the expression in subsequent clauses</comment>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pOutputGroupKeys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExprsForSelect</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_GROUP_BY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOutputGroupKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pHaving</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pHaving</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// set the output</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>pOutputGroupKeys</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name>pOutputGroupKeys</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pOutputGroupKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createIndefRowsFuncLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// top/bottom are both an aggregate function and a indefinite rows function</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pSelect</name><operator>-&gt;</operator><name>hasIndefiniteRowsFunc</name></name> <operator>||</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>hasAggFuncs</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SIndefRowsFuncLogicNode</name><modifier>*</modifier></type> <name>pIdfRowsFunc</name> <init>=
      <expr><operator>(</operator><name>SIndefRowsFuncLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_INDEF_ROWS_FUNC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pIdfRowsFunc</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pIdfRowsFunc</name><operator>-&gt;</operator><name>isTailFunc</name></name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>hasTailFunc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdfRowsFunc</name><operator>-&gt;</operator><name>isUniqueFunc</name></name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>hasUniqueFunc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdfRowsFunc</name><operator>-&gt;</operator><name>isTimeLineFunc</name></name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>hasTimeLineFunc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdfRowsFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <call><name>getGroupAction</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdfRowsFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <call><name>getRequireDataOrder</name><argument_list>(<argument><expr><name><name>pIdfRowsFunc</name><operator>-&gt;</operator><name>isTimeLineFunc</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIdfRowsFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name><name>pIdfRowsFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name></expr>;</expr_stmt>

  <comment type="line">// indefinite rows functions and _select_values functions</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesCollectFuncs</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_SELECT</name></expr></argument>, <argument><expr><name>fmIsVectorFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIdfRowsFunc</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExprsForSelect</name><argument_list>(<argument><expr><name><name>pIdfRowsFunc</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_SELECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// set the output</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pIdfRowsFunc</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIdfRowsFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pIdfRowsFunc</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pIdfRowsFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isInterpFunc</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>funcId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>fmIsInterpFunc</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>fmIsInterpPseudoColumnFunc</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>fmIsGroupKeyFunc</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createInterpFuncLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pSelect</name><operator>-&gt;</operator><name>hasInterpFunc</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SInterpFuncLogicNode</name><modifier>*</modifier></type> <name>pInterpFunc</name> <init>= <expr><operator>(</operator><name>SInterpFuncLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_INTERP_FUNC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pInterpFunc</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pInterpFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <call><name>getGroupAction</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInterpFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <call><name>getRequireDataOrder</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInterpFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name><name>pInterpFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name></expr>;</expr_stmt>

  <comment type="line">// interp functions and _group_key functions</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesCollectFuncs</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_SELECT</name></expr></argument>, <argument><expr><name>isInterpFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInterpFunc</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExprsForSelect</name><argument_list>(<argument><expr><name><name>pInterpFunc</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_SELECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pFill</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SFillNode</name><modifier>*</modifier></type> <name>pFill</name> <init>= <expr><operator>(</operator><name>SFillNode</name><operator>*</operator><operator>)</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pFill</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pInterpFunc</name><operator>-&gt;</operator><name>timeRange</name></name> <operator>=</operator> <name><name>pFill</name><operator>-&gt;</operator><name>timeRange</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInterpFunc</name><operator>-&gt;</operator><name>fillMode</name></name> <operator>=</operator> <name><name>pFill</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInterpFunc</name><operator>-&gt;</operator><name>pTimeSeries</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pFill</name><operator>-&gt;</operator><name>pWStartTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInterpFunc</name><operator>-&gt;</operator><name>pFillValues</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pFill</name><operator>-&gt;</operator><name>pValues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pInterpFunc</name><operator>-&gt;</operator><name>pTimeSeries</name></name> <operator>||</operator> <operator>(</operator><name>NULL</name> <operator>!=</operator> <name><name>pFill</name><operator>-&gt;</operator><name>pValues</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name><name>pInterpFunc</name><operator>-&gt;</operator><name>pFillValues</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pEvery</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInterpFunc</name><operator>-&gt;</operator><name>interval</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SValueNode</name><operator>*</operator><operator>)</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pEvery</name></name><operator>)</operator><operator>-&gt;</operator><name><name>datum</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// set the output</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pInterpFunc</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInterpFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pInterpFunc</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pInterpFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createWindowLogicNodeFinalize</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWindow</name></decl></parameter>,
                                             <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>triggerType</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>triggerType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>watermark</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>watermark</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>deleteMark</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>deleteMark</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>igExpired</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>igExpired</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>inputTsOrder</name></name> <operator>=</operator> <name>ORDER_ASC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>outputTsOrder</name></name> <operator>=</operator> <name>ORDER_ASC</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesCollectFuncs</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_WINDOW</name></expr></argument>, <argument><expr><name>fmIsWindowClauseFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWindow</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExprsForSelect</name><argument_list>(<argument><expr><name><name>pWindow</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_WINDOW</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pWindow</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pSelect</name><operator>-&gt;</operator><name>hasAggFuncs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pWindow</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createWindowLogicNodeByState</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStateWindowNode</name><modifier>*</modifier></type> <name>pState</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>,
                                            <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWindow</name> <init>= <expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pWindow</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>winType</name></name> <operator>=</operator> <name>WINDOW_TYPE_STATE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <call><name>getGroupAction</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator>
      <ternary><condition><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr> ?</condition><then> <expr><name>DATA_ORDER_LEVEL_IN_BLOCK</name></expr> </then><else>: <expr><call><name>getRequireDataOrder</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator>
      <ternary><condition><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr> ?</condition><then> <expr><name>DATA_ORDER_LEVEL_GLOBAL</name></expr> </then><else>: <expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>pStateExpr</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pState</name><operator>-&gt;</operator><name>pExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>pTspk</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pState</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pWindow</name><operator>-&gt;</operator><name>pStateExpr</name></name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>pWindow</name><operator>-&gt;</operator><name>pTspk</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// rewrite the expression in subsequent clauses</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>rewriteExprForSelect</name><argument_list>(<argument><expr><name><name>pWindow</name><operator>-&gt;</operator><name>pStateExpr</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_WINDOW</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createWindowLogicNodeFinalize</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pWindow</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createWindowLogicNodeBySession</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSessionWindowNode</name><modifier>*</modifier></type> <name>pSession</name></decl></parameter>,
                                              <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWindow</name> <init>= <expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pWindow</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>winType</name></name> <operator>=</operator> <name>WINDOW_TYPE_SESSION</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>sessionGap</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SValueNode</name><operator>*</operator><operator>)</operator><name><name>pSession</name><operator>-&gt;</operator><name>pGap</name></name><operator>)</operator><operator>-&gt;</operator><name><name>datum</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>windowAlgo</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr> ?</condition><then> <expr><name>SESSION_ALGO_STREAM_SINGLE</name></expr> </then><else>: <expr><name>SESSION_ALGO_MERGE</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <call><name>getGroupAction</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator>
      <ternary><condition><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr> ?</condition><then> <expr><name>DATA_ORDER_LEVEL_IN_BLOCK</name></expr> </then><else>: <expr><call><name>getRequireDataOrder</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator>
      <ternary><condition><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr> ?</condition><then> <expr><name>DATA_ORDER_LEVEL_GLOBAL</name></expr> </then><else>: <expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name></expr></else></ternary></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>pTspk</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pSession</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pWindow</name><operator>-&gt;</operator><name>pTspk</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>pTsEnd</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pSession</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>createWindowLogicNodeFinalize</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pWindow</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createWindowLogicNodeByInterval</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SIntervalWindowNode</name><modifier>*</modifier></type> <name>pInterval</name></decl></parameter>,
                                               <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWindow</name> <init>= <expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pWindow</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>winType</name></name> <operator>=</operator> <name>WINDOW_TYPE_INTERVAL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>interval</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SValueNode</name><operator>*</operator><operator>)</operator><name><name>pInterval</name><operator>-&gt;</operator><name>pInterval</name></name><operator>)</operator><operator>-&gt;</operator><name><name>datum</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>intervalUnit</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SValueNode</name><operator>*</operator><operator>)</operator><name><name>pInterval</name><operator>-&gt;</operator><name>pInterval</name></name><operator>)</operator><operator>-&gt;</operator><name>unit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>NULL</name> <operator>!=</operator> <name><name>pInterval</name><operator>-&gt;</operator><name>pOffset</name></name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>SValueNode</name><operator>*</operator><operator>)</operator><name><name>pInterval</name><operator>-&gt;</operator><name>pOffset</name></name><operator>)</operator><operator>-&gt;</operator><name><name>datum</name><operator>.</operator><name>i</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>sliding</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>NULL</name> <operator>!=</operator> <name><name>pInterval</name><operator>-&gt;</operator><name>pSliding</name></name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>SValueNode</name><operator>*</operator><operator>)</operator><name><name>pInterval</name><operator>-&gt;</operator><name>pSliding</name></name><operator>)</operator><operator>-&gt;</operator><name><name>datum</name><operator>.</operator><name>i</name></name></expr> </then><else>: <expr><name><name>pWindow</name><operator>-&gt;</operator><name>interval</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>slidingUnit</name></name> <operator>=</operator>
      <operator>(</operator><ternary><condition><expr><name>NULL</name> <operator>!=</operator> <name><name>pInterval</name><operator>-&gt;</operator><name>pSliding</name></name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>SValueNode</name><operator>*</operator><operator>)</operator><name><name>pInterval</name><operator>-&gt;</operator><name>pSliding</name></name><operator>)</operator><operator>-&gt;</operator><name>unit</name></expr> </then><else>: <expr><name><name>pWindow</name><operator>-&gt;</operator><name>intervalUnit</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>windowAlgo</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr> ?</condition><then> <expr><name>INTERVAL_ALGO_STREAM_SINGLE</name></expr> </then><else>: <expr><name>INTERVAL_ALGO_HASH</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>NULL</name> <operator>!=</operator> <name><name>pInterval</name><operator>-&gt;</operator><name>pFill</name></name></expr> ?</condition><then> <expr><name>GROUP_ACTION_KEEP</name></expr> </then><else>: <expr><call><name>getGroupAction</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator>
      <ternary><condition><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr>
          ?</condition><then> <expr><name>DATA_ORDER_LEVEL_IN_BLOCK</name></expr>
          </then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>pSelect</name><operator>-&gt;</operator><name>hasTimeLineFunc</name></name></expr> ?</condition><then> <expr><call><name>getRequireDataOrder</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>DATA_ORDER_LEVEL_IN_BLOCK</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator>
      <ternary><condition><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr> ?</condition><then> <expr><name>DATA_ORDER_LEVEL_GLOBAL</name></expr> </then><else>: <expr><call><name>getRequireDataOrder</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pWindow</name><operator>-&gt;</operator><name>pTspk</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pInterval</name><operator>-&gt;</operator><name>pCol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pWindow</name><operator>-&gt;</operator><name>pTspk</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name>createWindowLogicNodeFinalize</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pWindow</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createWindowLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_STATE_WINDOW</name></expr>:</case>
      <return>return <expr><call><name>createWindowLogicNodeByState</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SStateWindowNode</name><operator>*</operator><operator>)</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SESSION_WINDOW</name></expr>:</case>
      <return>return <expr><call><name>createWindowLogicNodeBySession</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SSessionWindowNode</name><operator>*</operator><operator>)</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_INTERVAL_WINDOW</name></expr>:</case>
      <return>return <expr><call><name>createWindowLogicNodeByInterval</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SIntervalWindowNode</name><operator>*</operator><operator>)</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>needFillValueImpl</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>COLUMN_TYPE_WINDOW_START</name> <operator>!=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>colType</name></name> <operator>&amp;&amp;</operator> <name>COLUMN_TYPE_WINDOW_END</name> <operator>!=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>colType</name></name> <operator>&amp;&amp;</operator>
        <name>COLUMN_TYPE_WINDOW_DURATION</name> <operator>!=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>colType</name></name> <operator>&amp;&amp;</operator> <name>COLUMN_TYPE_GROUP_KEY</name> <operator>!=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>colType</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><name>pContext</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <return>return <expr><name>DEAL_RES_END</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>needFillValue</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>hasFillCol</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>needFillValueImpl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasFillCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>hasFillCol</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>partFillExprs</name><parameter_list>(<parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pFillExprs</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pNotFillExprs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pProject</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pProject</argument>, <argument>pSelect-&gt;pProjectionList</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>needFillValue</name><argument_list>(<argument><expr><name>pProject</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><name>pFillExprs</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pProject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_VALUE</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pProject</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><name>pNotFillExprs</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pProject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><operator>*</operator><name>pFillExprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><operator>*</operator><name>pNotFillExprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pSelect</name><operator>-&gt;</operator><name>isDistinct</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pOrderExpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pOrderExpr</argument>, <argument>pSelect-&gt;pOrderByList</argument>)</argument_list></macro> <block>{<block_content>
      <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pExpr</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SOrderByExprNode</name><operator>*</operator><operator>)</operator><name>pOrderExpr</name><operator>)</operator><operator>-&gt;</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>needFillValue</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><name>pFillExprs</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_VALUE</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><name>pNotFillExprs</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><operator>*</operator><name>pFillExprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><operator>*</operator><name>pNotFillExprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createFillLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name> <operator>||</operator> <name>QUERY_NODE_INTERVAL_WINDOW</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
      <name>NULL</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SIntervalWindowNode</name><operator>*</operator><operator>)</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name><operator>)</operator><operator>-&gt;</operator><name>pFill</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SFillNode</name><modifier>*</modifier></type> <name>pFillNode</name> <init>= <expr><operator>(</operator><name>SFillNode</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>SIntervalWindowNode</name><operator>*</operator><operator>)</operator><name><name>pSelect</name><operator>-&gt;</operator><name>pWindow</name></name><operator>)</operator><operator>-&gt;</operator><name>pFill</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>FILL_MODE_NONE</name> <operator>==</operator> <name><name>pFillNode</name><operator>-&gt;</operator><name>mode</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SFillLogicNode</name><modifier>*</modifier></type> <name>pFill</name> <init>= <expr><operator>(</operator><name>SFillLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_FILL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pFill</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pFill</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <call><name>getGroupAction</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFill</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <call><name>getRequireDataOrder</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFill</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name><name>pFill</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFill</name><operator>-&gt;</operator><name>inputTsOrder</name></name> <operator>=</operator> <name>ORDER_ASC</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>partFillExprs</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pFill</name><operator>-&gt;</operator><name>pFillExprs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pFill</name><operator>-&gt;</operator><name>pNotFillExprs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExprsForSelect</name><argument_list>(<argument><expr><name><name>pFill</name><operator>-&gt;</operator><name>pFillExprs</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_FILL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExprsForSelect</name><argument_list>(<argument><expr><name><name>pFill</name><operator>-&gt;</operator><name>pNotFillExprs</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_FILL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pFill</name><operator>-&gt;</operator><name>pFillExprs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pFill</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pFill</name><operator>-&gt;</operator><name>pNotFillExprs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pFill</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pFill</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name><name>pFillNode</name><operator>-&gt;</operator><name>mode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFill</name><operator>-&gt;</operator><name>timeRange</name></name> <operator>=</operator> <name><name>pFillNode</name><operator>-&gt;</operator><name>timeRange</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFill</name><operator>-&gt;</operator><name>pValues</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pFillNode</name><operator>-&gt;</operator><name>pValues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFill</name><operator>-&gt;</operator><name>pWStartTs</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pFillNode</name><operator>-&gt;</operator><name>pWStartTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>NULL</name> <operator>!=</operator> <name><name>pFillNode</name><operator>-&gt;</operator><name>pValues</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name><name>pFill</name><operator>-&gt;</operator><name>pValues</name></name><operator>)</operator> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>pFill</name><operator>-&gt;</operator><name>pWStartTs</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pFill</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pFill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isPrimaryKeySort</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pOrderByList</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pExpr</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SOrderByExprNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name>pOrderByList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>PRIMARYKEY_TIMESTAMP_COL_ID</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>colId</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createSortLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pOrderByList</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SSortLogicNode</name><modifier>*</modifier></type> <name>pSort</name> <init>= <expr><operator>(</operator><name>SSortLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_SORT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSort</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>groupSort</name></name> <operator>=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>groupSort</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pSort</name><operator>-&gt;</operator><name>groupSort</name></name></expr> ?</condition><then> <expr><name>GROUP_ACTION_KEEP</name></expr> </then><else>: <expr><name>GROUP_ACTION_CLEAR</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <ternary><condition><expr><call><name>isPrimaryKeySort</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pOrderByList</name></name></expr></argument>)</argument_list></call></expr>
                                    ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name><name>pSort</name><operator>-&gt;</operator><name>groupSort</name></name></expr> ?</condition><then> <expr><name>DATA_ORDER_LEVEL_IN_GROUP</name></expr> </then><else>: <expr><name>DATA_ORDER_LEVEL_GLOBAL</name></expr></else></ternary><operator>)</operator></expr>
                                    </then><else>: <expr><name>DATA_ORDER_LEVEL_NONE</name></expr></else></ternary></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesCollectColumns</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_ORDER_BY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>COLLECT_COL_TYPE_ALL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>,
                                     <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pCurrRoot</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>pSortKeys</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pOrderByList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSort</name><operator>-&gt;</operator><name>pSortKeys</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pSort</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createColumnByProjections</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pStmtName</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pExprs</name></decl></parameter>,
                                         <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pCols</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name> <init>= <expr><call><name>nodesMakeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pList</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pExprs</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <call><name>nodesListAppend</name><argument_list>(<argument><expr><name>pList</name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>createColumnByExpr</name><argument_list>(<argument><expr><name>pStmtName</name></expr></argument>, <argument><expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <expr_stmt><expr><operator>*</operator><name>pCols</name> <operator>=</operator> <name>pList</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createProjectLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProject</name> <init>= <expr><operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pProject</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pLimit</name></name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pSlimit</name></name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSlimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>ignoreGroupId</name></name> <operator>=</operator> <operator>(</operator><name>NULL</name> <operator>==</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pPartitionByList</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator>
      <ternary><condition><expr><operator>(</operator><operator>!</operator><name><name>pSelect</name><operator>-&gt;</operator><name>isSubquery</name></name> <operator>&amp;&amp;</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>GROUP_ACTION_KEEP</name></expr> </then><else>: <expr><name>GROUP_ACTION_CLEAR</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_NONE</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>pProjections</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pProjectionList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pProject</name><operator>-&gt;</operator><name>pProjections</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pProject</name><operator>-&gt;</operator><name>stmtName</name></name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>stmtName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByProjections</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>stmtName</name></name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pProjectionList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pProject</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createPartitionLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pPartitionByList</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SPartitionLogicNode</name><modifier>*</modifier></type> <name>pPartition</name> <init>= <expr><operator>(</operator><name>SPartitionLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pPartition</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pPartition</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <name>GROUP_ACTION_SET</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPartition</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPartition</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_NONE</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>=
      <expr><call><name>nodesCollectColumns</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_PARTITION_BY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>COLLECT_COL_TYPE_ALL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPartition</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name><name>pPartition</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pPartition</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>,
                                     <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pCurrRoot</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pPartition</name><operator>-&gt;</operator><name>pPartitionKeys</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pPartitionByList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pPartition</name><operator>-&gt;</operator><name>pPartitionKeys</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pTags</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pPartition</name><operator>-&gt;</operator><name>pTags</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pPartition</name><operator>-&gt;</operator><name>pTags</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pSubtable</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pPartition</name><operator>-&gt;</operator><name>pSubtable</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pSubtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pPartition</name><operator>-&gt;</operator><name>pSubtable</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pPartition</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pPartition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createDistinctLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pSelect</name><operator>-&gt;</operator><name>isDistinct</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name> <init>= <expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pAgg</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <name>GROUP_ACTION_CLEAR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_NONE</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <comment type="line">// set grouyp keys, agg funcs and having conditions</comment>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pGroupKeys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>     <name>pProjection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pProjection</argument>, <argument>pSelect-&gt;pProjectionList</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pGroupKeys</name></expr></argument>, <argument><expr><call><name>createGroupingSetNode</name><argument_list>(<argument><expr><name>pProjection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pGroupKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name> <operator>=</operator> <name>pGroupKeys</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// rewrite the expression in subsequent clauses</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExprsForSelect</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>SQL_CLAUSE_DISTINCT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// set the output</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createSelectWithoutFromLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>,
                                                <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>createProjectLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createSelectFromLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pRoot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>createLogicNodeByTable</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name><name>pSelect</name><operator>-&gt;</operator><name>pFromTable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createSelectRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>createPartitionLogicNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createSelectRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>createWindowLogicNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createSelectRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>createFillLogicNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createSelectRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>createAggLogicNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createSelectRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>createIndefRowsFuncLogicNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createSelectRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>createInterpFuncLogicNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createSelectRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>createDistinctLogicNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createSelectRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>createSortLogicNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createSelectRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>createProjectLogicNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createSelectLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSelectStmt</name><modifier>*</modifier></type> <name>pSelect</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSelect</name><operator>-&gt;</operator><name>pFromTable</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>createSelectWithoutFromLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>createSelectFromLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createSetOpRootLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSetOperator</name><modifier>*</modifier></type> <name>pSetOperator</name></decl></parameter>, <parameter><decl><type><name>FCreateSetOpLogicNode</name></type> <name>func</name></decl></parameter>,
                                        <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pRoot</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>createRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSetOperator</name></expr></argument>, <argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>precision</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FCreateLogicNode</name><operator>)</operator><name>func</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createSetOpSortLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSetOperator</name><modifier>*</modifier></type> <name>pSetOperator</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSetOperator</name><operator>-&gt;</operator><name>pOrderByList</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SSortLogicNode</name><modifier>*</modifier></type> <name>pSort</name> <init>= <expr><operator>(</operator><name>SSortLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_SORT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSort</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pLimit</name></name></expr></argument>, <argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>pProjectionList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>pSortKeys</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>pOrderByList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSort</name><operator>-&gt;</operator><name>pSortKeys</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pSort</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createSetOpProjectLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSetOperator</name><modifier>*</modifier></type> <name>pSetOperator</name></decl></parameter>,
                                           <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProject</name> <init>= <expr><operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pProject</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSetOperator</name><operator>-&gt;</operator><name>pOrderByList</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pLimit</name></name></expr></argument>, <argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>ignoreGroupId</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>pProjections</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>pProjectionList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pProject</name><operator>-&gt;</operator><name>pProjections</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByProjections</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>stmtName</name></name></expr></argument>, <argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>pProjectionList</name></name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pProject</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createSetOpAggLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSetOperator</name><modifier>*</modifier></type> <name>pSetOperator</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name> <init>= <expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pAgg</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSetOperator</name><operator>-&gt;</operator><name>pOrderByList</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pSlimit</name></name></expr></argument>, <argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>pProjectionList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// rewrite the expression in subsequent clauses</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExprs</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>, <argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>pOrderByList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// set the output</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createSetOpLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSetOperator</name><modifier>*</modifier></type> <name>pSetOperator</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pSetOp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>opType</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>SET_OP_TYPE_UNION_ALL</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createSetOpProjectLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSetOperator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSetOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SET_OP_TYPE_UNION</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createSetOpAggLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSetOperator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSetOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_FAILED</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pLeft</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createQueryLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSetOp</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pRight</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createQueryLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pSetOperator</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pSetOp</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pSetOp</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSetOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createSetOperatorLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SSetOperator</name><modifier>*</modifier></type> <name>pSetOperator</name></decl></parameter>,
                                          <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pRoot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>createSetOpLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSetOperator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createSetOpRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSetOperator</name></expr></argument>, <argument><expr><name>createSetOpSortLogicNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>getMsgType</name><parameter_list>(<parameter><decl><type><name>ENodeType</name></type> <name>sqlType</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>sqlType</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_CREATE_TABLE_STMT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_CREATE_MULTI_TABLE_STMT</name></expr>:</case>
      <return>return <expr><name>TDMT_VND_CREATE_TABLE</name></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DROP_TABLE_STMT</name></expr>:</case>
      <return>return <expr><name>TDMT_VND_DROP_TABLE</name></expr>;</return>
    <case>case <expr><name>QUERY_NODE_ALTER_TABLE_STMT</name></expr>:</case>
      <return>return <expr><name>TDMT_VND_ALTER_TABLE</name></expr>;</return>
    <case>case <expr><name>QUERY_NODE_FLUSH_DATABASE_STMT</name></expr>:</case>
      <return>return <expr><name>TDMT_VND_COMMIT</name></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>TDMT_VND_SUBMIT</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createVnodeModifLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SVnodeModifOpStmt</name><modifier>*</modifier></type> <name>pStmt</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SVnodeModifyLogicNode</name><modifier>*</modifier></type> <name>pModif</name> <init>= <expr><operator>(</operator><name>SVnodeModifyLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_VNODE_MODIFY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pModif</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pModif</name><operator>-&gt;</operator><name>modifyType</name></name> <operator>=</operator> <name>MODIFY_TABLE_TYPE_INSERT</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pModif</name><operator>-&gt;</operator><name>pDataBlocks</name></name></expr></argument>, <argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>pDataBlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pModif</name><operator>-&gt;</operator><name>msgType</name></name> <operator>=</operator> <call><name>getMsgType</name><argument_list>(<argument><expr><name><name>pStmt</name><operator>-&gt;</operator><name>sqlNodeType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pModif</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createDeleteRootLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SDeleteStmt</name><modifier>*</modifier></type> <name>pDelete</name></decl></parameter>, <parameter><decl><type><name>FCreateDeleteLogicNode</name></type> <name>func</name></decl></parameter>,
                                         <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pRoot</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>createRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pDelete</name></expr></argument>, <argument><expr><name><name>pDelete</name><operator>-&gt;</operator><name>precision</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FCreateLogicNode</name><operator>)</operator><name>func</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createDeleteScanLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SDeleteStmt</name><modifier>*</modifier></type> <name>pDelete</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>         <name>code</name> <init>= <expr><call><name>makeScanLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SRealTableNode</name><operator>*</operator><operator>)</operator><name><name>pDelete</name><operator>-&gt;</operator><name>pFromTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// set columns to scan</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanType</name></name> <operator>=</operator> <name>SCAN_TYPE_TABLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanRange</name></name> <operator>=</operator> <name><name>pDelete</name><operator>-&gt;</operator><name>timeRange</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pScanCols</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name><name>pDelete</name><operator>-&gt;</operator><name>pCountFunc</name></name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pScanCols</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pDelete</name><operator>-&gt;</operator><name>pTagCond</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pTagCond</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pDelete</name><operator>-&gt;</operator><name>pTagCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pTagCond</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// set output</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pScan</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createDeleteAggLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SDeleteStmt</name><modifier>*</modifier></type> <name>pDelete</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name> <init>= <expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pAgg</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pDelete</name><operator>-&gt;</operator><name>pCountFunc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pDelete</name><operator>-&gt;</operator><name>pFirstFunc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pDelete</name><operator>-&gt;</operator><name>pLastFunc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDelete</name><operator>-&gt;</operator><name>pCountFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDelete</name><operator>-&gt;</operator><name>pFirstFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteExpr</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pDelete</name><operator>-&gt;</operator><name>pLastFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// set the output</comment>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createVnodeModifLogicNodeByDelete</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SDeleteStmt</name><modifier>*</modifier></type> <name>pDelete</name></decl></parameter>,
                                                 <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SVnodeModifyLogicNode</name><modifier>*</modifier></type> <name>pModify</name> <init>= <expr><operator>(</operator><name>SVnodeModifyLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_VNODE_MODIFY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pModify</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SRealTableNode</name><modifier>*</modifier></type> <name>pRealTable</name> <init>= <expr><operator>(</operator><name>SRealTableNode</name><operator>*</operator><operator>)</operator><name><name>pDelete</name><operator>-&gt;</operator><name>pFromTable</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pModify</name><operator>-&gt;</operator><name>modifyType</name></name> <operator>=</operator> <name>MODIFY_TABLE_TYPE_DELETE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pModify</name><operator>-&gt;</operator><name>tableId</name></name> <operator>=</operator> <name><name>pRealTable</name><operator>-&gt;</operator><name>pMeta</name><operator>-&gt;</operator><name>uid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pModify</name><operator>-&gt;</operator><name>tableType</name></name> <operator>=</operator> <name><name>pRealTable</name><operator>-&gt;</operator><name>pMeta</name><operator>-&gt;</operator><name>tableType</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>pModify</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pModify</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pRealTable</name><operator>-&gt;</operator><name>table</name><operator>.</operator><name>tableName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pModify</name><operator>-&gt;</operator><name>tsColName</name></name></expr></argument>, <argument><expr><name><name>pRealTable</name><operator>-&gt;</operator><name>pMeta</name><operator>-&gt;</operator><name>schema</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pModify</name><operator>-&gt;</operator><name>deleteTimeRange</name></name> <operator>=</operator> <name><name>pDelete</name><operator>-&gt;</operator><name>timeRange</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pModify</name><operator>-&gt;</operator><name>pAffectedRows</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pDelete</name><operator>-&gt;</operator><name>pCountFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pModify</name><operator>-&gt;</operator><name>pStartTs</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pDelete</name><operator>-&gt;</operator><name>pFirstFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pModify</name><operator>-&gt;</operator><name>pEndTs</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pDelete</name><operator>-&gt;</operator><name>pLastFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pModify</name><operator>-&gt;</operator><name>pAffectedRows</name></name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>pModify</name><operator>-&gt;</operator><name>pStartTs</name></name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>pModify</name><operator>-&gt;</operator><name>pEndTs</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pModify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pModify</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createDeleteLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SDeleteStmt</name><modifier>*</modifier></type> <name>pDelete</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pRoot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>createDeleteScanLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pDelete</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createDeleteRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pDelete</name></expr></argument>, <argument><expr><name>createDeleteAggLogicNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createDeleteRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pDelete</name></expr></argument>, <argument><expr><name>createVnodeModifLogicNodeByDelete</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>creatInsertRootLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SInsertStmt</name><modifier>*</modifier></type> <name>pInsert</name></decl></parameter>, <parameter><decl><type><name>FCreateInsertLogicNode</name></type> <name>func</name></decl></parameter>,
                                        <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pRoot</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>createRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name><name>pInsert</name><operator>-&gt;</operator><name>precision</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FCreateLogicNode</name><operator>)</operator><name>func</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createVnodeModifLogicNodeByInsert</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SInsertStmt</name><modifier>*</modifier></type> <name>pInsert</name></decl></parameter>,
                                                 <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SVnodeModifyLogicNode</name><modifier>*</modifier></type> <name>pModify</name> <init>= <expr><operator>(</operator><name>SVnodeModifyLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_VNODE_MODIFY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pModify</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SRealTableNode</name><modifier>*</modifier></type> <name>pRealTable</name> <init>= <expr><operator>(</operator><name>SRealTableNode</name><operator>*</operator><operator>)</operator><name><name>pInsert</name><operator>-&gt;</operator><name>pTable</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pModify</name><operator>-&gt;</operator><name>modifyType</name></name> <operator>=</operator> <name>MODIFY_TABLE_TYPE_INSERT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pModify</name><operator>-&gt;</operator><name>tableId</name></name> <operator>=</operator> <name><name>pRealTable</name><operator>-&gt;</operator><name>pMeta</name><operator>-&gt;</operator><name>uid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pModify</name><operator>-&gt;</operator><name>stableId</name></name> <operator>=</operator> <name><name>pRealTable</name><operator>-&gt;</operator><name>pMeta</name><operator>-&gt;</operator><name>suid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pModify</name><operator>-&gt;</operator><name>tableType</name></name> <operator>=</operator> <name><name>pRealTable</name><operator>-&gt;</operator><name>pMeta</name><operator>-&gt;</operator><name>tableType</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>pModify</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pModify</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pRealTable</name><operator>-&gt;</operator><name>table</name><operator>.</operator><name>tableName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pModify</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr></argument>, <argument><expr><name><name>pRealTable</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pModify</name><operator>-&gt;</operator><name>pInsertCols</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pInsert</name><operator>-&gt;</operator><name>pCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pModify</name><operator>-&gt;</operator><name>pInsertCols</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pModify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pModify</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createInsertLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SInsertStmt</name><modifier>*</modifier></type> <name>pInsert</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pRoot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>createQueryLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInsert</name><operator>-&gt;</operator><name>pQuery</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>creatInsertRootLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInsert</name></expr></argument>, <argument><expr><name>createVnodeModifLogicNodeByInsert</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicNode</name> <operator>=</operator> <name>pRoot</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>createQueryLogicNode</name><parameter_list>(<parameter><decl><type><name>SLogicPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pStmt</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_SELECT_STMT</name></expr>:</case>
      <return>return <expr><call><name>createSelectLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SSelectStmt</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_VNODE_MODIF_STMT</name></expr>:</case>
      <return>return <expr><call><name>createVnodeModifLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SVnodeModifOpStmt</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_EXPLAIN_STMT</name></expr>:</case>
      <return>return <expr><call><name>createQueryLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SExplainStmt</name><operator>*</operator><operator>)</operator><name>pStmt</name><operator>)</operator><operator>-&gt;</operator><name>pQuery</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_SET_OPERATOR</name></expr>:</case>
      <return>return <expr><call><name>createSetOperatorLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SSetOperator</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_DELETE_STMT</name></expr>:</case>
      <return>return <expr><call><name>createDeleteLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SDeleteStmt</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_INSERT_STMT</name></expr>:</case>
      <return>return <expr><call><name>createInsertLogicNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SInsertStmt</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>TSDB_CODE_FAILED</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>doSetLogicNodeParent</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pParent</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pParent</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content> <expr_stmt><expr><call><name>doSetLogicNodeParent</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setLogicNodeParent</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>doSetLogicNodeParent</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setLogicSubplanType</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>hasScan</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_VNODE_MODIFY</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <ternary><condition><expr><name>hasScan</name></expr> ?</condition><then> <expr><name>SUBPLAN_TYPE_SCAN</name></expr> </then><else>: <expr><name>SUBPLAN_TYPE_MERGE</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>SVnodeModifyLogicNode</name><modifier>*</modifier></type> <name>pModify</name> <init>= <expr><operator>(</operator><name>SVnodeModifyLogicNode</name><operator>*</operator><operator>)</operator><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>MODIFY_TABLE_TYPE_INSERT</name> <operator>==</operator> <name><name>pModify</name><operator>-&gt;</operator><name>modifyType</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pModify</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name><operator>)</operator></expr>
                                ?</condition><then> <expr><name>SUBPLAN_TYPE_SCAN</name></expr>
                                </then><else>: <expr><name>SUBPLAN_TYPE_MODIFY</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>createLogicPlan</name><parameter_list>(<parameter><decl><type><name>SPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicPlanContext</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>pPlanCxt</name> <operator>=</operator> <name>pCxt</name></expr>, <expr><operator>.</operator><name>pCurrRoot</name> <operator>=</operator> <name>NULL</name></expr>, <expr><operator>.</operator><name>hasScan</name> <operator>=</operator> <name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name> <init>= <expr><operator>(</operator><name>SLogicSubplan</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_SUBPLAN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSubplan</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>queryId</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>queryId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>subplanId</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>createQueryLogicNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pAstRoot</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>setLogicNodeParent</name><argument_list>(<argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setLogicSubplanType</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>hasScan</name></name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustLogicNodeDataRequirement</name><argument_list>(<argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>DATA_ORDER_LEVEL_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLogicSubplan</name> <operator>=</operator> <name>pSubplan</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>
</unit>
