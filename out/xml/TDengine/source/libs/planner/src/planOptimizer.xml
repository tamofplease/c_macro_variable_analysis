<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/source/libs/planner/src/planOptimizer.c"><comment type="block">/*
 * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the GNU Affero General Public License, version 3
 * or later ("AGPL"), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"functionMgt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"systable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tglobal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ttime.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTIMIZE_FLAG_MASK</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1 &lt;&lt; n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTIMIZE_FLAG_SCAN_PATH</name></cpp:macro>       <cpp:value>OPTIMIZE_FLAG_MASK(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTIMIZE_FLAG_PUSH_DOWN_CONDE</name></cpp:macro> <cpp:value>OPTIMIZE_FLAG_MASK(1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTIMIZE_FLAG_SET_MASK</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>mask</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(val) |= (mask)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTIMIZE_FLAG_TEST_MASK</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>mask</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((val) &amp; (mask)) != 0)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>SOptimizeContext</name> <block>{
  <decl_stmt><decl><type><name>SPlanContext</name><modifier>*</modifier></type> <name>pPlanCxt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>          <name>optimized</name></decl>;</decl_stmt>
}</block></struct></type> <name>SOptimizeContext</name>;</typedef>

<typedef>typedef <function_decl><type><name>int32_t</name></type> (<modifier>*</modifier><name>FOptimize</name>)<parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <name>SOptimizeRule</name> <block>{
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>     <name>pName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FOptimize</name></type> <name>optimizeFunc</name></decl>;</decl_stmt>
}</block></struct></type> <name>SOptimizeRule</name>;</typedef>

<typedef>typedef <type><enum>enum <name>EScanOrder</name> <block>{ <decl><name>SCAN_ORDER_ASC</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><name>SCAN_ORDER_DESC</name></decl>, <decl><name>SCAN_ORDER_BOTH</name></decl> }</block></enum></type> <name>EScanOrder</name>;</typedef>

<typedef>typedef <type><struct>struct <name>SOsdInfo</name> <block>{
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type>      <name>pSdrFuncs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type>      <name>pDsoFuncs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>EScanOrder</name></type>      <name>scanOrder</name></decl>;</decl_stmt>
}</block></struct></type> <name>SOsdInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>SCpdIsMultiTableCondCxt</name> <block>{
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pLeftCols</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pRightCols</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>       <name>havaLeftCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>       <name>haveRightCol</name></decl>;</decl_stmt>
}</block></struct></type> <name>SCpdIsMultiTableCondCxt</name>;</typedef>

<typedef>typedef <type><enum>enum <name>ECondAction</name> <block>{
  <decl><name>COND_ACTION_STAY</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>COND_ACTION_PUSH_JOIN</name></decl>,
  <decl><name>COND_ACTION_PUSH_LEFT_CHILD</name></decl>,
  <decl><name>COND_ACTION_PUSH_RIGHT_CHILD</name></decl>
  <comment type="line">// after supporting outer join, there are other possibilities</comment>
}</block></enum></type> <name>ECondAction</name>;</typedef>

<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>FMayBeOptimized</name>)<parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>FShouldBeOptimized</name>)<parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>SLogicNode</name><modifier>*</modifier></type> <name>optFindPossibleNode</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>FMayBeOptimized</name></type> <name>func</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>func</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>pNode</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pScanNode</name> <init>= <expr><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>pScanNode</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>pScanNode</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>optFindEligibleNode</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>FShouldBeOptimized</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>func</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>optFindEligibleNode</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>optResetParent</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name><operator>)</operator><operator>-&gt;</operator><name>pParent</name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt> </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>optRebuildTbanme</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><operator>*</operator><name>pNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>COLUMN_TYPE_TBNAME</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><operator>*</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colType</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_FUNCTION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pFunc</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int32_t</name><operator>*</operator><operator>)</operator><name>pContext</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
      <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>, <argument><expr><literal type="string">"tbname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFunc</name><operator>-&gt;</operator><name>funcType</name></name> <operator>=</operator> <name>FUNCTION_TYPE_TBNAME</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><operator>*</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name><name>node</name><operator>.</operator><name>resType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>*</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pNode</name> <operator>=</operator> <operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr>;</expr_stmt>
    <return>return <expr><name>DEAL_RES_IGNORE_CHILD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>optSetParentOrder</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>EOrder</name></type> <name>order</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pNode</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name></expr>:</case>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>inputTsOrder</name> <operator>=</operator> <name>order</name></expr>;</expr_stmt>
      <comment type="line">// window has a sorting function, and the operator behind it uses its output order</comment>
      <return>return;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_JOIN</name></expr>:</case>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SJoinLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>inputTsOrder</name> <operator>=</operator> <name>order</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_FILL</name></expr>:</case>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SFillLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>inputTsOrder</name> <operator>=</operator> <name>order</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>optSetParentOrder</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>EDealRes</name></type> <name>scanPathOptHaveNormalColImpl</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><name>pContext</name><operator>)</operator> <operator>=</operator>
        <operator>(</operator><name>COLUMN_TYPE_TAG</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colType</name> <operator>&amp;&amp;</operator> <name>COLUMN_TYPE_TBNAME</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colType</name><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><name>pContext</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEAL_RES_END</name></expr> </then><else>: <expr><name>DEAL_RES_IGNORE_CHILD</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>scanPathOptHaveNormalCol</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pList</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesWalkExprsPostOrder</name><argument_list>(<argument><expr><name>pList</name></expr></argument>, <argument><expr><name>scanPathOptHaveNormalColImpl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>scanPathOptMayBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>OPTIMIZE_FLAG_TEST_MASK</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_SCAN_PATH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>||</operator> <operator>(</operator><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                                 <name>QUERY_NODE_LOGIC_PLAN_AGG</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                                 <name>QUERY_NODE_LOGIC_PLAN_PARTITION</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
       <name>WINDOW_TYPE_INTERVAL</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name><operator>)</operator><operator>-&gt;</operator><name>winType</name><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pParent</name></name> <operator>&amp;&amp;</operator>
       <name>QUERY_NODE_LOGIC_PLAN_WINDOW</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
       <name>WINDOW_TYPE_INTERVAL</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name><operator>)</operator><operator>-&gt;</operator><name>winType</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>!</operator><call><name>scanPathOptHaveNormalCol</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name><operator>)</operator><operator>-&gt;</operator><name>pGroupKeys</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNodeList</name><modifier>*</modifier></type> <name>scanPathOptGetAllFuncs</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name></expr>:</case>
      <return>return <expr><operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pFuncs</name></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr>:</case>
      <return>return <expr><operator>(</operator><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pAggFuncs</name></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>scanPathOptNeedOptimizeDataRequire</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fmIsSpecialDataRequiredFunc</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>funcId</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pPara</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pPara</argument>, <argument>pFunc-&gt;pParameterList</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pPara</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>QUERY_NODE_VALUE</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pPara</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>scanPathOptNeedDynOptimize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fmIsDynamicScanOptimizedFunc</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>funcId</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pPara</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pPara</argument>, <argument>pFunc-&gt;pParameterList</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pPara</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>QUERY_NODE_VALUE</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pPara</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>scanPathOptGetRelatedFuncs</name><parameter_list>(<parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pSdrFuncs</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pDsoFuncs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pAllFuncs</name> <init>= <expr><call><name>scanPathOptGetAllFuncs</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pParent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTmpSdrFuncs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTmpDsoFuncs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>     <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>       <name>otherFunc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pAllFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type>        <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>scanPathOptNeedOptimizeDataRequire</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pTmpSdrFuncs</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>scanPathOptNeedDynOptimize</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pTmpDsoFuncs</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>otherFunc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pTmpSdrFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pTmpDsoFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <if_stmt><if>if <condition>(<expr><name>otherFunc</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pTmpSdrFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pTmpDsoFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pSdrFuncs</name> <operator>=</operator> <name>pTmpSdrFuncs</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pDsoFuncs</name> <operator>=</operator> <name>pTmpDsoFuncs</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>scanPathOptGetScanOrder</name><parameter_list>(<parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>, <parameter><decl><type><name>EScanOrder</name><modifier>*</modifier></type> <name>pScanOrder</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pAllFuncs</name> <init>= <expr><call><name>scanPathOptGetAllFuncs</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pParent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>     <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>       <name>hasFirst</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>       <name>hasLast</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>       <name>otherFunc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pAllFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>FUNCTION_TYPE_FIRST</name> <operator>==</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>funcType</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hasFirst</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>FUNCTION_TYPE_LAST</name> <operator>==</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>funcType</name></name> <operator>||</operator> <name>FUNCTION_TYPE_LAST_ROW</name> <operator>==</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>funcType</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hasLast</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>FUNCTION_TYPE_SELECT_VALUE</name> <operator>!=</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>funcType</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>otherFunc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <if_stmt><if>if <condition>(<expr><name>hasFirst</name> <operator>&amp;&amp;</operator> <name>hasLast</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>otherFunc</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pScanOrder</name> <operator>=</operator> <name>SCAN_ORDER_BOTH</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>hasLast</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pScanOrder</name> <operator>=</operator> <name>SCAN_ORDER_DESC</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pScanOrder</name> <operator>=</operator> <name>SCAN_ORDER_ASC</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>scanPathOptSetOsdInfo</name><parameter_list>(<parameter><decl><type><name>SOsdInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>scanPathOptGetRelatedFuncs</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSdrFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pDsoFuncs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>scanPathOptGetScanOrder</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>scanOrder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>scanPathOptMatch</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>, <parameter><decl><type><name>SOsdInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name></name> <operator>=</operator> <operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><name>pLogicNode</name></expr></argument>, <argument><expr><name>scanPathOptMayBeOptimized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>scanPathOptSetOsdInfo</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EFuncDataRequired</name></type> <name>scanPathOptPromoteDataRequired</name><parameter_list>(<parameter><decl><type><name>EFuncDataRequired</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>EFuncDataRequired</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>l</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>FUNC_DATA_REQUIRED_DATA_LOAD</name></expr>:</case>
      <return>return <expr><name>l</name></expr>;</return>
    <case>case <expr><name>FUNC_DATA_REQUIRED_SMA_LOAD</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><name>FUNC_DATA_REQUIRED_DATA_LOAD</name> <operator>==</operator> <name>r</name></expr> ?</condition><then> <expr><name>r</name></expr> </then><else>: <expr><name>l</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>FUNC_DATA_REQUIRED_NOT_LOAD</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><name>FUNC_DATA_REQUIRED_FILTEROUT</name> <operator>==</operator> <name>r</name></expr> ?</condition><then> <expr><name>l</name></expr> </then><else>: <expr><name>r</name></expr></else></ternary></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>scanPathOptGetDataRequired</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pFuncs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pFuncs</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FUNC_DATA_REQUIRED_DATA_LOAD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>EFuncDataRequired</name></type> <name>dataRequired</name> <init>= <expr><name>FUNC_DATA_REQUIRED_FILTEROUT</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>            <name>pFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pFunc</argument>, <argument>pFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><name>dataRequired</name> <operator>=</operator> <call><name>scanPathOptPromoteDataRequired</name><argument_list>(<argument><expr><name>dataRequired</name></expr></argument>, <argument><expr><call><name>fmFuncDataRequired</name><argument_list>(<argument><expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
  <return>return <expr><name>dataRequired</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>scanPathOptSetScanWin</name><parameter_list>(<parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pParent</name> <init>= <expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pParent</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pParent</name></name> <operator>&amp;&amp;</operator>
      <name>QUERY_NODE_LOGIC_PLAN_WINDOW</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pParent</name> <operator>=</operator> <name><name>pParent</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>interval</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pParent</name><operator>)</operator><operator>-&gt;</operator><name>interval</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pParent</name><operator>)</operator><operator>-&gt;</operator><name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>sliding</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pParent</name><operator>)</operator><operator>-&gt;</operator><name>sliding</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>intervalUnit</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pParent</name><operator>)</operator><operator>-&gt;</operator><name>intervalUnit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>slidingUnit</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pParent</name><operator>)</operator><operator>-&gt;</operator><name>slidingUnit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>triggerType</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pParent</name><operator>)</operator><operator>-&gt;</operator><name>triggerType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>watermark</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pParent</name><operator>)</operator><operator>-&gt;</operator><name>watermark</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>deleteMark</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pParent</name><operator>)</operator><operator>-&gt;</operator><name>deleteMark</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>igExpired</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pParent</name><operator>)</operator><operator>-&gt;</operator><name>igExpired</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>scanPathOptSetScanOrder</name><parameter_list>(<parameter><decl><type><name>EScanOrder</name></type> <name>scanOrder</name></decl></parameter>, <parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pScan</name><operator>-&gt;</operator><name>sortPrimaryKey</name></name> <operator>||</operator> <name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <switch>switch <condition>(<expr><name>scanOrder</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>SCAN_ORDER_ASC</name></expr>:</case>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>optSetParentOrder</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pParent</name></name></expr></argument>, <argument><expr><name>ORDER_ASC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SCAN_ORDER_DESC</name></expr>:</case>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>optSetParentOrder</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pParent</name></name></expr></argument>, <argument><expr><name>ORDER_DESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SCAN_ORDER_BOTH</name></expr>:</case>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>scanPathOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SOsdInfo</name></type> <name>info</name> <init>= <expr><block>{<expr><operator>.</operator><name>scanOrder</name> <operator>=</operator> <name>SCAN_ORDER_ASC</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>code</name> <init>= <expr><call><name>scanPathOptMatch</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>pScan</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>scanPathOptSetScanWin</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>pScan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>scanPathOptSetScanOrder</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>scanOrder</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pScan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>NULL</name> <operator>!=</operator> <name><name>info</name><operator>.</operator><name>pDsoFuncs</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>info</name><operator>.</operator><name>pSdrFuncs</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>pScan</name><operator>-&gt;</operator><name>dataRequired</name></name> <operator>=</operator> <call><name>scanPathOptGetDataRequired</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>pSdrFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>pScan</name><operator>-&gt;</operator><name>pDynamicScanFuncs</name></name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>pDsoFuncs</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>pScan</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>OPTIMIZE_FLAG_SET_MASK</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_SCAN_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>pSdrFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptMergeCond</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pDst</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pSrc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicConditionNode</name><modifier>*</modifier></type> <name>pLogicCond</name> <init>= <expr><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_CONDITION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pLogicCond</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pLogicCond</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>TSDB_DATA_TYPE_BOOL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLogicCond</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name><operator>.</operator><name>bytes</name></name> <operator>=</operator> <name><name>tDataTypes</name><index>[<expr><name>TSDB_DATA_TYPE_BOOL</name></expr>]</index></name><operator>.</operator><name>bytes</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLogicCond</name><operator>-&gt;</operator><name>condType</name></name> <operator>=</operator> <name>LOGIC_COND_TYPE_AND</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pLogicCond</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><operator>*</operator><name>pSrc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pSrc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pLogicCond</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><operator>*</operator><name>pDst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pDst</name> <operator>=</operator> <operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pLogicCond</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pLogicCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptAppendCond</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pCond</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pAdditionalCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>pCond</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><operator>*</operator><name>pCond</name></expr></argument>, <argument><expr><operator>*</operator><name>pAdditionalCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_CONDITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><operator>*</operator><name>pCond</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <name>LOGIC_COND_TYPE_AND</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><operator>*</operator><name>pCond</name><operator>)</operator><operator>-&gt;</operator><name>condType</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListAppend</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><operator>*</operator><name>pCond</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><operator>*</operator><name>pAdditionalCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pAdditionalCond</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptMergeCond</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>, <argument><expr><name>pAdditionalCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptCalcTimeRange</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pPrimaryKeyCond</name></decl></parameter>,
                                            <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOtherCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>topicQuery</name></name> <operator>||</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptAppendCond</name><argument_list>(<argument><expr><name>pOtherCond</name></expr></argument>, <argument><expr><name>pPrimaryKeyCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>isStrict</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>filterGetTimeRange</name><argument_list>(<argument><expr><operator>*</operator><name>pPrimaryKeyCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>scanRange</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isStrict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>isStrict</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>*</operator><name>pPrimaryKeyCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptAppendCond</name><argument_list>(<argument><expr><name>pOtherCond</name></expr></argument>, <argument><expr><name>pPrimaryKeyCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pPrimaryKeyCond</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptRebuildTbanme</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pTagCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesRewriteExpr</name><argument_list>(<argument><expr><name>pTagCond</name></expr></argument>, <argument><expr><name>optRebuildTbanme</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptDealScan</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>||</operator>
      <call><name>OPTIMIZE_FLAG_TEST_MASK</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_PUSH_DOWN_CONDE</name></expr></argument>)</argument_list></call> <operator>||</operator>
      <name>TSDB_SYSTEM_TABLE</name> <operator>==</operator> <name><name>pScan</name><operator>-&gt;</operator><name>tableType</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pPrimaryKeyCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pOtherCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>filterPartitionCond</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPrimaryKeyCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>pTagIndexCond</name></name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>pTagCond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOtherCond</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pTagCond</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptRebuildTbanme</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>pTagCond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>pPrimaryKeyCond</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptCalcTimeRange</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pScan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPrimaryKeyCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOtherCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>=</operator> <name>pOtherCond</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>OPTIMIZE_FLAG_SET_MASK</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_PUSH_DOWN_CONDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pPrimaryKeyCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pOtherCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>pushDownCondOptBelongThisTable</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCondCol</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTableCols</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTableCol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pTableCol</argument>, <argument>pTableCols</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pCondCol</name></expr></argument>, <argument><expr><name>pTableCol</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>pushDownCondOptIsCrossTableCond</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SCpdIsMultiTableCondCxt</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><name>pContext</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>pushDownCondOptBelongThisTable</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pLeftCols</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>havaLeftCol</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>pushDownCondOptBelongThisTable</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pRightCols</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>haveRightCol</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><name><name>pCxt</name><operator>-&gt;</operator><name>havaLeftCol</name></name> <operator>&amp;&amp;</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>haveRightCol</name></name></expr> ?</condition><then> <expr><name>DEAL_RES_END</name></expr> </then><else>: <expr><name>DEAL_RES_CONTINUE</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ECondAction</name></type> <name>pushDownCondOptGetCondAction</name><parameter_list>(<parameter><decl><type><name>EJoinType</name></type> <name>joinType</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pLeftCols</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pRightCols</name></decl></parameter>,
                                                <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SCpdIsMultiTableCondCxt</name></type> <name>cxt</name> <init>= <expr><block>{
      <expr><operator>.</operator><name>pLeftCols</name> <operator>=</operator> <name>pLeftCols</name></expr>, <expr><operator>.</operator><name>pRightCols</name> <operator>=</operator> <name>pRightCols</name></expr>, <expr><operator>.</operator><name>havaLeftCol</name> <operator>=</operator> <name>false</name></expr>, <expr><operator>.</operator><name>haveRightCol</name> <operator>=</operator> <name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pushDownCondOptIsCrossTableCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>JOIN_TYPE_INNER</name> <operator>!=</operator> <name>joinType</name></expr>
              ?</condition><then> <expr><name>COND_ACTION_STAY</name></expr>
              </then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>cxt</name><operator>.</operator><name>havaLeftCol</name></name> <operator>&amp;&amp;</operator> <name><name>cxt</name><operator>.</operator><name>haveRightCol</name></name></expr>
                     ?</condition><then> <expr><name>COND_ACTION_PUSH_JOIN</name></expr>
                     </then><else>: <expr><operator>(</operator><ternary><condition><expr><name><name>cxt</name><operator>.</operator><name>havaLeftCol</name></name></expr> ?</condition><then> <expr><name>COND_ACTION_PUSH_LEFT_CHILD</name></expr> </then><else>: <expr><name>COND_ACTION_PUSH_RIGHT_CHILD</name></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptPartLogicCond</name><parameter_list>(<parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOnCond</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLeftChildCond</name></decl></parameter>,
                                            <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pRightChildCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicConditionNode</name><modifier>*</modifier></type> <name>pLogicCond</name> <init>= <expr><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>LOGIC_COND_TYPE_AND</name> <operator>!=</operator> <name><name>pLogicCond</name><operator>-&gt;</operator><name>condType</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pLeftCols</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pTargets</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pRightCols</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pTargets</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pOnConds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pLeftChildConds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pRightChildConds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pRemainConds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>     <name>pCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pCond</argument>, <argument>pLogicCond-&gt;pParameterList</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>ECondAction</name></type> <name>condAction</name> <init>= <expr><call><name>pushDownCondOptGetCondAction</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>joinType</name></name></expr></argument>, <argument><expr><name>pLeftCols</name></expr></argument>, <argument><expr><name>pRightCols</name></expr></argument>, <argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>COND_ACTION_PUSH_JOIN</name> <operator>==</operator> <name>condAction</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pOnConds</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>COND_ACTION_PUSH_LEFT_CHILD</name> <operator>==</operator> <name>condAction</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pLeftChildConds</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>COND_ACTION_PUSH_RIGHT_CHILD</name> <operator>==</operator> <name>condAction</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pRightChildConds</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pRemainConds</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTempOnCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTempLeftChildCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTempRightChildCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTempRemainCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesMergeConds</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pTempOnCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOnConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesMergeConds</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pTempLeftChildCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeftChildConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesMergeConds</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pTempRightChildCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRightChildConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesMergeConds</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pTempRemainCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRemainConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOnCond</name> <operator>=</operator> <name>pTempOnCond</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pLeftChildCond</name> <operator>=</operator> <name>pTempLeftChildCond</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pRightChildCond</name> <operator>=</operator> <name>pTempRightChildCond</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>=</operator> <name>pTempRemainCond</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pOnConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pLeftChildConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pRightChildConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pRemainConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pTempOnCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pTempLeftChildCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pTempRightChildCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pTempRemainCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptPartOpCond</name><parameter_list>(<parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOnCond</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLeftChildCond</name></decl></parameter>,
                                         <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pRightChildCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type>  <name>pLeftCols</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pTargets</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type>  <name>pRightCols</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pTargets</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ECondAction</name></type> <name>condAction</name> <init>=
      <expr><call><name>pushDownCondOptGetCondAction</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>joinType</name></name></expr></argument>, <argument><expr><name>pLeftCols</name></expr></argument>, <argument><expr><name>pRightCols</name></expr></argument>, <argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>COND_ACTION_STAY</name> <operator>==</operator> <name>condAction</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>COND_ACTION_PUSH_JOIN</name> <operator>==</operator> <name>condAction</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOnCond</name> <operator>=</operator> <name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>COND_ACTION_PUSH_LEFT_CHILD</name> <operator>==</operator> <name>condAction</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pLeftChildCond</name> <operator>=</operator> <name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>COND_ACTION_PUSH_RIGHT_CHILD</name> <operator>==</operator> <name>condAction</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pRightChildCond</name> <operator>=</operator> <name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptPartCond</name><parameter_list>(<parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOnCond</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pLeftChildCond</name></decl></parameter>,
                                       <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pRightChildCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_CONDITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>pushDownCondOptPartLogicCond</name><argument_list>(<argument><expr><name>pJoin</name></expr></argument>, <argument><expr><name>pOnCond</name></expr></argument>, <argument><expr><name>pLeftChildCond</name></expr></argument>, <argument><expr><name>pRightChildCond</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>pushDownCondOptPartOpCond</name><argument_list>(<argument><expr><name>pJoin</name></expr></argument>, <argument><expr><name>pOnCond</name></expr></argument>, <argument><expr><name>pLeftChildCond</name></expr></argument>, <argument><expr><name>pRightChildCond</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptPushCondToOnCond</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>pushDownCondOptAppendCond</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name></expr></argument>, <argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptPushCondToChild</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pChild</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>pushDownCondOptAppendCond</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pChild</name><operator>-&gt;</operator><name>pConditions</name></name></expr></argument>, <argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>pushDownCondOptIsPriKey</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTableCols</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>PRIMARYKEY_TIMESTAMP_COL_ID</name> <operator>!=</operator> <name><name>pCol</name><operator>-&gt;</operator><name>colId</name></name> <operator>||</operator> <name>TSDB_SYSTEM_TABLE</name> <operator>==</operator> <name><name>pCol</name><operator>-&gt;</operator><name>tableType</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>pushDownCondOptBelongThisTable</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pTableCols</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>pushDownCondOptIsPriKeyEqualCond</name><parameter_list>(<parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_OPERATOR</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SOperatorNode</name><modifier>*</modifier></type> <name>pOper</name> <init>= <expr><operator>(</operator><name>SOperatorNode</name><operator>*</operator><operator>)</operator><name>pCond</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>OP_TYPE_EQUAL</name> <operator>!=</operator> <name><name>pOper</name><operator>-&gt;</operator><name>opType</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pLeftCols</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pTargets</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pRightCols</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pTargets</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>pushDownCondOptIsPriKey</name><argument_list>(<argument><expr><name><name>pOper</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pLeftCols</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>pushDownCondOptIsPriKey</name><argument_list>(<argument><expr><name><name>pOper</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>pRightCols</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>pushDownCondOptIsPriKey</name><argument_list>(<argument><expr><name><name>pOper</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>, <argument><expr><name>pRightCols</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>pushDownCondOptIsPriKey</name><argument_list>(<argument><expr><name><name>pOper</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>, <argument><expr><name>pLeftCols</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>pushDownCondOptContainPriKeyEqualCond</name><parameter_list>(<parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_CONDITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SLogicConditionNode</name><modifier>*</modifier></type> <name>pLogicCond</name> <init>= <expr><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><name>pCond</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>LOGIC_COND_TYPE_AND</name> <operator>!=</operator> <name><name>pLogicCond</name><operator>-&gt;</operator><name>condType</name></name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>bool</name></type>   <name>hasPrimaryKeyEqualCond</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pCond</argument>, <argument>pLogicCond-&gt;pParameterList</argument>)</argument_list></macro> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>pushDownCondOptContainPriKeyEqualCond</name><argument_list>(<argument><expr><name>pJoin</name></expr></argument>, <argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>hasPrimaryKeyEqualCond</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>hasPrimaryKeyEqualCond</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>pushDownCondOptIsPriKeyEqualCond</name><argument_list>(<argument><expr><name>pJoin</name></expr></argument>, <argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptCheckJoinOnCond</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>generateUsageErrMsg</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>pMsg</name></name></expr></argument>, <argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>msgLen</name></name></expr></argument>, <argument><expr><name>TSDB_CODE_PLAN_NOT_SUPPORT_CROSS_JOIN</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pushDownCondOptContainPriKeyEqualCond</name><argument_list>(<argument><expr><name>pJoin</name></expr></argument>, <argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>generateUsageErrMsg</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>pMsg</name></name></expr></argument>, <argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>msgLen</name></name></expr></argument>, <argument><expr><name>TSDB_CODE_PLAN_EXPECTED_TS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptPartJoinOnCondLogicCond</name><parameter_list>(<parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>ppMergeCond</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>ppOnCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicConditionNode</name><modifier>*</modifier></type> <name>pLogicCond</name> <init>= <expr><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>    <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pOnConds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>     <name>pCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pCond</argument>, <argument>pLogicCond-&gt;pParameterList</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>pushDownCondOptIsPriKeyEqualCond</name><argument_list>(<argument><expr><name>pJoin</name></expr></argument>, <argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>ppMergeCond</name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pOnConds</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTempOnCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesMergeConds</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pTempOnCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOnConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <operator>*</operator><name>ppMergeCond</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppOnCond</name> <operator>=</operator> <name>pTempOnCond</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pOnConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pTempOnCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_PLAN_INTERNAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptPartJoinOnCond</name><parameter_list>(<parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>ppMergeCond</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>ppOnCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_CONDITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <name>LOGIC_COND_TYPE_AND</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>condType</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>pushDownCondOptPartJoinOnCondLogicCond</name><argument_list>(<argument><expr><name>pJoin</name></expr></argument>, <argument><expr><name>ppMergeCond</name></expr></argument>, <argument><expr><name>ppOnCond</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>pushDownCondOptIsPriKeyEqualCond</name><argument_list>(<argument><expr><name>pJoin</name></expr></argument>, <argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppMergeCond</name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppOnCond</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_PLAN_INTERNAL_ERROR</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptJoinExtractMergeCond</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>pushDownCondOptCheckJoinOnCond</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pJoin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pJoinMergeCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pJoinOnCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptPartJoinOnCond</name><argument_list>(<argument><expr><name>pJoin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pJoinMergeCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pJoinOnCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pMergeCondition</name></name> <operator>=</operator> <name>pJoinMergeCond</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pJoin</name><operator>-&gt;</operator><name>pOnConditions</name></name> <operator>=</operator> <name>pJoinOnCond</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pJoinMergeCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pJoinOnCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptDealJoin</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>OPTIMIZE_FLAG_TEST_MASK</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_PUSH_DOWN_CONDE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>pushDownCondOptJoinExtractMergeCond</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pJoin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>OPTIMIZE_FLAG_SET_MASK</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_PUSH_DOWN_CONDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>code</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pOnCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pLeftChildCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pRightChildCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>pushDownCondOptPartCond</name><argument_list>(<argument><expr><name>pJoin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOnCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeftChildCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRightChildCond</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>pOnCond</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptPushCondToOnCond</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pJoin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOnCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>pLeftChildCond</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator>
        <call><name>pushDownCondOptPushCondToChild</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pLeftChildCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>pRightChildCond</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator>
        <call><name>pushDownCondOptPushCondToChild</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRightChildCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptJoinExtractMergeCond</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>OPTIMIZE_FLAG_SET_MASK</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_PUSH_DOWN_CONDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pOnCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pLeftChildCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pRightChildCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SPartAggCondContext</name> <block>{
  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>           <name>hasAggFunc</name></decl>;</decl_stmt>
}</block></struct></type> <name>SPartAggCondContext</name>;</typedef>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>partAggCondHasAggFuncImpl</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SPartAggCondContext</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><name>pContext</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pAggFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pAggFunc</argument>, <argument>pCxt-&gt;pAgg-&gt;pAggFuncs</argument>)</argument_list></macro> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pAggFunc</name><operator>)</operator><operator>-&gt;</operator><name><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>hasAggFunc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><name>DEAL_RES_END</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>partitionAggCondHasAggFunc</name><parameter_list>(<parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SPartAggCondContext</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>pAgg</name> <operator>=</operator> <name>pAgg</name></expr>, <expr><operator>.</operator><name>hasAggFunc</name> <operator>=</operator> <name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>, <argument><expr><name>partAggCondHasAggFuncImpl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>cxt</name><operator>.</operator><name>hasAggFunc</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>partitionAggCondConj</name><parameter_list>(<parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>ppAggFuncCond</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>ppGroupKeyCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicConditionNode</name><modifier>*</modifier></type> <name>pLogicCond</name> <init>= <expr><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>              <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pAggFuncConds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pGroupKeyConds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>     <name>pCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pCond</argument>, <argument>pLogicCond-&gt;pParameterList</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>partitionAggCondHasAggFunc</name><argument_list>(<argument><expr><name>pAgg</name></expr></argument>, <argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pAggFuncConds</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pGroupKeyConds</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTempAggFuncCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTempGroupKeyCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesMergeConds</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pTempAggFuncCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pAggFuncConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesMergeConds</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pTempGroupKeyCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pGroupKeyConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppAggFuncCond</name> <operator>=</operator> <name>pTempAggFuncCond</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppGroupKeyCond</name> <operator>=</operator> <name>pTempGroupKeyCond</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pAggFuncConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pGroupKeyConds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pTempAggFuncCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pTempGroupKeyCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>partitionAggCond</name><parameter_list>(<parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>ppAggFunCond</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>ppGroupKeyCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pAggNodeCond</name> <init>= <expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_CONDITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pAggNodeCond</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <name>LOGIC_COND_TYPE_AND</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><operator>(</operator><name>pAggNodeCond</name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>condType</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>partitionAggCondConj</name><argument_list>(<argument><expr><name>pAgg</name></expr></argument>, <argument><expr><name>ppAggFunCond</name></expr></argument>, <argument><expr><name>ppGroupKeyCond</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>partitionAggCondHasAggFunc</name><argument_list>(<argument><expr><name>pAgg</name></expr></argument>, <argument><expr><name>pAggNodeCond</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppAggFunCond</name> <operator>=</operator> <name>pAggNodeCond</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppGroupKeyCond</name> <operator>=</operator> <name>pAggNodeCond</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushCondToAggCond</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pAggFuncCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>pushDownCondOptAppendCond</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></argument>, <argument><expr><name>pAggFuncCond</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SRewriteAggGroupKeyCondContext</name> <block>{
  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>        <name>errCode</name></decl>;</decl_stmt>
}</block></struct></type> <name>SRewriteAggGroupKeyCondContext</name>;</typedef>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>rewriteAggGroupKeyCondForPushDownImpl</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SRewriteAggGroupKeyCondContext</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><name>pContext</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type>                  <name>pAgg</name> <init>= <expr><name><name>pCxt</name><operator>-&gt;</operator><name>pAgg</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><operator>*</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pGroupKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pGroupKey</argument>, <argument>pAgg-&gt;pGroupKeys</argument>)</argument_list></macro> <block>{<block_content>
      <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pGroup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <macro><name>FOREACH</name><argument_list>(<argument>pGroup</argument>, <argument>((SGroupingSetNode*)pGroupKey)-&gt;pParameterList</argument>)</argument_list></macro> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pGroup</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>pNode</name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pExpr</name> <init>= <expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>pExpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
            <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>*</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>pNode</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
          <return>return <expr><name>DEAL_RES_IGNORE_CHILD</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
    </block_content>}</block>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteAggGroupKeyCondForPushDown</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pGroupKeyCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SRewriteAggGroupKeyCondContext</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>pAgg</name> <operator>=</operator> <name>pAgg</name></expr>, <expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesRewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pGroupKeyCond</name></expr></argument>, <argument><expr><name>rewriteAggGroupKeyCondForPushDownImpl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptDealAgg</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>||</operator>
      <call><name>OPTIMIZE_FLAG_TEST_MASK</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_PUSH_DOWN_CONDE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// TODO: remove it after full implementation of pushing down to child</comment>
  <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pAggFuncCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pGroupKeyCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>partitionAggCond</name><argument_list>(<argument><expr><name>pAgg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pAggFuncCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pGroupKeyCond</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>pAggFuncCond</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushCondToAggCond</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pAgg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pAggFuncCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>pGroupKeyCond</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteAggGroupKeyCondForPushDown</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pAgg</name></expr></argument>, <argument><expr><name>pGroupKeyCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>pGroupKeyCond</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptPushCondToChild</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pChild</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pGroupKeyCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>OPTIMIZE_FLAG_SET_MASK</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_PUSH_DOWN_CONDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pGroupKeyCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pAggFuncCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SRewriteProjCondContext</name> <block>{
  <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProj</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>            <name>errCode</name></decl>;</decl_stmt>
}</block></struct></type> <name>SRewriteProjCondContext</name>;</typedef>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>rewriteProjectCondForPushDownImpl</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>ppNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SRewriteProjCondContext</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><name>pContext</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type>       <name>pProj</name> <init>= <expr><name><name>pCxt</name><operator>-&gt;</operator><name>pProj</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><operator>*</operator><name>ppNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTarget</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pTarget</argument>, <argument>pProj-&gt;node.pTargets</argument>)</argument_list></macro> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pTarget</name></expr></argument>, <argument><expr><operator>*</operator><name>ppNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pProjection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <macro><name>FOREACH</name><argument_list>(<argument>pProjection</argument>, <argument>pProj-&gt;pProjections</argument>)</argument_list></macro> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pProjection</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>ppNode</name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pExpr</name> <init>= <expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pProjection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>pExpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
              <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>*</operator><name>ppNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>ppNode</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
            <return>return <expr><name>DEAL_RES_IGNORE_CHILD</name></expr>;</return>
          </block_content>}</block></if></if_stmt>  <comment type="line">// end if expr alias name equal column name</comment>
        </block_content>}</block>    <comment type="line">// end for each project</comment>
      </block_content>}</block></if></if_stmt>      <comment type="line">// end if target node equals cond column node</comment>
    </block_content>}</block>        <comment type="line">// end for each targets</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteProjectCondForPushDown</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProject</name></decl></parameter>,
                                             <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>ppProjectCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SRewriteProjCondContext</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>pProj</name> <operator>=</operator> <name>pProject</name></expr>, <expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>                  <name>pProjectCond</name> <init>= <expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesRewriteExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pProjectCond</name></expr></argument>, <argument><expr><name>rewriteProjectCondForPushDownImpl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppProjectCond</name> <operator>=</operator> <name>pProjectCond</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptDealProject</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProject</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>||</operator>
      <call><name>OPTIMIZE_FLAG_TEST_MASK</name><argument_list>(<argument><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_PUSH_DOWN_CONDE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// TODO: remove it after full implementation of pushing down to child</comment>
  <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pLimit</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pSlimit</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pProjCond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteProjectCondForPushDown</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pProject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pProjCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptPushCondToChild</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pChild</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pProjCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>OPTIMIZE_FLAG_SET_MASK</name><argument_list>(<argument><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_PUSH_DOWN_CONDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pProjCond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptTrivialPushDown</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pLogicNode</name><operator>-&gt;</operator><name>pConditions</name></name> <operator>||</operator>
      <call><name>OPTIMIZE_FLAG_TEST_MASK</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_PUSH_DOWN_CONDE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>pushDownCondOptPushCondToChild</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pChild</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pLogicNode</name><operator>-&gt;</operator><name>pConditions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>OPTIMIZE_FLAG_SET_MASK</name><argument_list>(<argument><expr><name><name>pLogicNode</name><operator>-&gt;</operator><name>optimizedFlag</name></name></expr></argument>, <argument><expr><name>OPTIMIZE_FLAG_PUSH_DOWN_CONDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptimizeImpl</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptDealScan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_JOIN</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptDealJoin</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SJoinLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptDealAgg</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptDealProject</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SORT</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptTrivialPushDown</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pLogicNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pushDownCondOptimizeImpl</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownCondOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>pushDownCondOptimizeImpl</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>sortPriKeyOptIsPriKeyOrderBy</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSortKeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name>pSortKeys</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SOrderByExprNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name>pSortKeys</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pExpr</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>PRIMARYKEY_TIMESTAMP_COL_ID</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colId</name><operator>)</operator></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>sortPriKeyOptMayBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SORT</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SSortLogicNode</name><modifier>*</modifier></type> <name>pSort</name> <init>= <expr><operator>(</operator><name>SSortLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pSort</name><operator>-&gt;</operator><name>groupSort</name></name> <operator>||</operator> <operator>!</operator><call><name>sortPriKeyOptIsPriKeyOrderBy</name><argument_list>(<argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>pSortKeys</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sortPriKeyOptGetSequencingNodesImpl</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>bool</name><modifier>*</modifier></type> <name>pNotOptimize</name></decl></parameter>,
                                                   <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pSequencingNodes</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name> <operator>||</operator> <name>TSDB_SYSTEM_TABLE</name> <operator>==</operator> <name><name>pScan</name><operator>-&gt;</operator><name>tableType</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pNotOptimize</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><name>pSequencingNodes</name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_JOIN</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>sortPriKeyOptGetSequencingNodesImpl</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                                                         <argument><expr><name>pNotOptimize</name></expr></argument>, <argument><expr><name>pSequencingNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>sortPriKeyOptGetSequencingNodesImpl</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pNotOptimize</name></expr></argument>,
                                                   <argument><expr><name>pSequencingNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name></expr>:</case>
      <return>return <expr><call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><name>pSequencingNodes</name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr>:</case>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pNotOptimize</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pNotOptimize</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name>sortPriKeyOptGetSequencingNodesImpl</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pNotOptimize</name></expr></argument>,
                                             <argument><expr><name>pSequencingNodes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sortPriKeyOptGetSequencingNodes</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pSequencingNodes</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type>    <name>notOptimize</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>sortPriKeyOptGetSequencingNodesImpl</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>notOptimize</name></expr></argument>, <argument><expr><name>pSequencingNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name> <operator>||</operator> <name>notOptimize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>NODES_CLEAR_LIST</name><argument_list>(<argument><expr><operator>*</operator><name>pSequencingNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EOrder</name></type> <name>sortPriKeyOptGetPriKeyOrder</name><parameter_list>(<parameter><decl><type><name>SSortLogicNode</name><modifier>*</modifier></type> <name>pSort</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><name>SOrderByExprNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>pSortKeys</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>order</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sortPriKeyOptApply</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>, <parameter><decl><type><name>SSortLogicNode</name><modifier>*</modifier></type> <name>pSort</name></decl></parameter>,
                                  <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSequencingNodes</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>EOrder</name></type> <name>order</name> <init>= <expr><call><name>sortPriKeyOptGetPriKeyOrder</name><argument_list>(<argument><expr><name>pSort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pSequencingNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pSequencingNode</argument>, <argument>pSequencingNodes</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pSequencingNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pSequencingNode</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ORDER_DESC</name> <operator>==</operator> <name>order</name> <operator>&amp;&amp;</operator> <name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>ORDER_ASC</name> <operator>==</operator> <name>order</name> <operator>&amp;&amp;</operator> <name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_SUPER_TABLE</name> <operator>==</operator> <name><name>pScan</name><operator>-&gt;</operator><name>tableType</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanType</name></name> <operator>=</operator> <name>SCAN_TYPE_TABLE_MERGE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_GLOBAL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_GLOBAL</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>sortPrimaryKey</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pSequencingNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pSequencingNode</name><operator>)</operator><operator>-&gt;</operator><name>outputTsOrder</name> <operator>=</operator> <name>order</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>optSetParentOrder</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pSequencingNode</name><operator>)</operator><operator>-&gt;</operator><name>pParent</name></expr></argument>, <argument><expr><name>order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>

  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pParent</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>, <argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>replaceLogicNode</name><argument_list>(<argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pSort</name></expr></argument>, <argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>NODES_CLEAR_LIST</name><argument_list>(<argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sortPrimaryKeyOptimizeImpl</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>, <parameter><decl><type><name>SSortLogicNode</name><modifier>*</modifier></type> <name>pSort</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSequencingNodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>code</name> <init>=
      <expr><call><name>sortPriKeyOptGetSequencingNodes</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSequencingNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>pSequencingNodes</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>sortPriKeyOptApply</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name>pSort</name></expr></argument>, <argument><expr><name>pSequencingNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>nodesClearList</name><argument_list>(<argument><expr><name>pSequencingNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>sortPrimaryKeyOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SSortLogicNode</name><modifier>*</modifier></type> <name>pSort</name> <init>= <expr><operator>(</operator><name>SSortLogicNode</name><operator>*</operator><operator>)</operator><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>sortPriKeyOptMayBeOptimized</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSort</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>sortPrimaryKeyOptimizeImpl</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name>pSort</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>smaIndexOptMayBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>||</operator>
      <name>QUERY_NODE_LOGIC_PLAN_WINDOW</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
      <name>WINDOW_TYPE_INTERVAL</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name><operator>)</operator><operator>-&gt;</operator><name>winType</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pSmaIndexes</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>smaIndexOptCreateSmaScan</name><parameter_list>(<parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>, <parameter><decl><type><name>STableIndexInfo</name><modifier>*</modifier></type> <name>pIndex</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pCols</name></decl></parameter>,
                                        <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pSmaScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSmaScan</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>pScanCols</name></name> <operator>=</operator> <name>pCols</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>tableType</name></name> <operator>=</operator> <name>TSDB_SUPER_TABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>tableId</name></name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>dstTbUid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>stableId</name></name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>dstTbUid</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>scanType</name></name> <operator>=</operator> <name>SCAN_TYPE_TABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>scanRange</name></name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>scanRange</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>dataRequired</name></name> <operator>=</operator> <name>FUNC_DATA_REQUIRED_DATA_LOAD</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>pVgroupList</name></name> <operator>=</operator> <call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVgroupsInfo</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SVgroupInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name>pCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSmaScan</name><operator>-&gt;</operator><name>pVgroupList</name></name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>pSmaScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSmaScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>pVgroupList</name><operator>-&gt;</operator><name>numOfVgroups</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSmaScan</name><operator>-&gt;</operator><name>pVgroupList</name><operator>-&gt;</operator><name>vgroups</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>vgId</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>dstVgId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pSmaScan</name><operator>-&gt;</operator><name>pVgroupList</name><operator>-&gt;</operator><name>vgroups</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>epSet</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pIndex</name><operator>-&gt;</operator><name>epSet</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SEpSet</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>pOutput</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pSmaScan</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>smaIndexOptEqualInterval</name><parameter_list>(<parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>, <parameter><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWindow</name></decl></parameter>, <parameter><decl><type><name>STableIndexInfo</name><modifier>*</modifier></type> <name>pIndex</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pWindow</name><operator>-&gt;</operator><name>interval</name></name> <operator>!=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>interval</name></name> <operator>||</operator> <name><name>pWindow</name><operator>-&gt;</operator><name>intervalUnit</name></name> <operator>!=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>intervalUnit</name></name> <operator>||</operator>
      <name><name>pWindow</name><operator>-&gt;</operator><name>offset</name></name> <operator>!=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>offset</name></name> <operator>||</operator> <name><name>pWindow</name><operator>-&gt;</operator><name>sliding</name></name> <operator>!=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>sliding</name></name> <operator>||</operator>
      <name><name>pWindow</name><operator>-&gt;</operator><name>slidingUnit</name></name> <operator>!=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>slidingUnit</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>IS_TSWINDOW_SPECIFIED</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanRange</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SInterval</name></type> <name>interval</name> <init>= <expr><block>{<expr><operator>.</operator><name>interval</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>interval</name></name></expr>,
                          <expr><operator>.</operator><name>intervalUnit</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>intervalUnit</name></name></expr>,
                          <expr><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>offset</name></name></expr>,
                          <expr><operator>.</operator><name>offsetUnit</name> <operator>=</operator> <name>TIME_UNIT_MILLISECOND</name></expr>,
                          <expr><operator>.</operator><name>sliding</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>sliding</name></name></expr>,
                          <expr><operator>.</operator><name>slidingUnit</name> <operator>=</operator> <name><name>pIndex</name><operator>-&gt;</operator><name>slidingUnit</name></name></expr>,
                          <expr><operator>.</operator><name>precision</name> <operator>=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
    <return>return <expr><operator>(</operator><name><name>pScan</name><operator>-&gt;</operator><name>scanRange</name><operator>.</operator><name>skey</name></name> <operator>==</operator> <call><name>taosTimeTruncate</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanRange</name><operator>.</operator><name>skey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interval</name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
           <operator>(</operator><name><name>pScan</name><operator>-&gt;</operator><name>scanRange</name><operator>.</operator><name>ekey</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <call><name>taosTimeTruncate</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanRange</name><operator>.</operator><name>ekey</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>interval</name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>smaIndexOptCreateSmaCol</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pFunc</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>tableId</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>colId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_COLUMN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pCol</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>tableId</name></name> <operator>=</operator> <name>tableId</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>tableType</name></name> <operator>=</operator> <name>TSDB_SUPER_TABLE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colId</name></name> <operator>=</operator> <name>colId</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>colType</name></name> <operator>=</operator> <name>COLUMN_TYPE_COLUMN</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>resType</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pCol</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>smaIndexOptFindSmaFunc</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pQueryFunc</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSmaFuncs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pSmaFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pSmaFunc</argument>, <argument>pSmaFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pQueryFunc</name></expr></argument>, <argument><expr><name>pSmaFunc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>index</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>++</operator><name>index</name></expr>;</expr_stmt>
  </block_content>}</block>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>smaIndexOptCreateSmaCols</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pFuncs</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>tableId</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSmaFuncs</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutput</name></decl></parameter>,
                                        <parameter><decl><type><name>int32_t</name><modifier>*</modifier></type> <name>pWStrartIndex</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pCols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>     <name>pFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>smaFuncIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pWStrartIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pFunc</argument>, <argument>pFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>FUNCTION_TYPE_WSTART</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>funcType</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pWStrartIndex</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>smaFuncIndex</name> <operator>=</operator> <call><name>smaIndexOptFindSmaFunc</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><name>pSmaFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>smaFuncIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pCols</name></expr></argument>, <argument><expr><call><name>smaIndexOptCreateSmaCol</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>smaFuncIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>++</operator><name>index</name></expr>;</expr_stmt>
  </block_content>}</block>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>smaFuncIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOutput</name> <operator>=</operator> <name>pCols</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>smaIndexOptCouldApplyIndex</name><parameter_list>(<parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>, <parameter><decl><type><name>STableIndexInfo</name><modifier>*</modifier></type> <name>pIndex</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pCols</name></decl></parameter>,
                                          <parameter><decl><type><name>int32_t</name><modifier>*</modifier></type> <name>pWStrartIndex</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWindow</name> <init>= <expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pParent</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>smaIndexOptEqualInterval</name><argument_list>(<argument><expr><name>pScan</name></expr></argument>, <argument><expr><name>pWindow</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSmaFuncs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>code</name> <init>= <expr><call><name>nodesStringToList</name><argument_list>(<argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSmaFuncs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>smaIndexOptCreateSmaCols</name><argument_list>(<argument><expr><name><name>pWindow</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><name><name>pIndex</name><operator>-&gt;</operator><name>dstTbUid</name></name></expr></argument>, <argument><expr><name>pSmaFuncs</name></expr></argument>, <argument><expr><name>pCols</name></expr></argument>, <argument><expr><name>pWStrartIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pSmaFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>smaIndexOptApplyIndex</name><parameter_list>(<parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>, <parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>, <parameter><decl><type><name>STableIndexInfo</name><modifier>*</modifier></type> <name>pIndex</name></decl></parameter>,
                                     <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSmaCols</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>wstrartIndex</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pSmaScan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>smaIndexOptCreateSmaScan</name><argument_list>(<argument><expr><name>pScan</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name>pSmaCols</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSmaScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>replaceLogicNode</name><argument_list>(<argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pParent</name></name></expr></argument>, <argument><expr><name>pSmaScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>smaIndexOptDestroySmaIndex</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>STableIndexInfo</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>smaIndexOptimizeImpl</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>, <parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>nindexes</name> <init>= <expr><call><name>taosArrayGetSize</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pSmaIndexes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>STableIndexInfo</name><modifier>*</modifier></type> <name>pIndex</name> <init>= <expr><call><name>taosArrayGet</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pSmaIndexes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type>       <name>pSmaCols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type>          <name>wstrartIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>smaIndexOptCouldApplyIndex</name><argument_list>(<argument><expr><name>pScan</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSmaCols</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wstrartIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>pSmaCols</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>smaIndexOptApplyIndex</name><argument_list>(<argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name>pScan</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name>pSmaCols</name></expr></argument>, <argument><expr><name>wstrartIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>taosArrayDestroyEx</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pSmaIndexes</name></name></expr></argument>, <argument><expr><name>smaIndexOptDestroySmaIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>pSmaIndexes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>smaIndexOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>smaIndexOptMayBeOptimized</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pScan</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>smaIndexOptimizeImpl</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name>pScan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>partTagsOptHasColImpl</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>COLUMN_TYPE_TAG</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colType</name> <operator>&amp;&amp;</operator> <name>COLUMN_TYPE_TBNAME</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colType</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><name>pContext</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <return>return <expr><name>DEAL_RES_END</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>planOptNodeListHasCol</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pKeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>hasCol</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesWalkExprs</name><argument_list>(<argument><expr><name>pKeys</name></expr></argument>, <argument><expr><name>partTagsOptHasColImpl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>hasCol</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>partTagsOptHasTbname</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>COLUMN_TYPE_TBNAME</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colType</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><name>pContext</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <return>return <expr><name>DEAL_RES_END</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>planOptNodeListHasTbname</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pKeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>hasCol</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesWalkExprs</name><argument_list>(<argument><expr><name>pKeys</name></expr></argument>, <argument><expr><name>partTagsOptHasTbname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>hasCol</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>partTagsIsOptimizableNode</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>||</operator>
           <operator>(</operator><name>QUERY_NODE_LOGIC_PLAN_AGG</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pGroupKeys</name> <operator>&amp;&amp;</operator>
            <name>NULL</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pAggFuncs</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
          <literal type="number">1</literal> <operator>==</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
          <name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNodeList</name><modifier>*</modifier></type> <name>partTagsGetPartKeys</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><name>SPartitionLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pPartitionKeys</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pGroupKeys</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNodeList</name><modifier>*</modifier></type> <name>partTagsGetFuncs</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pAggFuncs</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>partTagsOptAreSupportedFuncs</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pFuncs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pFunc</argument>, <argument>pFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>fmIsIndefiniteRowsFunc</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>funcId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>fmIsSelectFunc</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>funcId</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>partTagsOptMayBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>partTagsIsOptimizableNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><operator>!</operator><call><name>planOptNodeListHasCol</name><argument_list>(<argument><expr><call><name>partTagsGetPartKeys</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>partTagsOptAreSupportedFuncs</name><argument_list>(<argument><expr><call><name>partTagsGetFuncs</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>partTagsOptRebuildTbanme</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pPartKeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesRewriteExprs</name><argument_list>(<argument><expr><name>pPartKeys</name></expr></argument>, <argument><expr><name>optRebuildTbanme</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// todo refact: just to mask compilation warnings</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>partTagsSetAlias</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>pAlias</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pTableAlias</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pColName</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pAlias</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>pTableAlias</name></expr></argument>, <argument><expr><name>pColName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>partTagsCreateWrapperFunc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pFuncName</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_FUNCTION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pFunc</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>pFuncName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>COLUMN_TYPE_TBNAME</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colType</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>partTagsSetAlias</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>tableAlias</name></name></expr></argument>, <argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFunc</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>fmGetFuncInfo</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>partTagsHasIndefRowsSelectFunc</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pFuncs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pFunc</argument>, <argument>pFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>fmIsIndefiniteRowsFunc</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>funcId</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>partTagsNeedOutput</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pExpr</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTargets</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pOutput</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pOutput</argument>, <argument>pTargets</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pOutput</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pOutput</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>partTagsRewriteGroupTagsToFuncs</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pGroupTags</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type>    <name>hasIndefRowsSelectFunc</name> <init>= <expr><call><name>partTagsHasIndefRowsSelectFunc</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pGroupTags</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>index</name><operator>++</operator> <operator>&lt;</operator> <name>start</name> <operator>||</operator> <operator>!</operator><call><name>partTagsNeedOutput</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>hasIndefRowsSelectFunc</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><call><name>partTagsCreateWrapperFunc</name><argument_list>(<argument><expr><literal type="string">"_select_value"</literal></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><call><name>partTagsCreateWrapperFunc</name><argument_list>(<argument><expr><literal type="string">"_group_key"</literal></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>partTagsOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name> <init>= <expr><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>partTagsOptMayBeOptimized</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pNode</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>         <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SPartitionLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pPartitionKeys</name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SPartitionLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pTags</name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SPartitionLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pSubtable</name></expr></argument>, <argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pSubtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>replaceLogicNode</name><argument_list>(<argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustLogicNodeDataRequirement</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pScan</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>resultDataOrder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>NODES_CLEAR_LIST</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name> <init>= <expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type>        <name>start</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>         <name>pGroupKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pGroupKey</argument>, <argument>pAgg-&gt;pGroupKeys</argument>)</argument_list></macro> <block>{<block_content>
      <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pGroupExpr</name> <init>= <expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SGroupingSetNode</name><operator>*</operator><operator>)</operator><name>pGroupKey</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pGroupTag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <macro><name>FOREACH</name><argument_list>(<argument>pGroupTag</argument>, <argument>pScan-&gt;pGroupTags</argument>)</argument_list></macro> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pGroupTag</name></expr></argument>, <argument><expr><name>pGroupExpr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pGroupExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>start</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>partTagsRewriteGroupTagsToFuncs</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>pAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>partTagsOptRebuildTbanme</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>eliminateProjOptCheckProjColumnNames</name><parameter_list>(<parameter><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProjectNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SHashObj</name><modifier>*</modifier></type> <name>pProjColNameHash</name> <init>= <expr><call><name>taosHashInit</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><call><name>taosGetDefaultHashFunction</name><argument_list>(<argument><expr><name>TSDB_DATA_TYPE_BINARY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>HASH_NO_LOCK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>    <name>pProjection</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pProjection</argument>, <argument>pProjectNode-&gt;pProjections</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>    <name>projColumnName</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pProjection</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name><modifier>*</modifier></type> <name>pExist</name> <init>= <expr><call><name>taosHashGet</name><argument_list>(<argument><expr><name>pProjColNameHash</name></expr></argument>, <argument><expr><name>projColumnName</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>projColumnName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>pExist</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name>pProjColNameHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>exist</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>taosHashPut</name><argument_list>(<argument><expr><name>pProjColNameHash</name></expr></argument>, <argument><expr><name>projColumnName</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>projColumnName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>exist</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>exist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>
  <expr_stmt><expr><call><name>taosHashCleanup</name><argument_list>(<argument><expr><name>pProjColNameHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>eliminateProjOptMayBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="line">// TODO: enable this optimization after new mechanising that map projection and targets of project node</comment>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// Super table scan requires project operator to merge packets to improve performance.</comment>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
      <operator>(</operator><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
       <name>TSDB_SUPER_TABLE</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>tableType</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProjectNode</name> <init>= <expr><operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pProjectNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pLimit</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pProjectNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pSlimit</name></name> <operator>||</operator>
      <name>NULL</name> <operator>!=</operator> <name><name>pProjectNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pProjection</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pProjection</argument>, <argument>pProjectNode-&gt;pProjections</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SExprNode</name><modifier>*</modifier></type> <name>pExprNode</name> <init>= <expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pProjection</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pExprNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <return>return <expr><call><name>eliminateProjOptCheckProjColumnNames</name><argument_list>(<argument><expr><name>pProjectNode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>CheckNewChildTargetsCxt</name> <block>{
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pNewChildTargets</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>       <name>canUse</name></decl>;</decl_stmt>
}</block></struct></type> <name>CheckNewChildTargetsCxt</name>;</typedef>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>eliminateProjOptCanUseNewChildTargetsImpl</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CheckNewChildTargetsCxt</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><name>pContext</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>                   <name>pTarget</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pTarget</argument>, <argument>pCxt-&gt;pNewChildTargets</argument>)</argument_list></macro> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pTarget</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>canUse</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>canUse</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <return>return <expr><name>DEAL_RES_END</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>eliminateProjOptCanChildConditionUseChildTargets</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pChild</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pNewChildTargets</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pChild</name><operator>-&gt;</operator><name>pConditions</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>CheckNewChildTargetsCxt</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>pNewChildTargets</name> <operator>=</operator> <name>pNewChildTargets</name></expr>, <expr><operator>.</operator><name>canUse</name> <operator>=</operator> <name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pConditions</name></name></expr></argument>, <argument><expr><name>eliminateProjOptCanUseNewChildTargetsImpl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cxt</name><operator>.</operator><name>canUse</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_JOIN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>SJoinLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name><operator>)</operator><operator>-&gt;</operator><name>pOnConditions</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type>         <name>pJoinLogicNode</name> <init>= <expr><operator>(</operator><name>SJoinLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CheckNewChildTargetsCxt</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>pNewChildTargets</name> <operator>=</operator> <name>pNewChildTargets</name></expr>, <expr><operator>.</operator><name>canUse</name> <operator>=</operator> <name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name><name>pJoinLogicNode</name><operator>-&gt;</operator><name>pOnConditions</name></name></expr></argument>, <argument><expr><name>eliminateProjOptCanUseNewChildTargetsImpl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cxt</name><operator>.</operator><name>canUse</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>alignProjectionWithTarget</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name> <operator>!=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProjectNode</name> <init>= <expr><operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>             <name>pProjection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pProjection</argument>, <argument>pProjectNode-&gt;pProjections</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTarget</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>   <name>keep</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pTarget</argument>, <argument>pNode-&gt;pTargets</argument>)</argument_list></macro> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pProjection</name><operator>)</operator><operator>-&gt;</operator><name><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pTarget</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>keep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>keep</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>nodesListErase</name><argument_list>(<argument><expr><name><name>pProjectNode</name><operator>-&gt;</operator><name>pProjections</name></name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>eliminateProjOptimizeImpl</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>,
                                         <parameter><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProjectNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pProjectNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type>  <name>pNewChildTargets</name> <init>= <expr><call><name>nodesMakeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pProjection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pProjection</argument>, <argument>pProjectNode-&gt;pProjections</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChildTarget</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pChildTarget</argument>, <argument>pChild-&gt;pTargets</argument>)</argument_list></macro> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pProjection</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pChildTarget</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>nodesListAppend</name><argument_list>(<argument><expr><name>pNewChildTargets</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pChildTarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block>
  <if_stmt><if>if <condition>(<expr><call><name>eliminateProjOptCanChildConditionUseChildTargets</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>, <argument><expr><name>pNewChildTargets</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pChild</name><operator>-&gt;</operator><name>pTargets</name></name> <operator>=</operator> <name>pNewChildTargets</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pNewChildTargets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>replaceLogicNode</name><argument_list>(<argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pProjectNode</name></expr></argument>, <argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>NODES_CLEAR_LIST</name><argument_list>(<argument><expr><name><name>pProjectNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pProjectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// if pChild is a project logic node, remove its projection which is not reference by its target.</comment>
    <expr_stmt><expr><call><name>alignProjectionWithTarget</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>eliminateProjOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProjectNode</name> <init>=
      <expr><operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>eliminateProjOptMayBeOptimized</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pProjectNode</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name>eliminateProjOptimizeImpl</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name>pProjectNode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>rewriteTailOptMayBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>QUERY_NODE_LOGIC_PLAN_INDEF_ROWS_FUNC</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>SIndefRowsFuncLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>isTailFunc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>rewriteTailOptCreateOrderByExpr</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pSortKey</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SOrderByExprNode</name><modifier>*</modifier></type> <name>pOrder</name> <init>= <expr><operator>(</operator><name>SOrderByExprNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_ORDER_BY_EXPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pOrder</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pOrder</name><operator>-&gt;</operator><name>order</name></name> <operator>=</operator> <name>ORDER_DESC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOrder</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pSortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pOrder</name><operator>-&gt;</operator><name>pExpr</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pOrder</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteTailOptCreateLimit</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pLimit</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pOffset</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLimitNode</name><modifier>*</modifier></type> <name>pLimitNode</name> <init>= <expr><operator>(</operator><name>SLimitNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LIMIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pLimitNode</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pLimitNode</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <ternary><condition><expr><name>NULL</name> <operator>==</operator> <name>pLimit</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>SValueNode</name><operator>*</operator><operator>)</operator><name>pLimit</name><operator>)</operator><operator>-&gt;</operator><name><name>datum</name><operator>.</operator><name>i</name></name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pLimitNode</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <ternary><condition><expr><name>NULL</name> <operator>==</operator> <name>pOffset</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><name>SValueNode</name><operator>*</operator><operator>)</operator><name>pOffset</name><operator>)</operator><operator>-&gt;</operator><name><name>datum</name><operator>.</operator><name>i</name></name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pOutput</name> <operator>=</operator> <operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pLimitNode</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>rewriteTailOptNeedGroupSort</name><parameter_list>(<parameter><decl><type><name>SIndefRowsFuncLogicNode</name><modifier>*</modifier></type> <name>pIndef</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call> <operator>||</operator>
         <operator>(</operator><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name><operator>)</operator><operator>-&gt;</operator><name>pGroupTags</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteTailOptCreateSort</name><parameter_list>(<parameter><decl><type><name>SIndefRowsFuncLogicNode</name><modifier>*</modifier></type> <name>pIndef</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SSortLogicNode</name><modifier>*</modifier></type> <name>pSort</name> <init>= <expr><operator>(</operator><name>SSortLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_SORT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSort</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>groupSort</name></name> <operator>=</operator> <call><name>rewriteTailOptNeedGroupSort</name><argument_list>(<argument><expr><name>pIndef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>optResetParent</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name> <operator>=</operator> <name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pTail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>         <name>pFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pFunc</argument>, <argument>pIndef-&gt;pFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>FUNCTION_TYPE_TAIL</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>funcType</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>pTail</name> <operator>=</operator> <operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <comment type="line">// tail(expr, [limit, offset,] _rowts)</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>rowtsIndex</name> <init>= <expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pTail</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesListMakeStrictAppend</name><argument_list>(
      <argument><expr><operator>&amp;</operator><name><name>pSort</name><operator>-&gt;</operator><name>pSortKeys</name></name></expr></argument>, <argument><expr><call><name>rewriteTailOptCreateOrderByExpr</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pTail</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><name>rowtsIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pTargets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOutput</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pSort</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>rewriteTailOptCreateProjectExpr</name><parameter_list>(<parameter><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pExpr</name> <init>= <expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pExpr</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>, <argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pExpr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteTailOptCreateProject</name><parameter_list>(<parameter><decl><type><name>SIndefRowsFuncLogicNode</name><modifier>*</modifier></type> <name>pIndef</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProject</name> <init>= <expr><operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pProject</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>, <argument><expr><name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name> <operator>=</operator> <name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>        <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pTail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>         <name>pFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pFunc</argument>, <argument>pIndef-&gt;pFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pProject</name><operator>-&gt;</operator><name>pProjections</name></name></expr></argument>, <argument><expr><call><name>rewriteTailOptCreateProjectExpr</name><argument_list>(<argument><expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>FUNCTION_TYPE_TAIL</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>funcType</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>pTail</name> <operator>=</operator> <operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <comment type="line">// tail(expr, [limit, offset,] _rowts)</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>limitIndex</name> <init>= <expr><ternary><condition><expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pTail</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>offsetIndex</name> <init>= <expr><ternary><condition><expr><call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pTail</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteTailOptCreateLimit</name><argument_list>(<argument><expr><ternary><condition><expr><name>limitIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pTail</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><name>limitIndex</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
                                     <argument><expr><ternary><condition><expr><name>offsetIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pTail</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><name>offsetIndex</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOutput</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pProject</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteTailOptimizeImpl</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>,
                                       <parameter><decl><type><name>SIndefRowsFuncLogicNode</name><modifier>*</modifier></type> <name>pIndef</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pSort</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pProject</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>rewriteTailOptCreateSort</name><argument_list>(<argument><expr><name>pIndef</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteTailOptCreateProject</name><argument_list>(<argument><expr><name>pIndef</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pProject</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pProject</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSort</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>replaceLogicNode</name><argument_list>(<argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pIndef</name></expr></argument>, <argument><expr><name>pProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pIndef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteTailOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SIndefRowsFuncLogicNode</name><modifier>*</modifier></type> <name>pIndef</name> <init>=
      <expr><operator>(</operator><name>SIndefRowsFuncLogicNode</name><operator>*</operator><operator>)</operator><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>rewriteTailOptMayBeOptimized</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pIndef</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name>rewriteTailOptimizeImpl</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name>pIndef</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>eliminateSetOpMayBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pParent</name> <init>= <expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pParent</name> <operator>||</operator>
      <name>QUERY_NODE_LOGIC_PLAN_AGG</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>QUERY_NODE_LOGIC_PLAN_PROJECT</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>)</argument_list></call> <operator>||</operator>
      <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>eliminateSetOpOptimizeImpl</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>,
                                          <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pSetOpNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pSibling</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pSibling</argument>, <argument>pSetOpNode-&gt;pParent-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pSibling</name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSetOpNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name></decl>;</decl_stmt>
      <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pSetOpNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name><operator>)</operator><operator>-&gt;</operator><name>pParent</name> <operator>=</operator> <name><name>pSetOpNode</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt> </block_content>}</block>
      <expr_stmt><expr><call><name>INSERT_LIST</name><argument_list>(<argument><expr><name><name>pSetOpNode</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><name><name>pSetOpNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>pSetOpNode</name><operator>-&gt;</operator><name>pChildren</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ERASE_NODE</name><argument_list>(<argument><expr><name><name>pSetOpNode</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <return>return <expr><name>TSDB_CODE_PLAN_INTERNAL_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>eliminateSetOpOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pSetOpNode</name> <init>= <expr><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>eliminateSetOpMayBeOptimized</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSetOpNode</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name>eliminateSetOpOptimizeImpl</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name>pSetOpNode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>rewriteUniqueOptMayBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>QUERY_NODE_LOGIC_PLAN_INDEF_ROWS_FUNC</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>SIndefRowsFuncLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>isUniqueFunc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>rewriteUniqueOptCreateGroupingSet</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SGroupingSetNode</name><modifier>*</modifier></type> <name>pGroupingSet</name> <init>= <expr><operator>(</operator><name>SGroupingSetNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_GROUPING_SET</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pGroupingSet</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pGroupingSet</name><operator>-&gt;</operator><name>groupingSetType</name></name> <operator>=</operator> <name>GP_TYPE_NORMAL</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SExprNode</name><modifier>*</modifier></type> <name>pGroupExpr</name> <init>= <expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pGroupingSet</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pGroupExpr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pGroupingSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pGroupingSet</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>rewriteUniqueOptCreateFirstFunc</name><parameter_list>(<parameter><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pSelectValue</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCol</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_FUNCTION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pFunc</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>, <argument><expr><literal type="string">"first"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>pSelectValue</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><name><name>pSelectValue</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>pointer</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>pFunc</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%"</literal> <name>PRId64</name> <literal type="string">""</literal></expr></argument>, <argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFunc</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>fmGetFuncInfo</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteUniqueOptCreateAgg</name><parameter_list>(<parameter><decl><type><name>SIndefRowsFuncLogicNode</name><modifier>*</modifier></type> <name>pIndef</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name> <init>= <expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pAgg</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>optResetParent</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name> <operator>=</operator> <name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_IN_BLOCK</name></expr>;</expr_stmt>  <comment type="line">// first function requirement</comment>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_NONE</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>    <name>hasSelectPrimaryKey</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pPrimaryKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pIndef-&gt;pFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>         <name>pExpr</name> <init>= <expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>FUNCTION_TYPE_UNIQUE</name> <operator>==</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>funcType</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>pPrimaryKey</name> <operator>=</operator> <call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>, <argument><expr><call><name>rewriteUniqueOptCreateGroupingSet</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>PRIMARYKEY_TIMESTAMP_COL_ID</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>colId</name></expr>)</condition> <block>{<block_content>  <comment type="line">// _select_value(ts) =&gt; first(ts)</comment>
      <expr_stmt><expr><name>hasSelectPrimaryKey</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><call><name>rewriteUniqueOptCreateFirstFunc</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="line">// _select_value(other_col)</comment>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasSelectPrimaryKey</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><call><name>rewriteUniqueOptCreateFirstFunc</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pPrimaryKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOutput</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>rewriteUniqueOptCreateProjectCol</name><parameter_list>(<parameter><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_COLUMN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pCol</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name></name> <operator>=</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>FUNCTION_TYPE_UNIQUE</name> <operator>==</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>funcType</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SExprNode</name><modifier>*</modifier></type> <name>pExpr</name> <init>= <expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>tableAlias</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>tableAlias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>aliasName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pCol</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteUniqueOptCreateProject</name><parameter_list>(<parameter><decl><type><name>SIndefRowsFuncLogicNode</name><modifier>*</modifier></type> <name>pIndef</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProject</name> <init>= <expr><operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pProject</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>, <argument><expr><name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name> <operator>=</operator> <name><name>pIndef</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>requireDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resultDataOrder</name></name> <operator>=</operator> <name>DATA_ORDER_LEVEL_NONE</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pIndef-&gt;pFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pProject</name><operator>-&gt;</operator><name>pProjections</name></name></expr></argument>, <argument><expr><call><name>rewriteUniqueOptCreateProjectCol</name><argument_list>(<argument><expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOutput</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pProject</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteUniqueOptimizeImpl</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>,
                                         <parameter><decl><type><name>SIndefRowsFuncLogicNode</name><modifier>*</modifier></type> <name>pIndef</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pAgg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pProject</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>rewriteUniqueOptCreateAgg</name><argument_list>(<argument><expr><name>pIndef</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pAgg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rewriteUniqueOptCreateProject</name><argument_list>(<argument><expr><name>pIndef</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pProject</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>pProject</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pAgg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>replaceLogicNode</name><argument_list>(<argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pIndef</name></expr></argument>, <argument><expr><name>pProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>adjustLogicNodeDataRequirement</name><argument_list>(
        <argument><expr><name>pProject</name></expr></argument>, <argument><expr><ternary><condition><expr><name>NULL</name> <operator>==</operator> <name><name>pProject</name><operator>-&gt;</operator><name>pParent</name></name></expr> ?</condition><then> <expr><name>DATA_ORDER_LEVEL_NONE</name></expr> </then><else>: <expr><name><name>pProject</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>requireDataOrder</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pProject</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pIndef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>rewriteUniqueOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SIndefRowsFuncLogicNode</name><modifier>*</modifier></type> <name>pIndef</name> <init>=
      <expr><operator>(</operator><name>SIndefRowsFuncLogicNode</name><operator>*</operator><operator>)</operator><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>rewriteUniqueOptMayBeOptimized</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pIndef</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name>rewriteUniqueOptimizeImpl</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name>pIndef</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SLastRowScanOptLastParaCkCxt</name> <block>{
  <decl_stmt><decl><type><name>bool</name></type> <name>hasTag</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>hasCol</name></decl>;</decl_stmt>
}</block></struct></type> <name>SLastRowScanOptLastParaCkCxt</name>;</typedef>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>lastRowScanOptLastParaCheckImpl</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SLastRowScanOptLastParaCkCxt</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><name>pContext</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>COLUMN_TYPE_TAG</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colType</name> <operator>||</operator> <name>COLUMN_TYPE_TBNAME</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colType</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>hasTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>hasCol</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>DEAL_RES_END</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>lastRowScanOptLastParaCheck</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLastRowScanOptLastParaCkCxt</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>hasTag</name> <operator>=</operator> <name>false</name></expr>, <expr><operator>.</operator><name>hasCol</name> <operator>=</operator> <name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>lastRowScanOptLastParaCheckImpl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>!</operator><name><name>cxt</name><operator>.</operator><name>hasTag</name></name> <operator>&amp;&amp;</operator> <name><name>cxt</name><operator>.</operator><name>hasCol</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>hasSuitableCache</name><parameter_list>(<parameter><decl><type><name>int8_t</name></type> <name>cacheLastMode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasLastRow</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasLast</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>cacheLastMode</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_CACHE_MODEL_NONE</name></expr>:</case>
      <return>return <expr><name>false</name></expr>;</return>
    <case>case <expr><name>TSDB_CACHE_MODEL_LAST_ROW</name></expr>:</case>
      <return>return <expr><name>hasLastRow</name></expr>;</return>
    <case>case <expr><name>TSDB_CACHE_MODEL_LAST_VALUE</name></expr>:</case>
      <return>return <expr><name>hasLast</name></expr>;</return>
    <case>case <expr><name>TSDB_CACHE_MODEL_BOTH</name></expr>:</case>
      <return>return <expr><name>true</name></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>lastRowScanOptMayBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
      <name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type>  <name>pAgg</name> <init>= <expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// Only one of LAST and LASTROW can appear</comment>
  <if_stmt><if>if <condition>(<expr><name><name>pAgg</name><operator>-&gt;</operator><name>hasLastRow</name></name> <operator>==</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>hasLast</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>||</operator>
      <operator>!</operator><call><name>hasSuitableCache</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>cacheLastMode</name></name></expr></argument>, <argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>hasLastRow</name></name></expr></argument>, <argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>hasLast</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
      <call><name>IS_TSWINDOW_SPECIFIED</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanRange</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>bool</name></type>   <name>hasLastFunc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>   <name>hasSelectFunc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pFunc</argument>, <argument>((SAggLogicNode*)pNode)-&gt;pAggFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pAggFunc</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>FUNCTION_TYPE_LAST</name> <operator>==</operator> <name><name>pAggFunc</name><operator>-&gt;</operator><name>funcType</name></name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>hasSelectFunc</name> <operator>||</operator> <operator>!</operator><call><name>lastRowScanOptLastParaCheck</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pAggFunc</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>hasLastFunc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>FUNCTION_TYPE_SELECT_VALUE</name> <operator>==</operator> <name><name>pAggFunc</name><operator>-&gt;</operator><name>funcType</name></name> <operator>||</operator> <name>FUNCTION_TYPE_GROUP_KEY</name> <operator>==</operator> <name><name>pAggFunc</name><operator>-&gt;</operator><name>funcType</name></name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>hasLastFunc</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>hasSelectFunc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>FUNCTION_TYPE_LAST_ROW</name> <operator>!=</operator> <name><name>pAggFunc</name><operator>-&gt;</operator><name>funcType</name></name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SLastRowScanOptSetColDataTypeCxt</name> <block>{
  <decl_stmt><decl><type><name>bool</name></type>       <name>doAgg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pLastCols</name></decl>;</decl_stmt>
}</block></struct></type> <name>SLastRowScanOptSetColDataTypeCxt</name>;</typedef>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>lastRowScanOptSetColDataType</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SLastRowScanOptSetColDataTypeCxt</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><name>pContext</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pCxt</name><operator>-&gt;</operator><name>doAgg</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCxt</name><operator>-&gt;</operator><name>pLastCols</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>getLastCacheDataType</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name><name>node</name><operator>.</operator><name>resType</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <macro><name>FOREACH</name><argument_list>(<argument>pCol</argument>, <argument>pCxt-&gt;pLastCols</argument>)</argument_list></macro> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>getLastCacheDataType</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name><name>node</name><operator>.</operator><name>resType</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>DEAL_RES_IGNORE_CHILD</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>lastRowScanOptSetLastTargets</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTargets</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pLastCols</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTarget</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>WHERE_EACH</name><argument_list>(<argument>pTarget</argument>, <argument>pTargets</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>   <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pCol</argument>, <argument>pLastCols</argument>)</argument_list></macro> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>, <argument><expr><name>pTarget</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>getLastCacheDataType</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pTarget</name><operator>)</operator><operator>-&gt;</operator><name><name>node</name><operator>.</operator><name>resType</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ERASE_NODE</name><argument_list>(<argument><expr><name>pTargets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>WHERE_NEXT</name></expr>;</expr_stmt>
  </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>lastRowScanOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name> <init>= <expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>lastRowScanOptMayBeOptimized</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pAgg</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SLastRowScanOptSetColDataTypeCxt</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>doAgg</name> <operator>=</operator> <name>true</name></expr>, <expr><operator>.</operator><name>pLastCols</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>                           <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pAgg-&gt;pAggFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type>        <name>funcType</name> <init>= <expr><name><name>pFunc</name><operator>-&gt;</operator><name>funcType</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>FUNCTION_TYPE_LAST_ROW</name> <operator>==</operator> <name>funcType</name> <operator>||</operator> <name>FUNCTION_TYPE_LAST</name> <operator>==</operator> <name>funcType</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>len</name> <init>= <expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                             <argument><expr><ternary><condition><expr><name>FUNCTION_TYPE_LAST_ROW</name> <operator>==</operator> <name>funcType</name></expr> ?</condition><then> <expr><literal type="string">"_cache_last_row"</literal></expr> </then><else>: <expr><literal type="string">"_cache_last"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pFunc</name><operator>-&gt;</operator><name>functionName</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>fmGetFuncInfo</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>nodesClearList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pLastCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>code</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>FUNCTION_TYPE_LAST</name> <operator>==</operator> <name>funcType</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>nodesWalkExpr</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lastRowScanOptSetColDataType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>nodesListErase</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><call><name>nodesListGetCell</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanType</name></name> <operator>=</operator> <name>SCAN_TYPE_LAST_ROW</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>igLastNull</name></name> <operator>=</operator> <ternary><condition><expr><name><name>pAgg</name><operator>-&gt;</operator><name>hasLast</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>cxt</name><operator>.</operator><name>pLastCols</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>doAgg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lastRowScanOptSetLastTargets</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>pLastCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesWalkExprs</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>, <argument><expr><name>lastRowScanOptSetColDataType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lastRowScanOptSetLastTargets</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>pLastCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesClearList</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>pLastCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>hasLastRow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAgg</name><operator>-&gt;</operator><name>hasLast</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// merge projects</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>mergeProjectsMayBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="number">1</literal> <operator>&lt;</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
      <name>NULL</name> <operator>!=</operator> <name><name>pChild</name><operator>-&gt;</operator><name>pConditions</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pChild</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pChild</name><operator>-&gt;</operator><name>pSlimit</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SMergeProjectionsContext</name> <block>{
  <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pChildProj</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>            <name>errCode</name></decl>;</decl_stmt>
}</block></struct></type> <name>SMergeProjectionsContext</name>;</typedef>

<function><type><specifier>static</specifier> <name>EDealRes</name></type> <name>mergeProjectionsExpr</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SMergeProjectionsContext</name><modifier>*</modifier></type> <name>pCxt</name> <init>= <expr><name>pContext</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type>        <name>pChildProj</name> <init>= <expr><name><name>pCxt</name><operator>-&gt;</operator><name>pChildProj</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><operator>*</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTarget</name></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pTarget</argument>, <argument>((SLogicNode*)pChildProj)-&gt;pTargets</argument>)</argument_list></macro> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pTarget</name></expr></argument>, <argument><expr><operator>*</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pProjection</name></decl>;</decl_stmt>
        <macro><name>FOREACH</name><argument_list>(<argument>pProjection</argument>, <argument>pChildProj-&gt;pProjections</argument>)</argument_list></macro> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pTarget</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pProjection</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pExpr</name> <init>= <expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pProjection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>pExpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>terrno</name></expr>;</expr_stmt>
              <return>return <expr><name>DEAL_RES_ERROR</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><operator>*</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>aliasName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>*</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>pNode</name> <operator>=</operator> <name>pExpr</name></expr>;</expr_stmt>
            <return>return <expr><name>DEAL_RES_IGNORE_CHILD</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>DEAL_RES_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>mergeProjectsOptimizeImpl</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pSelfNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pSelfNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SMergeProjectionsContext</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>pChildProj</name> <operator>=</operator> <operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr>, <expr><operator>.</operator><name>errCode</name> <operator>=</operator> <name>TSDB_CODE_SUCCESS</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesRewriteExprs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><name>pSelfNode</name><operator>)</operator><operator>-&gt;</operator><name>pProjections</name></expr></argument>, <argument><expr><name>mergeProjectionsExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name><name>cxt</name><operator>.</operator><name>errCode</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pGrandChild</name> <init>= <expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>replaceLogicNode</name><argument_list>(<argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name>pChild</name></expr></argument>, <argument><expr><name>pGrandChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="line">// no grand child</comment>
      <expr_stmt><expr><call><name>NODES_CLEAR_LIST</name><argument_list>(<argument><expr><name><name>pSelfNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>NODES_CLEAR_LIST</name><argument_list>(<argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>mergeProjectsOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pProjectNode</name> <init>= <expr><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>mergeProjectsMayBeOptimized</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pProjectNode</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name>mergeProjectsOptimizeImpl</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name>pProjectNode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>tagScanOptShouldBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>SCAN_TYPE_TAG</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>scanType</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pScan</name><operator>-&gt;</operator><name>hasNormalCols</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>||</operator> <name>QUERY_NODE_LOGIC_PLAN_AGG</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
      <literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name> <init>= <expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name> <operator>||</operator> <call><name>planOptNodeListHasCol</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
      <operator>!</operator><call><name>planOptNodeListHasTbname</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pGroupKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pGroupKey</argument>, <argument>pAgg-&gt;pGroupKeys</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pGroup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pGroup</argument>, <argument>((SGroupingSetNode*)pGroupKey)-&gt;pParameterList</argument>)</argument_list></macro> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pGroup</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
  </block_content>}</block>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tagScanOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScanNode</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>tagScanOptShouldBeOptimized</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pScanNode</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>scanType</name></name> <operator>=</operator> <name>SCAN_TYPE_TAG</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTarget</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pTarget</argument>, <argument>pScanNode-&gt;node.pTargets</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>PRIMARYKEY_TIMESTAMP_COL_ID</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><operator>(</operator><name>pTarget</name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>colId</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>ERASE_NODE</name><argument_list>(<argument><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pAgg</name> <init>= <expr><name><name>pScanNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pParent</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pParent</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pScanTargets</name> <init>= <expr><call><name>nodesMakeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pAggTarget</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pAggTarget</argument>, <argument>pAgg-&gt;pTargets</argument>)</argument_list></macro> <block>{<block_content>
      <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pScanTarget</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <macro><name>FOREACH</name><argument_list>(<argument>pScanTarget</argument>, <argument>pScanNode-&gt;node.pTargets</argument>)</argument_list></macro> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pAggTarget</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pScanTarget</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>nodesListAppend</name><argument_list>(<argument><expr><name>pScanTargets</name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pScanTarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block>
    </block_content>}</block>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pScanNode</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <name>pScanTargets</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>replaceLogicNode</name><argument_list>(<argument><expr><name>pLogicSubplan</name></expr></argument>, <argument><expr><name>pAgg</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pScanNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>NODES_CLEAR_LIST</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>pushDownLimitOptShouldBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>||</operator> <literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
      <name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>pushDownLimitOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name> <init>= <expr><call><name>optFindPossibleNode</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>pushDownLimitOptShouldBeOptimized</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pNode</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pChild</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLimit</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>optimized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>STbCntScanOptInfo</name> <block>{
  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type>  <name>pAgg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SName</name></type>           <name>table</name></decl>;</decl_stmt>
}</block></struct></type> <name>STbCntScanOptInfo</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>tbCntScanOptIsEligibleGroupKeys</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pGroupKeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pGroupKeys</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pGroupKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pGroupKey</argument>, <argument>pGroupKeys</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pKey</name> <init>= <expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SGroupingSetNode</name><operator>*</operator><operator>)</operator><name>pGroupKey</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pKey</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><literal type="string">"db_name"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><literal type="string">"stable_name"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>tbCntScanOptNotNullableExpr</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pColName</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>pColName</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>pColName</name></expr></argument>, <argument><expr><literal type="string">"db_name"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>pColName</name></expr></argument>, <argument><expr><literal type="string">"stable_name"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
         <literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>pColName</name></expr></argument>, <argument><expr><literal type="string">"table_name"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>tbCntScanOptIsEligibleAggFuncs</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pAggFuncs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pAggFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name>pAggFuncs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>FUNCTION_TYPE_COUNT</name> <operator>!=</operator> <name><name>pFunc</name><operator>-&gt;</operator><name>funcType</name></name> <operator>||</operator>
        <operator>!</operator><call><name>tbCntScanOptNotNullableExpr</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>tbCntScanOptIsEligibleAgg</name><parameter_list>(<parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>tbCntScanOptIsEligibleGroupKeys</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tbCntScanOptIsEligibleAggFuncs</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>tbCntScanOptGetColValFromCond</name><parameter_list>(<parameter><decl><type><name>SOperatorNode</name><modifier>*</modifier></type> <name>pOper</name></decl></parameter>, <parameter><decl><type><name>SColumnNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pCol</name></decl></parameter>, <parameter><decl><type><name>SValueNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pVal</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>OP_TYPE_EQUAL</name> <operator>!=</operator> <name><name>pOper</name><operator>-&gt;</operator><name>opType</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pCol</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pOper</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pCol</name> <operator>=</operator> <operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name><name>pOper</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_VALUE</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pOper</name><operator>-&gt;</operator><name>pLeft</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <operator>(</operator><name>SValueNode</name><operator>*</operator><operator>)</operator><name><name>pOper</name><operator>-&gt;</operator><name>pLeft</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pOper</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pCol</name> <operator>=</operator> <operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name><name>pOper</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_VALUE</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pOper</name><operator>-&gt;</operator><name>pRight</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pVal</name> <operator>=</operator> <operator>(</operator><name>SValueNode</name><operator>*</operator><operator>)</operator><name><name>pOper</name><operator>-&gt;</operator><name>pRight</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>NULL</name> <operator>!=</operator> <operator>*</operator><name>pCol</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <operator>*</operator><name>pVal</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>tbCntScanOptIsEligibleLogicCond</name><parameter_list>(<parameter><decl><type><name>STbCntScanOptInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>, <parameter><decl><type><name>SLogicConditionNode</name><modifier>*</modifier></type> <name>pCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>LOGIC_COND_TYPE_AND</name> <operator>!=</operator> <name><name>pCond</name><operator>-&gt;</operator><name>condType</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>bool</name></type>         <name>hasDbCond</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>         <name>hasStbCond</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SValueNode</name><modifier>*</modifier></type>  <name>pVal</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>       <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pCond-&gt;pParameterList</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_OPERATOR</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>tbCntScanOptGetColValFromCond</name><argument_list>(<argument><expr><operator>(</operator><name>SOperatorNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasDbCond</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><literal type="string">"db_name"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hasDbCond</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>table</name><operator>.</operator><name>dbname</name></name></expr></argument>, <argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>literal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>hasStbCond</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><literal type="string">"stable_name"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>hasStbCond</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>table</name><operator>.</operator><name>tname</name></name></expr></argument>, <argument><expr><name><name>pVal</name><operator>-&gt;</operator><name>literal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>hasDbCond</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>tbCntScanOptIsEligibleOpCond</name><parameter_list>(<parameter><decl><type><name>SOperatorNode</name><modifier>*</modifier></type> <name>pCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SValueNode</name><modifier>*</modifier></type>  <name>pVal</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tbCntScanOptGetColValFromCond</name><argument_list>(<argument><expr><name>pCond</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><literal type="string">"db_name"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>tbCntScanOptIsEligibleConds</name><parameter_list>(<parameter><decl><type><name>STbCntScanOptInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pConditions</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pConditions</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_CONDITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pConditions</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tbCntScanOptIsEligibleLogicCond</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicConditionNode</name><operator>*</operator><operator>)</operator><name>pConditions</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_OPERATOR</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pConditions</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>tbCntScanOptIsEligibleOpCond</name><argument_list>(<argument><expr><operator>(</operator><name>SOperatorNode</name><operator>*</operator><operator>)</operator><name>pConditions</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>tbCntScanOptIsEligibleScan</name><parameter_list>(<parameter><decl><type><name>STbCntScanOptInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>tableName</name><operator>.</operator><name>dbname</name></name></expr></argument>, <argument><expr><name>TSDB_INFORMATION_SCHEMA_DB</name></expr></argument>)</argument_list></call> <operator>||</operator>
      <literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>tableName</name><operator>.</operator><name>tname</name></name></expr></argument>, <argument><expr><name>TSDB_INS_TABLE_TABLES</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>pVgroupList</name><operator>-&gt;</operator><name>numOfVgroups</name></name> <operator>&amp;&amp;</operator> <name>MNODE_HANDLE</name> <operator>==</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>pVgroupList</name><operator>-&gt;</operator><name>vgroups</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>vgId</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>tbCntScanOptIsEligibleConds</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>tbCntScanOptShouldBeOptimized</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>STbCntScanOptInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
      <name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pAgg</name></name> <operator>=</operator> <operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name></name> <operator>=</operator> <operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>tbCntScanOptIsEligibleAgg</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pAgg</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tbCntScanOptIsEligibleScan</name><argument_list>(<argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>tbCntScanOptCreateTableCountFunc</name><parameter_list>()</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_FUNCTION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pFunc</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>, <argument><expr><literal type="string">"_table_count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><literal type="string">"_table_count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <call><name>fmGetFuncInfo</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tbCntScanOptRewriteScan</name><parameter_list>(<parameter><decl><type><name>STbCntScanOptInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>scanType</name></name> <operator>=</operator> <name>SCAN_TYPE_TABLE_COUNT</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>tableName</name><operator>.</operator><name>dbname</name></name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>table</name><operator>.</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>tableName</name><operator>.</operator><name>tname</name></name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>table</name><operator>.</operator><name>tname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NODES_DESTORY_NODE</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>, <argument><expr><call><name>tbCntScanOptCreateTableCountFunc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExpr</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pGroupKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pGroupKey</argument>, <argument>pInfo-&gt;pAgg-&gt;pGroupKeys</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pGroupCol</name> <init>= <expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SGroupingSetNode</name><operator>*</operator><operator>)</operator><name>pGroupKey</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pGroupCol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>pScanCols</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pGroupCol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pGroupCol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tbCntScanOptCreateSumFunc</name><parameter_list>(<parameter><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pCntFunc</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pParam</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_FUNCTION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pFunc</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>, <argument><expr><literal type="string">"sum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><name><name>pCntFunc</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>createColumnByRewriteExpr</name><argument_list>(<argument><expr><name>pParam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pFunc</name><operator>-&gt;</operator><name>pParameterList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>fmGetFuncInfo</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOutput</name> <operator>=</operator> <operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tbCntScanOptRewriteAgg</name><parameter_list>(<parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>          <name>pSum</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>         <name>code</name> <init>= <expr><call><name>tbCntScanOptCreateSumFunc</name><argument_list>(<argument><expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                                                   <argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pScanPseudoCols</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><name>pSum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>partTagsRewriteGroupTagsToFuncs</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>tableCountScanOptimize</name><parameter_list>(<parameter><decl><type><name>SOptimizeContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>STbCntScanOptInfo</name></type> <name>info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>optFindEligibleNode</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FShouldBeOptimized</name><operator>)</operator><name>tbCntScanOptShouldBeOptimized</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>tbCntScanOptRewriteScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tbCntScanOptRewriteAgg</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>pAgg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// clang-format off</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>SOptimizeRule</name></type> <name><name>optimizeRuleSet</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"ScanPath"</literal></expr>,                   <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>scanPathOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"PushDownCondition"</literal></expr>,          <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>pushDownCondOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"SortPrimaryKey"</literal></expr>,             <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>sortPrimaryKeyOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"SmaIndex"</literal></expr>,                   <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>smaIndexOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"PartitionTags"</literal></expr>,              <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>partTagsOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"MergeProjects"</literal></expr>,              <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>mergeProjectsOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"EliminateProject"</literal></expr>,           <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>eliminateProjOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"EliminateSetOperator"</literal></expr>,       <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>eliminateSetOpOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"RewriteTail"</literal></expr>,                <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>rewriteTailOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"RewriteUnique"</literal></expr>,              <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>rewriteUniqueOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"LastRowScan"</literal></expr>,                <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>lastRowScanOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"TagScan"</literal></expr>,                    <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>tagScanOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"PushDownLimit"</literal></expr>,              <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>pushDownLimitOptimize</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"TableCountScan"</literal></expr>,             <expr><operator>.</operator><name>optimizeFunc</name> <operator>=</operator> <name>tableCountScanOptimize</name></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<comment type="line">// clang-format on</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int32_t</name></type> <name>optimizeRuleNum</name> <init>= <expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>optimizeRuleSet</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SOptimizeRule</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dumpLogicSubplan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pRuleName</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tsQueryPlannerTrace</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>pStr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesNodeToString</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSubplan</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pRuleName</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>qDebugL</name><argument_list>(<argument><expr><literal type="string">"before optimize: %s"</literal></expr></argument>, <argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>qDebugL</name><argument_list>(<argument><expr><literal type="string">"apply optimize %s rule: %s"</literal></expr></argument>, <argument><expr><name>pRuleName</name></expr></argument>, <argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>applyOptimizeRule</name><parameter_list>(<parameter><decl><type><name>SPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SOptimizeContext</name></type> <name>cxt</name> <init>= <expr><block>{<expr><operator>.</operator><name>pPlanCxt</name> <operator>=</operator> <name>pCxt</name></expr>, <expr><operator>.</operator><name>optimized</name> <operator>=</operator> <name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>             <name>optimized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>dumpLogicSubplan</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>optimized</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>optimizeRuleNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>optimized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name><name>optimizeRuleSet</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>optimizeFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>code</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>.</operator><name>optimized</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>optimized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dumpLogicSubplan</name><argument_list>(<argument><expr><name><name>optimizeRuleSet</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pName</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block> while <condition>(<expr><name>optimized</name></expr>)</condition>;</do>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>optimizeLogicPlan</name><parameter_list>(<parameter><decl><type><name>SPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>SUBPLAN_TYPE_MODIFY</name> <operator>==</operator> <name><name>pLogicSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>applyOptimizeRule</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
