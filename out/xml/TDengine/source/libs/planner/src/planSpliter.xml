<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/source/libs/planner/src/planSpliter.c"><comment type="block">/*
 * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the GNU Affero General Public License, version 3
 * or later ("AGPL"), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"functionMgt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tglobal.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLIT_FLAG_MASK</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1 &lt;&lt; n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLIT_FLAG_STABLE_SPLIT</name></cpp:macro> <cpp:value>SPLIT_FLAG_MASK(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLIT_FLAG_INSERT_SPLIT</name></cpp:macro> <cpp:value>SPLIT_FLAG_MASK(1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLIT_FLAG_SET_MASK</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>mask</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(val) |= (mask)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLIT_FLAG_TEST_MASK</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>mask</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((val) &amp; (mask)) != 0)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>SSplitContext</name> <block>{
  <decl_stmt><decl><type><name>SPlanContext</name><modifier>*</modifier></type> <name>pPlanCxt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type>      <name>queryId</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>       <name>groupId</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>          <name>split</name></decl>;</decl_stmt>
}</block></struct></type> <name>SSplitContext</name>;</typedef>

<typedef>typedef <function_decl><type><name>int32_t</name></type> (<modifier>*</modifier><name>FSplit</name>)<parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <name>SSplitRule</name> <block>{
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>  <name>pName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FSplit</name></type> <name>splitFunc</name></decl>;</decl_stmt>
}</block></struct></type> <name>SSplitRule</name>;</typedef>

<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>FSplFindSplitNode</name>)<parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>splSetSubplanVgroups</name><parameter_list>(<parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pVgroupList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>splSetSubplanVgroups</name><argument_list>(<argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLogicSubplan</name><modifier>*</modifier></type> <name>splCreateScanSubplan</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>flag</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name> <init>= <expr><operator>(</operator><name>SLogicSubplan</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_SUBPLAN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSubplan</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>queryId</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>queryId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_SCAN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>splSetSubplanVgroups</name><argument_list>(<argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SPLIT_FLAG_SET_MASK</name><argument_list>(<argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>splitFlag</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pSubplan</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>splHasScan</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>splHasScan</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block>

  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>splSetSubplanType</name><parameter_list>(<parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <ternary><condition><expr><call><name>splHasScan</name><argument_list>(<argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>SUBPLAN_TYPE_SCAN</name></expr> </then><else>: <expr><name>SUBPLAN_TYPE_MERGE</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLogicSubplan</name><modifier>*</modifier></type> <name>splCreateSubplan</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name> <init>= <expr><operator>(</operator><name>SLogicSubplan</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_SUBPLAN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSubplan</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>queryId</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>queryId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>splSetSubplanType</name><argument_list>(<argument><expr><name>pSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pSubplan</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>splCreateExchangeNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pChild</name></decl></parameter>, <parameter><decl><type><name>SExchangeLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExchangeLogicNode</name><modifier>*</modifier></type> <name>pExchange</name> <init>= <expr><operator>(</operator><name>SExchangeLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_EXCHANGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pExchange</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>srcStartGroupId</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>srcEndGroupId</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name> <operator>=</operator> <name><name>pChild</name><operator>-&gt;</operator><name>precision</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pChild</name><operator>-&gt;</operator><name>pLimit</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pLimit</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pChild</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pLimit</name></name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SLimitNode</name><operator>*</operator><operator>)</operator><name><name>pChild</name><operator>-&gt;</operator><name>pLimit</name></name><operator>)</operator><operator>-&gt;</operator><name>limit</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>SLimitNode</name><operator>*</operator><operator>)</operator><name><name>pChild</name><operator>-&gt;</operator><name>pLimit</name></name><operator>)</operator><operator>-&gt;</operator><name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SLimitNode</name><operator>*</operator><operator>)</operator><name><name>pChild</name><operator>-&gt;</operator><name>pLimit</name></name><operator>)</operator><operator>-&gt;</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pOutput</name> <operator>=</operator> <name>pExchange</name></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>splCreateExchangeNodeForSubplan</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pSplitNode</name></decl></parameter>,
                                               <parameter><decl><type><name>ESubplanType</name></type> <name>subplanType</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExchangeLogicNode</name><modifier>*</modifier></type> <name>pExchange</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>             <name>code</name> <init>= <expr><call><name>splCreateExchangeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSplitNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExchange</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>replaceLogicNode</name><argument_list>(<argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><name>pSplitNode</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pExchange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>subplanType</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pExchange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>splIsChildSubplan</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pLogicNode</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>groupId</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_EXCHANGE</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>groupId</name> <operator>&gt;=</operator> <operator>(</operator><operator>(</operator><name>SExchangeLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name><operator>)</operator><operator>-&gt;</operator><name>srcStartGroupId</name> <operator>&amp;&amp;</operator>
           <name>groupId</name> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>SExchangeLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name><operator>)</operator><operator>-&gt;</operator><name>srcEndGroupId</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_MERGE</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pLogicNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><name>SMergeLogicNode</name><operator>*</operator><operator>)</operator><name>pLogicNode</name><operator>)</operator><operator>-&gt;</operator><name>srcGroupId</name> <operator>==</operator> <name>groupId</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pLogicNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>isChild</name> <init>= <expr><call><name>splIsChildSubplan</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>isChild</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>isChild</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>splMountSubplan</name><parameter_list>(<parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pParent</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pChildren</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>WHERE_EACH</name><argument_list>(<argument>pChild</argument>, <argument>pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>splIsChildSubplan</name><argument_list>(<argument><expr><name><name>pParent</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SLogicSubplan</name><operator>*</operator><operator>)</operator><name>pChild</name><operator>)</operator><operator>-&gt;</operator><name><name>id</name><operator>.</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pParent</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>REPLACE_NODE</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ERASE_NODE</name><argument_list>(<argument><expr><name>pChildren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>code</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>WHERE_NEXT</name></expr>;</expr_stmt>
  </block_content>}</block>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>splMatchByNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>FSplFindSplitNode</name></type> <name>func</name></decl></parameter>,
                           <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>func</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>splMatchByNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>splMatch</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>FSplFindSplitNode</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPLIT_FLAG_TEST_MASK</name><argument_list>(<argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>splitFlag</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>splMatchByNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pSubplan-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>splMatch</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicSubplan</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>splSetParent</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name><operator>)</operator><operator>-&gt;</operator><name>pParent</name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt> </block_content>}</block>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SStableSplitInfo</name> <block>{
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type>    <name>pSplitNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl>;</decl_stmt>
}</block></struct></type> <name>SStableSplitInfo</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplHasGatherExecFunc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SNodeList</name><modifier>*</modifier></type> <name>pFuncs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pFunc</argument>, <argument>pFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fmIsWindowPseudoColumnFunc</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>funcId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>fmIsDistExecFunc</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>funcId</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplIsMultiTbScan</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>streamQuery</name></decl></parameter>, <parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name>NULL</name> <operator>!=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pVgroupList</name></name> <operator>&amp;&amp;</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pVgroupList</name><operator>-&gt;</operator><name>numOfVgroups</name></name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplHasMultiTbScan</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>streamQuery</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name><operator>)</operator><operator>-&gt;</operator><name>pChildren</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pChild</name> <operator>=</operator> <call><name>nodesListGetNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name><operator>)</operator><operator>-&gt;</operator><name>pChildren</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>stbSplIsMultiTbScan</name><argument_list>(<argument><expr><name>streamQuery</name></expr></argument>, <argument><expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplIsMultiTbScanChild</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>streamQuery</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>stbSplIsMultiTbScan</name><argument_list>(<argument><expr><name>streamQuery</name></expr></argument>, <argument><expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplNeedSplitWindow</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>streamQuery</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWindow</name> <init>= <expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>WINDOW_TYPE_INTERVAL</name> <operator>==</operator> <name><name>pWindow</name><operator>-&gt;</operator><name>winType</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>!</operator><call><name>stbSplHasGatherExecFunc</name><argument_list>(<argument><expr><name><name>pWindow</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>stbSplHasMultiTbScan</name><argument_list>(<argument><expr><name>streamQuery</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>WINDOW_TYPE_SESSION</name> <operator>==</operator> <name><name>pWindow</name><operator>-&gt;</operator><name>winType</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>streamQuery</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>stbSplHasMultiTbScan</name><argument_list>(<argument><expr><name>streamQuery</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><operator>!</operator><call><name>stbSplHasGatherExecFunc</name><argument_list>(<argument><expr><name><name>pWindow</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>stbSplHasMultiTbScan</name><argument_list>(<argument><expr><name>streamQuery</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>WINDOW_TYPE_STATE</name> <operator>==</operator> <name><name>pWindow</name><operator>-&gt;</operator><name>winType</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>streamQuery</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>stbSplHasMultiTbScan</name><argument_list>(<argument><expr><name>streamQuery</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplNeedSplitJoin</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>streamQuery</name></decl></parameter>, <parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pJoin</name><operator>-&gt;</operator><name>isSingleTableJoin</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pJoin-&gt;node.pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>QUERY_NODE_LOGIC_PLAN_JOIN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplIsTableCountQuery</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name><operator>)</operator><operator>-&gt;</operator><name>pChildren</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pChild</name> <operator>=</operator> <call><name>nodesListGetNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name><operator>)</operator><operator>-&gt;</operator><name>pChildren</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SCAN_TYPE_TABLE_COUNT</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name><operator>)</operator><operator>-&gt;</operator><name>scanType</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNodeList</name><modifier>*</modifier></type> <name>stbSplGetPartKeys</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pGroupTags</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><name>SPartitionLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pPartitionKeys</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplHasPartTbname</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pPartKeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pPartKeys</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pPartKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pPartKey</argument>, <argument>pPartKeys</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_GROUPING_SET</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pPartKey</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>pPartKey</name> <operator>=</operator> <call><name>nodesListGetNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SGroupingSetNode</name><operator>*</operator><operator>)</operator><name>pPartKey</name><operator>)</operator><operator>-&gt;</operator><name>pParameterList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>QUERY_NODE_FUNCTION</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pPartKey</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>FUNCTION_TYPE_TBNAME</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pPartKey</name><operator>)</operator><operator>-&gt;</operator><name>funcType</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pPartKey</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>COLUMN_TYPE_TBNAME</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pPartKey</name><operator>)</operator><operator>-&gt;</operator><name>colType</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplIsPartTableAgg</name><parameter_list>(<parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>stbSplHasPartTbname</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>stbSplHasPartTbname</name><argument_list>(<argument><expr><call><name>stbSplGetPartKeys</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplNeedSplit</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>streamQuery</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><name>streamQuery</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><call><name>stbSplIsMultiTbScan</name><argument_list>(<argument><expr><name>streamQuery</name></expr></argument>, <argument><expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_JOIN</name></expr>:</case>
      <return>return <expr><call><name>stbSplNeedSplitJoin</name><argument_list>(<argument><expr><name>streamQuery</name></expr></argument>, <argument><expr><operator>(</operator><name>SJoinLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><name>streamQuery</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><call><name>stbSplIsMultiTbScanChild</name><argument_list>(<argument><expr><name>streamQuery</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr>:</case>
      <return>return <expr><operator>(</operator><operator>!</operator><call><name>stbSplHasGatherExecFunc</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pAggFuncs</name></expr></argument>)</argument_list></call> <operator>||</operator>
              <call><name>stbSplIsPartTableAgg</name><argument_list>(<argument><expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
             <call><name>stbSplHasMultiTbScan</name><argument_list>(<argument><expr><name>streamQuery</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>stbSplIsTableCountQuery</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name></expr>:</case>
      <return>return <expr><call><name>stbSplNeedSplitWindow</name><argument_list>(<argument><expr><name>streamQuery</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SORT</name></expr>:</case>
      <return>return <expr><call><name>stbSplHasMultiTbScan</name><argument_list>(<argument><expr><name>streamQuery</name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplFindSplitNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>,
                                <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>stbSplNeedSplit</name><argument_list>(<argument><expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr></argument>, <argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name> <operator>=</operator> <name>pSubplan</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplRewriteFuns</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SNodeList</name><modifier>*</modifier></type> <name>pFuncs</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pPartialFuncs</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pMergeFuncs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pPartFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pMergeFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type>        <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fmIsWindowPseudoColumnFunc</name><argument_list>(<argument><expr><name><name>pFunc</name><operator>-&gt;</operator><name>funcId</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>pPartFunc</name> <operator>=</operator> <operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMergeFunc</name> <operator>=</operator> <operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pPartFunc</name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name>pMergeFunc</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pPartFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pMergeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>fmGetDistMethod</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPartFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMergeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><name>pPartialFuncs</name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pPartFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><name>pMergeFuncs</name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pMergeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><operator>*</operator><name>pPartialFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><operator>*</operator><name>pMergeFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplAppendWStart</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pFuncs</name></decl></parameter>, <parameter><decl><type><name>int32_t</name><modifier>*</modifier></type> <name>pIndex</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pFunc</argument>, <argument>pFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>FUNCTION_TYPE_WSTART</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>funcType</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pIndex</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>++</operator><name>index</name></expr>;</expr_stmt>
  </block_content>}</block>

  <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pWStart</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_FUNCTION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pWStart</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pWStart</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>, <argument><expr><literal type="string">"_wstart"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>pointer</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>pWStart</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>pWStart</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pWStart</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%"</literal> <name>PRId64</name> <literal type="string">""</literal></expr></argument>, <argument><expr><name><name>pWStart</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>fmGetFuncInfo</name><argument_list>(<argument><expr><name>pWStart</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name>pFuncs</name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pWStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pIndex</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplAppendWEnd</name><parameter_list>(<parameter><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWin</name></decl></parameter>, <parameter><decl><type><name>int32_t</name><modifier>*</modifier></type> <name>pIndex</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pFunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pFunc</argument>, <argument>pWin-&gt;pFuncs</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>FUNCTION_TYPE_WEND</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><name>pFunc</name><operator>)</operator><operator>-&gt;</operator><name>funcType</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pIndex</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>++</operator><name>index</name></expr>;</expr_stmt>
  </block_content>}</block>

  <decl_stmt><decl><type><name>SFunctionNode</name><modifier>*</modifier></type> <name>pWEnd</name> <init>= <expr><operator>(</operator><name>SFunctionNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_FUNCTION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pWEnd</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pWEnd</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>, <argument><expr><literal type="string">"_wend"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>pointer</name> <init>= <expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>pWEnd</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>pWEnd</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pWEnd</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%"</literal> <name>PRId64</name> <literal type="string">""</literal></expr></argument>, <argument><expr><name><name>pWEnd</name><operator>-&gt;</operator><name>functionName</name></name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>fmGetFuncInfo</name><argument_list>(<argument><expr><name>pWEnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pWEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pIndex</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExpr</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pWin</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplCreatePartWindowNode</name><parameter_list>(<parameter><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pMergeWindow</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pPartWindow</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><name><name>pMergeWindow</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pMergeWindow</name><operator>-&gt;</operator><name>pFuncs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTargets</name> <init>= <expr><name><name>pMergeWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pMergeWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pChildren</name> <init>= <expr><name><name>pMergeWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pMergeWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pConditions</name> <init>= <expr><name><name>pMergeWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pMergeWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pPartWin</name> <init>= <expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesCloneNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pMergeWindow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pPartWin</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pPartWin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <name>GROUP_ACTION_KEEP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMergeWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <name>pTargets</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMergeWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>=</operator> <name>pConditions</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPartWin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name> <operator>=</operator> <name>pChildren</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>splSetParent</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pPartWin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>stbSplRewriteFuns</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPartWin</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMergeWindow</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplAppendWStart</name><argument_list>(<argument><expr><name><name>pPartWin</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pPartWin</name><operator>-&gt;</operator><name>pFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPartWin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pMergeWindow</name><operator>-&gt;</operator><name>pTspk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMergeWindow</name><operator>-&gt;</operator><name>pTspk</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pPartWin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pMergeWindow</name><operator>-&gt;</operator><name>pTspk</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pPartWindow</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pPartWin</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pPartWin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplGetNumOfVgroups</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>(</operator><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name><name>pVgroupList</name><operator>-&gt;</operator><name>numOfVgroups</name></name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><call><name>stbSplGetNumOfVgroups</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplCreateMergeNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pSplitNode</name></decl></parameter>,
                                     <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pMergeKeys</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pPartChild</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>groupSort</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SMergeLogicNode</name><modifier>*</modifier></type> <name>pMerge</name> <init>= <expr><operator>(</operator><name>SMergeLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_MERGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pMerge</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>numOfChannels</name></name> <operator>=</operator> <call><name>stbSplGetNumOfVgroups</name><argument_list>(<argument><expr><name>pPartChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>srcGroupId</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name> <operator>=</operator> <name><name>pPartChild</name><operator>-&gt;</operator><name>precision</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>pMergeKeys</name></name> <operator>=</operator> <name>pMergeKeys</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>groupSort</name></name> <operator>=</operator> <name>groupSort</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>pInputs</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pPartChild</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// NULL != pSubplan means 'merge node' replaces 'split node'.</comment>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSubplan</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pPartChild</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pSplitNode</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pMerge</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>pMerge</name><operator>-&gt;</operator><name>pInputs</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pSplitNode</name><operator>-&gt;</operator><name>pLimit</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pMerge</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pLimit</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pSplitNode</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pMerge</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pLimit</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pSubplan</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSplitNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pMerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>replaceLogicNode</name><argument_list>(<argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><name>pSplitNode</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pMerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pMerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplCreateExchangeNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pParent</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pPartChild</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExchangeLogicNode</name><modifier>*</modifier></type> <name>pExchange</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>             <name>code</name> <init>= <expr><call><name>splCreateExchangeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pPartChild</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExchange</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pParent</name></name> <operator>=</operator> <name>pParent</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pParent</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pExchange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplCreateMergeKeysByPrimaryKey</name><parameter_list>(<parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pPrimaryKey</name></decl></parameter>, <parameter><decl><type><name>EOrder</name></type> <name>order</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pMergeKeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SOrderByExprNode</name><modifier>*</modifier></type> <name>pMergeKey</name> <init>= <expr><operator>(</operator><name>SOrderByExprNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_ORDER_BY_EXPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pMergeKey</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pMergeKey</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pPrimaryKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pMergeKey</name><operator>-&gt;</operator><name>pExpr</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pMergeKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pMergeKey</name><operator>-&gt;</operator><name>order</name></name> <operator>=</operator> <name>order</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMergeKey</name><operator>-&gt;</operator><name>nullOrder</name></name> <operator>=</operator> <name>NULL_ORDER_FIRST</name></expr>;</expr_stmt>
  <return>return <expr><call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><name>pMergeKeys</name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pMergeKey</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitIntervalForBatch</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pPartWindow</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>stbSplCreatePartWindowNode</name><argument_list>(<argument><expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPartWindow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pPartWindow</name><operator>)</operator><operator>-&gt;</operator><name>windowAlgo</name> <operator>=</operator> <name>INTERVAL_ALGO_HASH</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name><operator>)</operator><operator>-&gt;</operator><name>windowAlgo</name> <operator>=</operator> <name>INTERVAL_ALGO_MERGE</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pMergeKeys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateMergeKeysByPrimaryKey</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name><operator>)</operator><operator>-&gt;</operator><name>pTspk</name></expr></argument>,
                                             <argument><expr><operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name><operator>)</operator><operator>-&gt;</operator><name>outputTsOrder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateMergeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name>pMergeKeys</name></expr></argument>, <argument><expr><name>pPartWindow</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pPartWindow</name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitIntervalForStream</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pPartWindow</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>stbSplCreatePartWindowNode</name><argument_list>(<argument><expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPartWindow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pPartWindow</name><operator>)</operator><operator>-&gt;</operator><name>windowAlgo</name> <operator>=</operator> <name>INTERVAL_ALGO_STREAM_SEMI</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name><operator>)</operator><operator>-&gt;</operator><name>windowAlgo</name> <operator>=</operator> <name>INTERVAL_ALGO_STREAM_FINAL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateExchangeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name>pPartWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pPartWindow</name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitInterval</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>stbSplSplitIntervalForStream</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>stbSplSplitIntervalForBatch</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitSessionForStream</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pPartWindow</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>stbSplCreatePartWindowNode</name><argument_list>(<argument><expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPartWindow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pPartWin</name> <init>= <expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pPartWindow</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pMergeWin</name> <init>= <expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pPartWin</name><operator>-&gt;</operator><name>windowAlgo</name></name> <operator>=</operator> <name>SESSION_ALGO_STREAM_SEMI</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMergeWin</name><operator>-&gt;</operator><name>windowAlgo</name></name> <operator>=</operator> <name>SESSION_ALGO_STREAM_FINAL</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>stbSplAppendWEnd</name><argument_list>(<argument><expr><name>pPartWin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name><name>pMergeWin</name><operator>-&gt;</operator><name>pTsEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMergeWin</name><operator>-&gt;</operator><name>pTsEnd</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pPartWin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pMergeWin</name><operator>-&gt;</operator><name>pTsEnd</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateExchangeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name>pPartWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pPartWindow</name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>stbSplSetTableMergeScan</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanType</name></name> <operator>=</operator> <name>SCAN_TYPE_TABLE_MERGE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>groupSort</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>stbSplSetTableMergeScan</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitSessionOrStateForBatch</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pWindow</name> <init>= <expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pWindow</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pMergeKeys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>code</name> <init>= <expr><call><name>stbSplCreateMergeKeysByPrimaryKey</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pWindow</name><operator>)</operator><operator>-&gt;</operator><name>pTspk</name></expr></argument>,
                                                      <argument><expr><operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name>pWindow</name><operator>)</operator><operator>-&gt;</operator><name>inputTsOrder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateMergeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name>pChild</name></expr></argument>, <argument><expr><name>pMergeKeys</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pChild</name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>stbSplSetTableMergeScan</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SPLIT_FLAG_SET_MASK</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>splitFlag</name></name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitSession</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>stbSplSplitSessionForStream</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>stbSplSplitSessionOrStateForBatch</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitStateForStream</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>TSDB_CODE_PLAN_INTERNAL_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitState</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>stbSplSplitStateForStream</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>stbSplSplitSessionOrStateForBatch</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplIsPartTableWinodw</name><parameter_list>(<parameter><decl><type><name>SWindowLogicNode</name><modifier>*</modifier></type> <name>pWindow</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>stbSplHasPartTbname</name><argument_list>(<argument><expr><call><name>stbSplGetPartKeys</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pWindow</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitWindowForCrossTable</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name><operator>)</operator><operator>-&gt;</operator><name>winType</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>WINDOW_TYPE_INTERVAL</name></expr>:</case>
      <return>return <expr><call><name>stbSplSplitInterval</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>WINDOW_TYPE_SESSION</name></expr>:</case>
      <return>return <expr><call><name>stbSplSplitSession</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>WINDOW_TYPE_STATE</name></expr>:</case>
      <return>return <expr><call><name>stbSplSplitState</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>TSDB_CODE_PLAN_INTERNAL_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>stbSplNeedSeqRecvData</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pNode</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>||</operator> <name>NULL</name> <operator>!=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pSlimit</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>stbSplNeedSeqRecvData</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitWindowForPartTable</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>streamQuery</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>SPLIT_FLAG_SET_MASK</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>splitFlag</name></name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>&amp;&amp;</operator> <name>QUERY_NODE_LOGIC_PLAN_FILL</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SExchangeLogicNode</name><modifier>*</modifier></type> <name>pExchange</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>             <name>code</name> <init>= <expr><call><name>splCreateExchangeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pExchange</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>replaceLogicNode</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pExchange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>seqRecvData</name></name> <operator>=</operator> <call><name>stbSplNeedSeqRecvData</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pExchange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitWindowNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>stbSplIsPartTableWinodw</name><argument_list>(<argument><expr><operator>(</operator><name>SWindowLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>stbSplSplitWindowForPartTable</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>stbSplSplitWindowForCrossTable</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplCreatePartAggNode</name><parameter_list>(<parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pMergeAgg</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pFunc</name> <init>= <expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pGroupKeys</name> <init>= <expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTargets</name> <init>= <expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pChildren</name> <init>= <expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pConditions</name> <init>= <expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pPartAgg</name> <init>= <expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesCloneNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pMergeAgg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pPartAgg</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pPartAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>groupAction</name></name> <operator>=</operator> <name>GROUP_ACTION_KEEP</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>pGroupKeys</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pPartAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name> <operator>=</operator> <name>pGroupKeys</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pPartAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPartAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>pGroupKeys</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pPartAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pMergeAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pConditions</name></name> <operator>=</operator> <name>pConditions</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMergeAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <name>pTargets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPartAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name> <operator>=</operator> <name>pChildren</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>splSetParent</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pPartAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplRewriteFuns</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPartAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMergeAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>createColumnByRewriteExprs</name><argument_list>(<argument><expr><name><name>pPartAgg</name><operator>-&gt;</operator><name>pAggFuncs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pPartAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOutput</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pPartAgg</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pPartAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitAggNodeForPartTable</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>splCreateExchangeNodeForSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name>SUBPLAN_TYPE_MERGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitAggNodeForCrossTable</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pPartAgg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>stbSplCreatePartAggNode</name><argument_list>(<argument><expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPartAgg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateExchangeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name>pPartAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pPartAgg</name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitAggNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>stbSplIsPartTableAgg</name><argument_list>(<argument><expr><operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>stbSplSplitAggNodeForPartTable</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>stbSplSplitAggNodeForCrossTable</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>stbSplCreateColumnNode</name><parameter_list>(<parameter><decl><type><name>SExprNode</name><modifier>*</modifier></type> <name>pExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SColumnNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_COLUMN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pCol</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>dbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>tableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>tableAlias</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>tableAlias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pExpr</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>colName</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>aliasName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>pCol</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>aliasName</name></name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>aliasName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCol</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>resType</name></name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>resType</name></name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pCol</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>stbSplCreateOrderByExpr</name><parameter_list>(<parameter><decl><type><name>SOrderByExprNode</name><modifier>*</modifier></type> <name>pSortKey</name></decl></parameter>, <parameter><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCol</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SOrderByExprNode</name><modifier>*</modifier></type> <name>pOutput</name> <init>= <expr><operator>(</operator><name>SOrderByExprNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_ORDER_BY_EXPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pOutput</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>pExpr</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pOutput</name><operator>-&gt;</operator><name>pExpr</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>order</name></name> <operator>=</operator> <name><name>pSortKey</name><operator>-&gt;</operator><name>order</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOutput</name><operator>-&gt;</operator><name>nullOrder</name></name> <operator>=</operator> <name><name>pSortKey</name><operator>-&gt;</operator><name>nullOrder</name></name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pOutput</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplCreateMergeKeys</name><parameter_list>(<parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSortKeys</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pTargets</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pMergeKeys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>     <name>pNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pSortKeys</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SOrderByExprNode</name><modifier>*</modifier></type> <name>pSortKey</name> <init>= <expr><operator>(</operator><name>SOrderByExprNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SExprNode</name><modifier>*</modifier></type>        <name>pSortExpr</name> <init>= <expr><operator>(</operator><name>SExprNode</name><operator>*</operator><operator>)</operator><name><name>pSortKey</name><operator>-&gt;</operator><name>pExpr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>            <name>pTarget</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>              <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <macro><name>FOREACH</name><argument_list>(<argument>pTarget</argument>, <argument>pTargets</argument>)</argument_list></macro> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>QUERY_NODE_COLUMN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pSortExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>nodesEqualNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSortExpr</name></expr></argument>, <argument><expr><name>pTarget</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
          <operator>(</operator><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pSortExpr</name><operator>-&gt;</operator><name>aliasName</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pTarget</name><operator>)</operator><operator>-&gt;</operator><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pMergeKeys</name></expr></argument>, <argument><expr><call><name>stbSplCreateOrderByExpr</name><argument_list>(<argument><expr><name>pSortKey</name></expr></argument>, <argument><expr><name>pTarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><call><name>stbSplCreateColumnNode</name><argument_list>(<argument><expr><name>pSortExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pMergeKeys</name></expr></argument>, <argument><expr><call><name>stbSplCreateOrderByExpr</name><argument_list>(<argument><expr><name>pSortKey</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name>pTargets</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOutput</name> <operator>=</operator> <name>pMergeKeys</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplCreatePartSortNode</name><parameter_list>(<parameter><decl><type><name>SSortLogicNode</name><modifier>*</modifier></type> <name>pSort</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutputPartSort</name></decl></parameter>,
                                        <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutputMergeKeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSortKeys</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>pSortKeys</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>pSortKeys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pChildren</name> <init>= <expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>         <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SSortLogicNode</name><modifier>*</modifier></type> <name>pPartSort</name> <init>= <expr><operator>(</operator><name>SSortLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesCloneNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pPartSort</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pMergeKeys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pPartSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name> <operator>=</operator> <name>pChildren</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>splSetParent</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pPartSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPartSort</name><operator>-&gt;</operator><name>pSortKeys</name></name> <operator>=</operator> <name>pSortKeys</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPartSort</name><operator>-&gt;</operator><name>groupSort</name></name> <operator>=</operator> <name><name>pSort</name><operator>-&gt;</operator><name>groupSort</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateMergeKeys</name><argument_list>(<argument><expr><name><name>pPartSort</name><operator>-&gt;</operator><name>pSortKeys</name></name></expr></argument>, <argument><expr><name><name>pPartSort</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOutputPartSort</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pPartSort</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pOutputMergeKeys</name> <operator>=</operator> <name>pMergeKeys</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pPartSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>stbSplSetScanPartSort</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>groupSort</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>stbSplSetScanPartSort</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitSortNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pPartSort</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type>  <name>pMergeKeys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type>        <name>groupSort</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SSortLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name><operator>)</operator><operator>-&gt;</operator><name>groupSort</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>stbSplCreatePartSortNode</name><argument_list>(<argument><expr><operator>(</operator><name>SSortLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pPartSort</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateMergeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name>pMergeKeys</name></expr></argument>, <argument><expr><name>pPartSort</name></expr></argument>, <argument><expr><name>groupSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>groupSort</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>stbSplSetScanPartSort</name><argument_list>(<argument><expr><name>pPartSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pPartSort</name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitScanNodeWithoutPartTags</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pSplitNode</name> <init>= <expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>&amp;&amp;</operator> <name>QUERY_NODE_LOGIC_PLAN_PROJECT</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <name>NULL</name> <operator>==</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pSlimit</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pSplitNode</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pLimit</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pSplitNode</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>=</operator> <call><name>nodesCloneNode</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pSplitNode</name><operator>-&gt;</operator><name>pLimit</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SLimitNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pLimit</name></name><operator>)</operator><operator>-&gt;</operator><name>limit</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>SLimitNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pLimit</name></name><operator>)</operator><operator>-&gt;</operator><name>offset</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SLimitNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pLimit</name></name><operator>)</operator><operator>-&gt;</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>splCreateExchangeNodeForSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name>pSplitNode</name></expr></argument>, <argument><expr><name>SUBPLAN_TYPE_MERGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSplitNode</name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitScanNodeWithPartTags</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pSplitNode</name> <init>= <expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>&amp;&amp;</operator> <name>QUERY_NODE_LOGIC_PLAN_PROJECT</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <name>NULL</name> <operator>==</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pLimit</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name><operator>-&gt;</operator><name>pSlimit</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pSplitNode</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>pParent</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>stbSplCreateMergeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name>pSplitNode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pSplitNode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSplitNode</name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SNode</name><modifier>*</modifier></type> <name>stbSplFindPrimaryKeyFromScan</name><parameter_list>(<parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type>   <name>find</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pCol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pCol</argument>, <argument>pScan-&gt;pScanCols</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>PRIMARYKEY_TIMESTAMP_COL_ID</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SColumnNode</name><operator>*</operator><operator>)</operator><name>pCol</name><operator>)</operator><operator>-&gt;</operator><name>colId</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>find</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>find</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pTarget</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pTarget</argument>, <argument>pScan-&gt;node.pTargets</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pTarget</name></expr></argument>, <argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>pCol</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <expr_stmt><expr><call><name>nodesListStrictAppend</name><argument_list>(<argument><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>, <argument><expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pCol</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplCreateMergeScanNode</name><parameter_list>(<parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutputMergeScan</name></decl></parameter>,
                                         <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pOutputMergeKeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pChildren</name> <init>= <expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type>         <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pMergeScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesCloneNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pMergeScan</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pMergeKeys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pMergeScan</name><operator>-&gt;</operator><name>scanType</name></name> <operator>=</operator> <name>SCAN_TYPE_TABLE_MERGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMergeScan</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name> <operator>=</operator> <name>pChildren</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>splSetParent</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pMergeScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateMergeKeysByPrimaryKey</name><argument_list>(<argument><expr><call><name>stbSplFindPrimaryKeyFromScan</name><argument_list>(<argument><expr><name>pMergeScan</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><ternary><condition><expr><name><name>pMergeScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ORDER_ASC</name></expr> </then><else>: <expr><name>ORDER_DESC</name></expr></else></ternary></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pOutputMergeScan</name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pMergeScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pOutputMergeKeys</name> <operator>=</operator> <name>pMergeKeys</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pMergeScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitMergeScanNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name></decl></parameter>,
                                        <parameter><decl><type><name>bool</name></type> <name>groupSort</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pMergeScan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type>  <name>pMergeKeys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>     <name>code</name> <init>= <expr><call><name>stbSplCreateMergeScanNode</name><argument_list>(<argument><expr><name>pScan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMergeScan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pMergeScan</name><operator>-&gt;</operator><name>pLimit</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SLimitNode</name><operator>*</operator><operator>)</operator><name><name>pMergeScan</name><operator>-&gt;</operator><name>pLimit</name></name><operator>)</operator><operator>-&gt;</operator><name>limit</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>SLimitNode</name><operator>*</operator><operator>)</operator><name><name>pMergeScan</name><operator>-&gt;</operator><name>pLimit</name></name><operator>)</operator><operator>-&gt;</operator><name>offset</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SLimitNode</name><operator>*</operator><operator>)</operator><name><name>pMergeScan</name><operator>-&gt;</operator><name>pLimit</name></name><operator>)</operator><operator>-&gt;</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateMergeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pScan</name></expr></argument>, <argument><expr><name>pMergeKeys</name></expr></argument>, <argument><expr><name>pMergeScan</name></expr></argument>, <argument><expr><name>groupSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pMergeScan</name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitScanNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>SCAN_TYPE_TABLE_MERGE</name> <operator>==</operator> <name><name>pScan</name><operator>-&gt;</operator><name>scanType</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>
    <return>return <expr><call><name>stbSplSplitMergeScanNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name>pScan</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>pScan</name><operator>-&gt;</operator><name>pGroupTags</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>stbSplSplitScanNodeWithPartTags</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>stbSplSplitScanNodeWithoutPartTags</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitJoinNodeImpl</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>  <name>pChild</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pJoin-&gt;node.pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplSplitMergeScanNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_JOIN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplSplitJoinNodeImpl</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><operator>(</operator><name>SJoinLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_PLAN_INTERNAL_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitJoinNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>stbSplSplitJoinNodeImpl</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SJoinLogicNode</name><operator>*</operator><operator>)</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SPLIT_FLAG_SET_MASK</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>splitFlag</name></name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplCreateMergeKeysForPartitionNode</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pPart</name></decl></parameter>, <parameter><decl><type><name>SNodeList</name><modifier>*</modifier><modifier>*</modifier></type> <name>pMergeKeys</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SScanLogicNode</name><modifier>*</modifier></type> <name>pScan</name> <init>= <expr><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pPart</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type>          <name>pPrimaryKey</name> <init>= <expr><call><name>nodesCloneNode</name><argument_list>(<argument><expr><call><name>stbSplFindPrimaryKeyFromScan</name><argument_list>(<argument><expr><name>pScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pPrimaryKey</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>nodesListAppend</name><argument_list>(<argument><expr><name><name>pPart</name><operator>-&gt;</operator><name>pTargets</name></name></expr></argument>, <argument><expr><name>pPrimaryKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateMergeKeysByPrimaryKey</name><argument_list>(<argument><expr><name>pPrimaryKey</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pScan</name><operator>-&gt;</operator><name>scanSeq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ORDER_ASC</name></expr> </then><else>: <expr><name>ORDER_DESC</name></expr></else></ternary></expr></argument>, <argument><expr><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stbSplSplitPartitionNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SStableSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>    <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pMergeKeys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name><operator>-&gt;</operator><name>requireDataOrder</name></name> <operator>&gt;=</operator> <name>DATA_ORDER_LEVEL_IN_GROUP</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateMergeKeysForPartitionNode</name><argument_list>(<argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pMergeKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplCreateMergeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name>pMergeKeys</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>stableSplit</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pCxt</name><operator>-&gt;</operator><name>pPlanCxt</name><operator>-&gt;</operator><name>rSmaQuery</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SStableSplitInfo</name></type> <name>info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>splMatch</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><name>SPLIT_FLAG_STABLE_SPLIT</name></expr></argument>, <argument><expr><operator>(</operator><name>FSplFindSplitNode</name><operator>)</operator><name>stbSplFindSplitNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>nodeType</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>pSplitNode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplSplitScanNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_JOIN</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplSplitJoinNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_PARTITION</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplSplitPartitionNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplSplitAggNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_WINDOW</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplSplitWindowNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>QUERY_NODE_LOGIC_PLAN_SORT</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>stbSplSplitSortNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <break>break;</break>
  </block_content>}</block></switch>

  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>split</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SSigTbJoinSplitInfo</name> <block>{
  <decl_stmt><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type>     <name>pSplitNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type>  <name>pSubplan</name></decl>;</decl_stmt>
}</block></struct></type> <name>SSigTbJoinSplitInfo</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>sigTbJoinSplNeedSplit</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_JOIN</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SJoinLogicNode</name><modifier>*</modifier></type> <name>pJoin</name> <init>= <expr><operator>(</operator><name>SJoinLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pJoin</name><operator>-&gt;</operator><name>isSingleTableJoin</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>QUERY_NODE_LOGIC_PLAN_EXCHANGE</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
         <name>QUERY_NODE_LOGIC_PLAN_EXCHANGE</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pJoin</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>sigTbJoinSplFindSplitNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>,
                                      <parameter><decl><type><name>SSigTbJoinSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>sigTbJoinSplNeedSplit</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pJoin</name></name> <operator>=</operator> <operator>(</operator><name>SJoinLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name> <operator>=</operator> <name>pSubplan</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>singleTableJoinSplit</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SSigTbJoinSplitInfo</name></type> <name>info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>splMatch</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>FSplFindSplitNode</name><operator>)</operator><name>sigTbJoinSplFindSplitNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>splCreateExchangeNodeForSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>split</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>unionSplitSubplan</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pUnionSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pSplitNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type> <name>pSubplanChildren</name> <init>= <expr><name><name>pUnionSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pUnionSubplan</name><operator>-&gt;</operator><name>pChildren</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name>TSDB_CODE_SUCCESS</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pSplitNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pNewSubplan</name> <init>= <expr><call><name>splCreateSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pUnionSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pNewSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>REPLACE_NODE</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>splMountSubplan</name><argument_list>(<argument><expr><name>pNewSubplan</name></expr></argument>, <argument><expr><name>pSubplanChildren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>nodesDestroyList</name><argument_list>(<argument><expr><name>pSubplanChildren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NODES_DESTORY_LIST</name><argument_list>(<argument><expr><name><name>pSplitNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SUnionAllSplitInfo</name> <block>{
  <decl_stmt><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProject</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type>     <name>pSubplan</name></decl>;</decl_stmt>
}</block></struct></type> <name>SUnionAllSplitInfo</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>unAllSplFindSplitNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>,
                                  <parameter><decl><type><name>SUnionAllSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_PROJECT</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pProject</name></name> <operator>=</operator> <operator>(</operator><name>SProjectLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name> <operator>=</operator> <name>pSubplan</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>unAllSplCreateExchangeNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>startGroupId</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>,
                                          <parameter><decl><type><name>SProjectLogicNode</name><modifier>*</modifier></type> <name>pProject</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExchangeLogicNode</name><modifier>*</modifier></type> <name>pExchange</name> <init>= <expr><operator>(</operator><name>SExchangeLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_EXCHANGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pExchange</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>srcStartGroupId</name></name> <operator>=</operator> <name>startGroupId</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>srcEndGroupId</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name> <operator>=</operator> <name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pLimit</name></name></expr></argument>, <argument><expr><name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pProject</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pParent</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pNode</name></name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pExchange</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pNode</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pNode</argument>, <argument>pProject-&gt;node.pParent-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>nodesEqualNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pProject</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>REPLACE_NODE</name><argument_list>(<argument><expr><name>pExchange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
  <expr_stmt><expr><call><name>nodesDestroyNode</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pExchange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TSDB_CODE_PLAN_INTERNAL_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>unionAllSplit</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SUnionAllSplitInfo</name></type> <name>info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>splMatch</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>FSplFindSplitNode</name><operator>)</operator><name>unAllSplFindSplitNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>startGroupId</name> <init>= <expr><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>unionSplitSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name><name>info</name><operator>.</operator><name>pProject</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>unAllSplCreateExchangeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>startGroupId</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pProject</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>split</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SUnionDistinctSplitInfo</name> <block>{
  <decl_stmt><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl>;</decl_stmt>
}</block></struct></type> <name>SUnionDistinctSplitInfo</name>;</typedef>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>unDistSplCreateExchangeNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>startGroupId</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>,
                                           <parameter><decl><type><name>SAggLogicNode</name><modifier>*</modifier></type> <name>pAgg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SExchangeLogicNode</name><modifier>*</modifier></type> <name>pExchange</name> <init>= <expr><operator>(</operator><name>SExchangeLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesMakeNode</name><argument_list>(<argument><expr><name>QUERY_NODE_LOGIC_PLAN_EXCHANGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pExchange</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>srcStartGroupId</name></name> <operator>=</operator> <name>startGroupId</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>srcEndGroupId</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name> <operator>=</operator> <name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>precision</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name> <operator>=</operator> <call><name>nodesCloneList</name><argument_list>(<argument><expr><name><name>pAgg</name><operator>-&gt;</operator><name>pGroupKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>pExchange</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pTargets</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_MERGE</name></expr>;</expr_stmt>

  <return>return <expr><call><name>nodesListMakeAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pAgg</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pExchange</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>unDistSplFindSplitNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>,
                                   <parameter><decl><type><name>SUnionDistinctSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_AGG</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pAgg</name></name> <operator>=</operator> <operator>(</operator><name>SAggLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name> <operator>=</operator> <name>pSubplan</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>unionDistinctSplit</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SUnionDistinctSplitInfo</name></type> <name>info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>splMatch</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>FSplFindSplitNode</name><operator>)</operator><name>unDistSplFindSplitNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>startGroupId</name> <init>= <expr><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>unionSplitSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name><name>info</name><operator>.</operator><name>pAgg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>unDistSplCreateExchangeNode</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>startGroupId</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pAgg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>split</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SSmaIndexSplitInfo</name> <block>{
  <decl_stmt><decl><type><name>SMergeLogicNode</name><modifier>*</modifier></type> <name>pMerge</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type>   <name>pSubplan</name></decl>;</decl_stmt>
}</block></struct></type> <name>SSmaIndexSplitInfo</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>smaIdxSplFindSplitNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>,
                                   <parameter><decl><type><name>SSmaIndexSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_MERGE</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pMerge</name></name> <operator>=</operator> <operator>(</operator><name>SMergeLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name> <operator>=</operator> <name>pSubplan</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>smaIndexSplit</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SSmaIndexSplitInfo</name></type> <name>info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>splMatch</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>FSplFindSplitNode</name><operator>)</operator><name>smaIdxSplFindSplitNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>unionSplitSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name><name>info</name><operator>.</operator><name>pMerge</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>pMerge</name><operator>-&gt;</operator><name>srcGroupId</name></name> <operator>=</operator> <name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>split</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SInsertSelectSplitInfo</name> <block>{
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type>    <name>pQueryRoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl>;</decl_stmt>
}</block></struct></type> <name>SInsertSelectSplitInfo</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>insSelSplFindSplitNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>,
                                   <parameter><decl><type><name>SInsertSelectSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_VNODE_MODIFY</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">1</literal> <operator>==</operator> <call><name>LIST_LENGTH</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
      <name>MODIFY_TABLE_TYPE_INSERT</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>SVnodeModifyLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>modifyType</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pQueryRoot</name></name> <operator>=</operator> <operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><call><name>nodesListGetNode</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name> <operator>=</operator> <name>pSubplan</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>insertSelectSplit</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SInsertSelectSplitInfo</name></type> <name>info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>splMatch</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><name>SPLIT_FLAG_INSERT_SPLIT</name></expr></argument>, <argument><expr><operator>(</operator><name>FSplFindSplitNode</name><operator>)</operator><name>insSelSplFindSplitNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pNewSubplan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SNodeList</name><modifier>*</modifier></type>     <name>pSubplanChildren</name> <init>= <expr><name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>        <name>code</name> <init>= <expr><call><name>splCreateExchangeNodeForSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pQueryRoot</name></name></expr></argument>, <argument><expr><name>SUBPLAN_TYPE_MODIFY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pNewSubplan</name> <operator>=</operator> <call><name>splCreateSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pQueryRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pNewSubplan</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pNewSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>splMountSubplan</name><argument_list>(<argument><expr><name>pNewSubplan</name></expr></argument>, <argument><expr><name>pSubplanChildren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>SPLIT_FLAG_SET_MASK</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>splitFlag</name></name></expr></argument>, <argument><expr><name>SPLIT_FLAG_INSERT_SPLIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>split</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>SQnodeSplitInfo</name> <block>{
  <decl_stmt><decl><type><name>SLogicNode</name><modifier>*</modifier></type>    <name>pSplitNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl>;</decl_stmt>
}</block></struct></type> <name>SQnodeSplitInfo</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>qndSplFindSplitNode</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>, <parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>,
                                <parameter><decl><type><name>SQnodeSplitInfo</name><modifier>*</modifier></type> <name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name> <operator>&amp;&amp;</operator>
      <name>QUERY_NODE_LOGIC_PLAN_INTERP_FUNC</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>pParent</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name><name>scanSeq</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
      <operator>(</operator><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name><name>scanSeq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSplitNode</name></name> <operator>=</operator> <name>pNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>pSubplan</name></name> <operator>=</operator> <name>pSubplan</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>qnodeSplit</name><parameter_list>(<parameter><decl><type><name>SSplitContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_POLICY_QNODE</name> <operator>!=</operator> <name>tsQueryPolicy</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SQnodeSplitInfo</name></type> <name>info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>splMatch</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>FSplFindSplitNode</name><operator>)</operator><name>qndSplFindSplitNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>(</operator><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name><name>info</name><operator>.</operator><name>pSplitNode</name></name><operator>)</operator><operator>-&gt;</operator><name>dataRequired</name> <operator>=</operator> <name>FUNC_DATA_REQUIRED_DATA_LOAD</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><call><name>splCreateExchangeNodeForSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSubplan</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>==</operator> <name>code</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pScanSubplan</name> <init>= <expr><call><name>splCreateScanSubplan</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSplitNode</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>pScanSubplan</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>numOfComputeNodes</name></name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>pVgroupList</name><operator>-&gt;</operator><name>numOfVgroups</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><name><name>pScanSubplan</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>numOfComputeNodes</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>nodesListMakeStrictAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>pChildren</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pScanSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TSDB_CODE_OUT_OF_MEMORY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>info</name><operator>.</operator><name>pSubplan</name><operator>-&gt;</operator><name>subplanType</name></name> <operator>=</operator> <name>SUBPLAN_TYPE_COMPUTE</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>++</operator><operator>(</operator><name><name>pCxt</name><operator>-&gt;</operator><name>groupId</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCxt</name><operator>-&gt;</operator><name>split</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// clang-format off</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>SSplitRule</name></type> <name><name>splitRuleSet</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"SuperTableSplit"</literal></expr>,      <expr><operator>.</operator><name>splitFunc</name> <operator>=</operator> <name>stableSplit</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"SingleTableJoinSplit"</literal></expr>, <expr><operator>.</operator><name>splitFunc</name> <operator>=</operator> <name>singleTableJoinSplit</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"UnionAllSplit"</literal></expr>,        <expr><operator>.</operator><name>splitFunc</name> <operator>=</operator> <name>unionAllSplit</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"UnionDistinctSplit"</literal></expr>,   <expr><operator>.</operator><name>splitFunc</name> <operator>=</operator> <name>unionDistinctSplit</name></expr>}</block></expr>,
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"SmaIndexSplit"</literal></expr>,        <expr><operator>.</operator><name>splitFunc</name> <operator>=</operator> <name>smaIndexSplit</name></expr>}</block></expr>, <comment type="line">// not used yet</comment>
  <expr><block>{<expr><operator>.</operator><name>pName</name> <operator>=</operator> <literal type="string">"InsertSelectSplit"</literal></expr>,    <expr><operator>.</operator><name>splitFunc</name> <operator>=</operator> <name>insertSelectSplit</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<comment type="line">// clang-format on</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int32_t</name></type> <name>splitRuleNum</name> <init>= <expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>splitRuleSet</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SSplitRule</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dumpLogicSubplan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>pRuleName</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tsQueryPlannerTrace</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>pStr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nodesNodeToString</name><argument_list>(<argument><expr><operator>(</operator><name>SNode</name><operator>*</operator><operator>)</operator><name>pSubplan</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pStr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>pRuleName</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>qDebugL</name><argument_list>(<argument><expr><literal type="string">"before split: %s"</literal></expr></argument>, <argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>qDebugL</name><argument_list>(<argument><expr><literal type="string">"apply split %s rule: %s"</literal></expr></argument>, <argument><expr><name>pRuleName</name></expr></argument>, <argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>applySplitRule</name><parameter_list>(<parameter><decl><type><name>SPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SSplitContext</name></type> <name>cxt</name> <init>= <expr><block>{
      <expr><operator>.</operator><name>pPlanCxt</name> <operator>=</operator> <name>pCxt</name></expr>, <expr><operator>.</operator><name>queryId</name> <operator>=</operator> <name><name>pSubplan</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>queryId</name></name></expr>, <expr><operator>.</operator><name>groupId</name> <operator>=</operator> <name><name>pSubplan</name><operator>-&gt;</operator><name>id</name><operator>.</operator><name>groupId</name></name> <operator>+</operator> <literal type="number">1</literal></expr>, <expr><operator>.</operator><name>split</name> <operator>=</operator> <name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>split</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>dumpLogicSubplan</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>split</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>splitRuleNum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>split</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>code</name> <init>= <expr><name><name>splitRuleSet</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>splitFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>TSDB_CODE_SUCCESS</name> <operator>!=</operator> <name>code</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>code</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>.</operator><name>split</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>split</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dumpLogicSubplan</name><argument_list>(<argument><expr><name><name>splitRuleSet</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pName</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block> while <condition>(<expr><name>split</name></expr>)</condition>;</do>
  <return>return <expr><call><name>qnodeSplit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setVgroupsInfo</name><parameter_list>(<parameter><decl><type><name>SLogicNode</name><modifier>*</modifier></type> <name>pNode</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_SCAN</name> <operator>==</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>TSWAP</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SScanLogicNode</name><operator>*</operator><operator>)</operator><name>pNode</name><operator>)</operator><operator>-&gt;</operator><name>pVgroupList</name></expr></argument>, <argument><expr><name><name>pSubplan</name><operator>-&gt;</operator><name>pVgroupList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>SNode</name><modifier>*</modifier></type> <name>pChild</name></decl>;</decl_stmt>
  <macro><name>FOREACH</name><argument_list>(<argument>pChild</argument>, <argument>pNode-&gt;pChildren</argument>)</argument_list></macro> <block>{<block_content> <expr_stmt><expr><call><name>setVgroupsInfo</name><argument_list>(<argument><expr><operator>(</operator><name>SLogicNode</name><operator>*</operator><operator>)</operator><name>pChild</name></expr></argument>, <argument><expr><name>pSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>needSplitSubplan</name><parameter_list>(<parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>QUERY_NODE_LOGIC_PLAN_VNODE_MODIFY</name> <operator>!=</operator> <call><name>nodeType</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>SVnodeModifyLogicNode</name><modifier>*</modifier></type> <name>pModify</name> <init>= <expr><operator>(</operator><name>SVnodeModifyLogicNode</name><operator>*</operator><operator>)</operator><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><name>MODIFY_TABLE_TYPE_INSERT</name> <operator>==</operator> <name><name>pModify</name><operator>-&gt;</operator><name>modifyType</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>pModify</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>pChildren</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>splitLogicPlan</name><parameter_list>(<parameter><decl><type><name>SPlanContext</name><modifier>*</modifier></type> <name>pCxt</name></decl></parameter>, <parameter><decl><type><name>SLogicSubplan</name><modifier>*</modifier></type> <name>pLogicSubplan</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>needSplitSubplan</name><argument_list>(<argument><expr><name>pLogicSubplan</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>setVgroupsInfo</name><argument_list>(<argument><expr><name><name>pLogicSubplan</name><operator>-&gt;</operator><name>pNode</name></name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TSDB_CODE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>applySplitRule</name><argument_list>(<argument><expr><name>pCxt</name></expr></argument>, <argument><expr><name>pLogicSubplan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
