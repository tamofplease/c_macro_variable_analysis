<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/utils/tsim/src/simParse.c"><comment type="block">/*
 * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the GNU Affero General Public License, version 3
 * or later ("AGPL"), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<comment type="block">/* Thi file is to parse the simScriptPos, function file and default file,
 *
 * syntax
 *
 *    expression is format like:
 *       $var [=|&lt;|&gt;|==] var
 *     or:
 *       $var = var [+|-|*|/|.] var
 *
 *    if expression
 *      command
 *
 *    if expression then
 *      commands
 *    elif expression
 *      commands
 *    elif expression
 *      commands
 *    else
 *      commands
 *    endi
 *
 *    while expression
 *      commands
 *      continue
 *      break
 *    endw
 *
 *    switch expression
 *      case 1
 *        commands
 *        break
 *      case 2
 *        commands
 *        break
 *      default
 *        commands
 *    ends
 *
 *    label:
 *    goto label
 *
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_DEFAULT_SOURCE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"simParse.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>SCommand</name> <modifier>*</modifier></type><name><name>cmdHashList</name><index>[<expr><name>MAX_NUM_CMD</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SCmdLine</name></type>  <name><name>cmdLine</name><index>[<expr><name>MAX_CMD_LINES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>      <name><name>parseErr</name><index>[<expr><name>MAX_ERROR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>      <name><name>optionBuffer</name><index>[<expr><name>MAX_OPTION_BUFFER</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int32_t</name></type>   <name>numOfLines</name></decl>, <decl><type ref="prev"/><name>optionOffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SLabel</name></type>    <name>label</name></decl>, <decl><type ref="prev"/><name>dest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SBlock</name></type>    <name>block</name></decl>;</decl_stmt>

<function><type><name>int32_t</name></type> <name>simHashCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>tokenLen</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>hash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tokenLen</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>hash</name> <operator>+=</operator> <name><name>token</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

  <expr_stmt><expr><name>hash</name> <operator>=</operator> <name>hash</name> <operator>%</operator> <name>MAX_NUM_CMD</name></expr>;</expr_stmt>

  <return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SCommand</name> <modifier>*</modifier></type><name>simCheckCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>tokenLen</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>   <name>hash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>simHashCmd</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>tokenLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>cmdHashList</name><index>[<expr><name>hash</name></expr>]</index></name></expr>;</expr_stmt>

  <while>while <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nlen</name></name> <operator>==</operator> <name>tokenLen</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>tokenLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>node</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>simAddCmdIntoHash</name><parameter_list>(<parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>   <name>hash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>simHashCmd</name><argument_list>(<argument><expr><name><name>pCmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>pCmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>cmdHashList</name><index>[<expr><name>hash</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCmd</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdHashList</name><index>[<expr><name>hash</name></expr>]</index></name> <operator>=</operator> <name>pCmd</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>simResetParser</name><parameter_list>()</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>optionOffset</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>numOfLines</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmdLine</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>optionBuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>optionBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>label</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>SScript</name> <modifier>*</modifier></type><name>simBuildScriptObj</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>destPos</name></decl>;</decl_stmt>

  <comment type="block">/* process labels */</comment>

  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_RETURN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfLines</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>errorJump</name> <operator>=</operator> <name>SQL_JUMP_FALSE</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <for>for <control>(<init><expr><operator>--</operator><name><name>dest</name><operator>.</operator><name>top</name></name></expr>;</init> <condition><expr><name><name>dest</name><operator>.</operator><name>top</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name><name>dest</name><operator>.</operator><name>top</name></name></expr></incr>)</control> <block>{<block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>label</name><operator>.</operator><name>top</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>label</name><operator>.</operator><name>label</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>label</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>dest</name><operator>.</operator><name>top</name></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>label</name><operator>.</operator><name>top</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"label:%s not defined"</literal></expr></argument>, <argument><expr><name><name>dest</name><operator>.</operator><name>label</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>dest</name><operator>.</operator><name>top</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>destPos</name> <operator>=</operator> <name><name>dest</name><operator>.</operator><name>pos</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>dest</name><operator>.</operator><name>top</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>destPos</name></expr>]</index></name><operator>.</operator><name>jump</name> <operator>=</operator> <name><name>label</name><operator>.</operator><name>pos</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cmdLine</name><index>[<expr><name>destPos</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>==</operator> <name>SIM_CMD_SQL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>destPos</name></expr>]</index></name><operator>.</operator><name>errorJump</name> <operator>=</operator> <name>SQL_JUMP_TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"mismatched block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numOfLines</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cmdLine</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>jump</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>jump</name> <operator>=</operator> <name>numOfLines</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <decl_stmt><decl><type><name>SScript</name> <modifier>*</modifier></type><name>script</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SScript</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SScript</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>script</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SIM_SCRIPT_TYPE_MAIN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>script</name><operator>-&gt;</operator><name>numOfLines</name></name> <operator>=</operator> <name>numOfLines</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tstrncpy</name><argument_list>(<argument><expr><name><name>script</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>script</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>script</name><operator>-&gt;</operator><name>optionBuffer</name></name> <operator>=</operator> <call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name>optionOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>script</name><operator>-&gt;</operator><name>optionBuffer</name></name></expr></argument>, <argument><expr><name>optionBuffer</name></expr></argument>, <argument><expr><name>optionOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>script</name><operator>-&gt;</operator><name>lines</name></name> <operator>=</operator> <call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCmdLine</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numOfLines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>script</name><operator>-&gt;</operator><name>lines</name></name></expr></argument>, <argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SCmdLine</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numOfLines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>script</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SScript</name> <modifier>*</modifier></type><name>simParseScript</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TdFilePtr</name></type> <name>pFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>   <name>tokenLen</name></decl>, <decl><type ref="prev"/><name>lineNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>      <name><name>buffer</name><index>[<expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1024</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>      <name><name>name</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">9</literal></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>     <modifier>*</modifier></type><name>token</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>     <modifier>*</modifier></type><name>rest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SScript</name>  <modifier>*</modifier></type><name>script</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fileName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>fileName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>tstrncpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal> <name>TD_DIRSEP</name> <literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>simScriptDir</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosRealPath</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="line">// if ((fd = fopen(name, "r")) == NULL) {</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pFile</name> <operator>=</operator> <call><name>taosOpenFile</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>TD_FILE_READ</name> <operator>|</operator> <name>TD_FILE_STREAM</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>simError</name><argument_list>(<argument><expr><literal type="string">"failed to open file:%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>simResetParser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <while>while <condition>(<expr><operator>!</operator><call><name>taosEOFFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>taosGetsFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>lineNum</name><operator>++</operator></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>cmdlen</name> <init>= <expr><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>cmdlen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <name><name>buffer</name><index>[<expr><name>cmdlen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>cmdlen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rest</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cmdlen</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

  <label><name>again</name>:</label>
    <expr_stmt><expr><name>rest</name> <operator>=</operator> <call><name>paGetToken</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tokenLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>tokenLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><name>tokenLen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>label</name><operator>.</operator><name>label</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>label</name><operator>.</operator><name>top</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>tokenLen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>label</name><operator>.</operator><name>pos</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>label</name><operator>.</operator><name>top</name></name></expr>]</index></name> <operator>=</operator> <name>numOfLines</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>label</name><operator>.</operator><name>top</name></name><operator>++</operator></expr>;</expr_stmt>
      <goto>goto <name>again</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>simParseExpression</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>lineNum</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>simError</name><argument_list>(<argument><expr><literal type="string">"script:%s line:%d %s"</literal></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>lineNum</name></expr></argument>, <argument><expr><name>parseErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pCmd</name> <operator>=</operator> <call><name>simCheckCmd</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>tokenLen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>token</name><index>[<expr><name>tokenLen</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>simError</name><argument_list>(<argument><expr><literal type="string">"script:%s line:%d invalid cmd:%s"</literal></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>lineNum</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pCmd</name><operator>-&gt;</operator><name>parseCmd</name></name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><name>lineNum</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>simError</name><argument_list>(<argument><expr><literal type="string">"script:%s line:%d %s"</literal></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>lineNum</name></expr></argument>, <argument><expr><name>parseErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>taosCloseFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>script</name> <operator>=</operator> <call><name>simBuildScriptObj</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>script</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>simError</name><argument_list>(<argument><expr><literal type="string">"script:%s %s"</literal></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>parseErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>script</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>simCheckExpression</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>op1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>op2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>op</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>op1Len</name></decl>, <decl><type ref="prev"/><name>op2Len</name></decl>, <decl><type ref="prev"/><name>opLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rest</name> <operator>=</operator> <call><name>paGetToken</name><argument_list>(<argument><expr><name>exp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op1Len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>op1Len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"expression is required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rest</name> <operator>=</operator> <call><name>paGetToken</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>opLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"operator is missed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rest</name> <operator>=</operator> <call><name>paGetToken</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op2Len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>op2Len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"operand is missed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>opLen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"invalid operator:%s"</literal></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <name><name>op1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"left side of assignment must be variable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>opLen</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'='</literal> <operator>||</operator> <operator>(</operator><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&gt;'</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'!'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"left side of assignment must be variable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"invalid operator:%s"</literal></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>rest</name> <operator>=</operator> <call><name>paGetToken</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>opLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>rest</name> <operator>-</operator> <name>exp</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* if it is key word "then" */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="string">"then"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>op</name> <operator>-</operator> <name>exp</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rest</name> <operator>=</operator> <call><name>paGetToken</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op2Len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>op2Len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"operand is missed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>opLen</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"invalid operator:%s"</literal></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>rest</name> <operator>-</operator> <name>exp</name><operator>)</operator></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseExpression</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>expLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>expLen</name> <operator>=</operator> <call><name>simCheckExpression</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>expLen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_EXP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>optionOffset</name> <operator>=</operator> <name>optionOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>expLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>optionOffset</name> <operator>+=</operator> <name>expLen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseIfCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>expLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>expLen</name> <operator>=</operator> <call><name>simCheckExpression</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>expLen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>rest</name> <operator>+</operator> <name>expLen</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><literal type="string">"then"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>block</name><operator>.</operator><name>type</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>block</name><operator>.</operator><name>top</name></name></expr>]</index></name> <operator>=</operator> <name>BLOCK_IF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>block</name><operator>.</operator><name>pos</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>block</name><operator>.</operator><name>top</name></name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>jump</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>block</name><operator>.</operator><name>top</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>jump</name> <operator>=</operator> <name>numOfLines</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>optionOffset</name> <operator>=</operator> <name>optionOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>expLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>optionOffset</name> <operator>+=</operator> <name>expLen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_TEST</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseElifCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>expLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>expLen</name> <operator>=</operator> <call><name>simCheckExpression</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>expLen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"no matching if"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>.</operator><name>type</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>BLOCK_IF</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"no matched if block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_GOTO</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>jump</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>block</name><operator>.</operator><name>numJump</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>jump</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>numJump</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>block</name><operator>.</operator><name>pos</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>=</operator> <name>numOfLines</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>pos</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>jump</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>optionOffset</name> <operator>=</operator> <name>optionOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>expLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>optionOffset</name> <operator>+=</operator> <name>expLen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_TEST</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseElseCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"no matching if"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>.</operator><name>type</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>BLOCK_IF</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"no matched if block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_GOTO</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>jump</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>block</name><operator>.</operator><name>numJump</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>jump</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>numJump</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>block</name><operator>.</operator><name>pos</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>=</operator> <name>numOfLines</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>pos</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseEndiCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"no matching if"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>.</operator><name>type</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>BLOCK_IF</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"no matched if block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>.</operator><name>pos</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>block</name><operator>.</operator><name>pos</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>=</operator> <name>numOfLines</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>block</name><operator>.</operator><name>numJump</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>block</name><operator>.</operator><name>jump</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>=</operator> <name>numOfLines</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>numJump</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseWhileCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>expLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>expLen</name> <operator>=</operator> <call><name>simCheckExpression</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>expLen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>type</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>block</name><operator>.</operator><name>top</name></name></expr>]</index></name> <operator>=</operator> <name>BLOCK_WHILE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>pos</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>block</name><operator>.</operator><name>top</name></name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>jump</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>back</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>block</name><operator>.</operator><name>top</name></name></expr>]</index></name> <operator>=</operator> <name>numOfLines</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>top</name></name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>optionOffset</name> <operator>=</operator> <name>optionOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>expLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>optionOffset</name> <operator>+=</operator> <name>expLen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_TEST</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseEndwCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"no matching while"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>block</name><operator>.</operator><name>type</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>BLOCK_WHILE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"no matched while block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_GOTO</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>jump</name> <operator>=</operator> <name><name>block</name><operator>.</operator><name>back</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>block</name><operator>.</operator><name>pos</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>=</operator> <name>numOfLines</name></expr>;</expr_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>block</name><operator>.</operator><name>numJump</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>block</name><operator>.</operator><name>jump</name><index>[<expr><name><name>block</name><operator>.</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>=</operator> <name>numOfLines</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name><name>block</name><operator>.</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
bool simParseSwitchCmd(char *rest, SCommand *pCmd, int32_t lineNum) {
  char   *token;
  int32_t tokenLen;

  rest = paGetToken(rest, &amp;token, &amp;tokenLen);
  if (tokenLen == 0) {
    sprintf(parseErr, "switch should be followed by variable");
    return false;
  }

  if (token[0] != '$') {
    sprintf(parseErr, "switch must be followed by variable");
    return false;
  }

  memcpy(block.sexp[(uint8_t)block.top], token, tokenLen);
  block.sexpLen[(uint8_t)block.top] = tokenLen;
  block.type[(uint8_t)block.top] = BLOCK_SWITCH;
  block.top++;

  return true;
}

bool simParseCaseCmd(char *rest, SCommand *pCmd, int32_t lineNum) {
  char   *token;
  int32_t tokenLen;

  rest = paGetToken(rest, &amp;token, &amp;tokenLen);
  if (tokenLen == 0) {
    sprintf(parseErr, "case should be followed by value");
    return false;
  }

  if (block.top &lt; 1) {
    sprintf(parseErr, "no matching switch");
    return false;
  }

  if (block.type[block.top - 1] != BLOCK_SWITCH) {
    sprintf(parseErr, "case not matched");
    return false;
  }

  if (block.pos[block.top - 1] != NULL) {
    *(block.pos[block.top - 1]) = numOfLines;
  }

  block.pos[block.top - 1] = &amp;(cmdLine[numOfLines].jump);

  cmdLine[numOfLines].cmdno = SIM_CMD_TEST;
  cmdLine[numOfLines].lineNum = lineNum;
  cmdLine[numOfLines].optionOffset = optionOffset;
  memcpy(optionBuffer + optionOffset, block.sexp[block.top - 1], block.sexpLen[block.top - 1]);
  optionOffset += block.sexpLen[block.top - 1];
  *(optionBuffer + optionOffset++) = ' ';
  *(optionBuffer + optionOffset++) = '=';
  *(optionBuffer + optionOffset++) = '=';
  *(optionBuffer + optionOffset++) = ' ';
  memcpy(optionBuffer + optionOffset, token, tokenLen);
  optionOffset += tokenLen + 1;
  *(optionBuffer + optionOffset - 1) = 0;

  numOfLines++;
  return true;
}

bool simParseBreakCmd(char *rest, SCommand *pCmd, int32_t lineNum) {
  if (block.top &lt; 1) {
    sprintf(parseErr, "no blcok exists");
    return false;
  }

  if (block.type[block.top - 1] != BLOCK_SWITCH &amp;&amp; block.type[block.top - 1] != BLOCK_WHILE) {
    sprintf(parseErr, "not in switch or while block");
    return false;
  }

  block.jump[block.top - 1][(uint8_t)block.numJump[block.top - 1]] = &amp;(cmdLine[numOfLines].jump);
  block.numJump[block.top - 1]++;

  cmdLine[numOfLines].cmdno = SIM_CMD_GOTO;
  cmdLine[numOfLines].lineNum = lineNum;

  numOfLines++;
  return true;
}

bool simParseDefaultCmd(char *rest, SCommand *pCmd, int32_t lineNum) {
  if (block.top &lt; 1) {
    sprintf(parseErr, "no matching switch");
    return false;
  }

  if (block.type[block.top - 1] != BLOCK_SWITCH) {
    sprintf(parseErr, "default should be matched with switch");
    return false;
  }

  if (block.pos[block.top - 1] != NULL) {
    *(block.pos[block.top - 1]) = numOfLines;
  }

  return true;
}

bool simParseEndsCmd(char *rest, SCommand *pCmd, int32_t lineNum) {
  int32_t i;

  if (block.top &lt; 1) {
    sprintf(parseErr, "no matching switch");
    return false;
  }

  if (block.type[block.top - 1] != BLOCK_SWITCH) {
    sprintf(parseErr, "ends should be matched with switch");
    return false;
  }

  for (i = 0; i &lt; block.numJump[block.top - 1]; ++i) {
    *(block.jump[block.top - 1][i]) = numOfLines;
  }

  block.numJump[block.top - 1] = 0;
  block.top--;

  return true;
}

bool simParseContinueCmd(char *rest, SCommand *pCmd, int32_t lineNum) {
  if (block.top &lt; 1) {
    sprintf(parseErr, "no matching while");
    return false;
  }

  if (block.type[block.top - 1] != BLOCK_WHILE) {
    sprintf(parseErr, "continue should be matched with while cmd");
    return false;
  }

  cmdLine[numOfLines].cmdno = SIM_CMD_GOTO;
  cmdLine[numOfLines].lineNum = lineNum;
  cmdLine[numOfLines].jump = block.back[block.top - 1];

  numOfLines++;
  return true;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>bool</name></type> <name>simParsePrintCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>expLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rest</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_PRINT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>optionOffset</name> <operator>=</operator> <name>optionOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>expLen</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>expLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>optionOffset</name> <operator>+=</operator> <name>expLen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>simCheckSqlOption</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>valueLen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>value</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>xpos</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>xpos</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><literal type="string">" -x"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// need a blank</comment>
  <if_stmt><if>if <condition>(<expr><name>xpos</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>paGetToken</name><argument_list>(<argument><expr><name>xpos</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valueLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>valueLen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dest</name><operator>.</operator><name>label</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>dest</name><operator>.</operator><name>top</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>valueLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>label</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>dest</name><operator>.</operator><name>top</name></name></expr>]</index><index>[<expr><name>valueLen</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>pos</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>dest</name><operator>.</operator><name>top</name></name></expr>]</index></name> <operator>=</operator> <name>numOfLines</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>top</name></name><operator>++</operator></expr>;</expr_stmt>

      <expr_stmt><expr><operator>*</operator><name>xpos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseSqlCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>expLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rest</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simCheckSqlOption</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_SQL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>optionOffset</name> <operator>=</operator> <name>optionOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>expLen</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>expLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>optionOffset</name> <operator>+=</operator> <name>expLen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseSqlErrorCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>expLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rest</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_SQL_ERROR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>optionOffset</name> <operator>=</operator> <name>optionOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>expLen</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>expLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>optionOffset</name> <operator>+=</operator> <name>expLen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseSqlSlowCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>simParseSqlCmd</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><name>lineNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_SQL_SLOW</name></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseSystemCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>expLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rest</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_SYSTEM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>optionOffset</name> <operator>=</operator> <name>optionOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>expLen</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>expLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>optionOffset</name> <operator>+=</operator> <name>expLen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseSystemContentCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>simParseSystemCmd</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><name>lineNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_SYSTEM_CONTENT</name></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseSleepCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>tokenLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_SLEEP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>paGetToken</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tokenLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tokenLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>optionOffset</name> <operator>=</operator> <name>optionOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>tokenLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>optionOffset</name> <operator>+=</operator> <name>tokenLen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseReturnCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>tokenLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_RETURN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>paGetToken</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tokenLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tokenLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>optionOffset</name> <operator>=</operator> <name>optionOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>tokenLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>optionOffset</name> <operator>+=</operator> <name>tokenLen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseGotoCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>tokenLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rest</name> <operator>=</operator> <call><name>paGetToken</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tokenLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>tokenLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"label should be followed by goto cmd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dest</name><operator>.</operator><name>label</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>dest</name><operator>.</operator><name>top</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>tokenLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>label</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>dest</name><operator>.</operator><name>top</name></name></expr>]</index><index>[<expr><name>tokenLen</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>pos</name><index>[<expr><operator>(</operator><name>uint8_t</name><operator>)</operator><name><name>dest</name><operator>.</operator><name>top</name></name></expr>]</index></name> <operator>=</operator> <name>numOfLines</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest</name><operator>.</operator><name>top</name></name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_GOTO</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseRunCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>tokenLen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rest</name> <operator>=</operator> <call><name>paGetToken</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tokenLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>tokenLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>parseErr</name></expr></argument>, <argument><expr><literal type="string">"file name should be followed by run cmd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_RUN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>lineNum</name> <operator>=</operator> <name>lineNum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name></expr>]</index></name><operator>.</operator><name>optionOffset</name> <operator>=</operator> <name>optionOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>tokenLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>optionOffset</name> <operator>+=</operator> <name>tokenLen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>optionBuffer</name> <operator>+</operator> <name>optionOffset</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>numOfLines</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>simParseRunBackCmd</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rest</name></decl></parameter>, <parameter><decl><type><name>SCommand</name> <modifier>*</modifier></type><name>pCmd</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>lineNum</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>simParseRunCmd</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><name>lineNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cmdLine</name><index>[<expr><name>numOfLines</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_RUN_BACK</name></expr>;</expr_stmt>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
bool simParseLineInsertCmd(char *rest, SCommand *pCmd, int32_t lineNum) {
  int32_t expLen;

  rest++;
  cmdLine[numOfLines].cmdno = SIM_CMD_LINE_INSERT;
  cmdLine[numOfLines].lineNum = lineNum;
  cmdLine[numOfLines].optionOffset = optionOffset;
  expLen = (int32_t)strlen(rest);
  memcpy(optionBuffer + optionOffset, rest, expLen);
  optionOffset += expLen + 1;
  *(optionBuffer + optionOffset - 1) = 0;

  numOfLines++;
  return true;
}

bool simParseLineInsertErrorCmd(char *rest, SCommand *pCmd, int32_t lineNum) {
  int32_t expLen;

  rest++;
  cmdLine[numOfLines].cmdno = SIM_CMD_LINE_INSERT;
  cmdLine[numOfLines].lineNum = lineNum;
  cmdLine[numOfLines].optionOffset = optionOffset;
  expLen = (int32_t)strlen(rest);
  memcpy(optionBuffer + optionOffset, rest, expLen);
  optionOffset += expLen + 1;
  *(optionBuffer + optionOffset - 1) = 0;

  numOfLines++;
  return true;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>simInitsimCmdList</name><parameter_list>()</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>cmdno</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>simCmdList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SIM_CMD_END</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* internal command */</comment>
  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_EXP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"exp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecuteExpCmd</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_IF</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"if"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseIfCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_ELIF</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"elif"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseElifCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_ELSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"else"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseElseCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_ENDI</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"endi"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseEndiCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_WHILE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"while"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseWhileCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_ENDW</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"endw"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseEndwCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  cmdno = SIM_CMD_SWITCH;
  simCmdList[cmdno].cmdno = cmdno;
  strcpy(simCmdList[cmdno].name, "switch");
  simCmdList[cmdno].nlen = (int16_t)strlen(simCmdList[cmdno].name);
  simCmdList[cmdno].parseCmd = simParseSwitchCmd;
  simCmdList[cmdno].executeCmd = NULL;
  simAddCmdIntoHash(&amp;(simCmdList[cmdno]));

  cmdno = SIM_CMD_CASE;
  simCmdList[cmdno].cmdno = cmdno;
  strcpy(simCmdList[cmdno].name, "case");
  simCmdList[cmdno].nlen = (int16_t)strlen(simCmdList[cmdno].name);
  simCmdList[cmdno].parseCmd = simParseCaseCmd;
  simCmdList[cmdno].executeCmd = NULL;
  simAddCmdIntoHash(&amp;(simCmdList[cmdno]));

  cmdno = SIM_CMD_DEFAULT;
  simCmdList[cmdno].cmdno = cmdno;
  strcpy(simCmdList[cmdno].name, "default");
  simCmdList[cmdno].nlen = (int16_t)strlen(simCmdList[cmdno].name);
  simCmdList[cmdno].parseCmd = simParseDefaultCmd;
  simCmdList[cmdno].executeCmd = NULL;
  simAddCmdIntoHash(&amp;(simCmdList[cmdno]));

  cmdno = SIM_CMD_BREAK;
  simCmdList[cmdno].cmdno = cmdno;
  strcpy(simCmdList[cmdno].name, "break");
  simCmdList[cmdno].nlen = (int16_t)strlen(simCmdList[cmdno].name);
  simCmdList[cmdno].parseCmd = simParseBreakCmd;
  simCmdList[cmdno].executeCmd = NULL;
  simAddCmdIntoHash(&amp;(simCmdList[cmdno]));

  cmdno = SIM_CMD_CONTINUE;
  simCmdList[cmdno].cmdno = cmdno;
  strcpy(simCmdList[cmdno].name, "continue");
  simCmdList[cmdno].nlen = (int16_t)strlen(simCmdList[cmdno].name);
  simCmdList[cmdno].parseCmd = simParseContinueCmd;
  simCmdList[cmdno].executeCmd = NULL;
  simAddCmdIntoHash(&amp;(simCmdList[cmdno]));

  cmdno = SIM_CMD_ENDS;
  simCmdList[cmdno].cmdno = cmdno;
  strcpy(simCmdList[cmdno].name, "ends");
  simCmdList[cmdno].nlen = (int16_t)strlen(simCmdList[cmdno].name);
  simCmdList[cmdno].parseCmd = simParseEndsCmd;
  simCmdList[cmdno].executeCmd = NULL;
  simAddCmdIntoHash(&amp;(simCmdList[cmdno]));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_SLEEP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"sleep"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseSleepCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecuteSleepCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_GOTO</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"goto"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseGotoCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecuteGotoCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_RUN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"run"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseRunCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecuteRunCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_RUN_BACK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"run_back"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseRunBackCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecuteRunBackCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_SYSTEM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"system"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseSystemCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecuteSystemCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_SYSTEM_CONTENT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"system_content"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseSystemContentCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecuteSystemContentCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_PRINT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"print"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParsePrintCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecutePrintCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_SQL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"sql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseSqlCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecuteSqlCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_SQL_ERROR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"sql_error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseSqlErrorCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecuteSqlErrorCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_SQL_SLOW</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"sql_slow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseSqlSlowCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecuteSqlSlowCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* test is only an internal command */</comment>
  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_TEST</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecuteTestCmd</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>cmdno</name> <operator>=</operator> <name>SIM_CMD_RETURN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>cmdno</name> <operator>=</operator> <name>cmdno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"return"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>nlen</name> <operator>=</operator> <operator>(</operator><name>int16_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>parseCmd</name> <operator>=</operator> <name>simParseReturnCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>.</operator><name>executeCmd</name> <operator>=</operator> <name>simExecuteReturnCmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>simAddCmdIntoHash</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>simCmdList</name><index>[<expr><name>cmdno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  cmdno = SIM_CMD_LINE_INSERT;
  simCmdList[cmdno].cmdno = cmdno;
  strcpy(simCmdList[cmdno].name, "line_insert");
  simCmdList[cmdno].nlen = (int16_t)strlen(simCmdList[cmdno].name);
  simCmdList[cmdno].parseCmd = simParseLineInsertCmd;
  simCmdList[cmdno].executeCmd = simExecuteLineInsertCmd;
  simAddCmdIntoHash(&amp;(simCmdList[cmdno]));

  cmdno = SIM_CMD_LINE_INSERT_ERROR;
  simCmdList[cmdno].cmdno = cmdno;
  strcpy(simCmdList[cmdno].name, "line_insert_error");
  simCmdList[cmdno].nlen = (int16_t)strlen(simCmdList[cmdno].name);
  simCmdList[cmdno].parseCmd = simParseLineInsertErrorCmd;
  simCmdList[cmdno].executeCmd = simExecuteLineInsertErrorCmd;
  simAddCmdIntoHash(&amp;(simCmdList[cmdno]));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
</unit>
