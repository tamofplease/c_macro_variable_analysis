<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/db_tutorial/db.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>buffer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>buffer_length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>input_length</name></decl>;</decl_stmt>
}</block></struct></type> <name>InputBuffer</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
  <decl><name>EXECUTE_SUCCESS</name></decl>,
  <decl><name>EXECUTE_DUPLICATE_KEY</name></decl>,
}</block></enum></type> <name>ExecuteResult</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
  <decl><name>META_COMMAND_SUCCESS</name></decl>,
  <decl><name>META_COMMAND_UNRECOGNIZED_COMMAND</name></decl>
}</block></enum></type> <name>MetaCommandResult</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
  <decl><name>PREPARE_SUCCESS</name></decl>,
  <decl><name>PREPARE_NEGATIVE_ID</name></decl>,
  <decl><name>PREPARE_STRING_TOO_LONG</name></decl>,
  <decl><name>PREPARE_SYNTAX_ERROR</name></decl>,
  <decl><name>PREPARE_UNRECOGNIZED_STATEMENT</name></decl>
}</block></enum></type> <name>PrepareResult</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{ <decl><name>STATEMENT_INSERT</name></decl>, <decl><name>STATEMENT_SELECT</name></decl> }</block></enum></type> <name>StatementType</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLUMN_USERNAME_SIZE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLUMN_EMAIL_SIZE</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>username</name><index>[<expr><name>COLUMN_USERNAME_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>email</name><index>[<expr><name>COLUMN_EMAIL_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>Row</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>StatementType</name></type> <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Row</name></type> <name>row_to_insert</name></decl>;</decl_stmt>  <comment type="line">// only used by insert statement</comment>
}</block></struct></type> <name>Statement</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>size_of_attribute</name><parameter_list>(<parameter><type><name>Struct</name></type></parameter>, <parameter><type><name>Attribute</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sizeof(((Struct*)0)-&gt;Attribute)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>ID_SIZE</name> <init>= <expr><call><name>size_of_attribute</name><argument_list>(<argument><expr><name>Row</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>USERNAME_SIZE</name> <init>= <expr><call><name>size_of_attribute</name><argument_list>(<argument><expr><name>Row</name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>EMAIL_SIZE</name> <init>= <expr><call><name>size_of_attribute</name><argument_list>(<argument><expr><name>Row</name></expr></argument>, <argument><expr><name>email</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>ID_OFFSET</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>USERNAME_OFFSET</name> <init>= <expr><name>ID_OFFSET</name> <operator>+</operator> <name>ID_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>EMAIL_OFFSET</name> <init>= <expr><name>USERNAME_OFFSET</name> <operator>+</operator> <name>USERNAME_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>ROW_SIZE</name> <init>= <expr><name>ID_SIZE</name> <operator>+</operator> <name>USERNAME_SIZE</name> <operator>+</operator> <name>EMAIL_SIZE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>PAGE_SIZE</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TABLE_MAX_PAGES</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>file_descriptor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>file_length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_pages</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name><name>pages</name><index>[<expr><name>TABLE_MAX_PAGES</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>Pager</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>Pager</name><modifier>*</modifier></type> <name>pager</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>root_page_num</name></decl>;</decl_stmt>
}</block></struct></type> <name>Table</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>page_num</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>cell_num</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>end_of_table</name></decl>;</decl_stmt>  <comment type="line">// Indicates a position one past the last element</comment>
}</block></struct></type> <name>Cursor</name>;</typedef>

<function><type><name>void</name></type> <name>print_row</name><parameter_list>(<parameter><decl><type><name>Row</name><modifier>*</modifier></type> <name>row</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"(%d, %s, %s)\n"</literal></expr></argument>, <argument><expr><name><name>row</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>row</name><operator>-&gt;</operator><name>username</name></name></expr></argument>, <argument><expr><name><name>row</name><operator>-&gt;</operator><name>email</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{ <decl><name>NODE_INTERNAL</name></decl>, <decl><name>NODE_LEAF</name></decl> }</block></enum></type> <name>NodeType</name>;</typedef>

<comment type="block">/*
 * Common Node Header Layout
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>NODE_TYPE_SIZE</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>NODE_TYPE_OFFSET</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>IS_ROOT_SIZE</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>IS_ROOT_OFFSET</name> <init>= <expr><name>NODE_TYPE_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>PARENT_POINTER_SIZE</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>PARENT_POINTER_OFFSET</name> <init>= <expr><name>IS_ROOT_OFFSET</name> <operator>+</operator> <name>IS_ROOT_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>COMMON_NODE_HEADER_SIZE</name> <init>=
    <expr><name>NODE_TYPE_SIZE</name> <operator>+</operator> <name>IS_ROOT_SIZE</name> <operator>+</operator> <name>PARENT_POINTER_SIZE</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Internal Node Header Layout
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>INTERNAL_NODE_NUM_KEYS_SIZE</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>INTERNAL_NODE_NUM_KEYS_OFFSET</name> <init>= <expr><name>COMMON_NODE_HEADER_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>INTERNAL_NODE_RIGHT_CHILD_SIZE</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>INTERNAL_NODE_RIGHT_CHILD_OFFSET</name> <init>=
    <expr><name>INTERNAL_NODE_NUM_KEYS_OFFSET</name> <operator>+</operator> <name>INTERNAL_NODE_NUM_KEYS_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>INTERNAL_NODE_HEADER_SIZE</name> <init>= <expr><name>COMMON_NODE_HEADER_SIZE</name> <operator>+</operator>
                                           <name>INTERNAL_NODE_NUM_KEYS_SIZE</name> <operator>+</operator>
                                           <name>INTERNAL_NODE_RIGHT_CHILD_SIZE</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Internal Node Body Layout
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>INTERNAL_NODE_KEY_SIZE</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>INTERNAL_NODE_CHILD_SIZE</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>INTERNAL_NODE_CELL_SIZE</name> <init>=
    <expr><name>INTERNAL_NODE_CHILD_SIZE</name> <operator>+</operator> <name>INTERNAL_NODE_KEY_SIZE</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* Keep this small for testing */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>INTERNAL_NODE_MAX_CELLS</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Leaf Node Header Layout
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_NUM_CELLS_SIZE</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_NUM_CELLS_OFFSET</name> <init>= <expr><name>COMMON_NODE_HEADER_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_NEXT_LEAF_SIZE</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_NEXT_LEAF_OFFSET</name> <init>=
    <expr><name>LEAF_NODE_NUM_CELLS_OFFSET</name> <operator>+</operator> <name>LEAF_NODE_NUM_CELLS_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_HEADER_SIZE</name> <init>= <expr><name>COMMON_NODE_HEADER_SIZE</name> <operator>+</operator>
                                       <name>LEAF_NODE_NUM_CELLS_SIZE</name> <operator>+</operator>
                                       <name>LEAF_NODE_NEXT_LEAF_SIZE</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Leaf Node Body Layout
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_KEY_SIZE</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_KEY_OFFSET</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_VALUE_SIZE</name> <init>= <expr><name>ROW_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_VALUE_OFFSET</name> <init>=
    <expr><name>LEAF_NODE_KEY_OFFSET</name> <operator>+</operator> <name>LEAF_NODE_KEY_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_CELL_SIZE</name> <init>= <expr><name>LEAF_NODE_KEY_SIZE</name> <operator>+</operator> <name>LEAF_NODE_VALUE_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_SPACE_FOR_CELLS</name> <init>= <expr><name>PAGE_SIZE</name> <operator>-</operator> <name>LEAF_NODE_HEADER_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_MAX_CELLS</name> <init>=
    <expr><name>LEAF_NODE_SPACE_FOR_CELLS</name> <operator>/</operator> <name>LEAF_NODE_CELL_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_RIGHT_SPLIT_COUNT</name> <init>= <expr><operator>(</operator><name>LEAF_NODE_MAX_CELLS</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>LEAF_NODE_LEFT_SPLIT_COUNT</name> <init>=
    <expr><operator>(</operator><name>LEAF_NODE_MAX_CELLS</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>LEAF_NODE_RIGHT_SPLIT_COUNT</name></expr></init></decl>;</decl_stmt>

<function><type><name>NodeType</name></type> <name>get_node_type</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>value</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>node</name> <operator>+</operator> <name>NODE_TYPE_OFFSET</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><name>NodeType</name><operator>)</operator><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>set_node_type</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>NodeType</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>value</name> <init>= <expr><name>type</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>node</name> <operator>+</operator> <name>NODE_TYPE_OFFSET</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>is_node_root</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>value</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>node</name> <operator>+</operator> <name>IS_ROOT_OFFSET</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><name>bool</name><operator>)</operator><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>set_node_root</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_root</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>value</name> <init>= <expr><name>is_root</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><operator>(</operator><name>node</name> <operator>+</operator> <name>IS_ROOT_OFFSET</name><operator>)</operator><operator>)</operator> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>uint32_t</name><modifier>*</modifier></type> <name>node_parent</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>node</name> <operator>+</operator> <name>PARENT_POINTER_OFFSET</name></expr>;</return> </block_content>}</block></function>

<function><type><name>uint32_t</name><modifier>*</modifier></type> <name>internal_node_num_keys</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>node</name> <operator>+</operator> <name>INTERNAL_NODE_NUM_KEYS_OFFSET</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32_t</name><modifier>*</modifier></type> <name>internal_node_right_child</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>node</name> <operator>+</operator> <name>INTERNAL_NODE_RIGHT_CHILD_OFFSET</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32_t</name><modifier>*</modifier></type> <name>internal_node_cell</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>cell_num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>node</name> <operator>+</operator> <name>INTERNAL_NODE_HEADER_SIZE</name> <operator>+</operator> <name>cell_num</name> <operator>*</operator> <name>INTERNAL_NODE_CELL_SIZE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32_t</name><modifier>*</modifier></type> <name>internal_node_child</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>child_num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_keys</name> <init>= <expr><operator>*</operator><call><name>internal_node_num_keys</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>child_num</name> <operator>&gt;</operator> <name>num_keys</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Tried to access child_num %d &gt; num_keys %d\n"</literal></expr></argument>, <argument><expr><name>child_num</name></expr></argument>, <argument><expr><name>num_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>child_num</name> <operator>==</operator> <name>num_keys</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>internal_node_right_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>internal_node_cell</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>child_num</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>uint32_t</name><modifier>*</modifier></type> <name>internal_node_key</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>key_num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><call><name>internal_node_cell</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>key_num</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>INTERNAL_NODE_CHILD_SIZE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32_t</name><modifier>*</modifier></type> <name>leaf_node_num_cells</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>node</name> <operator>+</operator> <name>LEAF_NODE_NUM_CELLS_OFFSET</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32_t</name><modifier>*</modifier></type> <name>leaf_node_next_leaf</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>node</name> <operator>+</operator> <name>LEAF_NODE_NEXT_LEAF_OFFSET</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>leaf_node_cell</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>cell_num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>node</name> <operator>+</operator> <name>LEAF_NODE_HEADER_SIZE</name> <operator>+</operator> <name>cell_num</name> <operator>*</operator> <name>LEAF_NODE_CELL_SIZE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32_t</name><modifier>*</modifier></type> <name>leaf_node_key</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>cell_num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>leaf_node_cell</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>cell_num</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>leaf_node_value</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>cell_num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>leaf_node_cell</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>cell_num</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>LEAF_NODE_KEY_SIZE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32_t</name></type> <name>get_node_max_key</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><call><name>get_node_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>NODE_INTERNAL</name></expr>:</case>
      <return>return <expr><operator>*</operator><call><name>internal_node_key</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>*</operator><call><name>internal_node_num_keys</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>NODE_LEAF</name></expr>:</case>
      <return>return <expr><operator>*</operator><call><name>leaf_node_key</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>*</operator><call><name>leaf_node_num_cells</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>print_constants</name><parameter_list>()</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ROW_SIZE: %d\n"</literal></expr></argument>, <argument><expr><name>ROW_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"COMMON_NODE_HEADER_SIZE: %d\n"</literal></expr></argument>, <argument><expr><name>COMMON_NODE_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"LEAF_NODE_HEADER_SIZE: %d\n"</literal></expr></argument>, <argument><expr><name>LEAF_NODE_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"LEAF_NODE_CELL_SIZE: %d\n"</literal></expr></argument>, <argument><expr><name>LEAF_NODE_CELL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"LEAF_NODE_SPACE_FOR_CELLS: %d\n"</literal></expr></argument>, <argument><expr><name>LEAF_NODE_SPACE_FOR_CELLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"LEAF_NODE_MAX_CELLS: %d\n"</literal></expr></argument>, <argument><expr><name>LEAF_NODE_MAX_CELLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>get_page</name><parameter_list>(<parameter><decl><type><name>Pager</name><modifier>*</modifier></type> <name>pager</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>page_num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>page_num</name> <operator>&gt;</operator> <name>TABLE_MAX_PAGES</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Tried to fetch page number out of bounds. %d &gt; %d\n"</literal></expr></argument>, <argument><expr><name>page_num</name></expr></argument>,
           <argument><expr><name>TABLE_MAX_PAGES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pager</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>page_num</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <comment type="line">// Cache miss. Allocate memory and load from file.</comment>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>page</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>PAGE_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_pages</name> <init>= <expr><name><name>pager</name><operator>-&gt;</operator><name>file_length</name></name> <operator>/</operator> <name>PAGE_SIZE</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// We might save a partial page at the end of the file</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pager</name><operator>-&gt;</operator><name>file_length</name></name> <operator>%</operator> <name>PAGE_SIZE</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>num_pages</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>page_num</name> <operator>&lt;=</operator> <name>num_pages</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name><name>pager</name><operator>-&gt;</operator><name>file_descriptor</name></name></expr></argument>, <argument><expr><name>page_num</name> <operator>*</operator> <name>PAGE_SIZE</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_read</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><name><name>pager</name><operator>-&gt;</operator><name>file_descriptor</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>bytes_read</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error reading file: %d\n"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pager</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>page_num</name></expr>]</index></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>page_num</name> <operator>&gt;=</operator> <name><name>pager</name><operator>-&gt;</operator><name>num_pages</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pager</name><operator>-&gt;</operator><name>num_pages</name></name> <operator>=</operator> <name>page_num</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name><name>pager</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>page_num</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>indent</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>print_tree</name><parameter_list>(<parameter><decl><type><name>Pager</name><modifier>*</modifier></type> <name>pager</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>page_num</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>indentation_level</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name>pager</name></expr></argument>, <argument><expr><name>page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_keys</name></decl>, <decl><type ref="prev"/><name>child</name></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><call><name>get_node_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><operator>(</operator><name>NODE_LEAF</name><operator>)</operator></expr>:</case>
      <expr_stmt><expr><name>num_keys</name> <operator>=</operator> <operator>*</operator><call><name>leaf_node_num_cells</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>indent</name><argument_list>(<argument><expr><name>indentation_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"- leaf (size %d)\n"</literal></expr></argument>, <argument><expr><name>num_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_keys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>indent</name><argument_list>(<argument><expr><name>indentation_level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"- %d\n"</literal></expr></argument>, <argument><expr><operator>*</operator><call><name>leaf_node_key</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    <case>case <expr><operator>(</operator><name>NODE_INTERNAL</name><operator>)</operator></expr>:</case>
      <expr_stmt><expr><name>num_keys</name> <operator>=</operator> <operator>*</operator><call><name>internal_node_num_keys</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>indent</name><argument_list>(<argument><expr><name>indentation_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"- internal (size %d)\n"</literal></expr></argument>, <argument><expr><name>num_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_keys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name>child</name> <operator>=</operator> <operator>*</operator><call><name>internal_node_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>print_tree</name><argument_list>(<argument><expr><name>pager</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>indentation_level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>indent</name><argument_list>(<argument><expr><name>indentation_level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"- key %d\n"</literal></expr></argument>, <argument><expr><operator>*</operator><call><name>internal_node_key</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><name>child</name> <operator>=</operator> <operator>*</operator><call><name>internal_node_right_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>print_tree</name><argument_list>(<argument><expr><name>pager</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>indentation_level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>serialize_row</name><parameter_list>(<parameter><decl><type><name>Row</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>destination</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destination</name> <operator>+</operator> <name>ID_OFFSET</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>source</name><operator>-&gt;</operator><name>id</name></name><operator>)</operator></expr></argument>, <argument><expr><name>ID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destination</name> <operator>+</operator> <name>USERNAME_OFFSET</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>source</name><operator>-&gt;</operator><name>username</name></name><operator>)</operator></expr></argument>, <argument><expr><name>USERNAME_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destination</name> <operator>+</operator> <name>EMAIL_OFFSET</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>source</name><operator>-&gt;</operator><name>email</name></name><operator>)</operator></expr></argument>, <argument><expr><name>EMAIL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>deserialize_row</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>Row</name><modifier>*</modifier></type> <name>destination</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>destination</name><operator>-&gt;</operator><name>id</name></name><operator>)</operator></expr></argument>, <argument><expr><name>source</name> <operator>+</operator> <name>ID_OFFSET</name></expr></argument>, <argument><expr><name>ID_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>destination</name><operator>-&gt;</operator><name>username</name></name><operator>)</operator></expr></argument>, <argument><expr><name>source</name> <operator>+</operator> <name>USERNAME_OFFSET</name></expr></argument>, <argument><expr><name>USERNAME_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>destination</name><operator>-&gt;</operator><name>email</name></name><operator>)</operator></expr></argument>, <argument><expr><name>source</name> <operator>+</operator> <name>EMAIL_OFFSET</name></expr></argument>, <argument><expr><name>EMAIL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>initialize_leaf_node</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>set_node_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NODE_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_node_root</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>leaf_node_num_cells</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>leaf_node_next_leaf</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="line">// 0 represents no sibling</comment>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>initialize_internal_node</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>set_node_type</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NODE_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_node_root</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>internal_node_num_keys</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Cursor</name><modifier>*</modifier></type> <name>leaf_node_find</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>page_num</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_cells</name> <init>= <expr><operator>*</operator><call><name>leaf_node_num_cells</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>Cursor</name><modifier>*</modifier></type> <name>cursor</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Cursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <name>table</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>page_num</name></name> <operator>=</operator> <name>page_num</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>end_of_table</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

  <comment type="line">// Binary search</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>min_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>one_past_max_index</name> <init>= <expr><name>num_cells</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>one_past_max_index</name> <operator>!=</operator> <name>min_index</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>min_index</name> <operator>+</operator> <name>one_past_max_index</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>key_at_index</name> <init>= <expr><operator>*</operator><call><name>leaf_node_key</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>key_at_index</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
      <return>return <expr><name>cursor</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>key</name> <operator>&lt;</operator> <name>key_at_index</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>one_past_max_index</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>min_index</name> <operator>=</operator> <name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name> <operator>=</operator> <name>min_index</name></expr>;</expr_stmt>
  <return>return <expr><name>cursor</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint32_t</name></type> <name>internal_node_find_child</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/*
  Return the index of the child which should contain
  the given key.
  */</comment>

  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_keys</name> <init>= <expr><operator>*</operator><call><name>internal_node_num_keys</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Binary search */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>min_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>max_index</name> <init>= <expr><name>num_keys</name></expr></init></decl>;</decl_stmt> <comment type="block">/* there is one more child than key */</comment>

  <while>while <condition>(<expr><name>min_index</name> <operator>!=</operator> <name>max_index</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>min_index</name> <operator>+</operator> <name>max_index</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>key_to_right</name> <init>= <expr><operator>*</operator><call><name>internal_node_key</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>key_to_right</name> <operator>&gt;=</operator> <name>key</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>max_index</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>min_index</name> <operator>=</operator> <name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <return>return <expr><name>min_index</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Cursor</name><modifier>*</modifier></type> <name>internal_node_find</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>page_num</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>uint32_t</name></type> <name>child_index</name> <init>= <expr><call><name>internal_node_find_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>child_num</name> <init>= <expr><operator>*</operator><call><name>internal_node_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>child_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>child</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>child_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>get_node_type</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>NODE_LEAF</name></expr>:</case>
      <return>return <expr><call><name>leaf_node_find</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>child_num</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>NODE_INTERNAL</name></expr>:</case>
      <return>return <expr><call><name>internal_node_find</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>child_num</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
Return the position of the given key.
If the key is not present, return the position
where it should be inserted
*/</comment>
<function><type><name>Cursor</name><modifier>*</modifier></type> <name>table_find</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>root_page_num</name> <init>= <expr><name><name>table</name><operator>-&gt;</operator><name>root_page_num</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>root_node</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>root_page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>get_node_type</name><argument_list>(<argument><expr><name>root_node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NODE_LEAF</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>leaf_node_find</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>root_page_num</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>internal_node_find</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>root_page_num</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Cursor</name><modifier>*</modifier></type> <name>table_start</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Cursor</name><modifier>*</modifier></type> <name>cursor</name> <init>= <expr><call><name>table_find</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>page_num</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_cells</name> <init>= <expr><operator>*</operator><call><name>leaf_node_num_cells</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>end_of_table</name></name> <operator>=</operator> <operator>(</operator><name>num_cells</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

  <return>return <expr><name>cursor</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>cursor_value</name><parameter_list>(<parameter><decl><type><name>Cursor</name><modifier>*</modifier></type> <name>cursor</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>page_num</name> <init>= <expr><name><name>cursor</name><operator>-&gt;</operator><name>page_num</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>page</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>leaf_node_value</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>cursor_advance</name><parameter_list>(<parameter><decl><type><name>Cursor</name><modifier>*</modifier></type> <name>cursor</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>page_num</name> <init>= <expr><name><name>cursor</name><operator>-&gt;</operator><name>page_num</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name> <operator>&gt;=</operator> <operator>(</operator><operator>*</operator><call><name>leaf_node_num_cells</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Advance to next leaf node */</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>next_page_num</name> <init>= <expr><operator>*</operator><call><name>leaf_node_next_leaf</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>next_page_num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <comment type="block">/* This was rightmost leaf */</comment>
      <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>end_of_table</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>page_num</name></name> <operator>=</operator> <name>next_page_num</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>Pager</name><modifier>*</modifier></type> <name>pager_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,
                <argument><expr><name>O_RDWR</name> <operator>|</operator>      <comment type="line">// Read/Write mode</comment>
                    <name>O_CREAT</name></expr></argument>,  <comment type="line">// Create file if it does not exist</comment>
                <argument><expr><name>S_IWUSR</name> <operator>|</operator>     <comment type="line">// User write permission</comment>
                    <name>S_IRUSR</name></expr></argument>   <comment type="line">// User read permission</comment>
                )</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Unable to open file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>off_t</name></type> <name>file_length</name> <init>= <expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>Pager</name><modifier>*</modifier></type> <name>pager</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Pager</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pager</name><operator>-&gt;</operator><name>file_descriptor</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pager</name><operator>-&gt;</operator><name>file_length</name></name> <operator>=</operator> <name>file_length</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pager</name><operator>-&gt;</operator><name>num_pages</name></name> <operator>=</operator> <operator>(</operator><name>file_length</name> <operator>/</operator> <name>PAGE_SIZE</name><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>file_length</name> <operator>%</operator> <name>PAGE_SIZE</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Db file is not a whole number of pages. Corrupt file.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TABLE_MAX_PAGES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>pager</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><name>pager</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Table</name><modifier>*</modifier></type> <name>db_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name><modifier>*</modifier></type> <name>pager</name> <init>= <expr><call><name>pager_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name> <operator>=</operator> <name>pager</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>root_page_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pager</name><operator>-&gt;</operator><name>num_pages</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="line">// New database file. Initialize page 0 as leaf node.</comment>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>root_node</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name>pager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>initialize_leaf_node</name><argument_list>(<argument><expr><name>root_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_node_root</name><argument_list>(<argument><expr><name>root_node</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>table</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>InputBuffer</name><modifier>*</modifier></type> <name>new_input_buffer</name><parameter_list>()</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>InputBuffer</name><modifier>*</modifier></type> <name>input_buffer</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>InputBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>input_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <return>return <expr><name>input_buffer</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>print_prompt</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"db &gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>read_input</name><parameter_list>(<parameter><decl><type><name>InputBuffer</name><modifier>*</modifier></type> <name>input_buffer</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_read</name> <init>=
      <expr><call><name>getline</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer_length</name></name><operator>)</operator></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>bytes_read</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error reading input\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// Ignore trailing newline</comment>
  <expr_stmt><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>input_length</name></name> <operator>=</operator> <name>bytes_read</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>bytes_read</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>close_input_buffer</name><parameter_list>(<parameter><decl><type><name>InputBuffer</name><modifier>*</modifier></type> <name>input_buffer</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>input_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>pager_flush</name><parameter_list>(<parameter><decl><type><name>Pager</name><modifier>*</modifier></type> <name>pager</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>page_num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pager</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>page_num</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Tried to flush null page\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>off_t</name></type> <name>offset</name> <init>= <expr><call><name>lseek</name><argument_list>(<argument><expr><name><name>pager</name><operator>-&gt;</operator><name>file_descriptor</name></name></expr></argument>, <argument><expr><name>page_num</name> <operator>*</operator> <name>PAGE_SIZE</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error seeking: %d\n"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_written</name> <init>=
      <expr><call><name>write</name><argument_list>(<argument><expr><name><name>pager</name><operator>-&gt;</operator><name>file_descriptor</name></name></expr></argument>, <argument><expr><name><name>pager</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>page_num</name></expr>]</index></name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>bytes_written</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error writing: %d\n"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>db_close</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Pager</name><modifier>*</modifier></type> <name>pager</name> <init>= <expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pager</name><operator>-&gt;</operator><name>num_pages</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pager</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pager_flush</name><argument_list>(<argument><expr><name>pager</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pager</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pager</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>close</name><argument_list>(<argument><expr><name><name>pager</name><operator>-&gt;</operator><name>file_descriptor</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error closing db file.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TABLE_MAX_PAGES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>page</name> <init>= <expr><name><name>pager</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>page</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pager</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>MetaCommandResult</name></type> <name>do_meta_command</name><parameter_list>(<parameter><decl><type><name>InputBuffer</name><modifier>*</modifier></type> <name>input_buffer</name></decl></parameter>, <parameter><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">".exit"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>close_input_buffer</name><argument_list>(<argument><expr><name>input_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>db_close</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">".btree"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Tree:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>print_tree</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>META_COMMAND_SUCCESS</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">".constants"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Constants:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>print_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>META_COMMAND_SUCCESS</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>META_COMMAND_UNRECOGNIZED_COMMAND</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>PrepareResult</name></type> <name>prepare_insert</name><parameter_list>(<parameter><decl><type><name>InputBuffer</name><modifier>*</modifier></type> <name>input_buffer</name></decl></parameter>, <parameter><decl><type><name>Statement</name><modifier>*</modifier></type> <name>statement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>statement</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>STATEMENT_INSERT</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>keyword</name> <init>= <expr><call><name>strtok</name><argument_list>(<argument><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>id_string</name> <init>= <expr><call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>username</name> <init>= <expr><call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>email</name> <init>= <expr><call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>id_string</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>username</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>email</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>PREPARE_SYNTAX_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>id_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>PREPARE_NEGATIVE_ID</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>COLUMN_USERNAME_SIZE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>PREPARE_STRING_TOO_LONG</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>email</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>COLUMN_EMAIL_SIZE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>PREPARE_STRING_TOO_LONG</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>statement</name><operator>-&gt;</operator><name>row_to_insert</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>statement</name><operator>-&gt;</operator><name>row_to_insert</name><operator>.</operator><name>username</name></name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>statement</name><operator>-&gt;</operator><name>row_to_insert</name><operator>.</operator><name>email</name></name></expr></argument>, <argument><expr><name>email</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PREPARE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PrepareResult</name></type> <name>prepare_statement</name><parameter_list>(<parameter><decl><type><name>InputBuffer</name><modifier>*</modifier></type> <name>input_buffer</name></decl></parameter>,
                                <parameter><decl><type><name>Statement</name><modifier>*</modifier></type> <name>statement</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"insert"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>prepare_insert</name><argument_list>(<argument><expr><name>input_buffer</name></expr></argument>, <argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"select"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>statement</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>STATEMENT_SELECT</name></expr>;</expr_stmt>
    <return>return <expr><name>PREPARE_SUCCESS</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>PREPARE_UNRECOGNIZED_STATEMENT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
Until we start recycling free pages, new pages will always
go onto the end of the database file
*/</comment>
<function><type><name>uint32_t</name></type> <name>get_unused_page_num</name><parameter_list>(<parameter><decl><type><name>Pager</name><modifier>*</modifier></type> <name>pager</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name><name>pager</name><operator>-&gt;</operator><name>num_pages</name></name></expr>;</return> </block_content>}</block></function>

<function><type><name>void</name></type> <name>create_new_root</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>right_child_page_num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/*
  Handle splitting the root.
  Old root copied to new page, becomes left child.
  Address of right child passed in.
  Re-initialize root page to contain the new root node.
  New root node points to two children.
  */</comment>

  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>root</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>root_page_num</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>right_child</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>right_child_page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>left_child_page_num</name> <init>= <expr><call><name>get_unused_page_num</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>left_child</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>left_child_page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Left child has data copied from old root */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>left_child</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_node_root</name><argument_list>(<argument><expr><name>left_child</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Root node is a new internal node with one key and two children */</comment>
  <expr_stmt><expr><call><name>initialize_internal_node</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_node_root</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>internal_node_num_keys</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>internal_node_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>left_child_page_num</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>left_child_max_key</name> <init>= <expr><call><name>get_node_max_key</name><argument_list>(<argument><expr><name>left_child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>internal_node_key</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>left_child_max_key</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>internal_node_right_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>right_child_page_num</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>node_parent</name><argument_list>(<argument><expr><name>left_child</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>root_page_num</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>node_parent</name><argument_list>(<argument><expr><name>right_child</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>root_page_num</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>internal_node_insert</name><parameter_list>(<parameter><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>parent_page_num</name></decl></parameter>,
                          <parameter><decl><type><name>uint32_t</name></type> <name>child_page_num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/*
  Add a new child/key pair to parent that corresponds to child
  */</comment>

  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>parent</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>parent_page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>child</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>child_page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>child_max_key</name> <init>= <expr><call><name>get_node_max_key</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>index</name> <init>= <expr><call><name>internal_node_find_child</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>child_max_key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>uint32_t</name></type> <name>original_num_keys</name> <init>= <expr><operator>*</operator><call><name>internal_node_num_keys</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>internal_node_num_keys</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>original_num_keys</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>original_num_keys</name> <operator>&gt;=</operator> <name>INTERNAL_NODE_MAX_CELLS</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Need to implement splitting internal node\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>uint32_t</name></type> <name>right_child_page_num</name> <init>= <expr><operator>*</operator><call><name>internal_node_right_child</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>right_child</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>right_child_page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>child_max_key</name> <operator>&gt;</operator> <call><name>get_node_max_key</name><argument_list>(<argument><expr><name>right_child</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Replace right child */</comment>
    <expr_stmt><expr><operator>*</operator><call><name>internal_node_child</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>original_num_keys</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>right_child_page_num</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><call><name>internal_node_key</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>original_num_keys</name></expr></argument>)</argument_list></call> <operator>=</operator>
        <call><name>get_node_max_key</name><argument_list>(<argument><expr><name>right_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><call><name>internal_node_right_child</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>child_page_num</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* Make room for the new cell */</comment>
    <for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><name>original_num_keys</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <name>index</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>destination</name> <init>= <expr><call><name>internal_node_cell</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>source</name> <init>= <expr><call><name>internal_node_cell</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>INTERNAL_NODE_CELL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><call><name>internal_node_child</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>child_page_num</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><call><name>internal_node_key</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>child_max_key</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>update_internal_node_key</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>old_key</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>new_key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>old_child_index</name> <init>= <expr><call><name>internal_node_find_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>old_key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>internal_node_key</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>old_child_index</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>new_key</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>leaf_node_split_and_insert</name><parameter_list>(<parameter><decl><type><name>Cursor</name><modifier>*</modifier></type> <name>cursor</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>Row</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/*
  Create a new node and move half the cells over.
  Insert the new value in one of the two nodes.
  Update parent or create a new parent.
  */</comment>

  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>old_node</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>page_num</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>old_max</name> <init>= <expr><call><name>get_node_max_key</name><argument_list>(<argument><expr><name>old_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>new_page_num</name> <init>= <expr><call><name>get_unused_page_num</name><argument_list>(<argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>new_node</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>new_page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>initialize_leaf_node</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>node_parent</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>*</operator><call><name>node_parent</name><argument_list>(<argument><expr><name>old_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>leaf_node_next_leaf</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>*</operator><call><name>leaf_node_next_leaf</name><argument_list>(<argument><expr><name>old_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><call><name>leaf_node_next_leaf</name><argument_list>(<argument><expr><name>old_node</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>new_page_num</name></expr>;</expr_stmt>

  <comment type="block">/*
  All existing keys plus new key should should be divided
  evenly between old (left) and new (right) nodes.
  Starting from the right, move each key to correct position.
  */</comment>
  <for>for <control>(<init><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><name>LEAF_NODE_MAX_CELLS</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>destination_node</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>LEAF_NODE_LEFT_SPLIT_COUNT</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>destination_node</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>destination_node</name> <operator>=</operator> <name>old_node</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>index_within_node</name> <init>= <expr><name>i</name> <operator>%</operator> <name>LEAF_NODE_LEFT_SPLIT_COUNT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>destination</name> <init>= <expr><call><name>leaf_node_cell</name><argument_list>(<argument><expr><name>destination_node</name></expr></argument>, <argument><expr><name>index_within_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>serialize_row</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
                    <argument><expr><call><name>leaf_node_value</name><argument_list>(<argument><expr><name>destination_node</name></expr></argument>, <argument><expr><name>index_within_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><call><name>leaf_node_key</name><argument_list>(<argument><expr><name>destination_node</name></expr></argument>, <argument><expr><name>index_within_node</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><call><name>leaf_node_cell</name><argument_list>(<argument><expr><name>old_node</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LEAF_NODE_CELL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><call><name>leaf_node_cell</name><argument_list>(<argument><expr><name>old_node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LEAF_NODE_CELL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Update cell count on both leaf nodes */</comment>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>leaf_node_num_cells</name><argument_list>(<argument><expr><name>old_node</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name>LEAF_NODE_LEFT_SPLIT_COUNT</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>leaf_node_num_cells</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name>LEAF_NODE_RIGHT_SPLIT_COUNT</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>is_node_root</name><argument_list>(<argument><expr><name>old_node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>create_new_root</name><argument_list>(<argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>new_page_num</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>parent_page_num</name> <init>= <expr><operator>*</operator><call><name>node_parent</name><argument_list>(<argument><expr><name>old_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>new_max</name> <init>= <expr><call><name>get_node_max_key</name><argument_list>(<argument><expr><name>old_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>parent</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name>parent_page_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>update_internal_node_key</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>old_max</name></expr></argument>, <argument><expr><name>new_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>internal_node_insert</name><argument_list>(<argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>parent_page_num</name></expr></argument>, <argument><expr><name>new_page_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>leaf_node_insert</name><parameter_list>(<parameter><decl><type><name>Cursor</name><modifier>*</modifier></type> <name>cursor</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>Row</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>page_num</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_cells</name> <init>= <expr><operator>*</operator><call><name>leaf_node_num_cells</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>num_cells</name> <operator>&gt;=</operator> <name>LEAF_NODE_MAX_CELLS</name></expr>)</condition> <block>{<block_content>
    <comment type="line">// Node full</comment>
    <expr_stmt><expr><call><name>leaf_node_split_and_insert</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name> <operator>&lt;</operator> <name>num_cells</name></expr>)</condition> <block>{<block_content>
    <comment type="line">// Make room for new cell</comment>
    <for>for <control>(<init><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><name>num_cells</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>leaf_node_cell</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>leaf_node_cell</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><name>LEAF_NODE_CELL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>leaf_node_num_cells</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>leaf_node_key</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>serialize_row</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>leaf_node_value</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ExecuteResult</name></type> <name>execute_insert</name><parameter_list>(<parameter><decl><type><name>Statement</name><modifier>*</modifier></type> <name>statement</name></decl></parameter>, <parameter><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Row</name><modifier>*</modifier></type> <name>row_to_insert</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>statement</name><operator>-&gt;</operator><name>row_to_insert</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>key_to_insert</name> <init>= <expr><name><name>row_to_insert</name><operator>-&gt;</operator><name>id</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Cursor</name><modifier>*</modifier></type> <name>cursor</name> <init>= <expr><call><name>table_find</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key_to_insert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><call><name>get_page</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>pager</name></name></expr></argument>, <argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>page_num</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>num_cells</name> <init>= <expr><operator>*</operator><call><name>leaf_node_num_cells</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name> <operator>&lt;</operator> <name>num_cells</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>key_at_index</name> <init>= <expr><operator>*</operator><call><name>leaf_node_key</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>cell_num</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>key_at_index</name> <operator>==</operator> <name>key_to_insert</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>EXECUTE_DUPLICATE_KEY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>leaf_node_insert</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name><name>row_to_insert</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>row_to_insert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>EXECUTE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExecuteResult</name></type> <name>execute_select</name><parameter_list>(<parameter><decl><type><name>Statement</name><modifier>*</modifier></type> <name>statement</name></decl></parameter>, <parameter><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Cursor</name><modifier>*</modifier></type> <name>cursor</name> <init>= <expr><call><name>table_start</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>Row</name></type> <name>row</name></decl>;</decl_stmt>
  <while>while <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cursor</name><operator>-&gt;</operator><name>end_of_table</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>deserialize_row</name><argument_list>(<argument><expr><call><name>cursor_value</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>print_row</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cursor_advance</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>EXECUTE_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExecuteResult</name></type> <name>execute_statement</name><parameter_list>(<parameter><decl><type><name>Statement</name><modifier>*</modifier></type> <name>statement</name></decl></parameter>, <parameter><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>statement</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><operator>(</operator><name>STATEMENT_INSERT</name><operator>)</operator></expr>:</case>
      <return>return <expr><call><name>execute_insert</name><argument_list>(<argument><expr><name>statement</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><operator>(</operator><name>STATEMENT_SELECT</name><operator>)</operator></expr>:</case>
      <return>return <expr><call><name>execute_select</name><argument_list>(<argument><expr><name>statement</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Must supply a database filename.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>filename</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name><modifier>*</modifier></type> <name>table</name> <init>= <expr><call><name>db_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>InputBuffer</name><modifier>*</modifier></type> <name>input_buffer</name> <init>= <expr><call><name>new_input_buffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>true</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>print_prompt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>read_input</name><argument_list>(<argument><expr><name>input_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
      <switch>switch <condition>(<expr><call><name>do_meta_command</name><argument_list>(<argument><expr><name>input_buffer</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <case>case <expr><operator>(</operator><name>META_COMMAND_SUCCESS</name><operator>)</operator></expr>:</case>
          <continue>continue;</continue>
        <case>case <expr><operator>(</operator><name>META_COMMAND_UNRECOGNIZED_COMMAND</name><operator>)</operator></expr>:</case>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Unrecognized command '%s'\n"</literal></expr></argument>, <argument><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
      </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>Statement</name></type> <name>statement</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><call><name>prepare_statement</name><argument_list>(<argument><expr><name>input_buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statement</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <case>case <expr><operator>(</operator><name>PREPARE_SUCCESS</name><operator>)</operator></expr>:</case>
        <break>break;</break>
      <case>case <expr><operator>(</operator><name>PREPARE_NEGATIVE_ID</name><operator>)</operator></expr>:</case>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ID must be positive.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      <case>case <expr><operator>(</operator><name>PREPARE_STRING_TOO_LONG</name><operator>)</operator></expr>:</case>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"String is too long.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      <case>case <expr><operator>(</operator><name>PREPARE_SYNTAX_ERROR</name><operator>)</operator></expr>:</case>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Syntax error. Could not parse statement.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      <case>case <expr><operator>(</operator><name>PREPARE_UNRECOGNIZED_STATEMENT</name><operator>)</operator></expr>:</case>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Unrecognized keyword at start of '%s'.\n"</literal></expr></argument>,
               <argument><expr><name><name>input_buffer</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
    </block_content>}</block></switch>

    <switch>switch <condition>(<expr><call><name>execute_statement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>statement</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <case>case <expr><operator>(</operator><name>EXECUTE_SUCCESS</name><operator>)</operator></expr>:</case>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Executed.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><operator>(</operator><name>EXECUTE_DUPLICATE_KEY</name><operator>)</operator></expr>:</case>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error: Duplicate key.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></while>
</block_content>}</block></function>
</unit>
