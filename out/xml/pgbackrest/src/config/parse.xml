<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/config/parse.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Command and Option Parse
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ini.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/macro.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/memContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/regExp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.intern.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/parse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Define global section name
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CFGDEF_SECTION_GLOBAL</name></cpp:macro>                                       <cpp:value>"global"</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
The maximum number of keys that an indexed option can have, e.g. pg256-path would be the maximum pg-path option
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CFG_OPTION_KEY_MAX</name></cpp:macro>                                          <cpp:value>256</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Section enum - defines which sections of the config an option can appear in
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>cfgSectionCommandLine</name></decl>,                                          <comment type="line">// Command-line only</comment>
    <decl><name>cfgSectionGlobal</name></decl>,                                               <comment type="line">// Command-line or in any config section</comment>
    <decl><name>cfgSectionStanza</name></decl>,                                               <comment type="line">// Command-line or in any config stanza section</comment>
}</block></enum></type> <name>ConfigSection</name>;</typedef>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Standard config file name and old default path and name
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGBACKREST_CONFIG_ORIG_PATH_FILE</name></cpp:macro>                            <cpp:value>"/etc/" PROJECT_CONFIG_FILE</cpp:value></cpp:define>
    <expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>PGBACKREST_CONFIG_ORIG_PATH_FILE_STR</name></expr></argument>,             <argument><expr><name>PGBACKREST_CONFIG_ORIG_PATH_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Prefix for environment variables
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGBACKREST_ENV</name></cpp:macro>                                              <cpp:value>"PGBACKREST_"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGBACKREST_ENV_SIZE</name></cpp:macro>                                         <cpp:value>(sizeof(PGBACKREST_ENV) - 1)</cpp:value></cpp:define>

<comment type="line">// In some environments this will not be externed</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>environ</name></decl>;</decl_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Define how a command is parsed
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>ParseRuleCommand</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>                                               <comment type="line">// Name</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>commandRoleValid</name><range>:<expr><name>CFG_COMMAND_ROLE_TOTAL</name></expr></range></decl>;</decl_stmt>           <comment type="line">// Valid for the command role?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>lockRequired</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                            <comment type="line">// Is an immediate lock required?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>lockRemoteRequired</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                      <comment type="line">// Is a lock required on the remote?</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>lockType</name><range>:<expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>                                        <comment type="line">// Lock type required</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>logFile</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                                 <comment type="line">// Will the command log to a file?</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>logLevelDefault</name><range>:<expr><literal type="number">4</literal></expr></range></decl>;</decl_stmt>                                 <comment type="line">// Default log level</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>parameterAllowed</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                        <comment type="line">// Command-line parameters are allowed</comment>
}</block></struct></type> <name>ParseRuleCommand</name>;</typedef>

<comment type="line">// Macros used to define parse rules in parse.auto.c.inc in a format that diffs well</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_COMMAND</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                                                    \
    <cpp:value>{__VA_ARGS__}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_COMMAND_NAME</name><parameter_list>(<parameter><type><name>nameParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                         \
    <cpp:value>.name = nameParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_COMMAND_ROLE_VALID_LIST</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                                    \
    <cpp:value>.commandRoleValid = 0 __VA_ARGS__</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_COMMAND_ROLE</name><parameter_list>(<parameter><type><name>commandRoleParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                  \
    <cpp:value>| (1 &lt;&lt; commandRoleParam)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_COMMAND_LOCK_REQUIRED</name><parameter_list>(<parameter><type><name>lockRequiredParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                        \
    <cpp:value>.lockRequired = lockRequiredParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_COMMAND_LOCK_REMOTE_REQUIRED</name><parameter_list>(<parameter><type><name>lockRemoteRequiredParam</name></type></parameter>)</parameter_list></cpp:macro>                                                           \
    <cpp:value>.lockRemoteRequired = lockRemoteRequiredParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_COMMAND_LOCK_TYPE</name><parameter_list>(<parameter><type><name>lockTypeParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                \
    <cpp:value>.lockType = lockTypeParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_COMMAND_LOG_FILE</name><parameter_list>(<parameter><type><name>logFileParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                  \
    <cpp:value>.logFile = logFileParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_COMMAND_LOG_LEVEL_DEFAULT</name><parameter_list>(<parameter><type><name>logLevelDefaultParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                 \
    <cpp:value>.logLevelDefault = logLevelDefaultParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_COMMAND_PARAMETER_ALLOWED</name><parameter_list>(<parameter><type><name>parameterAllowedParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                \
    <cpp:value>.parameterAllowed = parameterAllowedParam</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Define how an option group is parsed
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>ParseRuleOptionGroup</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>                                               <comment type="line">// All options in the group must be prefixed with this name</comment>
}</block></struct></type> <name>ParseRuleOptionGroup</name>;</typedef>

<comment type="line">// Macros used to define parse rules in parse.auto.c.inc in a format that diffs well</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_GROUP</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                                               \
    <cpp:value>{__VA_ARGS__}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_GROUP_NAME</name><parameter_list>(<parameter><type><name>nameParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                    \
    <cpp:value>.name = nameParam</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Define how an option is parsed and interacts with other options
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>ParseRuleOption</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>                                               <comment type="line">// Name</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>type</name><range>:<expr><literal type="number">4</literal></expr></range></decl>;</decl_stmt>                                            <comment type="line">// e.g. string, int, boolean</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>negate</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                                  <comment type="line">// Can the option be negated on the command line?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>reset</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                                   <comment type="line">// Can the option be reset on the command line?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>required</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                                <comment type="line">// Is the option required?</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>section</name><range>:<expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>                                         <comment type="line">// e.g. global, stanza, cmd-line</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>secure</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                                  <comment type="line">// Needs to be redacted in logs and cmd-line?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>multi</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                                   <comment type="line">// Can be specified multiple times?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>group</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                                   <comment type="line">// In a group?</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>groupId</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                         <comment type="line">// Id if in a group</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>deprecateMatch</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                          <comment type="line">// Does a deprecated name exactly match the option name?</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>packSize</name><range>:<expr><literal type="number">7</literal></expr></range></decl>;</decl_stmt>                                        <comment type="line">// Size of optional data in pack format</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>commandRoleValid</name><index>[<expr><name>CFG_COMMAND_ROLE_TOTAL</name></expr>]</index></name></decl>;</decl_stmt>              <comment type="line">// Valid for the command role?</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pack</name></decl>;</decl_stmt>                                      <comment type="line">// Optional data in pack format</comment>
}</block></struct></type> <name>ParseRuleOption</name>;</typedef>

<comment type="line">// Define additional types of data that can be associated with an option. Because these types are rare they are not given dedicated</comment>
<comment type="line">// fields and are instead packed and read at runtime. This may seem inefficient but they are only accessed a single time during</comment>
<comment type="line">// parse so space efficiency is more important than performance.</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>parseRuleOptionalTypeValid</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
    <decl><name>parseRuleOptionalTypeAllowRange</name></decl>,
    <decl><name>parseRuleOptionalTypeAllowList</name></decl>,
    <decl><name>parseRuleOptionalTypeDefault</name></decl>,
    <decl><name>parseRuleOptionalTypeRequired</name></decl>,
}</block></enum></type> <name>ParseRuleOptionalType</name>;</typedef>

<comment type="line">// Optional rule filter types</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>parseRuleFilterTypeCommand</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
}</block></enum></type> <name>ParseRuleFilterType</name>;</typedef>

<comment type="line">// Macros used to define parse rules in parse.auto.c.inc in a format that diffs well</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                                                     \
    <cpp:value>{__VA_ARGS__}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_NAME</name><parameter_list>(<parameter><type><name>nameParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                          \
    <cpp:value>.name = nameParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_TYPE</name><parameter_list>(<parameter><type><name>typeParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                          \
    <cpp:value>.type = typeParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_NEGATE</name><parameter_list>(<parameter><type><name>negateParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                      \
    <cpp:value>.negate = negateParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_RESET</name><parameter_list>(<parameter><type><name>resetParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                        \
    <cpp:value>.reset = resetParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_REQUIRED</name><parameter_list>(<parameter><type><name>requiredParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                  \
    <cpp:value>.required = requiredParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_SECTION</name><parameter_list>(<parameter><type><name>sectionParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                    \
    <cpp:value>.section = sectionParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_SECURE</name><parameter_list>(<parameter><type><name>secureParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                      \
    <cpp:value>.secure = secureParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_MULTI</name><parameter_list>(<parameter><type><name>typeMulti</name></type></parameter>)</parameter_list></cpp:macro>                                                                                         \
    <cpp:value>.multi = typeMulti</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_GROUP_MEMBER</name><parameter_list>(<parameter><type><name>groupParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                 \
    <cpp:value>.group = groupParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_GROUP_ID</name><parameter_list>(<parameter><type><name>groupIdParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                   \
    <cpp:value>.groupId = groupIdParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_DEPRECATE_MATCH</name><parameter_list>(<parameter><type><name>deprecateMatchParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                     \
    <cpp:value>.deprecateMatch = deprecateMatchParam</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_COMMAND_ROLE_MAIN_VALID_LIST</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                        \
    <cpp:value>.commandRoleValid[cfgCmdRoleMain] = 0 __VA_ARGS__</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_COMMAND_ROLE_ASYNC_VALID_LIST</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                       \
    <cpp:value>.commandRoleValid[cfgCmdRoleAsync] = 0 __VA_ARGS__</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_COMMAND_ROLE_LOCAL_VALID_LIST</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                       \
    <cpp:value>.commandRoleValid[cfgCmdRoleLocal] = 0 __VA_ARGS__</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_COMMAND_ROLE_REMOTE_VALID_LIST</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                      \
    <cpp:value>.commandRoleValid[cfgCmdRoleRemote] = 0 __VA_ARGS__</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTION_COMMAND</name><parameter_list>(<parameter><type><name>commandParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                    \
    <cpp:value>| (1 &lt;&lt; commandParam)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_STRPUB</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>                                    <cpp:value>{.buffer = (char *)value, .size = sizeof(value) - 1}</cpp:value></cpp:define>

<comment type="line">// Macros used to define optional parse rules in pack format</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_VARINT_01</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>                                                                                                \
    <cpp:value>value</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_VARINT_02</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>                                                                                                \
    <cpp:value>0x80 | (value &amp; 0x7f), (value &gt;&gt; 7) &amp; 0x7f</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_BOOL_TRUE</name></cpp:macro>                                        <cpp:value>0x28</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_BOOL_FALSE</name></cpp:macro>                                       <cpp:value>0x20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_U32_1</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>                                     <cpp:value>0x88, PARSE_RULE_VARINT_01(value)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_U32_2</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>                                     <cpp:value>0x88, PARSE_RULE_VARINT_02(value)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_PACK</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                        <cpp:value>__VA_ARGS__ 0x00</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_PACK_SIZE</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                                                  \
    <cpp:value>0xf0, 0x02, sizeof((const unsigned char []){PARSE_RULE_PACK(__VA_ARGS__)}),                                                    \
    PARSE_RULE_PACK(__VA_ARGS__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_VAL_BOOL_TRUE</name></cpp:macro>                                    <cpp:value>PARSE_RULE_BOOL_TRUE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_VAL_BOOL_FALSE</name></cpp:macro>                                   <cpp:value>PARSE_RULE_BOOL_FALSE</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTIONAL</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                                                   \
    <cpp:value>.packSize = sizeof((const unsigned char []){PARSE_RULE_PACK(__VA_ARGS__)}),                                                    \
    .pack = (const unsigned char []){PARSE_RULE_PACK(__VA_ARGS__)}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTIONAL_GROUP</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                              <cpp:value>PARSE_RULE_PACK_SIZE(__VA_ARGS__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_FILTER_CMD</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                                                 \
    <cpp:value>PARSE_RULE_PACK_SIZE(PARSE_RULE_U32_1(parseRuleFilterTypeCommand), __VA_ARGS__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTIONAL_DEPEND</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                                            \
    <cpp:value>PARSE_RULE_U32_1(parseRuleOptionalTypeValid), PARSE_RULE_PACK_SIZE(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTIONAL_DEPEND_DEFAULT</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>                   <cpp:value>value</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTIONAL_ALLOW_LIST</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                                        \
    <cpp:value>PARSE_RULE_U32_1(parseRuleOptionalTypeAllowList), PARSE_RULE_PACK_SIZE(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTIONAL_ALLOW_RANGE</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                                       \
    <cpp:value>PARSE_RULE_U32_1(parseRuleOptionalTypeAllowRange), PARSE_RULE_PACK_SIZE(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTIONAL_DEFAULT</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                                           \
    <cpp:value>PARSE_RULE_U32_1(parseRuleOptionalTypeDefault), PARSE_RULE_PACK_SIZE(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTIONAL_REQUIRED</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                                                                                          \
    <cpp:value>PARSE_RULE_U32_1(parseRuleOptionalTypeRequired), PARSE_RULE_PACK_SIZE(__VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_RULE_OPTIONAL_NOT_REQUIRED</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>                       <cpp:value>PARSE_RULE_OPTIONAL_REQUIRED(__VA_ARGS__)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Define option deprecations
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>ParseRuleOptionDeprecate</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>                                               <comment type="line">// Deprecated name</comment>
    <decl_stmt><decl><type><name>ConfigOption</name></type> <name>id</name></decl>;</decl_stmt>                                                <comment type="line">// Option Id</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>indexed</name></decl>;</decl_stmt>                                                   <comment type="line">// Can the deprecation be indexed?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>unindexed</name></decl>;</decl_stmt>                                                 <comment type="line">// Can the deprecation be unindexed?</comment>
}</block></struct></type> <name>ParseRuleOptionDeprecate</name>;</typedef>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Include automatically generated parse data
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/parse.auto.c.inc"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Struct to hold options parsed from the command line
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>ParseOptionValue</name>
<block>{
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                                   <comment type="line">// Was the option found?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>negate</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                                  <comment type="line">// Was the option negated on the command line?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>reset</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                                   <comment type="line">// Was the option reset on the command line?</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>source</name><range>:<expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>                                          <comment type="line">// Where was the option found?</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>valueList</name></decl>;</decl_stmt>                                          <comment type="line">// List of values found</comment>
}</block></struct></type> <name>ParseOptionValue</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ParseOption</name>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>indexListTotal</name></decl>;</decl_stmt>                                    <comment type="line">// Total options in indexed list</comment>
    <decl_stmt><decl><type><name>ParseOptionValue</name> <modifier>*</modifier></type><name>indexList</name></decl>;</decl_stmt>                                    <comment type="line">// List of indexed option values</comment>
}</block></struct></type> <name>ParseOption</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_PARSE_OPTION_FORMAT</name><parameter_list>(<parameter><type><name>value</name></type></parameter>, <parameter><type><name>buffer</name></type></parameter>, <parameter><type><name>bufferSize</name></type></parameter>)</parameter_list></cpp:macro>                                                                \
    <cpp:value>typeToLog("ParseOption", buffer, bufferSize)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the indexed value, creating the array to contain it if needed
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>ParseOptionValue</name> <modifier>*</modifier></type>
<name>parseOptionIdxValue</name><parameter_list>(<parameter><decl><type><name>ParseOption</name> <modifier>*</modifier></type><name>optionList</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>optionId</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>optionKeyIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>PARSE_OPTION</name></expr></argument>, <argument><expr><name>optionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="line">// Structure containing all options being parsed</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                        <comment type="line">// Unique ID which also identifies the option in the parse list</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// Zero-based key index (e.g. pg3-path =&gt; 2), 0 for non-indexed</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If the requested index is beyond what has already been allocated</comment>
    <if_stmt><if>if <condition>(<expr><name>optionKeyIdx</name> <operator>&gt;=</operator> <name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexListTotal</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// If the option is in a group</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>group</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>optionOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="line">// Allocate enough memory to include the requested indexed or a fixed amount to avoid too many allocations</comment>
            <if_stmt><if>if <condition>(<expr><name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexListTotal</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexListTotal</name> <operator>=</operator>
                    <ternary><condition><expr><name>optionKeyIdx</name> <operator>&gt;=</operator> <operator>(</operator><name>LIST_INITIAL_SIZE</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><name>optionKeyIdx</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name>LIST_INITIAL_SIZE</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexList</name> <operator>=</operator> <call><name>memNew</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParseOptionValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexListTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Allocate more memory when needed. This could be more efficient but the limited number of indexes currently allowed</comment>
            <comment type="line">// makes it difficult to get coverage on a better implementation.</comment>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>optionOffset</name> <operator>=</operator> <name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexListTotal</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexListTotal</name> <operator>=</operator> <name>optionKeyIdx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexList</name> <operator>=</operator> <call><name>memResize</name><argument_list>(
                    <argument><expr><name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexList</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParseOptionValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexListTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="line">// Initialize the newly allocated memory</comment>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optKeyIdx</name> <init>= <expr><name>optionOffset</name></expr></init></decl>;</init> <condition><expr><name>optKeyIdx</name> <operator>&lt;</operator> <name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexListTotal</name></expr>;</condition> <incr><expr><name>optKeyIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><name>optKeyIdx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ParseOptionValue</name><operator>)</operator><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></if>
        <comment type="line">// Else the option is not in a group so there can only be one value</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexList</name> <operator>=</operator> <call><name>memNew</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParseOptionValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexListTotal</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ParseOptionValue</name><operator>)</operator><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Return the indexed value</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_TYPE_P</name><argument_list>(<argument><expr><name>ParseOptionValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>optionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><name>optionKeyIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get command id by name
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>ConfigCommand</name></type>
<name>cfgParseCommandId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>commandName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name>commandName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>commandName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ConfigCommand</name></type> <name>commandId</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>commandId</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>commandId</name> <operator>&lt;</operator> <name>CFG_COMMAND_TOTAL</name></expr>;</condition> <incr><expr><name>commandId</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>commandName</name></expr></argument>, <argument><expr><name><name>parseRuleCommand</name><index>[<expr><name>commandId</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>commandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>cfgParseCommandName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ConfigCommand</name></type> <name>commandId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>commandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>commandId</name> <operator>&lt;</operator> <name>cfgCmdNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name><name>parseRuleCommand</name><index>[<expr><name>commandId</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Convert command role from String to enum and vice versa
***********************************************************************************************************************************/</comment>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>CONFIG_COMMAND_ROLE_ASYNC_STR</name></expr></argument>,                        <argument><expr><name>CONFIG_COMMAND_ROLE_ASYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>CONFIG_COMMAND_ROLE_LOCAL_STR</name></expr></argument>,                        <argument><expr><name>CONFIG_COMMAND_ROLE_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>CONFIG_COMMAND_ROLE_REMOTE_STR</name></expr></argument>,                       <argument><expr><name>CONFIG_COMMAND_ROLE_REMOTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>ConfigCommandRole</name></type>
<name>cfgParseCommandRoleEnum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>commandRole</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>commandRole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>commandRole</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>cfgCmdRoleMain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>commandRole</name></expr></argument>, <argument><expr><name>CONFIG_COMMAND_ROLE_ASYNC_STR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>cfgCmdRoleAsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>commandRole</name></expr></argument>, <argument><expr><name>CONFIG_COMMAND_ROLE_LOCAL_STR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>cfgCmdRoleLocal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>commandRole</name></expr></argument>, <argument><expr><name>CONFIG_COMMAND_ROLE_REMOTE_STR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>cfgCmdRoleRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>CommandInvalidError</name></expr></argument>, <argument><expr><literal type="string">"invalid command role '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>commandRole</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type>
<name>cfgParseCommandRoleStr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ConfigCommandRole</name></type> <name>commandRole</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>commandRole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>commandRole</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>cfgCmdRoleMain</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>cfgCmdRoleAsync</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>CONFIG_COMMAND_ROLE_ASYNC_STR</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>cfgCmdRoleLocal</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>CONFIG_COMMAND_ROLE_LOCAL_STR</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>cfgCmdRoleRemote</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>CONFIG_COMMAND_ROLE_REMOTE_STR</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>cfgParseCommandRoleName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ConfigCommand</name></type> <name>commandId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ConfigCommandRole</name></type> <name>commandRoleId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>commandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>commandRoleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>strCatZ</name><argument_list>(<argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>cfgParseCommandName</name><argument_list>(<argument><expr><name>commandId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>commandRoleId</name> <operator>!=</operator> <name>cfgCmdRoleMain</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">":%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgParseCommandRoleStr</name><argument_list>(<argument><expr><name>commandRoleId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Find an option by name in the option list
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_PREFIX_NEGATE</name></cpp:macro>                                        <cpp:value>"no-"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_PREFIX_RESET</name></cpp:macro>                                         <cpp:value>"reset-"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_NAME_SIZE_MAX</name></cpp:macro>                                        <cpp:value>64</cpp:value></cpp:define>

<function><type><name>CfgParseOptionResult</name></type>
<name>cfgParseOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optionCandidate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CfgParseOptionParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>prefixMatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>ignoreMissingIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionCandidate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>CfgParseOptionResult</name></type> <name>result</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <comment type="line">// Copy the option to a buffer so it can be efficiently manipulated</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>optionName</name><index>[<expr><name>OPTION_NAME_SIZE_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>optionNameSize</name> <init>= <expr><call><name>strSize</name><argument_list>(<argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>optionNameSize</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>optionName</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
            <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' exceeds maximum size of "</literal> <call><name>STRINGIFY</name><argument_list>(<argument><expr><name>OPTION_NAME_SIZE_MAX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>optionName</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>optionName</name><index>[<expr><name>OPTION_NAME_SIZE_MAX</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <comment type="line">// If this looks like negate</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>, <argument><expr><name>OPTION_PREFIX_NEGATE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OPTION_PREFIX_NEGATE</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>negate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="line">// Strip the negate prefix</comment>
        <expr_stmt><expr><name>optionNameSize</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OPTION_PREFIX_NEGATE</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>, <argument><expr><name>optionName</name> <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>OPTION_PREFIX_NEGATE</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>optionNameSize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else if looks like reset</comment>
    <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>, <argument><expr><name>OPTION_PREFIX_RESET</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OPTION_PREFIX_RESET</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>reset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="line">// Strip the reset prefix</comment>
        <expr_stmt><expr><name>optionNameSize</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OPTION_PREFIX_RESET</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>, <argument><expr><name>optionName</name> <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>OPTION_PREFIX_RESET</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>optionNameSize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Indexed options must have at least one dash</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dashPtr</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>indexed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>dashPtr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>dashPtr</name> <operator>==</operator> <name>optionName</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' cannot begin with a dash"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Check if the first dash is preceeded by a numeric key and keep a tally of the key</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>numberPtr</name> <init>= <expr><name>dashPtr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>multiplier</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>numberPtr</name> <operator>&gt;</operator> <name>optionName</name> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>numberPtr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>numberPtr</name><operator>--</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>keyIdx</name></name> <operator>+=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><operator>*</operator><name>numberPtr</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>*</operator> <name>multiplier</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>multiplier</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name>numberPtr</name> <operator>==</operator> <name>optionName</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' cannot begin with a number"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// If there was a number then the option is indexed</comment>
        <if_stmt><if>if <condition>(<expr><name>numberPtr</name> <operator>!=</operator> <name>dashPtr</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>indexed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="line">// Strip the key to get the base option name</comment>
            <expr_stmt><expr><name>optionNameSize</name> <operator>-=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>dashPtr</name> <operator>-</operator> <name>numberPtr</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>numberPtr</name></expr></argument>, <argument><expr><name>dashPtr</name></expr></argument>, <argument><expr><name>optionNameSize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Check that the index does not exceed the maximum</comment>
            <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>keyIdx</name></name> <operator>&gt;</operator> <name>CFG_OPTION_KEY_MAX</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' key exceeds maximum of "</literal> <call><name>STRINGIFY</name><argument_list>(<argument><expr><name>CFG_OPTION_KEY_MAX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Subtract one to represent a key index</comment>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>keyIdx</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Search for an exact match. A copy of the option name must be made because bsearch() requires a reference.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optionNamePtr</name> <init>= <expr><name>optionName</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>ParseRuleOption</name> <modifier>*</modifier></type><name>optionFound</name> <init>= <expr><call><name>bsearch</name><argument_list>(
        <argument><expr><operator>&amp;</operator><name>optionNamePtr</name></expr></argument>, <argument><expr><name>parseRuleOption</name></expr></argument>, <argument><expr><name>CFG_OPTION_TOTAL</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParseRuleOption</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>lstComparatorZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the option was not found</comment>
    <if_stmt><if>if <condition>(<expr><name>optionFound</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Search for a single partial match (if requested)</comment>
        <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>prefixMatch</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>findPartialIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>findPartialTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>findIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>findIdx</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr>;</condition> <incr><expr><name>findIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>parseRuleOption</name><index>[<expr><name>findIdx</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>optionName</name></expr></argument>, <argument><expr><name>optionNameSize</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>findPartialIdx</name> <operator>=</operator> <name>findIdx</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>findPartialTotal</name><operator>++</operator></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>findPartialTotal</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="line">// If a single partial match was found</comment>
            <if_stmt><if>if <condition>(<expr><name>findPartialTotal</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>optionFound</name> <operator>=</operator> <operator>&amp;</operator><name><name>parseRuleOption</name><index>[<expr><name>findPartialIdx</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If the option was not found search deprecations</comment>
        <if_stmt><if>if <condition>(<expr><name>optionFound</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Search deprecations for an exact match</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ParseRuleOptionDeprecate</name> <modifier>*</modifier></type><name>deprecate</name> <init>= <expr><call><name>bsearch</name><argument_list>(
                <argument><expr><operator>&amp;</operator><name>optionNamePtr</name></expr></argument>, <argument><expr><name>parseRuleOptionDeprecate</name></expr></argument>, <argument><expr><name>CFG_OPTION_DEPRECATE_TOTAL</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParseRuleOptionDeprecate</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                <argument><expr><name>lstComparatorZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If the option was not found then search deprecations for a single partial match (if requested)</comment>
            <if_stmt><if>if <condition>(<expr><name>deprecate</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>param</name><operator>.</operator><name>prefixMatch</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>findPartialIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>findPartialTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>deprecateIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>deprecateIdx</name> <operator>&lt;</operator> <name>CFG_OPTION_DEPRECATE_TOTAL</name></expr>;</condition> <incr><expr><name>deprecateIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>parseRuleOptionDeprecate</name><index>[<expr><name>deprecateIdx</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>optionName</name></expr></argument>, <argument><expr><name>optionNameSize</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>findPartialIdx</name> <operator>=</operator> <name>deprecateIdx</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>findPartialTotal</name><operator>++</operator></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name>findPartialTotal</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                            <break>break;</break></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="line">// If a single partial match was found</comment>
                <if_stmt><if>if <condition>(<expr><name>findPartialTotal</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>deprecate</name> <operator>=</operator> <operator>&amp;</operator><name><name>parseRuleOptionDeprecate</name><index>[<expr><name>findPartialIdx</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Deprecation was found</comment>
            <if_stmt><if>if <condition>(<expr><name>deprecate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Error if the option is indexed but the deprecation is not</comment>
                <if_stmt><if>if <condition>(<expr><name>indexed</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>deprecate</name><operator>-&gt;</operator><name>indexed</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"deprecated option '%s' cannot have an index"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Error if the option is unindexed but the deprecation is not</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>indexed</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>deprecate</name><operator>-&gt;</operator><name>unindexed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>param</name><operator>.</operator><name>ignoreMissingIndex</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>dashPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>groupName</name> <init>= <expr><name><name>parseRuleOptionGroup</name><index>[<expr><name><name>parseRuleOption</name><index>[<expr><name><name>deprecate</name><operator>-&gt;</operator><name>id</name></name></expr>]</index></name><operator>.</operator><name>groupId</name></expr>]</index></name><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                        <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"deprecated option '%s' requires an index\n"</literal>
                        <literal type="string">"HINT: add the required index, e.g. %.*s1%s.\n"</literal>
                        <literal type="string">"HINT: consider using the non-deprecated name, e.g. %s1%s."</literal></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>dashPtr</name> <operator>-</operator> <name>optionName</name><operator>)</operator></expr></argument>, <argument><expr><name>optionName</name></expr></argument>, <argument><expr><name>dashPtr</name></expr></argument>, <argument><expr><name>groupName</name></expr></argument>,
                        <argument><expr><name><name>parseRuleOption</name><index>[<expr><name><name>deprecate</name><operator>-&gt;</operator><name>id</name></name></expr>]</index></name><operator>.</operator><name>name</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>groupName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>deprecated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>optionFound</name> <operator>=</operator> <operator>&amp;</operator><name><name>parseRuleOption</name><index>[<expr><name><name>deprecate</name><operator>-&gt;</operator><name>id</name></name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Option was found</comment>
    <if_stmt><if>if <condition>(<expr><name>optionFound</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>found</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>id</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>optionFound</name> <operator>-</operator> <name>parseRuleOption</name><operator>)</operator></expr>;</expr_stmt>

        <comment type="line">// Error if negate is not allowed</comment>
        <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>negate</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>optionFound</name><operator>-&gt;</operator><name>negate</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' cannot be negated"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Error if reset is not allowed</comment>
        <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>reset</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>optionFound</name><operator>-&gt;</operator><name>reset</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' cannot be reset"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// It is possible for an unindexed deprecation to match an indexed option name (without the index) exactly. For example, the</comment>
        <comment type="line">// deprecated repo-path option now maps to repo-path index 0, which will yield an exact match. In this case we still need to</comment>
        <comment type="line">// mark the option as deprecated.</comment>
        <if_stmt><if>if <condition>(<expr><name>indexed</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name><name>optionFound</name><operator>-&gt;</operator><name>deprecateMatch</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>deprecated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// If not deprecated make sure indexing matches. Deprecation indexing has already been checked because the rules are per</comment>
        <comment type="line">// deprecation.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>.</operator><name>deprecated</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Error if the option is indexed but should not be</comment>
            <if_stmt><if>if <condition>(<expr><name>indexed</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>optionFound</name><operator>-&gt;</operator><name>group</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' cannot have an index"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Error if the option is unindexed but an index is required</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>indexed</name> <operator>&amp;&amp;</operator> <name><name>optionFound</name><operator>-&gt;</operator><name>group</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>param</name><operator>.</operator><name>ignoreMissingIndex</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>groupName</name> <init>= <expr><name><name>parseRuleOptionGroup</name><index>[<expr><name><name>optionFound</name><operator>-&gt;</operator><name>groupId</name></name></expr>]</index></name><operator>.</operator><name>name</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>OptionInvalidError</name></expr></argument>,
                    <argument><expr><literal type="string">"option '%s' requires an index\n"</literal>
                    <literal type="string">"HINT: add the required index, e.g. %s1%s."</literal></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionCandidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>groupName</name></expr></argument>, <argument><expr><name><name>optionFound</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>groupName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_TYPE</name><argument_list>(<argument><expr><name>CfgParseOptionResult</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <macro><name>FUNCTION_TEST_RETURN_TYPE</name><argument_list>(<argument>CfgParseOptionResult</argument>, <argument>(CfgParseOptionResult){<literal type="number">0</literal>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>ConfigOptionDataType</name></type>
<name>cfgParseOptionDataType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ConfigOption</name></type> <name>optionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionId</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>cfgOptTypeBoolean</name></expr>:</case>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>cfgOptDataTypeBoolean</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <case>case <expr><name>cfgOptTypeHash</name></expr>:</case>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>cfgOptDataTypeHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <case>case <expr><name>cfgOptTypeInteger</name></expr>:</case>
        <case>case <expr><name>cfgOptTypeSize</name></expr>:</case>
        <case>case <expr><name>cfgOptTypeTime</name></expr>:</case>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>cfgOptDataTypeInteger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <case>case <expr><name>cfgOptTypeList</name></expr>:</case>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>cfgOptDataTypeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <case>case <expr><name>cfgOptTypeStringId</name></expr>:</case>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>cfgOptDataTypeStringId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>cfgOptTypePath</name> <operator>||</operator> <name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>cfgOptTypeString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>cfgOptDataTypeString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Find an optional rule
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>CfgParseOptionalRuleState</name>
<block>{
    <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier></type><name>pack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>typeNext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>done</name></decl>;</decl_stmt>

    <comment type="line">// Valid</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>valid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>validSize</name></decl>;</decl_stmt>

    <comment type="line">// Allow range</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>allowRangeMin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>allowRangeMax</name></decl>;</decl_stmt>

    <comment type="line">// Allow list</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>allowList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>allowListSize</name></decl>;</decl_stmt>

    <comment type="line">// Default</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>defaultRaw</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ConfigOptionValueType</name></type> <name>defaultValue</name></decl>;</decl_stmt>

    <comment type="line">// Required</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>required</name></decl>;</decl_stmt>
}</block></struct></type> <name>CfgParseOptionalRuleState</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cfgParseOptionalRule</name><parameter_list>(
    <parameter><decl><type><name>CfgParseOptionalRuleState</name> <modifier>*</modifier></type><name>optionalRules</name></decl></parameter>, <parameter><decl><type><name>ParseRuleOptionalType</name></type> <name>optionalRuleType</name></decl></parameter>, <parameter><decl><type><name>ConfigCommand</name></type> <name>commandId</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>ConfigOption</name></type> <name>optionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>optionalRules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>optionalRuleType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>commandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionalRuleType</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>commandId</name> <operator>&lt;</operator> <name>CFG_COMMAND_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionId</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Check for optional rules</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>optionalRules</name><operator>-&gt;</operator><name>done</name></name> <operator>&amp;&amp;</operator> <name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>pack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Initialize optional rules</comment>
        <if_stmt><if>if <condition>(<expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>groupList</name> <init>= <expr><call><name>pckReadNewC</name><argument_list>(<argument><expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>pack</name></expr></argument>, <argument><expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>packSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// Seach for a matching group</comment>
                <do>do
                <block>{<block_content>
                    <comment type="line">// Get the group pack</comment>
                    <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier></type><name>group</name> <init>= <expr><call><name>pckReadPackReadConstP</name><argument_list>(<argument><expr><name>groupList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Process filters if any</comment>
                    <expr_stmt><expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>pckReadType</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pckTypePack</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Check for filter match</comment>
                        <decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>filter</name> <init>= <expr><call><name>pckReadPackReadConstP</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>ParseRuleFilterType</name></type> <name>filterType</name> <init>= <expr><operator>(</operator><name>ParseRuleFilterType</name><operator>)</operator><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <switch>switch <condition>(<expr><name>filterType</name></expr>)</condition>
                        <block>{<block_content>
                            <default>default:</default>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>filterType</name> <operator>==</operator> <name>parseRuleFilterTypeCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <while>while <condition>(<expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ConfigCommand</name><operator>)</operator><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>commandId</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                        <break>break;</break>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></while>

                                <break>break;</break>
                            </block_content>}</block>
                        </block_content>}</block></switch>

                        <comment type="line">// Filter did not match</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>group</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// If the group matched</comment>
                    <if_stmt><if>if <condition>(<expr><name>group</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Get first optional rule type. This is needed since pckReadNext() has already been called and it cannot</comment>
                        <comment type="line">// be called again until data is read.</comment>
                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>typeNext</name></name> <operator>=</operator> <call><name>pckReadU32P</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>typeNext</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Move group to prior context and stop searching</comment>
                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name> <operator>=</operator> <call><name>pckReadMove</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
                while <condition>(<expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name>groupList</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If no group matched then done</comment>
            <if_stmt><if>if <condition>(<expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Search for the specified optional rule</comment>
        <do>do
        <block>{<block_content>
            <comment type="line">// Read the next optional rule type if it has not already been read</comment>
            <if_stmt><if>if <condition>(<expr><name><name>optionalRules</name><operator>-&gt;</operator><name>typeNext</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If there are no more rules then done</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pckReadNext</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>typeNext</name></name> <operator>=</operator> <call><name>pckReadU32P</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>typeNext</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// If this is the requested optional rule</comment>
            <if_stmt><if>if <condition>(<expr><name><name>optionalRules</name><operator>-&gt;</operator><name>typeNext</name></name> <operator>==</operator> <name>optionalRuleType</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Optional rule was found</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <comment type="line">// Process optional rule</comment>
                <switch>switch <condition>(<expr><name>optionalRuleType</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>parseRuleOptionalTypeValid</name></expr>:</case>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <call><name>pckReadBufPtr</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>validSize</name></name> <operator>=</operator> <call><name>pckReadSize</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>pckReadConsume</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block>

                    <case>case <expr><name>parseRuleOptionalTypeAllowList</name></expr>:</case>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>allowList</name></name> <operator>=</operator> <call><name>pckReadBufPtr</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>allowListSize</name></name> <operator>=</operator> <call><name>pckReadSize</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>pckReadConsume</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block>

                    <case>case <expr><name>parseRuleOptionalTypeAllowRange</name></expr>:</case>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ruleData</name> <init>= <expr><call><name>pckReadPackReadConstP</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>allowRangeMin</name></name> <operator>=</operator> <name><name>parseRuleValueInt</name><index>[<expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>ruleData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>allowRangeMax</name></name> <operator>=</operator> <name><name>parseRuleValueInt</name><index>[<expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>ruleData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>

                        <break>break;</break>
                    </block_content>}</block>

                    <case>case <expr><name>parseRuleOptionalTypeDefault</name></expr>:</case>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ruleData</name> <init>= <expr><call><name>pckReadPackReadConstP</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name>ruleData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <switch>switch <condition>(<expr><call><name>pckReadType</name><argument_list>(<argument><expr><name>ruleData</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <case>case <expr><name>pckTypeBool</name></expr>:</case>
                                <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>defaultValue</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <call><name>pckReadBoolP</name><argument_list>(<argument><expr><name>ruleData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>defaultRaw</name></name> <operator>=</operator> <ternary><condition><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>defaultValue</name><operator>.</operator><name>boolean</name></name></expr> ?</condition><then> <expr><name>Y_STR</name></expr> </then><else>: <expr><name>N_STR</name></expr></else></ternary></expr>;</expr_stmt>
                                <break>break;</break>

                            <default>default:</default>
                            <block>{<block_content>
                                <switch>switch <condition>(<expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition>
                                <block>{<block_content>
                                    <case>case <expr><name>cfgOptTypeInteger</name></expr>:</case>
                                    <case>case <expr><name>cfgOptTypeTime</name></expr>:</case>
                                    <case>case <expr><name>cfgOptTypeSize</name></expr>:</case>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>defaultValue</name><operator>.</operator><name>integer</name></name> <operator>=</operator> <name><name>parseRuleValueInt</name><index>[<expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>ruleData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>defaultRaw</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>String</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>parseRuleValueStr</name><index>[<expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>ruleData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>

                                        <break>break;</break>
                                    </block_content>}</block>

                                    <case>case <expr><name>cfgOptTypePath</name></expr>:</case>
                                    <case>case <expr><name>cfgOptTypeString</name></expr>:</case>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>defaultRaw</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>String</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>parseRuleValueStr</name><index>[<expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>ruleData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>defaultValue</name><operator>.</operator><name>string</name></name> <operator>=</operator> <name><name>optionalRules</name><operator>-&gt;</operator><name>defaultRaw</name></name></expr>;</expr_stmt>

                                        <break>break;</break>
                                    </block_content>}</block>

                                    <case>case <expr><name>cfgOptTypeStringId</name></expr>:</case>
                                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>defaultValue</name><operator>.</operator><name>stringId</name></name> <operator>=</operator> <name><name>parseRuleValueStrId</name><index>[<expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>ruleData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>defaultRaw</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>String</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>parseRuleValueStr</name><index>[<expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>ruleData</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
                                        <break>break;</break>
                                </block_content>}</block></switch>
                            </block_content>}</block>
                        </block_content>}</block></switch>

                        <break>break;</break>
                    </block_content>}</block>

                    <default>default:</default>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionalRuleType</name> <operator>==</operator> <name>parseRuleOptionalTypeRequired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>required</name></name> <operator>=</operator> <operator>!</operator><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>required</name></expr>;</expr_stmt>
                    </block_content>}</block>
                </block_content>}</block></switch>
            </block_content>}</block></if>
            <comment type="line">// Else not the requested optional rule</comment>
            <else>else
            <block>{<block_content>
                <comment type="line">// If the optional rule type is greater than requested then return. The optional rule may be requested later.</comment>
                <if_stmt><if>if <condition>(<expr><name><name>optionalRules</name><operator>-&gt;</operator><name>typeNext</name></name> <operator>&gt;</operator> <name>optionalRuleType</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Consume the unused optional rule</comment>
                <expr_stmt><expr><call><name>pckReadConsume</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="line">// Type will need to be read again on next iteration</comment>
            <expr_stmt><expr><name><name>optionalRules</name><operator>-&gt;</operator><name>typeNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block>
        while <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>;</do>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Resolve an option dependency
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>CfgParseOptionalFilterDependResult</name>
<block>{
    <decl_stmt><decl><type><name>bool</name></type> <name>valid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>defaultExists</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>defaultValue</name></decl>;</decl_stmt>
}</block></struct></type> <name>CfgParseOptionalFilterDependResult</name>;</typedef>

<function><type><specifier>static</specifier> <name>CfgParseOptionalFilterDependResult</name></type>
<name>cfgParseOptionalFilterDepend</name><parameter_list>(<parameter><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>filter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Config</name> <modifier>*</modifier><specifier>const</specifier></type> <name>config</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>optionListIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>PACK_READ</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>optionListIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>CfgParseOptionalFilterDependResult</name></type> <name>result</name> <init>= <expr><block>{<expr><operator>.</operator><name>valid</name> <operator>=</operator> <name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <comment type="line">// Default when the dependency is not resolved, if it exists</comment>
    <expr_stmt><expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pckReadType</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pckTypeBool</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>defaultExists</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>defaultValue</name></name> <operator>=</operator> <call><name>pckReadBoolP</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Get the depend option value</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ConfigOption</name></type> <name>dependId</name> <init>= <expr><operator>(</operator><name>ConfigOption</name><operator>)</operator><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>option</name><index>[<expr><name>dependId</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ConfigOptionValue</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dependValue</name> <init>= <expr><operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>option</name><index>[<expr><name>dependId</name></expr>]</index></name><operator>.</operator><name><name>index</name><index>[<expr><name>optionListIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Is the dependency resolved?</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dependValue</name><operator>-&gt;</operator><name>set</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// If a depend list exists, make sure the value is in the list</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <do>do
            <block>{<block_content>
                <switch>switch <condition>(<expr><call><name>cfgParseOptionDataType</name><argument_list>(<argument><expr><name>dependId</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>cfgOptDataTypeBoolean</name></expr>:</case>
                        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>valid</name></name> <operator>=</operator> <call><name>pckReadBoolP</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>dependValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>boolean</name></name></expr>;</expr_stmt>
                        <break>break;</break>

                    <default>default:</default>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cfgParseOptionDataType</name><argument_list>(<argument><expr><name>dependId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cfgOptDataTypeStringId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>parseRuleValueStrId</name><index>[<expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <name><name>dependValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>stringId</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <break>break;</break>
                    </block_content>}</block>
                </block_content>}</block></switch>
            </block_content>}</block>
            while <condition>(<expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_TYPE</name><argument_list>(<argument><expr><name>CfgParseOptionalFilterDependResult</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type>
<name>cfgParseOptionDefault</name><parameter_list>(<parameter><decl><type><name>ConfigCommand</name></type> <name>commandId</name></decl></parameter>, <parameter><decl><type><name>ConfigOption</name></type> <name>optionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>commandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>commandId</name> <operator>&lt;</operator> <name>CFG_COMMAND_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionId</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CfgParseOptionalRuleState</name></type> <name>optionalRules</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>cfgParseOptionalRule</name><argument_list>(<argument><expr><operator>&amp;</operator><name>optionalRules</name></expr></argument>, <argument><expr><name>parseRuleOptionalTypeDefault</name></expr></argument>, <argument><expr><name>commandId</name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optionalRules</name><operator>.</operator><name>defaultRaw</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>cfgParseOptionName</name><parameter_list>(<parameter><decl><type><name>ConfigOption</name></type> <name>optionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionId</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>cfgParseOptionKeyIdxName</name><parameter_list>(<parameter><decl><type><name>ConfigOption</name></type> <name>optionId</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>keyIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>keyIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionId</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>group</name> <operator>&amp;&amp;</operator> <name>keyIdx</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If the option is in a group then construct the name</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>group</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(
            <argument><expr><literal type="string">"%s%u%s"</literal></expr></argument>, <argument><expr><name><name>parseRuleOptionGroup</name><index>[<expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>groupId</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>keyIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
            <argument><expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>parseRuleOptionGroup</name><index>[<expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>groupId</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Else return the stored name</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>cfgParseOptionRequired</name><parameter_list>(<parameter><decl><type><name>ConfigCommand</name></type> <name>commandId</name></decl></parameter>, <parameter><decl><type><name>ConfigOption</name></type> <name>optionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>commandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>commandId</name> <operator>&lt;</operator> <name>CFG_COMMAND_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionId</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CfgParseOptionalRuleState</name></type> <name>optionalRules</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>cfgParseOptionalRule</name><argument_list>(<argument><expr><operator>&amp;</operator><name>optionalRules</name></expr></argument>, <argument><expr><name>parseRuleOptionalTypeRequired</name></expr></argument>, <argument><expr><name>commandId</name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optionalRules</name><operator>.</operator><name>required</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>required</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>cfgParseOptionSecure</name><parameter_list>(<parameter><decl><type><name>ConfigOption</name></type> <name>optionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionId</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>secure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>ConfigOptionType</name></type>
<name>cfgParseOptionType</name><parameter_list>(<parameter><decl><type><name>ConfigOption</name></type> <name>optionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionId</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>cfgParseOptionValid</name><parameter_list>(<parameter><decl><type><name>ConfigCommand</name></type> <name>commandId</name></decl></parameter>, <parameter><decl><type><name>ConfigCommandRole</name></type> <name>commandRoleId</name></decl></parameter>, <parameter><decl><type><name>ConfigOption</name></type> <name>optionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>commandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>commandRoleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>commandId</name> <operator>&lt;</operator> <name>CFG_COMMAND_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionId</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name><name>commandRoleValid</name><index>[<expr><name>commandRoleId</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>commandId</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Load the configuration file(s)

The parent mem context is used. Defaults are passed to make testing easier.

Rules:
- config and config-include-path are default. In this case, the config file will be loaded, if it exists, and *.conf files in the
  config-include-path will be appended, if they exist. A missing/empty dir will be ignored except that the original default
  for the config file will be attempted to be loaded if the current default is not found.
- config only is specified. Only the specified config file will be loaded and is required. The default config-include-path will be
  ignored.
- config and config-path are specified. The specified config file will be loaded and is required. The overridden default of the
  config-include-path (&lt;config-path&gt;/conf.d) will be loaded if exists but is not required.
- config-include-path only is specified. *.conf files in the config-include-path will be loaded and the path is required to exist.
  The default config will be be loaded if it exists.
- config-include-path and config-path are specified. The *.conf files in the config-include-path will be loaded and the directory
  passed must exist. The overridden default of the config file path (&lt;config-path&gt;/pgbackrest.conf) will be loaded if exists but is
  not required.
- If the config and config-include-path are specified. The config file will be loaded and is expected to exist and *.conf files in
  the config-include-path will be appended and at least one is expected to exist.
- If --no-config is specified and --config-include-path is specified then only *.conf files in the config-include-path will be
  loaded; the directory is required.
- If --no-config is specified and --config-path is specified then only *.conf files in the overridden default config-include-path
  (&lt;config-path&gt;/conf.d) will be loaded if exist but not required.
- If --no-config is specified and neither --config-include-path nor --config-path are specified then no configs will be loaded.
- If --config-path only, the defaults for config and config-include-path will be changed to use that as a base path but the files
  will not be required to exist since this is a default override.
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cfgFileLoadPart</name><parameter_list>(<parameter><decl><type><name>String</name> <modifier>*</modifier><modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Buffer</name> <modifier>*</modifier></type><name>configPart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BUFFER</name></expr></argument>, <argument><expr><name>configPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>configPart</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>configPartStr</name> <init>= <expr><call><name>strNewBuf</name><argument_list>(<argument><expr><name>configPart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Validate the file by parsing it as an Ini object. If the file is not properly formed, an error will occur.</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>configPartStr</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Ini</name> <modifier>*</modifier></type><name>configPartIni</name> <init>= <expr><call><name>iniNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>iniParse</name><argument_list>(<argument><expr><name>configPartIni</name></expr></argument>, <argument><expr><name>configPartStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Create the result config file</comment>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>config</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>config</name> <operator>=</operator> <call><name>strNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <comment type="line">// Else add an LF in case the previous file did not end with one</comment>
            <else>else<block type="pseudo"><block_content>

            <comment type="line">// Add the config part to the result config file</comment>
            <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><operator>*</operator><name>config</name></expr></argument>, <argument><expr><name>LF_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><operator>*</operator><name>config</name></expr></argument>, <argument><expr><name>configPartStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>cfgFileLoad</name><parameter_list>(                                                        <comment type="line">// NOTE: Passing defaults to enable more complete test coverage</comment>
    <parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storage</name></decl></parameter>,                                         <comment type="line">// Storage to load configs</comment>
    <parameter><decl><type><specifier>const</specifier> <name>ParseOption</name> <modifier>*</modifier></type><name>optionList</name></decl></parameter>,                                  <comment type="line">// All options and their current settings</comment>
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>optConfigDefault</name></decl></parameter>,                                 <comment type="line">// Current default for --config option</comment>
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>optConfigIncludePathDefault</name></decl></parameter>,                      <comment type="line">// Current default for --config-include-path option</comment>
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>origConfigDefault</name></decl></parameter>)</parameter_list>                                <comment type="line">// Original --config option default (/etc/pgbackrest.conf)</comment>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>PARSE_OPTION</name></expr></argument>, <argument><expr><name>optionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>optConfigDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>optConfigIncludePathDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>origConfigDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionList</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optConfigDefault</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optConfigIncludePathDefault</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>origConfigDefault</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>loadConfig</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>loadConfigInclude</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the option is specified on the command line, then found will be true meaning the file is required to exist,</comment>
    <comment type="line">// else it is optional</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>configFound</name> <init>= <expr><name><name>optionList</name><index>[<expr><name>cfgOptConfig</name></expr>]</index></name><operator>.</operator><name>indexList</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>optionList</name><index>[<expr><name>cfgOptConfig</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>found</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>configRequired</name> <init>= <expr><name>configFound</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>configPathRequired</name> <init>= <expr><name><name>optionList</name><index>[<expr><name>cfgOptConfigPath</name></expr>]</index></name><operator>.</operator><name>indexList</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>optionList</name><index>[<expr><name>cfgOptConfigPath</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>found</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>configIncludeRequired</name> <init>=
        <expr><name><name>optionList</name><index>[<expr><name>cfgOptConfigIncludePath</name></expr>]</index></name><operator>.</operator><name>indexList</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>optionList</name><index>[<expr><name>cfgOptConfigIncludePath</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>found</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Save default for later determining if must check old original default config path</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>optConfigDefaultCurrent</name> <init>= <expr><name>optConfigDefault</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the config-path option is found on the command line, then its value will override the base path defaults for config and</comment>
    <comment type="line">// config-include-path</comment>
    <if_stmt><if>if <condition>(<expr><name>configPathRequired</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>optConfigDefault</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(
            <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>optionList</name><index>[<expr><name>cfgOptConfigPath</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strBaseZ</name><argument_list>(<argument><expr><name>optConfigDefault</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>optConfigIncludePathDefault</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(
            <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>optionList</name><index>[<expr><name>cfgOptConfigPath</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PROJECT_CONFIG_INCLUDE_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If the --no-config option was passed then do not load the config file</comment>
    <if_stmt><if>if <condition>(<expr><name><name>optionList</name><index>[<expr><name>cfgOptConfig</name></expr>]</index></name><operator>.</operator><name>indexList</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>optionList</name><index>[<expr><name>cfgOptConfig</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>negate</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>loadConfig</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>configRequired</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If --config option is specified on the command line but neither the --config-include-path nor the config-path are passed,</comment>
    <comment type="line">// then do not attempt to load the include files</comment>
    <if_stmt><if>if <condition>(<expr><name>configFound</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>configPathRequired</name> <operator>||</operator> <name>configIncludeRequired</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>loadConfigInclude</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>configIncludeRequired</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Load the main config file</comment>
    <if_stmt><if>if <condition>(<expr><name>loadConfig</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>configFileName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get the config file name from the command-line if it exists else default</comment>
        <if_stmt><if>if <condition>(<expr><name>configRequired</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>configFileName</name> <operator>=</operator> <call><name>strLstGet</name><argument_list>(<argument><expr><name><name>optionList</name><index>[<expr><name>cfgOptConfig</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>configFileName</name> <operator>=</operator> <name>optConfigDefault</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="line">// Load the config file</comment>
        <decl_stmt><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><call><name>storageGetP</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>configFileName</name></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <operator>!</operator><name>configRequired</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Convert the contents of the file buffer to the config string object</comment>
        <if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strCatBuf</name><argument_list>(<argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>configFileName</name></expr></argument>, <argument><expr><name>optConfigDefaultCurrent</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If config is current default and it was not found, attempt to load the config file from the old default location</comment>
            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>storageGetP</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>origConfigDefault</name></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <operator>!</operator><name>configRequired</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strCatBuf</name><argument_list>(<argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Load *.conf files from the include directory</comment>
    <if_stmt><if>if <condition>(<expr><name>loadConfigInclude</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Validate the file by parsing it as an Ini object. If the file is not properly formed, an error will occur.</comment>
            <decl_stmt><decl><type><name>Ini</name> <modifier>*</modifier></type><name>ini</name> <init>= <expr><call><name>iniNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>iniParse</name><argument_list>(<argument><expr><name>ini</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>configIncludePath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get the config include path from the command-line if it exists else default</comment>
        <if_stmt><if>if <condition>(<expr><name>configIncludeRequired</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>configIncludePath</name> <operator>=</operator> <call><name>strLstGet</name><argument_list>(<argument><expr><name><name>optionList</name><index>[<expr><name>cfgOptConfigIncludePath</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>configIncludePath</name> <operator>=</operator> <name>optConfigIncludePathDefault</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="line">// Get a list of conf files from the specified path -error on missing directory if the option was passed on the command line</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>storageListP</name><argument_list>(
            <argument><expr><name>storage</name></expr></argument>, <argument><expr><name>configIncludePath</name></expr></argument>, <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">".+\\.conf$"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>configIncludeRequired</name></expr></argument>,
            <argument><expr><operator>.</operator><name>nullOnMissing</name> <operator>=</operator> <operator>!</operator><name>configIncludeRequired</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If conf files are found, then add them to the config string</comment>
        <if_stmt><if>if <condition>(<expr><name>list</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Sort the list for reproducibility only -- order does not matter</comment>
            <expr_stmt><expr><call><name>strLstSort</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>listIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>listIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>listIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>cfgFileLoadPart</name><argument_list>(
                    <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>,
                    <argument><expr><call><name>storageGetP</name><argument_list>(
                        <argument><expr><call><name>storageNewReadP</name><argument_list>(
                            <argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>configIncludePath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>listIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
??? Add validation of section names and check all sections for invalid options in the check command.  It's too expensive to add the
logic to this critical path code.
***********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>configParse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storage</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>argListSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>argList</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>resetLogLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>argListSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>CHARPY</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>resetLogLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Create the config struct</comment>
        <decl_stmt><decl><type><name>Config</name> <modifier>*</modifier></type><name>config</name></decl>;</decl_stmt>

        <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>Config</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>, <argument>.allocQty = MEM_CONTEXT_QTY_MAX</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>config</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><operator>*</operator><name>config</name> <operator>=</operator> <operator>(</operator><name>Config</name><operator>)</operator>
            <block>{
                <expr><operator>.</operator><name>memContext</name> <operator>=</operator> <call><name>MEM_CONTEXT_NEW</name><argument_list>()</argument_list></call></expr>,
                <expr><operator>.</operator><name>command</name> <operator>=</operator> <name>cfgCmdNone</name></expr>,
                <expr><operator>.</operator><name>exe</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>,
            }</block></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Phase 1: parse command line parameters</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <comment type="line">// List of parsed options</comment>
        <decl_stmt><decl><type><name>ParseOption</name></type> <name><name>parseOptionList</name><index>[<expr><name>CFG_OPTION_TOTAL</name></expr>]</index></name> <init>= <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

        <comment type="line">// Only the first non-option parameter should be treated as a command so track if the command has been set</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>commandSet</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>argListIdx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>argListIdx</name> <operator>&lt;</operator> <name>argListSize</name></expr>;</condition> <incr><expr><name>argListIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>argList</name><index>[<expr><name>argListIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// If an option</comment>
            <if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Options must start with --</comment>
                <if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' must begin with --"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Consume --</comment>
                <expr_stmt><expr><name>arg</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

                <comment type="line">// Get the option name and the value when separated by =</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>optionName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>optionArg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>equalPtr</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>equalPtr</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>optionName</name> <operator>=</operator> <call><name>strNewZN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>equalPtr</name> <operator>-</operator> <name>arg</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>optionArg</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><name>equalPtr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>optionName</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="line">// Lookup the option name</comment>
                <decl_stmt><decl><type><name>CfgParseOptionResult</name></type> <name>option</name> <init>= <expr><call><name>cfgParseOptionP</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>, <argument><expr><operator>.</operator><name>prefixMatch</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>option</name><operator>.</operator><name>found</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"invalid option '--%s'"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// If the option may have an argument (arguments are optional for boolean options)</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>option</name><operator>.</operator><name>negate</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>option</name><operator>.</operator><name>reset</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Handle boolean (only y/n allowed as argument)</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>parseRuleOption</name><index>[<expr><name><name>option</name><operator>.</operator><name>id</name></name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>cfgOptTypeBoolean</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Validate argument/set negate when argument present</comment>
                        <if_stmt><if>if <condition>(<expr><name>optionArg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>optionArg</name></expr></argument>, <argument><expr><literal type="string">"n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>option</name><operator>.</operator><name>negate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
                            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strEqZ</name><argument_list>(<argument><expr><name>optionArg</name></expr></argument>, <argument><expr><literal type="string">"y"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                    <argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"boolean option '--%s' argument must be 'y' or 'n'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// If no argument was found with the option then try the next argument</comment>
                    <if type="elseif">else if <condition>(<expr><name>optionArg</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Error if there are no more arguments in the list</comment>
                        <if_stmt><if>if <condition>(<expr><name>argListIdx</name> <operator>==</operator> <name>argListSize</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '--%s' requires an argument"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                        <expr_stmt><expr><name>optionArg</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><name><name>argList</name><index>[<expr><operator>++</operator><name>argListIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else error if an argument was found with the option</comment>
                <if type="elseif">else if <condition>(<expr><name>optionArg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' does not allow an argument"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Error if this option is secure and cannot be passed on the command line</comment>
                <if_stmt><if>if <condition>(<expr><call><name>cfgParseOptionSecure</name><argument_list>(<argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                        <argument><expr><name>OptionInvalidError</name></expr></argument>,
                        <argument><expr><literal type="string">"option '%s' is not allowed on the command-line\n"</literal>
                        <literal type="string">"HINT: this option could expose secrets in the process list.\n"</literal>
                        <literal type="string">"HINT: specify the option in a configuration file or an environment variable instead."</literal></expr></argument>,
                        <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>keyIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// If the option has not been found yet then set it</comment>
                <decl_stmt><decl><type><name>ParseOptionValue</name> <modifier>*</modifier></type><name>optionValue</name> <init>= <expr><call><name>parseOptionIdxValue</name><argument_list>(<argument><expr><name>parseOptionList</name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>keyIdx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>optionValue</name><operator>-&gt;</operator><name>found</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>optionValue</name> <operator>=</operator> <operator>(</operator><name>ParseOptionValue</name><operator>)</operator>
                    <block>{
                        <expr><operator>.</operator><name>found</name> <operator>=</operator> <name>true</name></expr>,
                        <expr><operator>.</operator><name>negate</name> <operator>=</operator> <name><name>option</name><operator>.</operator><name>negate</name></name></expr>,
                        <expr><operator>.</operator><name>reset</name> <operator>=</operator> <name><name>option</name><operator>.</operator><name>reset</name></name></expr>,
                        <expr><operator>.</operator><name>source</name> <operator>=</operator> <name>cfgSourceParam</name></expr>,
                    }</block></expr>;</expr_stmt>

                    <comment type="line">// Only set the argument if the option has one</comment>
                    <if_stmt><if>if <condition>(<expr><name>optionArg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>optionValue</name><operator>-&gt;</operator><name>valueList</name></name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name><name>optionValue</name><operator>-&gt;</operator><name>valueList</name></name></expr></argument>, <argument><expr><name>optionArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="line">// Make sure option is not negated more than once. It probably wouldn't hurt anything to accept this case but</comment>
                    <comment type="line">// there's no point in allowing the user to be sloppy.</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>optionValue</name><operator>-&gt;</operator><name>negate</name></name> <operator>&amp;&amp;</operator> <name><name>option</name><operator>.</operator><name>negate</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' is negated multiple times"</literal></expr></argument>,
                            <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>keyIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Make sure option is not reset more than once. Same justification as negate.</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>optionValue</name><operator>-&gt;</operator><name>reset</name></name> <operator>&amp;&amp;</operator> <name><name>option</name><operator>.</operator><name>reset</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' is reset multiple times"</literal></expr></argument>,
                            <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>keyIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Don't allow an option to be both negated and reset</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>optionValue</name><operator>-&gt;</operator><name>reset</name></name> <operator>&amp;&amp;</operator> <name><name>option</name><operator>.</operator><name>negate</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>optionValue</name><operator>-&gt;</operator><name>negate</name></name> <operator>&amp;&amp;</operator> <name><name>option</name><operator>.</operator><name>reset</name></name><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' cannot be negated and reset"</literal></expr></argument>,
                            <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>keyIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Don't allow an option to be both set and negated</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>optionValue</name><operator>-&gt;</operator><name>negate</name></name> <operator>!=</operator> <name><name>option</name><operator>.</operator><name>negate</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' cannot be set and negated"</literal></expr></argument>,
                            <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>keyIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Don't allow an option to be both set and reset</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>optionValue</name><operator>-&gt;</operator><name>reset</name></name> <operator>!=</operator> <name><name>option</name><operator>.</operator><name>reset</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' cannot be set and reset"</literal></expr></argument>,
                            <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>keyIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Add the argument</comment>
                    <if_stmt><if>if <condition>(<expr><name>optionArg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>parseRuleOption</name><index>[<expr><name><name>option</name><operator>.</operator><name>id</name></name></expr>]</index></name><operator>.</operator><name>multi</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name><name>optionValue</name><operator>-&gt;</operator><name>valueList</name></name></expr></argument>, <argument><expr><name>optionArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Error if the option does not accept multiple arguments</comment>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' cannot be set multiple times"</literal></expr></argument>,
                            <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>keyIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else command or parameter</comment>
            <else>else
            <block>{<block_content>
                <comment type="line">// The first argument should be the command</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>commandSet</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Try getting the command from the valid command list</comment>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name> <operator>=</operator> <call><name>cfgParseCommandId</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>commandRole</name></name> <operator>=</operator> <name>cfgCmdRoleMain</name></expr>;</expr_stmt>

                    <comment type="line">// If not successful then a command role may be appended</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name> <operator>==</operator> <name>cfgCmdNone</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>commandPart</name> <init>= <expr><call><name>strLstNewSplitZ</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>commandPart</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// Get command id</comment>
                            <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name> <operator>=</operator> <call><name>cfgParseCommandId</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>commandPart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// If command id is valid then get command role id</comment>
                            <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name> <operator>!=</operator> <name>cfgCmdNone</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>commandRole</name></name> <operator>=</operator> <call><name>cfgParseCommandRoleEnum</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>commandPart</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Error when command does not exist</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name> <operator>==</operator> <name>cfgCmdNone</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>CommandInvalidError</name></expr></argument>, <argument><expr><literal type="string">"invalid command '%s'"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Error when role is not valid for the command</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>parseRuleCommand</name><index>[<expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name><operator>.</operator><name>commandRoleValid</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>config</name><operator>-&gt;</operator><name>commandRole</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>CommandInvalidError</name></expr></argument>, <argument><expr><literal type="string">"invalid command/role combination '%s'"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name> <operator>==</operator> <name>cfgCmdHelp</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>help</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>commandSet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <comment type="line">// Set command options</comment>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>lockRequired</name></name> <operator>=</operator> <name><name>parseRuleCommand</name><index>[<expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name><operator>.</operator><name>lockRequired</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>lockRemoteRequired</name></name> <operator>=</operator> <name><name>parseRuleCommand</name><index>[<expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name><operator>.</operator><name>lockRemoteRequired</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>lockType</name></name> <operator>=</operator> <operator>(</operator><name>LockType</name><operator>)</operator><name><name>parseRuleCommand</name><index>[<expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name><operator>.</operator><name>lockType</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>logFile</name></name> <operator>=</operator> <name><name>parseRuleCommand</name><index>[<expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name><operator>.</operator><name>logFile</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>logLevelDefault</name></name> <operator>=</operator> <operator>(</operator><name>LogLevel</name><operator>)</operator><name><name>parseRuleCommand</name><index>[<expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name><operator>.</operator><name>logLevelDefault</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Additional arguments are command arguments</comment>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>paramList</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>config-&gt;memContext</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>paramList</name></name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>strLstAddZ</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>paramList</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Handle command not found</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>commandSet</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>config</name><operator>-&gt;</operator><name>help</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If there are args then error</comment>
            <if_stmt><if>if <condition>(<expr><name>argListSize</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>CommandRequiredError</name></expr></argument>, <argument><expr><literal type="string">"no command found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Otherwise set the command to help</comment>
            <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>help</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Error when parameters found but the command does not allow parameters</comment>
        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>paramList</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>config</name><operator>-&gt;</operator><name>help</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parseRuleCommand</name><index>[<expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr>]</index></name><operator>.</operator><name>parameterAllowed</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>ParamInvalidError</name></expr></argument>, <argument><expr><literal type="string">"command does not allow parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Enable logging for main role so config file warnings will be output</comment>
        <if_stmt><if>if <condition>(<expr><name>resetLogLevel</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>-&gt;</operator><name>commandRole</name></name> <operator>==</operator> <name>cfgCmdRoleMain</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>logInit</name><argument_list>(<argument><expr><name>logLevelWarn</name></expr></argument>, <argument><expr><name>logLevelWarn</name></expr></argument>, <argument><expr><name>logLevelOff</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Only continue if command options need to be validated, i.e. a real command is running or we are getting help for a</comment>
        <comment type="line">// specific command and would like to display actual option values in the help.</comment>
        <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name> <operator>!=</operator> <name>cfgCmdNone</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>-&gt;</operator><name>command</name></name> <operator>!=</operator> <name>cfgCmdVersion</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>-&gt;</operator><name>command</name></name> <operator>!=</operator> <name>cfgCmdHelp</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Phase 2: parse environment variables</comment>
            <comment type="line">// ---------------------------------------------------------------------------------------------------------------------</comment>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>environIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="line">// Loop through all environment variables and look for our env vars by matching the prefix</comment>
            <while>while <condition>(<expr><name><name>environ</name><index>[<expr><name>environIdx</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyValue</name> <init>= <expr><name><name>environ</name><index>[<expr><name>environIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>environIdx</name><operator>++</operator></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>keyValue</name></expr></argument>, <argument><expr><name>PGBACKREST_ENV</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>keyValue</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Find the first = char</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>equalPtr</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>keyValue</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>equalPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Get key and value</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>strReplaceChr</name><argument_list>(
                        <argument><expr><call><name>strLower</name><argument_list>(<argument><expr><call><name>strNewZN</name><argument_list>(<argument><expr><name>keyValue</name> <operator>+</operator> <name>PGBACKREST_ENV_SIZE</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>equalPtr</name> <operator>-</operator> <operator>(</operator><name>keyValue</name> <operator>+</operator> <name>PGBACKREST_ENV_SIZE</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><literal type="char">'_'</literal></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>STR</name><argument_list>(<argument><expr><name>equalPtr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Find the option</comment>
                    <decl_stmt><decl><type><name>CfgParseOptionResult</name></type> <name>option</name> <init>= <expr><call><name>cfgParseOptionP</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Warn if the option not found</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>option</name><operator>.</operator><name>found</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"environment contains invalid option '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></if>
                    <comment type="line">// Warn if negate option found in env</comment>
                    <if type="elseif">else if <condition>(<expr><name><name>option</name><operator>.</operator><name>negate</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"environment contains invalid negate option '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></if>
                    <comment type="line">// Warn if reset option found in env</comment>
                    <if type="elseif">else if <condition>(<expr><name><name>option</name><operator>.</operator><name>reset</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"environment contains invalid reset option '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Continue if the option is not valid for this command</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgParseOptionValid</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>commandRole</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"environment variable '%s' must have a value"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Continue if the option has already been specified on the command line</comment>
                    <decl_stmt><decl><type><name>ParseOptionValue</name> <modifier>*</modifier></type><name>optionValue</name> <init>= <expr><call><name>parseOptionIdxValue</name><argument_list>(<argument><expr><name>parseOptionList</name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>keyIdx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>optionValue</name><operator>-&gt;</operator><name>found</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name><name>optionValue</name><operator>-&gt;</operator><name>found</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>optionValue</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>cfgSourceConfig</name></expr>;</expr_stmt>

                    <comment type="line">// Convert boolean to string</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>cfgParseOptionType</name><argument_list>(<argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cfgOptTypeBoolean</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>optionValue</name><operator>-&gt;</operator><name>negate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
                        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strEqZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"y"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"environment boolean option '%s' must be 'y' or 'n'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Else split list/hash into separate values</comment>
                    <if type="elseif">else if <condition>(<expr><name><name>parseRuleOption</name><index>[<expr><name><name>option</name><operator>.</operator><name>id</name></name></expr>]</index></name><operator>.</operator><name>multi</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>optionValue</name><operator>-&gt;</operator><name>valueList</name></name> <operator>=</operator> <call><name>strLstNewSplitZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Else add the string value</comment>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>optionValue</name><operator>-&gt;</operator><name>valueList</name></name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name><name>optionValue</name><operator>-&gt;</operator><name>valueList</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></while>

            <comment type="line">// Phase 3: parse config file unless --no-config passed</comment>
            <comment type="line">// ---------------------------------------------------------------------------------------------------------------------</comment>
            <comment type="line">// Load the configuration file(s)</comment>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>configString</name> <init>= <expr><call><name>cfgFileLoad</name><argument_list>(
                <argument><expr><name>storage</name></expr></argument>, <argument><expr><name>parseOptionList</name></expr></argument>,
                <argument><expr><operator>(</operator><specifier>const</specifier> <name>String</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>parseRuleValueStr</name><index>[<expr><name>parseRuleValStrCFGOPTDEF_CONFIG_PATH_SP_QT_FS_QT_SP_PROJECT_CONFIG_FILE</name></expr>]</index></name></expr></argument>,
                <argument><expr><operator>(</operator><specifier>const</specifier> <name>String</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>parseRuleValueStr</name><index>[<expr><name>parseRuleValStrCFGOPTDEF_CONFIG_PATH_SP_QT_FS_QT_SP_PROJECT_CONFIG_INCLUDE_PATH</name></expr>]</index></name></expr></argument>,
                <argument><expr><name>PGBACKREST_CONFIG_ORIG_PATH_FILE_STR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>configString</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Ini</name> <modifier>*</modifier></type><name>ini</name> <init>= <expr><call><name>iniNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>iniParse</name><argument_list>(<argument><expr><name>ini</name></expr></argument>, <argument><expr><name>configString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// Get the stanza name</comment>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>stanza</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>parseOptionList</name><index>[<expr><name>cfgOptStanza</name></expr>]</index></name><operator>.</operator><name>indexList</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>stanza</name> <operator>=</operator> <call><name>strLstGet</name><argument_list>(<argument><expr><name><name>parseOptionList</name><index>[<expr><name>cfgOptStanza</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Build list of sections to search for options</comment>
                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>sectionList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>stanza</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>strLstAddFmt</name><argument_list>(<argument><expr><name>sectionList</name></expr></argument>, <argument><expr><literal type="string">"%s:%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>stanza</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgParseCommandName</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>sectionList</name></expr></argument>, <argument><expr><name>stanza</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>strLstAddFmt</name><argument_list>(<argument><expr><name>sectionList</name></expr></argument>, <argument><expr><name>CFGDEF_SECTION_GLOBAL</name> <literal type="string">":%s"</literal></expr></argument>, <argument><expr><call><name>cfgParseCommandName</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strLstAddZ</name><argument_list>(<argument><expr><name>sectionList</name></expr></argument>, <argument><expr><name>CFGDEF_SECTION_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Loop through sections to search for options</comment>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>sectionIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>sectionIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>sectionList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>sectionIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>section</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>sectionList</name></expr></argument>, <argument><expr><name>sectionIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>keyList</name> <init>= <expr><call><name>iniSectionKeyList</name><argument_list>(<argument><expr><name>ini</name></expr></argument>, <argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>optionFound</name> <init>= <expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Loop through keys to search for options</comment>
                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>keyIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>keyIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>keyList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>keyIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>keyList</name></expr></argument>, <argument><expr><name>keyIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Find the optionName in the main list</comment>
                        <decl_stmt><decl><type><name>CfgParseOptionResult</name></type> <name>option</name> <init>= <expr><call><name>cfgParseOptionP</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Warn if the option not found</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>option</name><operator>.</operator><name>found</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"configuration file contains invalid option '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        </block_content>}</block></if>
                        <comment type="line">// Warn if negate option found in config</comment>
                        <if type="elseif">else if <condition>(<expr><name><name>option</name><operator>.</operator><name>negate</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"configuration file contains negate option '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        </block_content>}</block></if>
                        <comment type="line">// Warn if reset option found in config</comment>
                        <if type="elseif">else if <condition>(<expr><name><name>option</name><operator>.</operator><name>reset</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"configuration file contains reset option '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// Warn if this option should be command-line only</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>parseRuleOption</name><index>[<expr><name><name>option</name><operator>.</operator><name>id</name></name></expr>]</index></name><operator>.</operator><name>section</name> <operator>==</operator> <name>cfgSectionCommandLine</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"configuration file contains command-line only option '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// Make sure this option does not appear in the same section with an alternate name</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>optionFoundKey</name> <init>= <expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name><name>option</name><operator>.</operator><name>id</name></name> <operator>*</operator> <name>CFG_OPTION_KEY_MAX</name> <operator>+</operator> <name><name>option</name><operator>.</operator><name>keyIdx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>optionFoundName</name> <init>= <expr><call><name>kvGet</name><argument_list>(<argument><expr><name>optionFound</name></expr></argument>, <argument><expr><name>optionFoundKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>optionFoundName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"configuration file contains duplicate options ('%s', '%s') in section '[%s]'"</literal></expr></argument>,
                                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>optionFoundName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionFound</name></expr></argument>, <argument><expr><name>optionFoundKey</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                        <comment type="line">// Continue if the option is not valid for this command</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgParseOptionValid</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>commandRole</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// Warn if it is in a command section</comment>
                            <if_stmt><if>if <condition>(<expr><name>sectionIdx</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                                    <argument><expr><literal type="string">"configuration file contains option '%s' invalid for section '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <continue>continue;</continue>
                            </block_content>}</block></if></if_stmt>

                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// Continue if stanza option is in a global section</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>parseRuleOption</name><index>[<expr><name><name>option</name><operator>.</operator><name>id</name></name></expr>]</index></name><operator>.</operator><name>section</name> <operator>==</operator> <name>cfgSectionStanza</name> <operator>&amp;&amp;</operator>
                            <operator>(</operator><call><name>strEqZ</name><argument_list>(<argument><expr><name>section</name></expr></argument>, <argument><expr><name>CFGDEF_SECTION_GLOBAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strBeginsWithZ</name><argument_list>(<argument><expr><name>section</name></expr></argument>, <argument><expr><name>CFGDEF_SECTION_GLOBAL</name> <literal type="string">":"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                                <argument><expr><literal type="string">"configuration file contains stanza-only option '%s' in global section '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// Continue if this option has already been found in another section or command-line/environment</comment>
                        <decl_stmt><decl><type><name>ParseOptionValue</name> <modifier>*</modifier></type><name>optionValue</name> <init>= <expr><call><name>parseOptionIdxValue</name><argument_list>(<argument><expr><name>parseOptionList</name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>keyIdx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>optionValue</name><operator>-&gt;</operator><name>found</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <continue>continue;</continue></block_content></block></if></if_stmt>

                        <expr_stmt><expr><name><name>optionValue</name><operator>-&gt;</operator><name>found</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>optionValue</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>cfgSourceConfig</name></expr>;</expr_stmt>

                        <comment type="line">// Process list</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>iniSectionKeyIsList</name><argument_list>(<argument><expr><name>ini</name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// Error if the option cannot be specified multiple times</comment>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>parseRuleOption</name><index>[<expr><name><name>option</name><operator>.</operator><name>id</name></name></expr>]</index></name><operator>.</operator><name>multi</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                    <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' cannot be set multiple times"</literal></expr></argument>,
                                    <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>.</operator><name>keyIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <expr_stmt><expr><name><name>optionValue</name><operator>-&gt;</operator><name>valueList</name></name> <operator>=</operator> <call><name>iniGetList</name><argument_list>(<argument><expr><name>ini</name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <comment type="line">// Get the option value</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>iniGet</name><argument_list>(<argument><expr><name>ini</name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                    <argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"section '%s', key '%s' must have a value"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>cfgParseOptionType</name><argument_list>(<argument><expr><name><name>option</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cfgOptTypeBoolean</name></expr>)</condition>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name><name>optionValue</name><operator>-&gt;</operator><name>negate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
                                <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strEqZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"y"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"boolean option '%s' must be 'y' or 'n'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Else add the string value</comment>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>optionValue</name><operator>-&gt;</operator><name>valueList</name></name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name><name>optionValue</name><operator>-&gt;</operator><name>valueList</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Phase 4: create the config and resolve indexed options for each group</comment>
            <comment type="line">// ---------------------------------------------------------------------------------------------------------------------</comment>
            <comment type="line">// Determine how many indexes are used in each group</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name><name>groupIdxMap</name><index>[<expr><name>CFG_OPTION_GROUP_TOTAL</name></expr>]</index><index>[<expr><name>CFG_OPTION_KEY_MAX</name></expr>]</index></name> <init>= <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optionId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optionId</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr>;</condition> <incr><expr><name>optionId</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="line">// Always assign name since it may be needed for error messages</comment>
                <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>option</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt>

                <comment type="line">// Is the option valid for this command?</comment>
                <if_stmt><if>if <condition>(<expr><call><name>cfgParseOptionValid</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>commandRole</name></name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>option</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>valid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>option</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>dataType</name> <operator>=</operator> <call><name>cfgParseOptionDataType</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>option</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>group</name> <operator>=</operator> <name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>group</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>option</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>groupId</name> <operator>=</operator> <name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>groupId</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="line">// Error if the invalid option was explicitly set on the command-line</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>parseOptionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexList</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' not valid for command '%s'"</literal></expr></argument>, <argument><expr><call><name>cfgParseOptionName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>cfgParseCommandName</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Continue to the next option</comment>
                    <continue>continue;</continue>
                </block_content>}</block></else></if_stmt>

                <comment type="line">// If the option is in a group</comment>
                <if_stmt><if>if <condition>(<expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>group</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>groupId</name> <init>= <expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>groupId</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>valid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                    <comment type="line">// Scan the option values to determine which indexes are in use. Store them in a map that will later be scanned</comment>
                    <comment type="line">// to create a list of just the used indexes.</comment>
                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optionKeyIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optionKeyIdx</name> <operator>&lt;</operator> <name><name>parseOptionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexListTotal</name></expr>;</condition> <incr><expr><name>optionKeyIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>parseOptionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><name>optionKeyIdx</name></expr>]</index></name><operator>.</operator><name>found</name> <operator>&amp;&amp;</operator>
                            <operator>!</operator><name><name>parseOptionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><name>optionKeyIdx</name></expr>]</index></name><operator>.</operator><name>reset</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>groupIdxMap</name><index>[<expr><name>groupId</name></expr>]</index><index>[<expr><name>optionKeyIdx</name></expr>]</index></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>indexTotal</name><operator>++</operator></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>groupIdxMap</name><index>[<expr><name>groupId</name></expr>]</index><index>[<expr><name>optionKeyIdx</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="line">// Write the indexes into the group in order</comment>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>groupId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>groupId</name> <operator>&lt;</operator> <name>CFG_OPTION_GROUP_TOTAL</name></expr>;</condition> <incr><expr><name>groupId</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="line">// Set group name</comment>
                <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name><name>parseRuleOptionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt>

                <comment type="line">// Skip the group if it is not valid</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>valid</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="line">// Allocate memory for the index to key index map</comment>
                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>config-&gt;memContext</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>indexMap</name> <operator>=</operator> <call><name>memNew</name><argument_list>(
                        <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>*</operator>
                        <operator>(</operator><ternary><condition><expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>indexTotal</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>indexTotal</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// If no values were found in any index then use index 0 since all valid groups must have at least one index. This</comment>
                <comment type="line">// may lead to an error unless all options in the group have defaults but that will be resolved later.</comment>
                <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>indexTotal</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>indexTotal</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name><name>indexMap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else write the key to index map for the group. This allows translation from keys to indexes and vice versa.</comment>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>optionIdxMax</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>optionKeyIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                    <comment type="line">// ??? For the pg group, key 1 is required to maintain compatibility with older versions. Before removing this</comment>
                    <comment type="line">// constraint the pg group remap to key 1 for remotes will need to be dealt with in the protocol/helper module.</comment>
                    <if_stmt><if>if <condition>(<expr><name>groupId</name> <operator>==</operator> <name>cfgOptGrpPg</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>optionKeyIdx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>optionIdxMax</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

                        <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name><name>indexMap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Write keys into the index map</comment>
                    <for>for <control>(<init>;</init> <condition><expr><name>optionKeyIdx</name> <operator>&lt;</operator> <name>CFG_OPTION_KEY_MAX</name></expr>;</condition> <incr><expr><name>optionKeyIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>groupIdxMap</name><index>[<expr><name>groupId</name></expr>]</index><index>[<expr><name>optionKeyIdx</name></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name><name>indexMap</name><index>[<expr><name>optionIdxMax</name></expr>]</index></name> <operator>=</operator> <name>optionKeyIdx</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>optionIdxMax</name><operator>++</operator></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>

            <comment type="line">// Phase 5: validate option definitions and load into configuration</comment>
            <comment type="line">// ---------------------------------------------------------------------------------------------------------------------</comment>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optionOrderIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optionOrderIdx</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr>;</condition> <incr><expr><name>optionOrderIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="line">// Validate options based on the option resolve order.  This allows resolving all options in a single pass.</comment>
                <decl_stmt><decl><type><name>ConfigOption</name></type> <name>optionId</name> <init>= <expr><name><name>optionResolveOrder</name><index>[<expr><name>optionOrderIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <comment type="line">// Skip this option if it is not valid</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>config</name><operator>-&gt;</operator><name>option</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>valid</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="line">// Determine the option index total. For options that are not indexed the index total is 1.</comment>
                <decl_stmt><decl><type><name>bool</name></type> <name>optionGroup</name> <init>= <expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>group</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>optionGroupId</name> <init>= <expr><ternary><condition><expr><name>optionGroup</name></expr> ?</condition><then> <expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>groupId</name></expr> </then><else>: <expr><name>UINT_MAX</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>optionListIndexTotal</name> <init>= <expr><ternary><condition><expr><name>optionGroup</name></expr> ?</condition><then> <expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>optionGroupId</name></expr>]</index></name><operator>.</operator><name>indexTotal</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>config-&gt;memContext</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>option</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>=</operator> <call><name>memNew</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConfigOptionValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>optionListIndexTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Loop through the option indexes</comment>
                <decl_stmt><decl><type><name>ConfigOptionType</name></type> <name>optionType</name> <init>= <expr><call><name>cfgParseOptionType</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optionListIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optionListIdx</name> <operator>&lt;</operator> <name>optionListIndexTotal</name></expr>;</condition> <incr><expr><name>optionListIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="line">// Get the key index by looking it up in the group or by defaulting to 0 for ungrouped options</comment>
                    <decl_stmt><decl><type><name>unsigned</name></type> <name>optionKeyIdx</name> <init>= <expr><ternary><condition><expr><name>optionGroup</name></expr> ?</condition><then> <expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>optionGroupId</name></expr>]</index></name><operator>.</operator><name><name>indexMap</name><index>[<expr><name>optionListIdx</name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Get the parsed value using the key index. Provide a default structure when the value was not found.</comment>
                    <decl_stmt><decl><type><name>ParseOptionValue</name> <modifier>*</modifier></type><name>parseOptionValue</name> <init>= <expr><ternary><condition><expr><name>optionKeyIdx</name> <operator>&lt;</operator> <name><name>parseOptionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>indexListTotal</name></expr> ?</condition><then>
                        <expr><operator>&amp;</operator><name><name>parseOptionList</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name><name>indexList</name><index>[<expr><name>optionKeyIdx</name></expr>]</index></name></expr> </then><else>: <expr><operator>&amp;</operator><operator>(</operator><name>ParseOptionValue</name><operator>)</operator><block>{<expr><literal type="number">0</literal></expr>}</block></expr></else></ternary></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Get the location where the value will be stored in the configuration</comment>
                    <decl_stmt><decl><type><name>ConfigOptionValue</name> <modifier>*</modifier></type><name>configOptionValue</name> <init>= <expr><operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>option</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name><name>index</name><index>[<expr><name>optionListIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Is the value set for this option?</comment>
                    <decl_stmt><decl><type><name>bool</name></type> <name>optionSet</name> <init>=
                            <expr><name><name>parseOptionValue</name><operator>-&gt;</operator><name>found</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>optionType</name> <operator>==</operator> <name>cfgOptTypeBoolean</name> <operator>||</operator> <operator>!</operator><name><name>parseOptionValue</name><operator>-&gt;</operator><name>negate</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
                        <operator>!</operator><name><name>parseOptionValue</name><operator>-&gt;</operator><name>reset</name></name></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Initialize option value and set negate and reset flag</comment>
                    <expr_stmt><expr><operator>*</operator><name>configOptionValue</name> <operator>=</operator> <operator>(</operator><name>ConfigOptionValue</name><operator>)</operator><block>{<expr><operator>.</operator><name>negate</name> <operator>=</operator> <name><name>parseOptionValue</name><operator>-&gt;</operator><name>negate</name></name></expr>, <expr><operator>.</operator><name>reset</name> <operator>=</operator> <name><name>parseOptionValue</name><operator>-&gt;</operator><name>reset</name></name></expr>}</block></expr>;</expr_stmt>

                    <comment type="line">// Is the option valid?</comment>
                    <decl_stmt><decl><type><name>CfgParseOptionalRuleState</name></type> <name>optionalRules</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>CfgParseOptionalFilterDependResult</name></type> <name>dependResult</name> <init>= <expr><block>{<expr><operator>.</operator><name>valid</name> <operator>=</operator> <name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>cfgParseOptionalRule</name><argument_list>(<argument><expr><operator>&amp;</operator><name>optionalRules</name></expr></argument>, <argument><expr><name>parseRuleOptionalTypeValid</name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier></type><name>filter</name> <init>= <expr><call><name>pckReadNewC</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>.</operator><name>valid</name></name></expr></argument>, <argument><expr><name><name>optionalRules</name><operator>.</operator><name>validSize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>dependResult</name> <operator>=</operator> <call><name>cfgParseOptionalFilterDepend</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>config</name></expr></argument>, <argument><expr><name>optionListIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// If depend not resolved and option value is set on the command-line then error. It is OK to have</comment>
                        <comment type="line">// unresolved options in the config file because they may be there for another command. For instance,</comment>
                        <comment type="line">// spool-path is only loaded for the archive-push command when archive-async=y, and the presence of</comment>
                        <comment type="line">// spool-path in the config file should not cause an error here, it will just end up null.</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dependResult</name><operator>.</operator><name>valid</name></name> <operator>&amp;&amp;</operator> <name>optionSet</name> <operator>&amp;&amp;</operator> <name><name>parseOptionValue</name><operator>-&gt;</operator><name>source</name></name> <operator>==</operator> <name>cfgSourceParam</name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier></type><name>filter</name> <init>= <expr><call><name>pckReadNewC</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>.</operator><name>valid</name></name></expr></argument>, <argument><expr><name><name>optionalRules</name><operator>.</operator><name>validSize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>ConfigOption</name></type> <name>dependId</name> <init>= <expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <comment type="line">// Get depend option name</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>dependOptionName</name> <init>= <expr><call><name>STR</name><argument_list>(<argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name>dependId</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <comment type="line">// If depend value is not set</comment>
                            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>option</name><index>[<expr><name>dependId</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>config</name><operator>-&gt;</operator><name>option</name><index>[<expr><name>dependId</name></expr>]</index></name><operator>.</operator><name><name>index</name><index>[<expr><name>optionListIdx</name></expr>]</index></name><operator>.</operator><name>set</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                    <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' not valid without option '%s'"</literal></expr></argument>,
                                    <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>dependOptionName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <comment type="line">// Build type dependent error data</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>errorValue</name> <init>= <expr><name>EMPTY_STR</name></expr></init></decl>;</decl_stmt>

                            <switch>switch <condition>(<expr><call><name>cfgParseOptionDataType</name><argument_list>(<argument><expr><name>dependId</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <case>case <expr><name>cfgOptDataTypeBoolean</name></expr>:</case>
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pckReadBoolP</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                        <expr_stmt><expr><name>dependOptionName</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"no-%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>dependOptionName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                                    <break>break;</break>
                                </block_content>}</block>

                                <default>default:</default>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cfgParseOptionDataType</name><argument_list>(<argument><expr><name>dependId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cfgOptDataTypeStringId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>errorList</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                                    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>validSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                                    <while>while <condition>(<expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                                            <argument><expr><name>errorList</name></expr></argument>, <argument><expr><literal type="string">"%s'%s'"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>validSize</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name><name>parseRuleValueStrId</name><index>[<expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                        <expr_stmt><expr><name>validSize</name><operator>++</operator></expr>;</expr_stmt>
                                    </block_content>}</block></while>

                                    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>validSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <if_stmt><if>if <condition>(<expr><name>validSize</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                                        <expr_stmt><expr><name>errorValue</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">" = %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>errorList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                                    <else>else<block type="pseudo"><block_content>
                                        <expr_stmt><expr><name>errorValue</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">" in (%s)"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>errorList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                                </block_content>}</block>
                            </block_content>}</block></switch>

                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' not valid without option '%s'%s"</literal></expr></argument>,
                                <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>dependOptionName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>errorValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <expr_stmt><expr><call><name>pckReadFree</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>dependResult</name><operator>.</operator><name>valid</name></name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Is the option set?</comment>
                        <if_stmt><if>if <condition>(<expr><name>optionSet</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name><name>parseOptionValue</name><operator>-&gt;</operator><name>source</name></name></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>optionType</name> <operator>==</operator> <name>cfgOptTypeBoolean</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <operator>!</operator><name><name>parseOptionValue</name><operator>-&gt;</operator><name>negate</name></name></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><name>optionType</name> <operator>==</operator> <name>cfgOptTypeHash</name></expr>)</condition>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>config-&gt;memContext</argument>)</argument_list></macro>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>kvNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block>
                                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>listIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>listIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>parseOptionValue</name><operator>-&gt;</operator><name>valueList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>listIdx</name><operator>++</operator></expr></incr>)</control>
                                <block>{<block_content>
                                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>parseOptionValue</name><operator>-&gt;</operator><name>valueList</name></name></expr></argument>, <argument><expr><name>listIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>equal</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>pair</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                    <if_stmt><if>if <condition>(<expr><name>equal</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                            <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><literal type="string">"key/value '%s' not valid for '%s' option"</literal></expr></argument>,
                                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>parseOptionValue</name><operator>-&gt;</operator><name>valueList</name></name></expr></argument>, <argument><expr><name>listIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>

                                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>strNewZN</name><argument_list>(<argument><expr><name>pair</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>equal</name> <operator>-</operator> <name>pair</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRZ</name><argument_list>(<argument><expr><name>equal</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></for>

                                <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>keyValue</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><name>optionType</name> <operator>==</operator> <name>cfgOptTypeList</name></expr>)</condition>
                            <block>{<block_content>
                                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>config-&gt;memContext</argument>)</argument_list></macro>
                                <block>{<block_content>
                                    <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>list</name></name> <operator>=</operator> <call><name>varLstNewStrLst</name><argument_list>(<argument><expr><name><name>parseOptionValue</name><operator>-&gt;</operator><name>valueList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block>
                                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>parseOptionValue</name><operator>-&gt;</operator><name>valueList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>valueAllow</name> <init>= <expr><name>value</name></expr></init></decl>;</decl_stmt>

                                <comment type="line">// Preserve original value to display</comment>
                                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>config-&gt;memContext</argument>)</argument_list></macro>
                                <block>{<block_content>
                                    <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>display</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block>
                                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                                <comment type="line">// If a numeric type check that the value is valid</comment>
                                <if_stmt><if>if <condition>(<expr><name>optionType</name> <operator>==</operator> <name>cfgOptTypeInteger</name> <operator>||</operator> <name>optionType</name> <operator>==</operator> <name>cfgOptTypeSize</name> <operator>||</operator>
                                    <name>optionType</name> <operator>==</operator> <name>cfgOptTypeTime</name></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="line">// Check that the value can be converted</comment>
                                    <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
                                    <block>{<block_content>
                                        <switch>switch <condition>(<expr><name>optionType</name></expr>)</condition>
                                        <block>{<block_content>
                                            <case>case <expr><name>cfgOptTypeInteger</name></expr>:</case>
                                                <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>integer</name></name> <operator>=</operator> <call><name>cvtZToInt64</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                                <break>break;</break>

                                            <case>case <expr><name>cfgOptTypeSize</name></expr>:</case>
                                                <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>integer</name></name> <operator>=</operator> <call><name>cfgParseSize</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                                <break>break;</break>

                                            <default>default:</default>
                                            <block>{<block_content>
                                                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionType</name> <operator>==</operator> <name>cfgOptTypeTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                                <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>integer</name></name> <operator>=</operator> <call><name>cfgParseTime</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                                <break>break;</break>
                                            </block_content>}</block>
                                        </block_content>}</block></switch>
                                    </block_content>}</block>
                                    <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                            <argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"'%s' is not valid for '%s' option"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block>
                                    <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                                    <if_stmt><if>if <condition>(<expr><call><name>cfgParseOptionalRule</name><argument_list>(
                                            <argument><expr><operator>&amp;</operator><name>optionalRules</name></expr></argument>, <argument><expr><name>parseRuleOptionalTypeAllowRange</name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                                        <operator>(</operator><name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>integer</name></name> <operator>&lt;</operator> <name><name>optionalRules</name><operator>.</operator><name>allowRangeMin</name></name> <operator>||</operator>
                                         <name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>integer</name></name> <operator>&gt;</operator> <name><name>optionalRules</name><operator>.</operator><name>allowRangeMax</name></name><operator>)</operator></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                            <argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"'%s' is out of range for '%s' option"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if>
                                <comment type="line">// Else if StringId</comment>
                                <if type="elseif">else if <condition>(<expr><name>optionType</name> <operator>==</operator> <name>cfgOptTypeStringId</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>stringId</name></name> <operator>=</operator> <call><name>strIdFromZN</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>valueAllow</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>valueAllow</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <comment type="line">// Else if string make sure it is valid</comment>
                                <else>else
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>optionType</name> <operator>==</operator> <name>cfgOptTypePath</name> <operator>||</operator> <name>optionType</name> <operator>==</operator> <name>cfgOptTypeString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <comment type="line">// Set string value to display value</comment>
                                    <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>string</name></name> <operator>=</operator> <name><name>configOptionValue</name><operator>-&gt;</operator><name>display</name></name></expr>;</expr_stmt>

                                    <comment type="line">// Empty strings are not valid</comment>
                                    <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                            <argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"'%s' must be &gt;= 1 character for '%s' option"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>

                                    <comment type="line">// If path make sure it is valid</comment>
                                    <if_stmt><if>if <condition>(<expr><name>optionType</name> <operator>==</operator> <name>cfgOptTypePath</name></expr>)</condition>
                                    <block>{<block_content>
                                        <comment type="line">// Make sure it starts with /</comment>
                                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strBeginsWithZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                                        <block>{<block_content>
                                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                                <argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"'%s' must begin with / for '%s' option"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>

                                        <comment type="line">// Make sure there are no occurrences of //</comment>
                                        <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"//"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                                        <block>{<block_content>
                                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                                <argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"'%s' cannot contain // for '%s' option"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>

                                        <comment type="line">// If the path ends with a / we'll strip it off (unless the value is just /)</comment>
                                        <if_stmt><if>if <condition>(<expr><call><name>strEndsWithZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strSize</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
                                        <block>{<block_content>
                                            <expr_stmt><expr><call><name>strTruncIdx</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strSize</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                            <comment type="line">// Reset string value since it was modified</comment>
                                            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>config-&gt;memContext</argument>)</argument_list></macro>
                                            <block>{<block_content>
                                                <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>string</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            </block_content>}</block>
                                            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></else></if_stmt>

                                <comment type="line">// If the option has an allow list then check it</comment>
                                <if_stmt><if>if <condition>(<expr><call><name>cfgParseOptionalRule</name><argument_list>(
                                        <argument><expr><operator>&amp;</operator><name>optionalRules</name></expr></argument>, <argument><expr><name>parseRuleOptionalTypeAllowList</name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>allowList</name> <init>= <expr><call><name>pckReadNewC</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>.</operator><name>allowList</name></name></expr></argument>, <argument><expr><name><name>optionalRules</name><operator>.</operator><name>allowListSize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                    <decl_stmt><decl><type><name>bool</name></type> <name>allowListFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                                    <if_stmt><if>if <condition>(<expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>cfgOptTypeStringId</name></expr>)</condition>
                                    <block>{<block_content>
                                        <while>while <condition>(<expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name>allowList</name></expr></argument>)</argument_list></call></expr>)</condition>
                                        <block>{<block_content>
                                            <if_stmt><if>if <condition>(<expr><name><name>parseRuleValueStrId</name><index>[<expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>allowList</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>stringId</name></name></expr>)</condition>
                                            <block>{<block_content>
                                                <expr_stmt><expr><name>allowListFound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                                <break>break;</break>
                                            </block_content>}</block></if></if_stmt>
                                        </block_content>}</block></while>
                                    </block_content>}</block></if>
                                    <else>else
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>cfgOptTypeSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                        <while>while <condition>(<expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name>allowList</name></expr></argument>)</argument_list></call></expr>)</condition>
                                        <block>{<block_content>
                                            <if_stmt><if>if <condition>(<expr><name><name>parseRuleValueInt</name><index>[<expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>allowList</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>integer</name></name></expr>)</condition>
                                            <block>{<block_content>
                                                <expr_stmt><expr><name>allowListFound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                                <break>break;</break>
                                            </block_content>}</block></if></if_stmt>
                                        </block_content>}</block></while>
                                    </block_content>}</block></else></if_stmt>

                                    <expr_stmt><expr><call><name>pckReadFree</name><argument_list>(<argument><expr><name>allowList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowListFound</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                            <argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"'%s' is not allowed for '%s' option"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>valueAllow</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><name><name>parseOptionValue</name><operator>-&gt;</operator><name>negate</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name><name>parseOptionValue</name><operator>-&gt;</operator><name>source</name></name></expr>;</expr_stmt></block_content></block></if>
                        <comment type="line">// Else try to set a default</comment>
                        <else>else
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>config-&gt;memContext</argument>)</argument_list></macro>
                            <block>{<block_content>
                                <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>cfgParseOptionalRule</name><argument_list>(
                                    <argument><expr><operator>&amp;</operator><name>optionalRules</name></expr></argument>, <argument><expr><name>parseRuleOptionalTypeDefault</name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block>
                            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// If the option has a default</comment>
                            <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>optionalRules</name><operator>.</operator><name>defaultValue</name></name></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Else error if option is required and help was not requested</comment>
                            <else>else
                            <block>{<block_content>
                                <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>required</name> <init>= <expr><ternary><condition><expr><call><name>cfgParseOptionalRule</name><argument_list>(
                                    <argument><expr><operator>&amp;</operator><name>optionalRules</name></expr></argument>, <argument><expr><name>parseRuleOptionalTypeRequired</name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
                                        <expr><name><name>optionalRules</name><operator>.</operator><name>required</name></name></expr> </then><else>: <expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>required</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

                                <if_stmt><if>if <condition>(<expr><name>required</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>config</name><operator>-&gt;</operator><name>help</name></name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                        <argument><expr><name>OptionRequiredError</name></expr></argument>, <argument><expr><literal type="string">"%s command requires option: %s%s"</literal></expr></argument>,
                                        <argument><expr><call><name>cfgParseCommandName</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>cfgParseOptionKeyIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><ternary><condition><expr><name><name>parseRuleOption</name><index>[<expr><name>optionId</name></expr>]</index></name><operator>.</operator><name>section</name> <operator>==</operator> <name>cfgSectionStanza</name></expr> ?</condition><then>
                                            <expr><literal type="string">"\nHINT: does this stanza exist?"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Else apply the default for the unresolved dependency, if it exists</comment>
                    <if type="elseif">else if <condition>(<expr><name><name>dependResult</name><operator>.</operator><name>defaultExists</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>configOptionValue</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <name><name>dependResult</name><operator>.</operator><name>defaultValue</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>pckReadFree</name><argument_list>(<argument><expr><name><name>optionalRules</name><operator>.</operator><name>pack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Initialize config</comment>
        <expr_stmt><expr><call><name>cfgInit</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Set option group default index. The first index in the group is automatically set unless the group option, e.g. pg, is</comment>
        <comment type="line">// set. For now the group default options are hard-coded but they could be dynamic. An assert has been added to make sure</comment>
        <comment type="line">// the code breaks if a new group is added.</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>groupId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>groupId</name> <operator>&lt;</operator> <name>CFG_OPTION_GROUP_TOTAL</name></expr>;</condition> <incr><expr><name>groupId</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>groupId</name> <operator>==</operator> <name>cfgOptGrpPg</name> <operator>||</operator> <name>groupId</name> <operator>==</operator> <name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Get the group default option</comment>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>defaultOptionId</name> <init>= <expr><ternary><condition><expr><name>groupId</name> <operator>==</operator> <name>cfgOptGrpPg</name></expr> ?</condition><then> <expr><name>cfgOptPg</name></expr> </then><else>: <expr><name>cfgOptRepo</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <comment type="line">// Does a default always exist?</comment>
            <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>indexDefaultExists</name> <operator>=</operator>
                <comment type="line">// A default always exists for the pg group</comment>
                <name>groupId</name> <operator>==</operator> <name>cfgOptGrpPg</name> <operator>||</operator>
                <comment type="line">// The repo group allows a default when the repo option is valid, i.e. either repo1 is the only key set or a repo</comment>
                <comment type="line">// is specified</comment>
                <call><name>cfgOptionValid</name><argument_list>(<argument><expr><name>cfgOptRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Does the group default option exist?</comment>
            <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>defaultOptionId</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Search for the key</comment>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>optionKeyIdx</name> <init>= <expr><call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>defaultOptionId</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name><name>indexMap</name><index>[<expr><name>index</name></expr>]</index></name> <operator>==</operator> <name>optionKeyIdx</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="line">// Error if the key was not found</comment>
                <if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                        <argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"key '%s' is not valid for '%s' option"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionDisplay</name><argument_list>(<argument><expr><name>defaultOptionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>cfgOptionName</name><argument_list>(<argument><expr><name>defaultOptionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Set the default</comment>
                <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>indexDefault</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>optionGroup</name><index>[<expr><name>groupId</name></expr>]</index></name><operator>.</operator><name>indexDefaultExists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
