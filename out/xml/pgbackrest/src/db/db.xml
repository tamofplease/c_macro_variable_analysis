<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/db/db.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Database Client
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/wait.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db/db.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db/protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Constants
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_BACKUP_ADVISORY_LOCK</name></cpp:macro>                                     <cpp:value>"12340078987004321"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DB_PING_SEC</name></cpp:macro>                                                 <cpp:value>30</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Object type
***********************************************************************************************************************************/</comment>
<struct>struct <name>Db</name>
<block>{
    <decl_stmt><decl><type><name>DbPub</name></type> <name>pub</name></decl>;</decl_stmt>                                                      <comment type="line">// Publicly accessible variables</comment>
    <decl_stmt><decl><type><name>PgClient</name> <modifier>*</modifier></type><name>client</name></decl>;</decl_stmt>                                               <comment type="line">// Local PostgreSQL client</comment>
    <decl_stmt><decl><type><name>ProtocolClient</name> <modifier>*</modifier></type><name>remoteClient</name></decl>;</decl_stmt>                                   <comment type="line">// Protocol client for remote db queries</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>remoteIdx</name></decl>;</decl_stmt>                                         <comment type="line">// Index provided by the remote on open for subsequent calls</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storage</name></decl>;</decl_stmt>                                         <comment type="line">// PostgreSQL storage</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>applicationName</name></decl>;</decl_stmt>                                  <comment type="line">// Used to identify this connection in PostgreSQL</comment>
    <decl_stmt><decl><type><name>time_t</name></type> <name>pingTimeLast</name></decl>;</decl_stmt>                                            <comment type="line">// Last time cluster was pinged</comment>
}</block>;</struct>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Close protocol connection.  No need to close a locally created PgClient since it has its own destructor.
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dbFreeResource</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>Db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ProtocolCommand</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>protocolCommandNew</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND_DB_CLOSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><call><name>protocolCommandParam</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>remoteIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>protocolClientExecute</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>remoteClient</name></name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>protocolCommandFree</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Db</name> <modifier>*</modifier></type>
<name>dbNew</name><parameter_list>(<parameter><decl><type><name>PgClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>, <parameter><decl><type><name>ProtocolClient</name> <modifier>*</modifier></type><name>remoteClient</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storage</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>applicationName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PG_CLIENT</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name>remoteClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>applicationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>client</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>remoteClient</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>client</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>remoteClient</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>storage</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>applicationName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>Db</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>, <argument>.callbackQty = <literal type="number">1</literal></argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>Db</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>pub</name> <operator>=</operator>
            <block>{
                <expr><operator>.</operator><name>memContext</name> <operator>=</operator> <call><name>memContextCurrent</name><argument_list>()</argument_list></call></expr>,
            }</block></expr>,
            <expr><operator>.</operator><name>remoteClient</name> <operator>=</operator> <name>remoteClient</name></expr>,
            <expr><operator>.</operator><name>storage</name> <operator>=</operator> <name>storage</name></expr>,
            <expr><operator>.</operator><name>applicationName</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>applicationName</name></expr></argument>)</argument_list></call></expr>,
        }</block></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>client</name></name> <operator>=</operator> <call><name>pgClientMove</name><argument_list>(<argument><expr><name>client</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>memContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Execute a query
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>Pack</name> <modifier>*</modifier></type>
<name>dbQuery</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PgClientQueryResult</name></type> <name>resultType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>resultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>resultType</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>query</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Pack</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Query remotely</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>remoteClient</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ProtocolCommand</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>protocolCommandNew</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND_DB_QUERY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>param</name> <init>= <expr><call><name>protocolCommandParam</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>remoteIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteStrIdP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>resultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pckReadPackP</name><argument_list>(<argument><expr><call><name>protocolClientExecute</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>remoteClient</name></name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else locally</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgClientQuery</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>resultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PACK</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Execute a command that expects no output
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dbExec</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>command</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><call><name>dbQuery</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pgClientQueryResultNone</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"exec returned data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Execute a query that returns a single row and column
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>PackRead</name> <modifier>*</modifier></type>
<name>dbQueryColumn</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>query</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PACK_READ</name></expr></argument>, <argument><expr><call><name>pckReadNew</name><argument_list>(<argument><expr><call><name>dbQuery</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pgClientQueryResultColumn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Execute a query that returns a single row
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>PackRead</name> <modifier>*</modifier></type>
<name>dbQueryRow</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>query</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PACK_READ</name></expr></argument>, <argument><expr><call><name>pckReadNew</name><argument_list>(<argument><expr><call><name>dbQuery</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pgClientQueryResultRow</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Is the cluster in recovery?
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dbIsInRecovery</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>PG_VERSION_HOT_STANDBY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pckReadBoolP</name><argument_list>(<argument><expr><call><name>dbQueryColumn</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"select pg_catalog.pg_is_in_recovery()"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>dbOpen</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Open the connection</comment>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>remoteClient</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ProtocolCommand</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>protocolCommandNew</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND_DB_OPEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>remoteIdx</name></name> <operator>=</operator> <call><name>pckReadU32P</name><argument_list>(<argument><expr><call><name>protocolClientExecute</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>remoteClient</name></name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Set a callback to notify the remote when a connection is closed</comment>
            <expr_stmt><expr><call><name>memContextCallbackSet</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>memContext</name></name></expr></argument>, <argument><expr><name>dbFreeResource</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Get db-timeout from the remote since it might be different than the local value</comment>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>dbTimeout</name></name> <operator>=</operator> <call><name>varUInt64Force</name><argument_list>(
                <argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><call><name>configOptionRemote</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>remoteClient</name></name></expr></argument>, <argument><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varNewStrZ</name><argument_list>(<argument><expr><name>CFGOPT_DB_TIMEOUT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>pgClientOpen</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>dbTimeout</name></name> <operator>=</operator> <call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptDbTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// Set search_path to prevent overrides of the functions we expect to call.  All queries should also be schema-qualified,</comment>
        <comment type="line">// but this is an extra level protection.</comment>
        <expr_stmt><expr><call><name>dbExec</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"set search_path = 'pg_catalog'"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Set client encoding to UTF8.  This is the only encoding (other than ASCII) that we can safely work with.</comment>
        <expr_stmt><expr><call><name>dbExec</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"set client_encoding = 'UTF8'"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Query the version and data_directory. Be sure the update the total in the null check below when adding/removing columns.</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>Pack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>row</name> <init>= <expr><call><name>dbQuery</name><argument_list>(
            <argument><expr><name>this</name></expr></argument>, <argument><expr><name>pgClientQueryResultRow</name></expr></argument>,
            <argument><expr><call><name>STRDEF</name><argument_list>(
                <argument><expr><literal type="string">"select (select setting from pg_catalog.pg_settings where name = 'server_version_num')::int4,"</literal>
                <literal type="string">" (select setting from pg_catalog.pg_settings where name = 'data_directory')::text,"</literal>
                <literal type="string">" (select setting from pg_catalog.pg_settings where name = 'archive_mode')::text,"</literal>
                <literal type="string">" (select setting from pg_catalog.pg_settings where name = 'archive_command')::text,"</literal>
                <literal type="string">" (select setting from pg_catalog.pg_settings where name = 'checkpoint_timeout')::int4"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Check that none of the return values are null, which indicates the user cannot select some rows in pg_settings</comment>
        <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier></type><name>read</name> <init>= <expr><call><name>pckReadNew</name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>columnIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIdx</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>columnIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>pckReadNullP</name><argument_list>(<argument><expr><name>read</name></expr></argument>, <argument><expr><operator>.</operator><name>id</name> <operator>=</operator> <name>columnIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW</name><argument_list>(
                    <argument><expr><name>DbQueryError</name></expr></argument>,
                    <argument><expr><literal type="string">"unable to select some rows from pg_settings\n"</literal>
                        <literal type="string">"HINT: is the backup running as the postgres user?\n"</literal>
                        <literal type="string">"HINT: is the pg_read_all_settings role assigned for "</literal> <name>PG_NAME</name> <literal type="string">" &gt;= "</literal> <name>PG_VERSION_10_STR</name> <literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Restart the read to get the data</comment>
        <expr_stmt><expr><name>read</name> <operator>=</operator> <call><name>pckReadNew</name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Strip the minor version off since we don't need it.  In the future it might be a good idea to warn users when they are</comment>
        <comment type="line">// running an old minor version.</comment>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>pgVersion</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>pckReadI32P</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">100</literal> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt>

        <comment type="line">// Store the data directory that PostgreSQL is running in, the archive mode, and archive command. These can be compared to</comment>
        <comment type="line">// the configured pgBackRest directory, and archive settings checked for validity, when validating the configuration.</comment>
        <comment type="line">// Also store the checkpoint timeout to warn in case a backup is requested without using the start-fast option.</comment>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>this-&gt;pub.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>pgDataPath</name></name> <operator>=</operator> <call><name>pckReadStrP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>archiveMode</name></name> <operator>=</operator> <call><name>pckReadStrP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>archiveCommand</name></name> <operator>=</operator> <call><name>pckReadStrP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>checkpointTimeout</name></name> <operator>=</operator> <operator>(</operator><name>TimeMSec</name><operator>)</operator><call><name>pckReadI32P</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>MSEC_PER_SEC</name></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Set application name to help identify the backup session</comment>
        <expr_stmt><expr><call><name>dbExec</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"set application_name = '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>applicationName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// There is no need to have parallelism enabled in a backup session. In particular, 9.6 marks pg_stop_backup() as</comment>
        <comment type="line">// parallel-safe but an error will be thrown if pg_stop_backup() is run in a worker.</comment>
        <if_stmt><if>if <condition>(<expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>PG_VERSION_PARALLEL_QUERY</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dbExec</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"set max_parallel_workers_per_gather = 0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Is the cluster a standby?</comment>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>standby</name></name> <operator>=</operator> <call><name>dbIsInRecovery</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Get control file</comment>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>pgControl</name></name> <operator>=</operator> <call><name>pgControlFromFile</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<comment type="line">// Helper to build start backup query</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>dbBackupStartQuery</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>startFast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>startFast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Build query to return start lsn and WAL segment name</comment>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>strCatFmt</name><argument_list>(
        <argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"select lsn::text as lsn,\n"</literal>
        <literal type="string">"       pg_catalog.pg_%sfile_name(lsn)::text as wal_segment_name\n"</literal>
        <literal type="string">"  from pg_catalog.pg_%s('"</literal> <name>PROJECT_NAME</name> <literal type="string">" backup started at ' || current_timestamp"</literal></expr></argument>,
        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgWalName</name><argument_list>(<argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr> ?</condition><then> <expr><literal type="string">"backup_start"</literal></expr> </then><else>: <expr><literal type="string">"start_backup"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Start backup after immediate checkpoint</comment>
    <if_stmt><if>if <condition>(<expr><name>startFast</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">", "</literal> <name>TRUE_Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else start backup at the next scheduled checkpoint</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">", "</literal> <name>FALSE_Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="line">// Use non-exclusive backup mode when available</comment>
    <if_stmt><if>if <condition>(<expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_96</name> <operator>&amp;&amp;</operator> <name>pgVersion</name> <operator>&lt;=</operator> <name>PG_VERSION_14</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">", "</literal> <name>FALSE_Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Complete query</comment>
    <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">") as lsn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>DbBackupStartResult</name></type>
<name>dbBackupStart</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>startFast</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>stopAuto</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>archiveCheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>startFast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>stopAuto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>archiveCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>DbBackupStartResult</name></type> <name>result</name> <init>= <expr><block>{<expr><operator>.</operator><name>lsn</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Acquire the backup advisory lock to make sure that backups are not running from multiple backup servers against the same</comment>
        <comment type="line">// database cluster.  This lock helps make the stop-auto option safe.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pckReadBoolP</name><argument_list>(<argument><expr><call><name>dbQueryColumn</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"select pg_catalog.pg_try_advisory_lock("</literal> <name>PG_BACKUP_ADVISORY_LOCK</name> <literal type="string">")::bool"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW</name><argument_list>(
                <argument><expr><name>LockAcquireError</name></expr></argument>,
                <argument><expr><literal type="string">"unable to acquire "</literal> <name>PROJECT_NAME</name> <literal type="string">" advisory lock\n"</literal>
                <literal type="string">"HINT: is another "</literal> <name>PROJECT_NAME</name> <literal type="string">" backup already running on this cluster?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If stop-auto is enabled check for a running backup</comment>
        <if_stmt><if>if <condition>(<expr><name>stopAuto</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>PG_VERSION_93</name></expr></argument>, <argument><expr><literal type="string">"feature not supported in PostgreSQL &lt; "</literal> <name>PG_VERSION_93_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Feature is not needed for PostgreSQL &gt;= 9.6 since backups are run in non-exclusive mode</comment>
            <if_stmt><if>if <condition>(<expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>PG_VERSION_96</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>pckReadBoolP</name><argument_list>(<argument><expr><call><name>dbQueryColumn</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"select pg_catalog.pg_is_in_backup()::bool"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(
                        <argument><expr><literal type="string">"the cluster is already in backup mode but no "</literal> <name>PROJECT_NAME</name> <literal type="string">" backup process is running."</literal>
                        <literal type="string">" pg_stop_backup() will be called so a new backup can be started."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>dbBackupStop</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// When the start-fast option is disabled and db-timeout is smaller than checkpoint_timeout, the command may timeout</comment>
        <comment type="line">// before the backup actually starts</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>startFast</name> <operator>&amp;&amp;</operator> <call><name>dbDbTimeout</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>dbCheckpointTimeout</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                <argument><expr><name>CFGOPT_START_FAST</name> <literal type="string">" is disabled and "</literal> <name>CFGOPT_DB_TIMEOUT</name> <literal type="string">" (%"</literal> <name>PRIu64</name> <literal type="string">"s) is smaller than the "</literal> <name>PG_NAME</name>
                    <literal type="string">" checkpoint_timeout (%"</literal> <name>PRIu64</name> <literal type="string">"s) - timeout may occur before the backup starts"</literal></expr></argument>,
                <argument><expr><call><name>dbDbTimeout</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>MSEC_PER_SEC</name></expr></argument>, <argument><expr><call><name>dbCheckpointTimeout</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>MSEC_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If archive check then get the current WAL segment</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegmentCheck</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>archiveCheck</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>walSegmentCheck</name> <operator>=</operator> <call><name>pckReadStrP</name><argument_list>(
                <argument><expr><call><name>dbQueryColumn</name><argument_list>(
                    <argument><expr><name>this</name></expr></argument>,
                    <argument><expr><call><name>strNewFmt</name><argument_list>(
                        <argument><expr><literal type="string">"select pg_catalog.pg_%sfile_name(pg_catalog.pg_current_%s_insert_%s())::text"</literal></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgWalName</name><argument_list>(<argument><expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgWalName</name><argument_list>(<argument><expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgLsnName</name><argument_list>(<argument><expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Start backup</comment>
        <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>read</name> <init>= <expr><call><name>dbQueryRow</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>dbBackupStartQuery</name><argument_list>(<argument><expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>startFast</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Make sure the backup start checkpoint was written to pg_control. This helps ensure that we have a consistent view of the</comment>
        <comment type="line">// storage with PostgreSQL.</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>PgControl</name></type> <name>pgControl</name> <init>= <expr><call><name>pgControlFromFile</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>lsnStart</name> <init>= <expr><call><name>pckReadStrP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>pgControl</name><operator>.</operator><name>checkpoint</name></name> <operator>&lt;</operator> <call><name>pgLsnFromStr</name><argument_list>(<argument><expr><name>lsnStart</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                <argument><expr><name>DbMismatchError</name></expr></argument>, <argument><expr><literal type="string">"current checkpoint '%s' is less than backup start '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgLsnToStr</name><argument_list>(<argument><expr><name><name>pgControl</name><operator>.</operator><name>checkpoint</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>lsnStart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If archive check then make sure WAL segment was switched on start backup</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>walSegmentName</name> <init>= <expr><call><name>pckReadStrP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>archiveCheck</name> <operator>&amp;&amp;</operator> <call><name>strEq</name><argument_list>(<argument><expr><name>walSegmentCheck</name></expr></argument>, <argument><expr><name>walSegmentName</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If the version supports restore points then force a WAL switch</comment>
            <if_stmt><if>if <condition>(<expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>PG_VERSION_RESTORE_POINT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>dbWalSwitch</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else disable the check. All WAL will still be checked at the end of the backup.</comment>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>walSegmentCheck</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Check that the WAL timeline matches what is in pg_control</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pgTimelineFromWalSegment</name><argument_list>(<argument><expr><name>walSegmentName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>dbPgControl</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>.</operator><name>timeline</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                <argument><expr><name>DbMismatchError</name></expr></argument>, <argument><expr><literal type="string">"WAL timeline %u does not match "</literal> <name>PG_FILE_PGCONTROL</name> <literal type="string">" timeline %u"</literal></expr></argument>,
                <argument><expr><call><name>pgTimelineFromWalSegment</name><argument_list>(<argument><expr><name>walSegmentName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>dbPgControl</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>.</operator><name>timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Return results</comment>
        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>lsn</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>lsnStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>walSegmentName</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>walSegmentName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>walSegmentCheck</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>walSegmentCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_STRUCT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<comment type="line">// Helper to build stop backup query</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>dbBackupStopQuery</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Build query to return start lsn and WAL segment name</comment>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>strCatFmt</name><argument_list>(
        <argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"select lsn::text as lsn,\n"</literal>
        <literal type="string">"       pg_catalog.pg_%sfile_name(lsn)::text as wal_segment_name"</literal></expr></argument>,
        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgWalName</name><argument_list>(<argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// For PostgreSQL &gt;= 9.6 the backup label and tablespace map are returned</comment>
    <if_stmt><if>if <condition>(<expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_96</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(
            <argument><expr><name>result</name></expr></argument>,
            <argument><expr><literal type="string">",\n"</literal>
            <literal type="string">"       labelfile::text as backuplabel_file,\n"</literal>
            <literal type="string">"       spcmapfile::text as tablespacemap_file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Build stop backup function</comment>
    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
        <argument><expr><name>result</name></expr></argument>,
        <argument><expr><literal type="string">"\n"</literal>
        <literal type="string">"  from pg_catalog.pg_%s("</literal></expr></argument>,
        <argument><expr><ternary><condition><expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr> ?</condition><then> <expr><literal type="string">"backup_stop"</literal></expr> </then><else>: <expr><literal type="string">"stop_backup"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Use non-exclusive backup mode when available</comment>
    <if_stmt><if>if <condition>(<expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_96</name> <operator>&amp;&amp;</operator> <name>pgVersion</name> <operator>&lt;=</operator> <name>PG_VERSION_14</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>FALSE_Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Disable archive checking since we do this elsewhere</comment>
    <if_stmt><if>if <condition>(<expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_10</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>pgVersion</name> <operator>&lt;=</operator> <name>PG_VERSION_14</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>FALSE_Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Complete query</comment>
    <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgVersion</name> <operator>&lt;</operator> <name>PG_VERSION_96</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">" as lsn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>DbBackupStopResult</name></type>
<name>dbBackupStop</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>DbBackupStopResult</name></type> <name>result</name> <init>= <expr><block>{<expr><operator>.</operator><name>lsn</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Stop backup</comment>
        <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>read</name> <init>= <expr><call><name>dbQueryRow</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>dbBackupStopQuery</name><argument_list>(<argument><expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Return results</comment>
        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>lsn</name></name> <operator>=</operator> <call><name>pckReadStrP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>walSegmentName</name></name> <operator>=</operator> <call><name>pckReadStrP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>PG_VERSION_96</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>backupLabel</name></name> <operator>=</operator> <call><name>pckReadStrP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Return the tablespace map if it is not empty</comment>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tablespaceMap</name> <init>= <expr><call><name>pckReadStrP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tablespaceMapTrim</name> <init>= <expr><call><name>strTrim</name><argument_list>(<argument><expr><call><name>strDup</name><argument_list>(<argument><expr><name>tablespaceMap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEmpty</name><argument_list>(<argument><expr><name>tablespaceMapTrim</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>tablespaceMap</name></name> <operator>=</operator> <name>tablespaceMap</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><name>tablespaceMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><name>tablespaceMapTrim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_STRUCT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Pack</name> <modifier>*</modifier></type>
<name>dbList</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(
        <argument><expr><name>PACK</name></expr></argument>,
        <argument><expr><call><name>dbQuery</name><argument_list>(
            <argument><expr><name>this</name></expr></argument>, <argument><expr><name>pgClientQueryResultAny</name></expr></argument>,
            <argument><expr><call><name>STRDEF</name><argument_list>(
                <argument><expr><literal type="string">"select oid::oid, datname::text, (select oid::oid from pg_catalog.pg_database where datname = 'template0')"</literal>
                    <literal type="string">" as datlastsysoid from pg_catalog.pg_database"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>dbReplayWait</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>targetLsn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>targetTimeline</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TimeMSec</name></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>targetLsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>targetTimeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>TIME_MSEC</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>targetLsn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>targetTimeline</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>

        <comment type="line">// Standby checkpoint before the backup started must be &lt;= the target LSN. If not, it indicates that the standby was ahead</comment>
        <comment type="line">// of the primary and cannot be following it.</comment>
        <if_stmt><if>if <condition>(<expr><call><name>dbPgControl</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>.</operator><name>checkpoint</name> <operator>&gt;</operator> <call><name>pgLsnFromStr</name><argument_list>(<argument><expr><name>targetLsn</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                <argument><expr><name>DbMismatchError</name></expr></argument>, <argument><expr><literal type="string">"standby checkpoint '%s' is ahead of target '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgLsnToStr</name><argument_list>(<argument><expr><call><name>dbPgControl</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>.</operator><name>checkpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>targetLsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Loop until lsn has been reached or timeout</comment>
        <decl_stmt><decl><type><name>Wait</name> <modifier>*</modifier></type><name>wait</name> <init>= <expr><call><name>waitNew</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>targetReached</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lsnName</name> <init>= <expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgLsnName</name><argument_list>(<argument><expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>replayLsnFunction</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(
            <argument><expr><literal type="string">"pg_catalog.pg_last_%s_replay_%s()"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgWalName</name><argument_list>(<argument><expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lsnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>replayLsn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <do>do
        <block>{<block_content>
            <comment type="line">// Build the query</comment>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>strCatFmt</name><argument_list>(
                <argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><literal type="string">"select replayLsn::text,\n"</literal>
                <literal type="string">"       (replayLsn &gt; '%s')::bool as targetReached"</literal></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>targetLsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>replayLsn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                    <argument><expr><name>query</name></expr></argument>,
                    <argument><expr><literal type="string">",\n"</literal>
                    <literal type="string">"       (replayLsn &gt; '%s')::bool as replayProgress"</literal></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>replayLsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                <argument><expr><name>query</name></expr></argument>,
                <argument><expr><literal type="string">"\n"</literal>
                <literal type="string">"  from %s as replayLsn"</literal></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>replayLsnFunction</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Execute the query and get replayLsn</comment>
            <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier></type><name>read</name> <init>= <expr><call><name>dbQueryRow</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>replayLsn</name> <operator>=</operator> <call><name>pckReadStrP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Error when replayLsn is null which indicates that this is not a standby.  This should have been sorted out before we</comment>
            <comment type="line">// connected but it's possible that the standby was promoted in the meantime.</comment>
            <if_stmt><if>if <condition>(<expr><name>replayLsn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>ArchiveTimeoutError</name></expr></argument>,
                    <argument><expr><literal type="string">"unable to query replay lsn on the standby using '%s'\n"</literal>
                    <literal type="string">"HINT: Is this a standby?"</literal></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>replayLsnFunction</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>targetReached</name> <operator>=</operator> <call><name>pckReadBoolP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If the target has not been reached but progress is being made then reset the timer</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>targetReached</name> <operator>&amp;&amp;</operator> <call><name>pckReadBoolP</name><argument_list>(<argument><expr><name>read</name></expr></argument>, <argument><expr><operator>.</operator><name>defaultValue</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>wait</name> <operator>=</operator> <call><name>waitNew</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>protocolKeepAlive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        while <condition>(<expr><operator>!</operator><name>targetReached</name> <operator>&amp;&amp;</operator> <call><name>waitMore</name><argument_list>(<argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <comment type="line">// Error if a timeout occurred before the target lsn was reached</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>targetReached</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                <argument><expr><name>ArchiveTimeoutError</name></expr></argument>,
                <argument><expr><literal type="string">"timeout before standby replayed to %s - only reached %s\n"</literal>
                <literal type="string">"HINT: is replication running and current on the standby?\n"</literal>
                <literal type="string">"HINT: disable the 'backup-standby' option to backup directly from the primary."</literal></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>targetLsn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>replayLsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Perform a checkpoint</comment>
        <expr_stmt><expr><call><name>dbExec</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"checkpoint"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// On PostgreSQL &gt;= 9.6 the checkpoint location can be verified so loop until lsn has been reached or timeout</comment>
        <if_stmt><if>if <condition>(<expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>PG_VERSION_96</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>wait</name> <operator>=</operator> <call><name>waitNew</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>targetReached</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>checkpointLsn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <do>do
            <block>{<block_content>
                <comment type="line">// Build the query</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(
                    <argument><expr><literal type="string">"select (checkpoint_%s &gt; '%s')::bool as targetReached,\n"</literal>
                    <literal type="string">"       checkpoint_%s::text as checkpointLsn\n"</literal>
                    <literal type="string">"  from pg_catalog.pg_control_checkpoint()"</literal></expr></argument>,
                    <argument><expr><name>lsnName</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>targetLsn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lsnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Execute the query and get checkpointLsn</comment>
                <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>read</name> <init>= <expr><call><name>dbQueryRow</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>targetReached</name> <operator>=</operator> <call><name>pckReadBoolP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>checkpointLsn</name> <operator>=</operator> <call><name>pckReadStrP</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>protocolKeepAlive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><operator>!</operator><name>targetReached</name> <operator>&amp;&amp;</operator> <call><name>waitMore</name><argument_list>(<argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

            <comment type="line">// Error if a timeout occurred before the target lsn was reached</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>targetReached</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>ArchiveTimeoutError</name></expr></argument>, <argument><expr><literal type="string">"timeout before standby checkpoint lsn reached %s - only reached %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>targetLsn</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>checkpointLsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Reload pg_control in case timeline was updated by the checkpoint</comment>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>pgControl</name></name> <operator>=</operator> <call><name>pgControlFromFile</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Check that the timeline matches the primary</comment>
        <if_stmt><if>if <condition>(<expr><call><name>dbPgControl</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>.</operator><name>timeline</name> <operator>!=</operator> <name>targetTimeline</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>DbMismatchError</name></expr></argument>, <argument><expr><literal type="string">"standby is on timeline %u but expected %u"</literal></expr></argument>, <argument><expr><call><name>dbPgControl</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>.</operator><name>timeline</name></expr></argument>, <argument><expr><name>targetTimeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>dbPing</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Ping if forced or interval has elapsed</comment>
        <decl_stmt><decl><type><name>time_t</name></type> <name>timeNow</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>force</name> <operator>||</operator> <name>timeNow</name> <operator>-</operator> <name><name>this</name><operator>-&gt;</operator><name>pingTimeLast</name></name> <operator>&gt;</operator> <name>DB_PING_SEC</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Make sure recovery state has not changed</comment>
            <if_stmt><if>if <condition>(<expr><call><name>dbIsInRecovery</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>dbIsStandby</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If this is the standby then it must have been promoted</comment>
                <if_stmt><if>if <condition>(<expr><call><name>dbIsStandby</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW</name><argument_list>(
                        <argument><expr><name>DbMismatchError</name></expr></argument>,
                        <argument><expr><literal type="string">"standby is no longer in recovery\n"</literal>
                        <literal type="string">"HINT: was the standby promoted during the backup?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else if a primary then something has gone seriously wrong</comment>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"primary has switched to recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pingTimeLast</name></name> <operator>=</operator> <name>timeNow</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Pack</name> <modifier>*</modifier></type>
<name>dbTablespaceList</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(
        <argument><expr><name>PACK</name></expr></argument>,
        <argument><expr><call><name>dbQuery</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pgClientQueryResultAny</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"select oid::oid, spcname::text from pg_catalog.pg_tablespace"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>TimeMSec</name></type>
<name>dbTimeMSec</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>TimeMSec</name></type> <name>result</name></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimeMSec</name><operator>)</operator><call><name>pckReadI64P</name><argument_list>(
            <argument><expr><call><name>dbQueryColumn</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"select (extract(epoch from clock_timestamp()) * 1000)::bigint"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>TIME_MSEC</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>dbWalSwitch</name><parameter_list>(<parameter><decl><type><name>Db</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Create a restore point to ensure current WAL will be archived.  For versions &lt; 9.1 activity will need to be generated by</comment>
        <comment type="line">// the user if there have been no writes since the last WAL switch.</comment>
        <if_stmt><if>if <condition>(<expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>PG_VERSION_RESTORE_POINT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dbQueryColumn</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"select pg_catalog.pg_create_restore_point('"</literal> <name>PROJECT_NAME</name> <literal type="string">" Archive Check')::text"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Request a WAL segment switch</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>walName</name> <init>= <expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgWalName</name><argument_list>(<argument><expr><call><name>dbPgVersion</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walFileName</name> <init>= <expr><call><name>pckReadStrP</name><argument_list>(
            <argument><expr><call><name>dbQueryColumn</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"select pg_catalog.pg_%sfile_name(pg_catalog.pg_switch_%s())::text"</literal></expr></argument>, <argument><expr><name>walName</name></expr></argument>, <argument><expr><name>walName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Copy WAL segment name to the prior context</comment>
        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>walFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>dbToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Db</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strNewFmt</name><argument_list>(
        <argument><expr><literal type="string">"{client: %s, remoteClient: %s}"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>this</name><operator>-&gt;</operator><name>client</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL_Z</name></expr> </then><else>: <expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgClientToLog</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>client</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
        <argument><expr><ternary><condition><expr><name><name>this</name><operator>-&gt;</operator><name>remoteClient</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL_Z</name></expr> </then><else>: <expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>protocolClientToLog</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>remoteClient</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
