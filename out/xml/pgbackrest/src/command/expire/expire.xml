<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/command/expire/expire.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Expire Command
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/archive/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/backup/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/control/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/regExp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoArchive.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoBackup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/manifest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Helper functions and structures
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>ArchiveExpired</name>
<block>{
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>total</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>stop</name></decl>;</decl_stmt>
}</block></struct></type> <name>ArchiveExpired</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ArchiveRange</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>stop</name></decl>;</decl_stmt>
}</block></struct></type> <name>ArchiveRange</name>;</typedef>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Given a backup label, expire a backup and all its dependents (if any).
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>StringList</name> <modifier>*</modifier></type>
<name>expireBackup</name><parameter_list>(<parameter><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupLabel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoBackup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>backupLabel</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Return a list of all backups being expired</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get the backup and all its dependents sorted from newest to oldest - that way if the process is aborted before all</comment>
        <comment type="line">// dependencies have been dealt with, the backups remaining should still be usable.</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>backupList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(<argument><expr><call><name>infoBackupDataDependentList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Expire each backup in the list</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>removeBackupLabel</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Execute the real expiration and deletion only if the dry-run option is disabled</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionValid</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Remove the manifest files to invalidate the backup</comment>
                <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(
                    <argument><expr><call><name>storageRepoIdxWrite</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>BACKUP_MANIFEST_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>removeBackupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(
                    <argument><expr><call><name>storageRepoIdxWrite</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><macro><name>strNewFmt</name><argument_list>(<argument>STORAGE_REPO_BACKUP <literal type="string">"/%s/"</literal> BACKUP_MANIFEST_FILE INFO_COPY_EXT</argument>, <argument>strZ(removeBackupLabel)</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Remove the backup from the info object</comment>
            <expr_stmt><expr><call><name>infoBackupDataDelete</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>removeBackupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>removeBackupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Sort from oldest to newest and return the list of expired backups</comment>
        <expr_stmt><expr><call><name>strLstSort</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Function to expire a selected backup (and all its dependents) regardless of retention rules.
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>expireAdhocBackup</name><parameter_list>(<parameter><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupLabel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoBackup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>backupLabel</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get a list of all full backups with most recent in position 0</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>fullList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(<argument><expr><call><name>infoBackupDataLabelList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If the requested backup to expire is the latest full backup</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>fullList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If the latest full backup requested is the only backup or the prior full backup is not for the same db-id</comment>
            <comment type="line">// then the backup requested cannot be expired</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>fullList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>infoBackupDataByLabel</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupPgId</name> <operator>!=</operator>
                <call><name>infoBackupDataByLabel</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>fullList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupPgId</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>BackupSetInvalidError</name></expr></argument>,
                    <argument><expr><literal type="string">"full backup %s cannot be expired until another full backup has been created on this repo"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Save off what is currently the latest backup (it may be removed if it is the adhoc backup or is a dependent of the</comment>
        <comment type="line">// adhoc backup</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>latestBackup</name> <init>= <expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>.</operator><name>backupLabel</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Expire the requested backup and any dependents</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>backupExpired</name> <init>= <expr><call><name>expireBackup</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If the latest backup was removed, then update the latest link if not a dry-run</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>infoBackupLabelExists</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>latestBackup</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If retention settings have been configured, then there may be holes in the archives. For example, if the archive</comment>
            <comment type="line">// for db-id=1 has 01,02,03,04,05 and F1 backup has archive start-stop 02-03 and retention-full=1</comment>
            <comment type="line">// (hence retention-archive=1 and retention-archive-type=full), then when F2 backup is created and assuming its</comment>
            <comment type="line">// archive start-stop=05-06 then archives 01 and 04 will be removed resulting in F1 not being able to play through</comment>
            <comment type="line">// PITR, which is expected. Now adhoc expire is attempted on F2 - it will be allowed but now there will be no</comment>
            <comment type="line">// backups that can be recovered through PITR until the next full backup is created. Same problem for differential</comment>
            <comment type="line">// backups with retention-diff.</comment>
            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                <argument><expr><literal type="string">"%s: expiring latest backup %s - the ability to perform point-in-time-recovery (PITR) may be affected\n"</literal>
                <literal type="string">"HINT: non-default settings for '%s'/'%s' (even in prior expires) can cause gaps in the WAL."</literal></expr></argument>,
                <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>latestBackup</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>cfgOptionIdxName</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionArchive</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionIdxName</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionArchiveType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Adhoc expire is never performed through backup command so only check to determine if dry-run has been set or not</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>backupLinkLatest</name><argument_list>(<argument><expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>.</operator><name>backupLabel</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>backupExpired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Log the expired backup list (prepend "set:" if there were any dependents that were also expired)</comment>
        <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
            <argument><expr><literal type="string">"%s: expire adhoc backup %s%s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>result</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"set "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>backupExpired</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Expire differential backups
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>expireDiffBackup</name><parameter_list>(<parameter><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoBackup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Total of all backups being expired</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>differentialRetention</name> <init>= <expr><ternary><condition><expr><call><name>cfgOptionIdxTest</name><argument_list>(
            <argument><expr><name>cfgOptRepoRetentionDiff</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>cfgOptionIdxUInt</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionDiff</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <comment type="line">// Find all the expired differential backups</comment>
        <if_stmt><if>if <condition>(<expr><name>differentialRetention</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Get a list of full and differential backups. Full are considered differential for the purpose of retention.</comment>
            <comment type="line">// Example: F1, D1, D2, F2, repo-retention-diff=2, then F1,D2,F2 will be retained, not D2 and D1 as might be expected.</comment>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>currentBackupList</name> <init>= <expr><call><name>infoBackupDataLabelList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>differential</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If there are more backups than the number to retain, then expire the oldest ones</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>currentBackupList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>differentialRetention</name></expr>)</condition>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>diffIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>diffIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>currentBackupList</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>differentialRetention</name></expr>;</condition> <incr><expr><name>diffIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="line">// Skip if this is a full backup.  Full backups only count as differential when deciding which differential</comment>
                    <comment type="line">// backups to expire.</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>regExpMatchOne</name><argument_list>(<argument><expr><call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>currentBackupList</name></expr></argument>, <argument><expr><name>diffIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>

                    <comment type="line">// Expire the differential and any dependent backups</comment>
                    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>backupExpired</name> <init>= <expr><call><name>expireBackup</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>currentBackupList</name></expr></argument>, <argument><expr><name>diffIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>backupExpired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Log the expired backups. If there is more than one backup, then prepend "set:"</comment>
                    <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                        <argument><expr><literal type="string">"%s: expire diff backup %s%s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><operator>(</operator><ternary><condition><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>backupExpired</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"set "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>backupExpired</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Expire full backups
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>expireFullBackup</name><parameter_list>(<parameter><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoBackup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Total of all backups being expired</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>fullRetention</name> <init>= <expr><ternary><condition><expr><call><name>cfgOptionIdxTest</name><argument_list>(
            <argument><expr><name>cfgOptRepoRetentionFull</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>cfgOptionIdxUInt</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionFull</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <comment type="line">// Find all the expired full backups</comment>
        <if_stmt><if>if <condition>(<expr><name>fullRetention</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Get list of current full backups (default order is oldest to newest)</comment>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>currentBackupList</name> <init>= <expr><call><name>infoBackupDataLabelList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If there are more full backups then the number to retain, then expire the oldest ones</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>currentBackupList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>fullRetention</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Expire all backups that depend on the full backup</comment>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fullIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fullIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>currentBackupList</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>fullRetention</name></expr>;</condition> <incr><expr><name>fullIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="line">// Expire the full backup and all its dependents</comment>
                    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>backupExpired</name> <init>= <expr><call><name>expireBackup</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>currentBackupList</name></expr></argument>, <argument><expr><name>fullIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>backupExpired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Log the expired backups. If there is more than one backup, then prepend "set:"</comment>
                    <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                        <argument><expr><literal type="string">"%s: expire full backup %s%s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><operator>(</operator><ternary><condition><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>backupExpired</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"set "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>backupExpired</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Expire backups based on time
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>expireTimeBasedBackup</name><parameter_list>(<parameter><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>time_t</name></type> <name>minTimestamp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>TIME</name></expr></argument>, <argument><expr><name>minTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoBackup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>minTimestamp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get the list of full backups</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>currentBackupList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(<argument><expr><call><name>infoBackupDataLabelList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name> <init>= <expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>currentBackupList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Find out the point where we will have to stop purging backups. Starting with the newest backup (the end of the list),</comment>
        <comment type="line">// find the first backup that is older than the expire time period by checking the backup stop time. This way, if the</comment>
        <comment type="line">// backups are F1 D1a D1b D1c F2 D2a D2b F3 D3a D3b and the expiration time period is at D2b, then purge only F1, D1a, D1b</comment>
        <comment type="line">// and D1c, and keep the next full backups (F2 and F3) and all intermediate non-full backups.</comment>
        <if_stmt><if>if <condition>(<expr><name>backupIdx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>lastBackupLabelToKeep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <do>do
            <block>{<block_content>
                <expr_stmt><expr><name>backupIdx</name><operator>--</operator></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>InfoBackupData</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>infoBackupDataByLabel</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>currentBackupList</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>lastBackupLabelToKeep</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>backupLabel</name></name></expr>;</expr_stmt>

                <comment type="line">// We can start deleting before this backup. This way, we keep one full backup and its dependents.</comment>
                <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>backupTimestampStop</name></name> <operator>&lt;</operator> <name>minTimestamp</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block>
            while <condition>(<expr><name>backupIdx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

            <comment type="line">// Count number of full backups being expired</comment>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>numFullExpired</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="line">// Since expireBackup will remove the requested entry from the backup list, we keep checking the first entry which is</comment>
            <comment type="line">// always the oldest so if it is not the backup to keep then we can remove it</comment>
            <while>while <condition>(<expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><name>backupLabel</name></expr></argument>, <argument><expr><name>lastBackupLabelToKeep</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>backupExpired</name> <init>= <expr><call><name>expireBackup</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><name>backupLabel</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>backupExpired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>numFullExpired</name><operator>++</operator></expr>;</expr_stmt>

                <comment type="line">// Log the expired backups. If there is more than one backup, then prepend "set:"</comment>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                    <argument><expr><literal type="string">"%s: expire time-based backup %s%s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><operator>(</operator><ternary><condition><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>backupExpired</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"set "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>backupExpired</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

            <if_stmt><if>if <condition>(<expr><call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionArchiveType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>backupTypeFull</name> <operator>&amp;&amp;</operator>
                <operator>!</operator><call><name>cfgOptionIdxTest</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionArchive</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>numFullExpired</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>cfgOptionIdxSet</name><argument_list>(
                    <argument><expr><name>cfgOptRepoRetentionArchive</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>, <argument><expr><name>cfgSourceDefault</name></expr></argument>,
                    <argument><expr><call><name>VARINT64</name><argument_list>(<argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>currentBackupList</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>numFullExpired</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Log detailed information about archive logs removed
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>logExpire</name><parameter_list>(<parameter><decl><type><name>ArchiveExpired</name> <modifier>*</modifier></type><name>archiveExpire</name></decl></parameter>, <parameter><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveId</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>archiveExpire</name><operator>-&gt;</operator><name>start</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Force out any remaining message</comment>
        <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
            <argument><expr><literal type="string">"%s: %s remove archive, start = %s, stop = %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveExpire</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveExpire</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>archiveExpire</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Process archive retention
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>removeExpiredArchive</name><parameter_list>(<parameter><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>timeBasedFullRetention</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>timeBasedFullRetention</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoBackup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get the retention options. repo-archive-retention-type always has a value as it defaults to "full"</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BackupType</name></type> <name>archiveRetentionType</name> <init>= <expr><operator>(</operator><name>BackupType</name><operator>)</operator><call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionArchiveType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>archiveRetention</name> <init>= <expr><ternary><condition><expr><call><name>cfgOptionIdxTest</name><argument_list>(
            <argument><expr><name>cfgOptRepoRetentionArchive</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>cfgOptionIdxUInt</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionArchive</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <comment type="line">// If archive retention is undefined, then ignore archiving. The user does not have to set this - it will be defaulted in</comment>
        <comment type="line">// cfgLoadUpdateOption based on certain rules.</comment>
        <if_stmt><if>if <condition>(<expr><name>archiveRetention</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>strNewZ</name><argument_list>(<argument><expr><literal type="string">"- archive logs will not be expired"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Only notify user if not time-based retention</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>timeBasedFullRetention</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"option '%s' is not set %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionIdxName</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionArchive</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                    <argument><expr><literal type="string">"%s: time-based archive retention not met %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// Determine which backup type to use for archive retention (full, differential, incremental) and get a list of the</comment>
            <comment type="line">// remaining non-expired backups, from newest to oldest, based on the type.</comment>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>globalBackupRetentionList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><name>archiveRetentionType</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>backupTypeFull</name></expr>:</case>
                    <expr_stmt><expr><name>globalBackupRetentionList</name> <operator>=</operator> <call><name>strLstSort</name><argument_list>(
                        <argument><expr><call><name>infoBackupDataLabelList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>backupTypeDiff</name></expr>:</case>
                    <expr_stmt><expr><name>globalBackupRetentionList</name> <operator>=</operator> <call><name>strLstSort</name><argument_list>(
                        <argument><expr><call><name>infoBackupDataLabelList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>differential</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>backupTypeIncr</name></expr>:</case>
                    <comment type="line">// Incrementals can depend on Full or Diff so get a list of all incrementals</comment>
                    <expr_stmt><expr><name>globalBackupRetentionList</name> <operator>=</operator> <call><name>strLstSort</name><argument_list>(
                        <argument><expr><call><name>infoBackupDataLabelList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>differential</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>incremental</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>

            <comment type="line">// Expire archives. If no backups were found or the number of backups found is not enough to satisfy archive retention</comment>
            <comment type="line">// then preserve current archive logs - too soon to expire them.</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>globalBackupRetentionList</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>archiveRetention</name> <operator>&lt;=</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>globalBackupRetentionList</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Attempt to load the archive info file</comment>
                <decl_stmt><decl><type><name>InfoArchive</name> <modifier>*</modifier></type><name>infoArchive</name> <init>= <expr><call><name>infoArchiveLoadFile</name><argument_list>(
                    <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INFO_ARCHIVE_PATH_FILE_STR</name></expr></argument>, <argument><expr><call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>cfgOptionIdxStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>InfoPg</name> <modifier>*</modifier></type><name>infoArchivePgData</name> <init>= <expr><call><name>infoArchivePg</name><argument_list>(<argument><expr><name>infoArchive</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Get a list of archive directories (e.g. 9.4-1, 10-2, etc) sorted by the db-id (number after the dash).</comment>
                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>listArchiveDisk</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
                    <argument><expr><call><name>strLstComparatorSet</name><argument_list>(
                        <argument><expr><call><name>storageListP</name><argument_list>(
                            <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STORAGE_REPO_ARCHIVE_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>STRDEF</name><argument_list>(<argument><expr><name>REGEX_ARCHIVE_DIR_DB_VERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>archiveIdComparator</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>globalBackupArchiveRetentionList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// globalBackupRetentionList is ordered newest to oldest backup, so create globalBackupArchiveRetentionList of the</comment>
                <comment type="line">// newest backups whose archives will be retained</comment>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init>
                     <condition><expr><name>idx</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><name>archiveRetention</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>globalBackupRetentionList</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
                        <expr><name>archiveRetention</name></expr> </then><else>: <expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>globalBackupRetentionList</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</condition>
                     <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>globalBackupArchiveRetentionList</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>globalBackupRetentionList</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <comment type="line">// From newest to oldest, confirm the pgVersion and pgSystemId from the archive.info history id match that of the</comment>
                <comment type="line">// same history id of the backup.info and if not, there is a mismatch between the info files so do not continue.</comment>
                <comment type="line">// NOTE: If the archive.info file was reconstructed and contains history 4: version 10, sys-id 456 and history 3:</comment>
                <comment type="line">// version 9.6, sys-id 123, but backup.info contains history 4 and 3 (identical to archive.info) but also 2 and 1</comment>
                <comment type="line">// then an error will not be thrown since only archive 4 and 3 would have existed and the others expired so</comment>
                <comment type="line">// nothing really to do.</comment>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>infoPgIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>infoPgIdx</name> <operator>&lt;</operator> <call><name>infoPgDataTotal</name><argument_list>(<argument><expr><name>infoArchivePgData</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>infoPgIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>InfoPgData</name></type> <name>archiveInfoPgHistory</name> <init>= <expr><call><name>infoPgData</name><argument_list>(<argument><expr><name>infoArchivePgData</name></expr></argument>, <argument><expr><name>infoPgIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>InfoPgData</name></type> <name>backupInfoPgHistory</name> <init>= <expr><call><name>infoPgData</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>infoPgIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>archiveInfoPgHistory</name><operator>.</operator><name>id</name></name> <operator>!=</operator> <name><name>backupInfoPgHistory</name><operator>.</operator><name>id</name></name> <operator>||</operator>
                        <name><name>archiveInfoPgHistory</name><operator>.</operator><name>systemId</name></name> <operator>!=</operator> <name><name>backupInfoPgHistory</name><operator>.</operator><name>systemId</name></name> <operator>||</operator>
                        <name><name>archiveInfoPgHistory</name><operator>.</operator><name>version</name></name> <operator>!=</operator> <name><name>backupInfoPgHistory</name><operator>.</operator><name>version</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW</name><argument_list>(
                            <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"archive expiration cannot continue - archive and backup history lists do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="line">// Loop through the archive.info history from oldest to newest and if there is a corresponding directory on disk</comment>
                <comment type="line">// then remove WAL that are not part of retention as long as the db:history id version/system-id matches backup.info</comment>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>pgIdx</name> <init>= <expr><call><name>infoPgDataTotal</name><argument_list>(<argument><expr><name>infoArchivePgData</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><operator>(</operator><name>int</name><operator>)</operator><name>pgIdx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>pgIdx</name><operator>--</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveId</name> <init>= <expr><call><name>infoPgArchiveId</name><argument_list>(<argument><expr><name>infoArchivePgData</name></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>localBackupRetentionList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Initialize the expired archive information for this archive ID</comment>
                    <decl_stmt><decl><type><name>ArchiveExpired</name></type> <name>archiveExpire</name> <init>= <expr><block>{<expr><operator>.</operator><name>total</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>start</name> <operator>=</operator> <name>NULL</name></expr>, <expr><operator>.</operator><name>stop</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>archiveIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>archiveIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>listArchiveDisk</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>archiveIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <comment type="line">// Is there an archive directory for this archiveId? If not, move on to the next.</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>listArchiveDisk</name></expr></argument>, <argument><expr><name>archiveIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <continue>continue;</continue></block_content></block></if></if_stmt>

                        <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>archivePgId</name> <init>= <expr><call><name>cvtZToUInt</name><argument_list>(<argument><expr><call><name>strrchr</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// From the global list of backups to retain, create a list of backups, oldest to newest, associated with</comment>
                        <comment type="line">// this archiveId (e.g. 9.4-1), e.g. If globalBackupRetention has 4F, 3F, 2F, 1F then</comment>
                        <comment type="line">// localBackupRetentionList will have 1F, 2F, 3F, 4F (assuming they all have same history id)</comment>
                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>retentionIdx</name> <init>= <expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>globalBackupRetentionList</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init>
                             <condition><expr><operator>(</operator><name>int</name><operator>)</operator><name>retentionIdx</name> <operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>retentionIdx</name><operator>--</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupIdx</name> <operator>&lt;</operator> <call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupIdx</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>backupData</name> <init>= <expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><name><name>backupData</name><operator>.</operator><name>backupLabel</name></name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>globalBackupRetentionList</name></expr></argument>, <argument><expr><name>retentionIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                                    <name><name>backupData</name><operator>.</operator><name>backupPgId</name></name> <operator>==</operator> <name>archivePgId</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>localBackupRetentionList</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></for>

                        <comment type="line">// If no backup to retain was found</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>localBackupRetentionList</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// If this is not the current database, then delete the archive directory else do nothing since the</comment>
                            <comment type="line">// current DB archive directory must not be deleted</comment>
                            <decl_stmt><decl><type><name>InfoPgData</name></type> <name>currentPg</name> <init>= <expr><call><name>infoPgDataCurrent</name><argument_list>(<argument><expr><name>infoArchivePgData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name><name>currentPg</name><operator>.</operator><name>id</name></name> <operator>!=</operator> <name>archivePgId</name></expr>)</condition>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>fullPath</name> <init>= <expr><call><name>storagePathP</name><argument_list>(
                                    <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                                    <argument><expr><literal type="string">"%s: remove archive path %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fullPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <comment type="line">// Execute the real expiration and deletion only if the dry-run option is disabled</comment>
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionValid</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>storagePathRemoveP</name><argument_list>(<argument><expr><call><name>storageRepoIdxWrite</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fullPath</name></expr></argument>, <argument><expr><operator>.</operator><name>recurse</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            </block_content>}</block></if></if_stmt>

                            <comment type="line">// Continue to next directory</comment>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// If we get here, then a local backup was found for retention</comment>
                        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>localBackupArchiveRetentionList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// From the full list of backups in archive retention, find the intersection of local backups to retain</comment>
                        <comment type="line">// from oldest to newest</comment>
                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>globalIdx</name> <init>= <expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>globalBackupArchiveRetentionList</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init>
                             <condition><expr><operator>(</operator><name>int</name><operator>)</operator><name>globalIdx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>globalIdx</name><operator>--</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>localIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>localIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>localBackupRetentionList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>localIdx</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(
                                        <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>globalBackupArchiveRetentionList</name></expr></argument>, <argument><expr><name>globalIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>localBackupRetentionList</name></expr></argument>, <argument><expr><name>localIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>localBackupArchiveRetentionList</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>localBackupRetentionList</name></expr></argument>, <argument><expr><name>localIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></for>

                        <comment type="line">// If no local backups were found as part of retention then set the backup archive retention to the newest</comment>
                        <comment type="line">// backup so that the database is fully recoverable (can be recovered from the last backup through pitr)</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>localBackupArchiveRetentionList</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(
                                <argument><expr><name>localBackupArchiveRetentionList</name></expr></argument>,
                                <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>localBackupRetentionList</name></expr></argument>, <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>localBackupRetentionList</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// Get the data for the backup selected for retention and all backups associated with this archive id</comment>
                        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>archiveIdBackupList</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>InfoBackupData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>archiveRetentionBackup</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>infoBackupIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>infoBackupIdx</name> <operator>&lt;</operator> <call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>infoBackupIdx</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>archiveIdBackup</name> <init>= <expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>infoBackupIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <comment type="line">// If this is the backup selected for retention, store its data</comment>
                            <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><name><name>archiveIdBackup</name><operator>.</operator><name>backupLabel</name></name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>localBackupArchiveRetentionList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>archiveRetentionBackup</name> <operator>=</operator> <call><name>infoBackupData</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>infoBackupIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <comment type="line">// If this is a backup associated with this archive Id, then add it to the list to check</comment>
                            <if_stmt><if>if <condition>(<expr><name><name>archiveIdBackup</name><operator>.</operator><name>backupPgId</name></name> <operator>==</operator> <name>archivePgId</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name>archiveIdBackupList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>archiveIdBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></for>

                        <comment type="line">// Only expire if the selected backup has archive data - backups performed with --no-online will</comment>
                        <comment type="line">// not have archive data and cannot be used for expiration.</comment>
                        <decl_stmt><decl><type><name>bool</name></type> <name>removeArchive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>archiveRetentionBackup</name><operator>.</operator><name>backupArchiveStart</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// Get archive ranges to preserve.  Because archive retention can be less than total retention it is</comment>
                            <comment type="line">// important to preserve archive that is required to make the older backups consistent even though they</comment>
                            <comment type="line">// cannot be played any further forward with PITR.</comment>
                            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveExpireMax</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>archiveRangeList</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArchiveRange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <comment type="line">// From the full list of backups, loop through those associated with this archiveId</comment>
                            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupListIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupListIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>archiveIdBackupList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupListIdx</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>InfoBackupData</name> <modifier>*</modifier></type><name>backupData</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>archiveIdBackupList</name></expr></argument>, <argument><expr><name>backupListIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <comment type="line">// If the backup is earlier than or the same as the retention backup and the backup has an</comment>
                                <comment type="line">// archive start</comment>
                                <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>, <argument><expr><name><name>archiveRetentionBackup</name><operator>.</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                                    <name><name>backupData</name><operator>-&gt;</operator><name>backupArchiveStart</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                                <block>{<block_content>
                                    <decl_stmt><decl><type><name>ArchiveRange</name></type> <name>archiveRange</name> <init>=
                                    <expr><block>{
                                        <expr><operator>.</operator><name>start</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupArchiveStart</name></name></expr></argument>)</argument_list></call></expr>,
                                        <expr><operator>.</operator><name>stop</name> <operator>=</operator> <name>NULL</name></expr>,
                                    }</block></expr></init></decl>;</decl_stmt>

                                    <comment type="line">// If this is not the retention backup, then set the stop, otherwise set the expire max to</comment>
                                    <comment type="line">// the archive start of the archive to retain</comment>
                                    <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>, <argument><expr><name><name>archiveRetentionBackup</name><operator>.</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                        <expr_stmt><expr><name><name>archiveRange</name><operator>.</operator><name>stop</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupArchiveStop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                                    <else>else<block type="pseudo"><block_content>
                                        <expr_stmt><expr><name>archiveExpireMax</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>archiveRange</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                                    <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(
                                        <argument><expr><literal type="string">"%s: %s archive retention on backup %s, start = %s%s"</literal></expr></argument>,
                                        <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveRange</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><ternary><condition><expr><name><name>archiveRange</name><operator>.</operator><name>stop</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>zNewFmt</name><argument_list>(<argument><expr><literal type="string">", stop = %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveRange</name><operator>.</operator><name>stop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <comment type="line">// Add the archive range to the list</comment>
                                    <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name>archiveRangeList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>archiveRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></for>

                            <comment type="line">// Get all major archive paths (timeline and first 32 bits of LSN)</comment>
                            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>walPathList</name> <init>=
                                <expr><call><name>strLstSort</name><argument_list>(
                                    <argument><expr><call><name>storageListP</name><argument_list>(
                                        <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>STRDEF</name><argument_list>(<argument><expr><name>WAL_SEGMENT_DIR_REGEXP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>walIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>walIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>walPathList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>walIdx</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>walPath</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>walPathList</name></expr></argument>, <argument><expr><name>walIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><name>removeArchive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                                <comment type="line">// Keep the path if it falls in the range of any backup in retention</comment>
                                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>rangeIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rangeIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>archiveRangeList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>rangeIdx</name><operator>++</operator></expr></incr>)</control>
                                <block>{<block_content>
                                    <decl_stmt><decl><type><name>ArchiveRange</name> <modifier>*</modifier></type><name>archiveRange</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>archiveRangeList</name></expr></argument>, <argument><expr><name>rangeIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                    <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>, <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name><name>archiveRange</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                                        <operator>(</operator><name><name>archiveRange</name><operator>-&gt;</operator><name>stop</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strCmp</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>, <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name><name>archiveRange</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>removeArchive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                        <break>break;</break>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></for>

                                <comment type="line">// Remove the entire directory if all archive is expired</comment>
                                <if_stmt><if>if <condition>(<expr><name>removeArchive</name></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="line">// Execute the real expiration and deletion only if the dry-run mode is disabled</comment>
                                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionValid</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>storagePathRemoveP</name><argument_list>(
                                            <argument><expr><call><name>storageRepoIdxWrite</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><operator>.</operator><name>recurse</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>

                                    <expr_stmt><expr><name><name>archiveExpire</name><operator>.</operator><name>total</name></name><operator>++</operator></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>archiveExpire</name><operator>.</operator><name>start</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>archiveExpire</name><operator>.</operator><name>stop</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <comment type="line">// Else delete individual files instead if the major path is less than or equal to the most recent</comment>
                                <comment type="line">// retention backup.  This optimization prevents scanning though major paths that could not possibly</comment>
                                <comment type="line">// have anything to expire.</comment>
                                <if type="elseif">else if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>, <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>archiveExpireMax</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="line">// Look for files in the archive directory</comment>
                                    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>walSubPathList</name> <init>=
                                        <expr><call><name>strLstSort</name><argument_list>(
                                            <argument><expr><call><name>storageListP</name><argument_list>(
                                                <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"^[0-F]{24}.*$"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>subIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>subIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>walSubPathList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>subIdx</name><operator>++</operator></expr></incr>)</control>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>removeArchive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>walSubPath</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>walSubPathList</name></expr></argument>, <argument><expr><name>subIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                        <comment type="line">// Determine if the individual archive log is used in a backup</comment>
                                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>rangeIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rangeIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>archiveRangeList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>rangeIdx</name><operator>++</operator></expr></incr>)</control>
                                        <block>{<block_content>
                                            <decl_stmt><decl><type><name>ArchiveRange</name> <modifier>*</modifier></type><name>archiveRange</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>archiveRangeList</name></expr></argument>, <argument><expr><name>rangeIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                            <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>walSubPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>archiveRange</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                                                <operator>(</operator><name><name>archiveRange</name><operator>-&gt;</operator><name>stop</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
                                                 <call><name>strCmp</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>walSubPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>archiveRange</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
                                            <block>{<block_content>
                                                <expr_stmt><expr><name>removeArchive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                                <break>break;</break>
                                            </block_content>}</block></if></if_stmt>
                                        </block_content>}</block></for>

                                        <comment type="line">// Remove archive log if it is not used in a backup</comment>
                                        <if_stmt><if>if <condition>(<expr><name>removeArchive</name></expr>)</condition>
                                        <block>{<block_content>
                                            <comment type="line">// Execute the real expiration and deletion only if the dry-run mode is disabled</comment>
                                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionValid</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call></expr>)</condition>
                                            <block>{<block_content>
                                                <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(
                                                    <argument><expr><call><name>storageRepoIdxWrite</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><call><name>strNewFmt</name><argument_list>(
                                                        <argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr></argument>,
                                                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSubPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            </block_content>}</block></if></if_stmt>

                                            <comment type="line">// Track that this archive was removed</comment>
                                            <expr_stmt><expr><name><name>archiveExpire</name><operator>.</operator><name>total</name></name><operator>++</operator></expr>;</expr_stmt>
                                            <expr_stmt><expr><name><name>archiveExpire</name><operator>.</operator><name>stop</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>walSubPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <if_stmt><if>if <condition>(<expr><name><name>archiveExpire</name><operator>.</operator><name>start</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                                                <expr_stmt><expr><name><name>archiveExpire</name><operator>.</operator><name>start</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>walSubPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                                        </block_content>}</block></if>
                                        <else>else<block type="pseudo"><block_content>
                                            <expr_stmt><expr><call><name>logExpire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>archiveExpire</name></expr></argument>, <argument><expr><name>archiveId</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                                    </block_content>}</block></for>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></for>

                            <comment type="line">// Log if no archive was expired</comment>
                            <if_stmt><if>if <condition>(<expr><name><name>archiveExpire</name><operator>.</operator><name>total</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                                    <argument><expr><literal type="string">"%s: %s no archive to remove"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Log if there is more to log</comment>
                            <else>else<block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>logExpire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>archiveExpire</name></expr></argument>, <argument><expr><name>archiveId</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                            <comment type="line">// Look for history files to expire based on the timeline of backupArchiveStart</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupArchiveStartTimeline</name> <init>= <expr><call><name>strSubN</name><argument_list>(<argument><expr><name><name>archiveRetentionBackup</name><operator>.</operator><name>backupArchiveStart</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>historyFilesList</name> <init>=
                                <expr><call><name>strLstSort</name><argument_list>(
                                    <argument><expr><call><name>storageListP</name><argument_list>(
                                        <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <name>WAL_TIMELINE_HISTORY_REGEXP_STR</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


                            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>historyFileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>historyFileIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>historyFilesList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>historyFileIdx</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>historyFile</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>historyFilesList</name></expr></argument>, <argument><expr><name>historyFileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <comment type="line">// Expire history files older than the oldest retained timeline</comment>
                                <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>historyFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>backupArchiveStartTimeline</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="line">// Execute the real expiration and deletion only if the dry-run mode is disabled</comment>
                                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionValid</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(
                                            <argument><expr><call><name>storageRepoIdxWrite</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>historyFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>

                                    <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                                        <argument><expr><literal type="string">"%s: %s remove history file %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>historyFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></for>

                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Remove expired backups from repo
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>removeExpiredBackup</name><parameter_list>(<parameter><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>adhocBackupLabel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>adhocBackupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoBackup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get all the current backups in backup.info - these will not be expired</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>currentBackupList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(<argument><expr><call><name>infoBackupDataLabelList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get all the backups on disk</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>backupList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
            <argument><expr><call><name>storageListP</name><argument_list>(
                <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STORAGE_REPO_BACKUP_STR</name></expr></argument>,
                <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>differential</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>incremental</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Initialize the index to the latest backup on disk</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// Only remove the resumable backup if there is a possibility it is a dependent of the adhoc label being expired</comment>
        <if_stmt><if>if <condition>(<expr><name>adhocBackupLabel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>manifestFileName</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(
                <argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>BACKUP_MANIFEST_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>manifestCopyFileName</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s"</literal> <name>INFO_COPY_EXT</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>manifestFileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If the latest backup is resumable (has a backup.manifest.copy but no backup.manifest)</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>manifestFileName</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>manifestCopyFileName</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If the resumable backup is not related to the expired adhoc backup then don't remove it</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strBeginsWith</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>adhocBackupLabel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>backupIdx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else it may be related to the adhoc backup so check if its ancestor still exists</comment>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifestResume</name> <init>= <expr><call><name>manifestLoadFile</name><argument_list>(
                        <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>manifestFileName</name></expr></argument>, <argument><expr><call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// If the ancestor of the resumable backup still exists in backup.info then do not remove the resumable backup</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>infoBackupLabelExists</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifestResume</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabelPrior</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>backupIdx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Remove non-current backups from disk</comment>
        <for>for <control>(<init>;</init> <condition><expr><name>backupIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>currentBackupList</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                    <argument><expr><literal type="string">"%s: remove expired backup %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Execute the real expiration and deletion only if the dry-run mode is disabled</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionValid</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>storagePathRemoveP</name><argument_list>(
                        <argument><expr><call><name>storageRepoIdxWrite</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><operator>.</operator><name>recurse</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Remove expired backup history manifests from repo
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>removeExpiredHistory</name><parameter_list>(<parameter><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoBackup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionIdxTest</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionHistory</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Get current backups in backup.info - these will not be expired</comment>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>currentBackupList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(<argument><expr><call><name>infoBackupDataLabelList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If the full backup history manifests are expired, we should expire diff and incr too. So, format the oldest full</comment>
            <comment type="line">// backup label to retain.</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>time_t</name></type> <name>minTimestamp</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>time_t</name><operator>)</operator><operator>(</operator><call><name>cfgOptionIdxUInt</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionHistory</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>SEC_PER_DAY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>minBackupLabel</name> <init>= <expr><call><name>backupLabelFormat</name><argument_list>(<argument><expr><name>backupTypeFull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>minTimestamp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Get all history years</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>historyYearList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
                <argument><expr><call><name>storageListP</name><argument_list>(
                    <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/"</literal> <name>BACKUP_PATH_HISTORY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"^2[0-9]{3}$"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>historyYearIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>historyYearIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>historyYearList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>historyYearIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="line">// Get all the backup history manifests</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>historyYear</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>historyYearList</name></expr></argument>, <argument><expr><name>historyYearIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// If the entire year is less than the year of the minimum backup to retain, then remove completely the directory</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><name>historyYear</name></expr></argument>, <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>minBackupLabel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                        <argument><expr><literal type="string">"%s: remove expired backup history path %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>historyYear</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Execute the real expiration and deletion only if the dry-run mode is disabled</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionValid</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>storagePathRemoveP</name><argument_list>(
                            <argument><expr><call><name>storageRepoIdxWrite</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/"</literal> <name>BACKUP_PATH_HISTORY</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>historyYear</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>recurse</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else find and remove individual files</comment>
                <if type="elseif">else if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>historyYear</name></expr></argument>, <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>minBackupLabel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>historyList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
                        <argument><expr><call><name>storageListP</name><argument_list>(
                            <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/"</literal> <name>BACKUP_PATH_HISTORY</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>historyYear</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(
                                <argument><expr><literal type="string">"%s\\.manifest\\.%s$"</literal></expr></argument>,
                                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>differential</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>incremental</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noAnchorEnd</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>compressTypeStr</name><argument_list>(<argument><expr><name>compressTypeGz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>historyIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>historyIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>historyList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>historyIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>historyBackupFile</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>historyList</name></expr></argument>, <argument><expr><name>historyIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>historyBackupLabel</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><call><name>strLstNewSplitZ</name><argument_list>(<argument><expr><name>historyBackupFile</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Keep backup history manifests for unexpired backups and backups newer than the oldest backup to retain</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>currentBackupList</name></expr></argument>, <argument><expr><name>historyBackupLabel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strCmp</name><argument_list>(<argument><expr><name>historyBackupLabel</name></expr></argument>, <argument><expr><name>minBackupLabel</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                                <argument><expr><literal type="string">"%s: remove expired backup history manifest %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>historyBackupFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// Execute the real expiration and deletion only if the dry-run mode is disabled</comment>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionValid</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(
                                    <argument><expr><call><name>storageRepoIdxWrite</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>strNewFmt</name><argument_list>(
                                        <argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/"</literal> <name>BACKUP_PATH_HISTORY</name> <literal type="string">"/%s/%s"</literal></expr></argument>,
                                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>historyYear</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>historyBackupFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></else></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>cmdExpire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Verify the repo is local</comment>
    <expr_stmt><expr><call><name>repoIsLocalVerify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Test for stop file</comment>
    <expr_stmt><expr><call><name>lockStopTest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Initialize the repo index</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdxMin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdxMax</name> <init>= <expr><call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// If the repo was specified then set index to the array location and max to loop only once</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptRepo</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>repoIdxMin</name> <operator>=</operator> <call><name>cfgOptionGroupIdxDefault</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>repoIdxMax</name> <operator>=</operator> <name>repoIdxMin</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Get the backup label if specified</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>adhocBackupLabel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>adhocBackupFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// If the --set option is valid (i.e. expire is called on its own) then check the label format</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptSet</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>adhocBackupLabel</name> <operator>=</operator> <call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If the label format is invalid, then error</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>regExpMatchOne</name><argument_list>(<argument><expr><call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>differential</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>incremental</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>adhocBackupLabel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"'%s' is not a valid backup label format"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>adhocBackupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Track any errors that may occur</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errorTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name> <init>= <expr><name>repoIdxMin</name></expr></init></decl>;</init> <condition><expr><name>repoIdx</name> <operator>&lt;=</operator> <name>repoIdxMax</name></expr>;</condition> <incr><expr><name>repoIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// Get the repo storage in case it is remote and encryption settings need to be pulled down</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storageRepo</name> <init>= <expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>bool</name></type> <name>timeBasedFullRetention</name> <init>=
                <expr><call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionFullType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_REPO_RETENTION_FULL_TYPE_TIME</name></expr></init></decl>;</decl_stmt>

            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// Load the backup.info</comment>
                <expr_stmt><expr><name>infoBackup</name> <operator>=</operator> <call><name>infoBackupLoadFileReconstruct</name><argument_list>(
                    <argument><expr><name>storageRepo</name></expr></argument>, <argument><expr><name>INFO_BACKUP_PATH_FILE_STR</name></expr></argument>, <argument><expr><call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>cfgOptionIdxStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// If a backupLabel was set, then attempt to expire the requested backup</comment>
                <if_stmt><if>if <condition>(<expr><name>adhocBackupLabel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>infoBackupLabelExists</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>adhocBackupLabel</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>adhocBackupFound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>expireAdhocBackup</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>adhocBackupLabel</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// If the adhoc backup was not found and this was the last repo to check, then log a warning but continue to</comment>
                    <comment type="line">// process the expiration based on retention</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>adhocBackupFound</name> <operator>&amp;&amp;</operator> <name>repoIdx</name> <operator>==</operator> <name>repoIdxMax</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                            <argument><expr><literal type="string">"backup %s does not exist\nHINT: run the info command and confirm the backup is listed"</literal></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>adhocBackupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="line">// If time-based retention for full backups is set, then expire based on time period</comment>
                    <if_stmt><if>if <condition>(<expr><name>timeBasedFullRetention</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// If a time period was provided then run time-based expiration otherwise do nothing (the user has already</comment>
                        <comment type="line">// been warned by the config system that retention-full was not set)</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionIdxTest</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionFull</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>expireTimeBasedBackup</name><argument_list>(
                                <argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>time_t</name><operator>)</operator><operator>(</operator><call><name>cfgOptionIdxUInt</name><argument_list>(<argument><expr><name>cfgOptRepoRetentionFull</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>SEC_PER_DAY</name><operator>)</operator></expr></argument>,
                                <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>expireFullBackup</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <expr_stmt><expr><call><name>expireDiffBackup</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="line">// Store the new backup info only if the dry-run mode is disabled</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionValid</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDryRun</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>infoBackupSaveFile</name><argument_list>(
                        <argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>storageRepoIdxWrite</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INFO_BACKUP_PATH_FILE_STR</name></expr></argument>,
                        <argument><expr><call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionIdxStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Remove all files on disk that are now expired</comment>
                <expr_stmt><expr><call><name>removeExpiredBackup</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>adhocBackupLabel</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>removeExpiredArchive</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>timeBasedFullRetention</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>removeExpiredHistory</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_ERROR_FMT</name><argument_list>(<argument><expr><call><name>errorTypeCode</name><argument_list>(<argument><expr><call><name>errorType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>errorTotal</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Error if any errors encountered on one or more repos</comment>
        <if_stmt><if>if <condition>(<expr><name>errorTotal</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>CommandError</name></expr></argument>, <argument><expr><name>CFGCMD_EXPIRE</name> <literal type="string">" command encountered %u error(s), check the log file for details"</literal></expr></argument>, <argument><expr><name>errorTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
