<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/command/restore/restore.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Restore Command
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/restore/file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/restore/protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/restore/restore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/crypto/cipherBlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/regExp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/exec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoBackup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/manifest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/write.intern.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Recovery constants
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE_COMMAND</name></cpp:macro>                                             <cpp:value>"restore_command"</cpp:value></cpp:define>
    <expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>RESTORE_COMMAND_STR</name></expr></argument>,                              <argument><expr><name>RESTORE_COMMAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_TARGET</name></cpp:macro>                                             <cpp:value>"recovery_target"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_TARGET_LSN</name></cpp:macro>                                         <cpp:value>"recovery_target_lsn"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_TARGET_NAME</name></cpp:macro>                                        <cpp:value>"recovery_target_name"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_TARGET_TIME</name></cpp:macro>                                        <cpp:value>"recovery_target_time"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_TARGET_XID</name></cpp:macro>                                         <cpp:value>"recovery_target_xid"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_TARGET_ACTION</name></cpp:macro>                                      <cpp:value>"recovery_target_action"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_TARGET_INCLUSIVE</name></cpp:macro>                                   <cpp:value>"recovery_target_inclusive"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_TARGET_TIMELINE</name></cpp:macro>                                    <cpp:value>"recovery_target_timeline"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_TARGET_TIMELINE_CURRENT</name></cpp:macro>                            <cpp:value>"current"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAUSE_AT_RECOVERY_TARGET</name></cpp:macro>                                    <cpp:value>"pause_at_recovery_target"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STANDBY_MODE</name></cpp:macro>                                                <cpp:value>"standby_mode"</cpp:value></cpp:define>
    <expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>STANDBY_MODE_STR</name></expr></argument>,                                 <argument><expr><name>STANDBY_MODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARCHIVE_MODE</name></cpp:macro>                                                <cpp:value>"archive_mode"</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Validate restore path
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restorePathValidate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// PostgreSQL must not be running</comment>
        <if_stmt><if>if <condition>(<expr><call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PG_FILE_POSTMTRPID_STR</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                <argument><expr><name>PgRunningError</name></expr></argument>,
                <argument><expr><literal type="string">"unable to restore while PostgreSQL is running\n"</literal>
                    <literal type="string">"HINT: presence of '"</literal> <name>PG_FILE_POSTMTRPID</name> <literal type="string">"' in '%s' indicates PostgreSQL is running.\n"</literal>
                    <literal type="string">"HINT: remove '"</literal> <name>PG_FILE_POSTMTRPID</name> <literal type="string">"' only if PostgreSQL is not running."</literal></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionDisplay</name><argument_list>(<argument><expr><name>cfgOptPgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If the restore will be destructive attempt to verify that PGDATA looks like a valid PostgreSQL directory</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDelta</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptForce</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PG_FILE_PGVERSION_STR</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_MANIFEST_FILE_STR</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                <argument><expr><literal type="string">"--delta or --force specified but unable to find '"</literal> <name>PG_FILE_PGVERSION</name> <literal type="string">"' or '"</literal> <name>BACKUP_MANIFEST_FILE</name> <literal type="string">"' in '%s' to"</literal>
                    <literal type="string">" confirm that this is a valid $PGDATA directory.  --delta and --force have been disabled and if any files"</literal>
                    <literal type="string">" exist in the destination directories the restore will be aborted."</literal></expr></argument>,
               <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionDisplay</name><argument_list>(<argument><expr><name>cfgOptPgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Disable delta and force so restore will fail if the directories are not empty</comment>
            <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(<argument><expr><name>cfgOptDelta</name></expr></argument>, <argument><expr><name>cfgSourceDefault</name></expr></argument>, <argument><expr><call><name>VARBOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(<argument><expr><name>cfgOptForce</name></expr></argument>, <argument><expr><name>cfgSourceDefault</name></expr></argument>, <argument><expr><call><name>VARBOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get epoch time from formatted string
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>time_t</name></type>
<name>getEpoch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>targetTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>targetTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>targetTime</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>time_t</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Build the regex to accept formats: YYYY-MM-DD HH:MM:SS with optional msec (up to 6 digits and separated from minutes by</comment>
        <comment type="line">// a comma or period), optional timezone offset +/- HH or HHMM or HH:MM, where offset boundaries are UTC-12 to UTC+14</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><call><name>STRDEF</name><argument_list>(
            <argument><expr><literal type="string">"^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}((\\,|\\.)[0-9]{1,6})?((\\+|\\-)[0-9]{2}(:?)([0-9]{2})?)?$"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>RegExp</name> <modifier>*</modifier></type><name>regExp</name> <init>= <expr><call><name>regExpNew</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If the target-recovery time matches the regular expression then validate it</comment>
        <if_stmt><if>if <condition>(<expr><call><name>regExpMatch</name><argument_list>(<argument><expr><name>regExp</name></expr></argument>, <argument><expr><name>targetTime</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Strip off the date and time and put the remainder into another string</comment>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>datetime</name> <init>= <expr><call><name>strSubN</name><argument_list>(<argument><expr><name>targetTime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>dtYear</name> <init>= <expr><call><name>cvtZSubNToInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>datetime</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>dtMonth</name> <init>= <expr><call><name>cvtZSubNToInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>datetime</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>dtDay</name> <init>= <expr><call><name>cvtZSubNToInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>datetime</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>dtHour</name> <init>= <expr><call><name>cvtZSubNToInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>datetime</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>dtMinute</name> <init>= <expr><call><name>cvtZSubNToInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>datetime</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>dtSecond</name> <init>= <expr><call><name>cvtZSubNToInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>datetime</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Confirm date and time parts are valid</comment>
            <expr_stmt><expr><call><name>datePartsValid</name><argument_list>(<argument><expr><name>dtYear</name></expr></argument>, <argument><expr><name>dtMonth</name></expr></argument>, <argument><expr><name>dtDay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>timePartsValid</name><argument_list>(<argument><expr><name>dtHour</name></expr></argument>, <argument><expr><name>dtMinute</name></expr></argument>, <argument><expr><name>dtSecond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>timeTargetZone</name> <init>= <expr><call><name>strSub</name><argument_list>(<argument><expr><name>targetTime</name></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Find the + or - indicating a timezone offset was provided (there may be milliseconds before the timezone, so need to</comment>
            <comment type="line">// skip). If a timezone offset was not provided, then local time is assumed.</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>idxSign</name> <init>= <expr><call><name>strChr</name><argument_list>(<argument><expr><name>timeTargetZone</name></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>idxSign</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>idxSign</name> <operator>=</operator> <call><name>strChr</name><argument_list>(<argument><expr><name>timeTargetZone</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>idxSign</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>timezoneOffset</name> <init>= <expr><call><name>strSub</name><argument_list>(<argument><expr><name>timeTargetZone</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>idxSign</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Include the sign with the hour</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>tzHour</name> <init>= <expr><call><name>cvtZSubNToInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>timezoneOffset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>tzMinute</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <comment type="line">// If minutes are included in timezone offset then extract the minutes based on whether a colon separates them from</comment>
                <comment type="line">// the hour</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>timezoneOffset</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tzMinute</name> <operator>=</operator> <call><name>cvtZSubNToInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>timezoneOffset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><call><name>strChr</name><argument_list>(<argument><expr><name>timezoneOffset</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>epochFromParts</name><argument_list>(<argument><expr><name>dtYear</name></expr></argument>, <argument><expr><name>dtMonth</name></expr></argument>, <argument><expr><name>dtDay</name></expr></argument>, <argument><expr><name>dtHour</name></expr></argument>, <argument><expr><name>dtMinute</name></expr></argument>, <argument><expr><name>dtSecond</name></expr></argument>, <argument><expr><call><name>tzOffsetSeconds</name><argument_list>(<argument><expr><name>tzHour</name></expr></argument>, <argument><expr><name>tzMinute</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// If there is no timezone offset, then assume it is local time</comment>
            <else>else
            <block>{<block_content>
                <comment type="line">// Set tm_isdst to -1 to force mktime to consider if DST. For example, if system time is America/New_York then</comment>
                <comment type="line">// 2019-09-14 20:02:49 was a time in DST so the Epoch value should be 1568505769 (and not 1568509369 which would be</comment>
                <comment type="line">// 2019-09-14 21:02:49 - an hour too late)</comment>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <macro><name>mktime</name><argument_list>(
                    <argument>&amp;(struct tm){.tm_sec = dtSecond</argument>, <argument>.tm_min = dtMinute</argument>, <argument>.tm_hour = dtHour</argument>, <argument>.tm_mday = dtDay</argument>, <argument>.tm_mon = dtMonth - <literal type="number">1</literal></argument>,
                    <argument>.tm_year = dtYear - <literal type="number">1900</literal></argument>, <argument>.tm_isdst = -<literal type="number">1</literal>}</argument>)</argument_list></macro></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                <argument><expr><name>FormatError</name></expr></argument>,
                <argument><expr><literal type="string">"automatic backup set selection cannot be performed with provided time '%s'\n"</literal>
                <literal type="string">"HINT: time format must be YYYY-MM-DD HH:MM:SS with optional msec and optional timezone (+/- HH or HHMM or HH:MM)"</literal>
                    <literal type="string">" - if timezone is omitted, local time is assumed (for UTC use +00)"</literal></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>targetTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>TIME</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the backup set to restore
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>RestoreBackupData</name>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl>;</decl_stmt>                                           <comment type="line">// Internal repo index</comment>
    <decl_stmt><decl><type><name>CipherType</name></type> <name>repoCipherType</name></decl>;</decl_stmt>                                      <comment type="line">// Repo encryption type (0 = none)</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupCipherPass</name></decl>;</decl_stmt>                                 <comment type="line">// Passphrase of backup files if repo is encrypted (else NULL)</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupSet</name></decl>;</decl_stmt>                                        <comment type="line">// Backup set to restore</comment>
}</block></struct></type> <name>RestoreBackupData</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_RESTORE_BACKUP_DATA_TYPE</name></cpp:macro>                                                                                      \
    <cpp:value>RestoreBackupData</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_RESTORE_BACKUP_DATA_FORMAT</name><parameter_list>(<parameter><type><name>value</name></type></parameter>, <parameter><type><name>buffer</name></type></parameter>, <parameter><type><name>bufferSize</name></type></parameter>)</parameter_list></cpp:macro>                                                         \
    <cpp:value>objToLog(&amp;value, "RestoreBackupData", buffer, bufferSize)</cpp:value></cpp:define>

<comment type="line">// Helper function for restoreBackupSet</comment>
<function><type><specifier>static</specifier> <name>RestoreBackupData</name></type>
<name>restoreBackupData</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupLabel</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupCipherPass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>backupLabel</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>RestoreBackupData</name></type> <name>restoreBackup</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name><name>restoreBackup</name><operator>.</operator><name>backupSet</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>restoreBackup</name><operator>.</operator><name>repoIdx</name></name> <operator>=</operator> <name>repoIdx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>restoreBackup</name><operator>.</operator><name>repoCipherType</name></name> <operator>=</operator> <call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>restoreBackup</name><operator>.</operator><name>backupCipherPass</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>backupCipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>restoreBackup</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RestoreBackupData</name></type>
<name>restoreBackupSet</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>RestoreBackupData</name></type> <name>result</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Initialize the repo index</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdxMin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdxMax</name> <init>= <expr><call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// If the repo was specified then set index to the array location and max to loop only once</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptRepo</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>repoIdxMin</name> <operator>=</operator> <call><name>cfgOptionGroupIdxDefault</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>repoIdxMax</name> <operator>=</operator> <name>repoIdxMin</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If the set option was not provided by the user but a target was set, then we will need to search for a backup set that</comment>
        <comment type="line">// satisfies the target condition, else we will use the backup provided</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupSetRequested</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringId</name></type> <name>targetType</name> <init>= <expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <union>union
        <block>{
            <decl_stmt><decl><type><name>time_t</name></type> <name>time</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>lsn</name></decl>;</decl_stmt>
        }</block> <decl><name>target</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</union>

        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionSource</name><argument_list>(<argument><expr><name>cfgOptSet</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cfgSourceDefault</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>targetType</name> <operator>==</operator> <name>CFGOPTVAL_TYPE_TIME</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>target</name><operator>.</operator><name>time</name></name> <operator>=</operator> <call><name>getEpoch</name><argument_list>(<argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptTarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>targetType</name> <operator>==</operator> <name>CFGOPTVAL_TYPE_LSN</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>target</name><operator>.</operator><name>lsn</name></name> <operator>=</operator> <call><name>pgLsnFromStr</name><argument_list>(<argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptTarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>backupSetRequested</name> <operator>=</operator> <call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="line">// Search through the repo list for a backup set to use for recovery</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name> <init>= <expr><name>repoIdxMin</name></expr></init></decl>;</init> <condition><expr><name>repoIdx</name> <operator>&lt;=</operator> <name>repoIdxMax</name></expr>;</condition> <incr><expr><name>repoIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// Get the repo storage in case it is remote and encryption settings need to be pulled down</comment>
            <expr_stmt><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Attempt to load backup.info</comment>
            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>infoBackup</name> <operator>=</operator> <call><name>infoBackupLoadFile</name><argument_list>(
                    <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INFO_BACKUP_PATH_FILE_STR</name></expr></argument>, <argument><expr><call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>cfgOptionIdxStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"%s: [%s] %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>errorTypeName</name><argument_list>(<argument><expr><call><name>errorType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If unable to load the backup info file, then move on to next repo</comment>
            <if_stmt><if>if <condition>(<expr><name>infoBackup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                    <argument><expr><literal type="string">"%s: [%s] no backup sets to restore"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>errorTypeName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BackupSetInvalidError</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// If a backup set was not specified, then see if a target was requested</comment>
            <if_stmt><if>if <condition>(<expr><name>backupSetRequested</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Get the latest backup</comment>
                <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>latestBackup</name> <init>= <expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// If a target was requested, attempt to determine the backup set</comment>
                <if_stmt><if>if <condition>(<expr><name>targetType</name> <operator>==</operator> <name>CFGOPTVAL_TYPE_TIME</name> <operator>||</operator> <name>targetType</name> <operator>==</operator> <name>CFGOPTVAL_TYPE_LSN</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Search current backups from newest to oldest</comment>
                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>keyIdx</name> <init>= <expr><call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><operator>(</operator><name>int</name><operator>)</operator><name>keyIdx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>keyIdx</name><operator>--</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <comment type="line">// Get the backup data</comment>
                        <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>backupData</name> <init>= <expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>keyIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// If target is lsn and no backupLsnStop exists, exit this repo and log that backup may be manually selected</comment>
                        <if_stmt><if>if <condition>(<expr><name>targetType</name> <operator>==</operator> <name>CFGOPTVAL_TYPE_LSN</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>backupData</name><operator>.</operator><name>backupLsnStop</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                                <argument><expr><literal type="string">"%s reached backup from prior version missing required LSN info before finding a match -- backup"</literal>
                                    <literal type="string">" auto-select has been disabled for this repo\n"</literal>
                                <literal type="string">"HINT: you may specify a backup to restore using the --set option."</literal></expr></argument>,
                                <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// If the end of the backup is valid for the target, then select this backup</comment>
                        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>targetType</name> <operator>==</operator> <name>CFGOPTVAL_TYPE_TIME</name> <operator>&amp;&amp;</operator> <name><name>backupData</name><operator>.</operator><name>backupTimestampStop</name></name> <operator>&lt;</operator> <name><name>target</name><operator>.</operator><name>time</name></name><operator>)</operator> <operator>||</operator>
                            <operator>(</operator><name>targetType</name> <operator>==</operator> <name>CFGOPTVAL_TYPE_LSN</name> <operator>&amp;&amp;</operator> <call><name>pgLsnFromStr</name><argument_list>(<argument><expr><name><name>backupData</name><operator>.</operator><name>backupLsnStop</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>target</name><operator>.</operator><name>lsn</name></name><operator>)</operator></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>restoreBackupData</name><argument_list>(<argument><expr><name><name>backupData</name><operator>.</operator><name>backupLabel</name></name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>, <argument><expr><call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                    <comment type="line">// If a backup was found on this repo matching the criteria for time then exit</comment>
                    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else use backup set found</comment>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>restoreBackupData</name><argument_list>(<argument><expr><name><name>latestBackup</name><operator>.</operator><name>backupLabel</name></name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>, <argument><expr><call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <comment type="line">// Otherwise check to see if the specified backup set is on this repo</comment>
            <else>else
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupIdx</name> <operator>&lt;</operator> <call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call><operator>.</operator><name>backupLabel</name></expr></argument>, <argument><expr><name>backupSetRequested</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>restoreBackupData</name><argument_list>(<argument><expr><name>backupSetRequested</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>, <argument><expr><call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="line">// If the backup set is found, then exit, else continue to next repo</comment>
                <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>backupSet</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Still no backup set to use after checking all the repos required to be checked?</comment>
        <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>backupSet</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>backupSetRequested</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>BackupSetInvalidError</name></expr></argument>, <argument><expr><literal type="string">"backup set %s is not valid"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupSetRequested</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>targetType</name> <operator>==</operator> <name>CFGOPTVAL_TYPE_TIME</name> <operator>||</operator> <name>targetType</name> <operator>==</operator> <name>CFGOPTVAL_TYPE_LSN</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>BackupSetInvalidError</name></expr></argument>, <argument><expr><literal type="string">"unable to find backup set with %s '%s'"</literal></expr></argument>,
                    <argument><expr><ternary><condition><expr><name>targetType</name> <operator>==</operator> <name>CFGOPTVAL_TYPE_LSN</name></expr> ?</condition><then> <expr><literal type="string">"lsn less than or equal to"</literal></expr> </then><else>: <expr><literal type="string">"stop time less than"</literal></expr></else></ternary></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionDisplay</name><argument_list>(<argument><expr><name>cfgOptTarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>BackupSetInvalidError</name></expr></argument>, <argument><expr><literal type="string">"no backup set found to restore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_STRUCT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Validate the manifest
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restoreManifestValidate</name><parameter_list>(<parameter><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>backupSet</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// If there are no files in the manifest then something has gone horribly wrong</comment>
        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><call><name>manifestFileTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"manifest missing files"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Sanity check to ensure the manifest has not been moved to a new directory</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>, <argument><expr><name>backupSet</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                <argument><expr><name>FormatError</name></expr></argument>,
                <argument><expr><literal type="string">"requested backup '%s' and manifest label '%s' do not match\n"</literal>
                <literal type="string">"HINT: this indicates some sort of corruption (at the very least paths have been renamed)."</literal></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupSet</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Remap the manifest based on mappings provided by the user
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restoreManifestMap</name><parameter_list>(<parameter><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Remap the data directory</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pgPath</name> <init>= <expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptPgPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestTarget</name> <modifier>*</modifier></type><name>targetBase</name> <init>= <expr><call><name>manifestTargetBase</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>targetBase</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"remap data directory to '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>manifestTargetUpdate</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name><name>targetBase</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Remap tablespaces</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>KeyValue</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tablespaceMap</name> <init>= <expr><call><name>cfgOptionKvNull</name><argument_list>(<argument><expr><name>cfgOptTablespaceMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>tablespaceMapAllPath</name> <init>= <expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptTablespaceMapAll</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>tablespaceMap</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>tablespaceMapAllPath</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>tablespaceRemapped</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>manifestTargetTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>targetIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>manifestTarget</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Is this a tablespace?</comment>
                <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>tablespacePath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Check for an individual mapping for this tablespace</comment>
                    <if_stmt><if>if <condition>(<expr><name>tablespaceMap</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Attempt to get the tablespace by name</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>tablespacePathByName</name> <init>= <expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>tablespaceMap</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>tablespacePathByName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>tablespaceRemapped</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                        <comment type="line">// Attempt to get the tablespace by id</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>tablespacePathById</name> <init>= <expr><call><name>varStr</name><argument_list>(
                            <argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>tablespaceMap</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>varStrForce</name><argument_list>(<argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>tablespacePathById</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>tablespaceRemapped</name></expr></argument>, <argument><expr><call><name>varStrForce</name><argument_list>(<argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                        <comment type="line">// Error when both are set but the paths are different</comment>
                        <if_stmt><if>if <condition>(<expr><name>tablespacePathByName</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>tablespacePathById</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator>
                            <call><name>strEq</name><argument_list>(<argument><expr><name>tablespacePathByName</name></expr></argument>, <argument><expr><name>tablespacePathById</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                <argument><expr><name>TablespaceMapError</name></expr></argument>, <argument><expr><literal type="string">"tablespace remapped by name '%s' and id %u with different paths"</literal></expr></argument>,
                                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceName</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <comment type="line">// Else set the path by name</comment>
                        <if type="elseif">else if <condition>(<expr><name>tablespacePathByName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>tablespacePath</name> <operator>=</operator> <name>tablespacePathByName</name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <comment type="line">// Else set the path by id</comment>
                        <if type="elseif">else if <condition>(<expr><name>tablespacePathById</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>tablespacePath</name> <operator>=</operator> <name>tablespacePathById</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// If not individual mapping check if all tablespaces are being remapped</comment>
                    <if_stmt><if>if <condition>(<expr><name>tablespacePath</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>tablespaceMapAllPath</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>tablespacePath</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>tablespaceMapAllPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Remap tablespace if a mapping was found</comment>
                    <if_stmt><if>if <condition>(<expr><name>tablespacePath</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"map tablespace '%s' to '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>tablespacePath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>manifestTargetUpdate</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>tablespacePath</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>manifestLinkUpdate</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tablespacePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="line">// Error on invalid tablespaces</comment>
            <if_stmt><if>if <condition>(<expr><name>tablespaceMap</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>VariantList</name> <modifier>*</modifier></type><name>tablespaceMapList</name> <init>= <expr><call><name>kvKeyList</name><argument_list>(<argument><expr><name>tablespaceMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>strLstSort</name><argument_list>(<argument><expr><name>tablespaceRemapped</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>tablespaceMapIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>tablespaceMapIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>tablespaceMapList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>tablespaceMapIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>tablespace</name> <init>= <expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>tablespaceMapList</name></expr></argument>, <argument><expr><name>tablespaceMapIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>tablespaceRemapped</name></expr></argument>, <argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>TablespaceMapError</name></expr></argument>, <argument><expr><literal type="string">"unable to remap invalid tablespace '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Issue a warning message when remapping tablespaces in PostgreSQL &lt; 9.2</comment>
            <if_stmt><if>if <condition>(<expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pgVersion</name> <operator>&lt;=</operator> <name>PG_VERSION_92</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"update pg_tablespace.spclocation with new tablespace locations for PostgreSQL &lt;= "</literal> <name>PG_VERSION_92_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Remap links</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>KeyValue</name> <modifier>*</modifier><specifier>const</specifier></type> <name>linkMap</name> <init>= <expr><call><name>cfgOptionKvNull</name><argument_list>(<argument><expr><name>cfgOptLinkMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>linkMap</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>linkMapList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(<argument><expr><call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>kvKeyList</name><argument_list>(<argument><expr><name>linkMap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>linkMapIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>linkMapIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>linkMapList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>linkMapIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>link</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>linkMapList</name></expr></argument>, <argument><expr><name>linkMapIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>linkPath</name> <init>= <expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>linkMap</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifestName</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Attempt to find the link target</comment>
                <decl_stmt><decl><type><name>ManifestTarget</name></type> <name>target</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>manifestTargetFindDefault</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>target</name> <operator>=</operator> <operator>*</operator><call><name>manifestTargetFind</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// If the target was not found then check if the link is a valid file or path</comment>
                <decl_stmt><decl><type><name>bool</name></type> <name>create</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>.</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Is the specified link a file or a path? Error if they both match.</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>pathExists</name> <init>= <expr><call><name>manifestPathFindDefault</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>fileExists</name> <init>= <expr><call><name>manifestFileExists</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><operator>!</operator><name>pathExists</name> <operator>||</operator> <operator>!</operator><name>fileExists</name></expr></argument>, <argument><expr><literal type="string">"link may not be both file and path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>ManifestTarget</name><operator>)</operator><block>{<expr><operator>.</operator><name>name</name> <operator>=</operator> <name>manifestName</name></expr>, <expr><operator>.</operator><name>path</name> <operator>=</operator> <name>linkPath</name></expr>, <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>manifestTargetTypeLink</name></expr>}</block></expr>;</expr_stmt>

                    <comment type="line">// If a file</comment>
                    <if_stmt><if>if <condition>(<expr><name>fileExists</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// File needs to be set so the file/path is updated later but set it to something invalid just in case it</comment>
                        <comment type="line">// it does not get updated due to a regression</comment>
                        <expr_stmt><expr><name><name>target</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>DOT_STR</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Else error if not a path</comment>
                    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>pathExists</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>LinkMapError</name></expr></argument>,
                            <argument><expr><literal type="string">"unable to map link '%s'\n"</literal>
                            <literal type="string">"HINT: Does the link reference a valid backup path or file?"</literal></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Add the link. Copy user/group from the base data directory.</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestPath</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pathBase</name> <init>= <expr><call><name>manifestPathFind</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGDATA_STR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <macro><name>manifestLinkAdd</name><argument_list>(
                        <argument>manifest</argument>,
                        <argument>&amp;(ManifestLink){
                            .name = manifestName</argument>, <argument>.destination = linkPath</argument>, <argument>.group = pathBase-&gt;group</argument>, <argument>.user = pathBase-&gt;user}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

                    <expr_stmt><expr><name>create</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else update target to new path</comment>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>target</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name>linkPath</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="line">// The target must be a link since pg_data/ was prepended and pgdata is the only allowed path</comment>
                <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><name><name>target</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>manifestTargetTypeLink</name></expr></argument>, <argument><expr><literal type="string">"target must be a link"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Error if the target is a tablespace</comment>
                <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>.</operator><name>tablespaceId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                        <argument><expr><name>LinkMapError</name></expr></argument>,
                        <argument><expr><literal type="string">"unable to remap tablespace '%s'\n"</literal>
                        <literal type="string">"HINT: use '"</literal> <name>CFGOPT_TABLESPACE_MAP</name> <literal type="string">"' option to remap tablespaces."</literal></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"%slink '%s' to '%s'"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>create</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"map "</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// If the link was not created update to the new destination</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>create</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>manifestLinkUpdate</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name><name>target</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// If the link is a file separate the file name from the path</comment>
                <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>.</operator><name>file</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// The link destination must have at least one path component in addition to the file part. So '..' would</comment>
                    <comment type="line">// not be a valid destination but '../file' or '/file' is.</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><call><name>strPath</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>LinkMapError</name></expr></argument>, <argument><expr><literal type="string">"'%s' is not long enough to be the destination for file link '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name><name>target</name><operator>.</operator><name>file</name></name> <operator>=</operator> <call><name>strBase</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>target</name><operator>.</operator><name>path</name></name> <operator>=</operator> <call><name>strPath</name><argument_list>(<argument><expr><name><name>target</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Create a new target or update the existing target file/path</comment>
                <if_stmt><if>if <condition>(<expr><name>create</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>manifestTargetAdd</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>manifestTargetUpdate</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name><name>target</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>.</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>.</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If all links are not being restored then check for links that were not remapped and remove them</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptLinkAll</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>manifestTargetTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>targetIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestTarget</name> <modifier>*</modifier><specifier>const</specifier></type> <name>target</name> <init>= <expr><call><name>manifestTarget</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Is this a non-tablespace link?</comment>
                <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>manifestTargetTypeLink</name> <operator>&amp;&amp;</operator> <name><name>target</name><operator>-&gt;</operator><name>tablespaceId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>link</name> <init>= <expr><call><name>strSub</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>MANIFEST_TARGET_PGDATA_STR</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// If the link was not remapped then remove it</comment>
                    <if_stmt><if>if <condition>(<expr><name>linkMap</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>kvGet</name><argument_list>(<argument><expr><name>linkMap</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>file</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"file link '%s' will be restored as a file at the same location"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                                <argument><expr><literal type="string">"contents of directory link '%s' will be restored in a directory at the same location"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>

                        <expr_stmt><expr><call><name>manifestLinkRemove</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>manifestTargetRemove</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>targetIdx</name><operator>--</operator></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Check ownership of items in the manifest
***********************************************************************************************************************************/</comment>
<comment type="line">// Helper to determine what the user/group of a path/file/link should be</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>String</name> <modifier>*</modifier></type>
<name>restoreManifestOwnerReplace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>owner</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ownerDefaultRoot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>ownerDefaultRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>userRoot</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name>owner</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>ownerDefaultRoot</name></expr> </then><else>: <expr><name>owner</name></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Helper to get list of owners from a file/link/path list</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE_MANIFEST_OWNER_GET</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>deref</name></type></parameter>)</parameter_list></cpp:macro>                                                                                    \
    <cpp:value>for (unsigned int itemIdx = 0; itemIdx &lt; manifest##type##Total(manifest); itemIdx++)                                           \
    {                                                                                                                              \
        Manifest##type item = deref manifest##type(manifest, itemIdx);                                                             \
                                                                                                                                   \
        if (item.user == NULL)                                                                                                     \
            userNull = true;                                                                                                       \
        else                                                                                                                       \
            strLstAddIfMissing(userList, item.user);                                                                               \
                                                                                                                                   \
        if (item.group == NULL)                                                                                                    \
            groupNull = true;                                                                                                      \
        else                                                                                                                       \
            strLstAddIfMissing(groupList, item.group);                                                                             \
    }</cpp:value></cpp:define>

<comment type="line">// Helper to warn when an owner is missing and must be remapped</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE_MANIFEST_OWNER_WARN</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro>                                                                                          \
    <cpp:value>do                                                                                                                             \
    {                                                                                                                              \
        if (type##Null)                                                                                                            \
            LOG_WARN("unknown " #type " in backup manifest mapped to current " #type);                                             \
                                                                                                                                   \
        for (unsigned int ownerIdx = 0; ownerIdx &lt; strLstSize(type##List); ownerIdx++)                                             \
        {                                                                                                                          \
            const String *owner = strLstGet(type##List, ownerIdx);                                                                 \
                                                                                                                                   \
            if (type##Name() == NULL || !strEq(type##Name(), owner))                                                               \
                LOG_WARN_FMT("unknown " #type " '%s' in backup manifest mapped to current " #type, strZ(owner));                   \
        }                                                                                                                          \
    }                                                                                                                              \
    while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>restoreManifestOwner</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>rootReplaceUser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><modifier>*</modifier><specifier>const</specifier></type> <name>rootReplaceGroup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>rootReplaceUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>rootReplaceGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Build a list of users and groups in the manifest</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>userNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>userList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>groupNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>groupList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>RESTORE_MANIFEST_OWNER_GET</name><argument_list>(<argument><expr><name>File</name></expr></argument>, )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RESTORE_MANIFEST_OWNER_GET</name><argument_list>(<argument><expr><name>Link</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>ManifestLink</name> <operator>*</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RESTORE_MANIFEST_OWNER_GET</name><argument_list>(<argument><expr><name>Path</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>ManifestPath</name> <operator>*</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Update users and groups in the manifest (this can only be done as root)</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <if_stmt><if>if <condition>(<expr><call><name>userRoot</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Get user/group info from data directory to use for invalid user/groups</comment>
            <decl_stmt><decl><type><name>StorageInfo</name></type> <name>pathInfo</name> <init>= <expr><call><name>storageInfoP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>manifestTargetBase</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If user/group is null then set it to root</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pathInfo</name><operator>.</operator><name>user</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>                                                                              <comment type="line">// {vm_covered}</comment>
                <expr_stmt><expr><name><name>pathInfo</name><operator>.</operator><name>user</name></name> <operator>=</operator> <call><name>userName</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>                                                                         <comment type="line">// {vm_covered}</comment>

            <if_stmt><if>if <condition>(<expr><name><name>pathInfo</name><operator>.</operator><name>group</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>                                                                             <comment type="line">// {vm_covered}</comment>
                <expr_stmt><expr><name><name>pathInfo</name><operator>.</operator><name>group</name></name> <operator>=</operator> <call><name>groupName</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>                                                                       <comment type="line">// {vm_covered}</comment>

            <if_stmt><if>if <condition>(<expr><name>userNull</name> <operator>||</operator> <name>groupNull</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>userNull</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"unknown user in backup manifest mapped to '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>pathInfo</name><operator>.</operator><name>user</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>groupNull</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"unknown group in backup manifest mapped to '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>pathInfo</name><operator>.</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>rootReplaceUser</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>pathInfo</name><operator>.</operator><name>user</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>rootReplaceGroup</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>pathInfo</name><operator>.</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else set owners to NULL.  This means we won't make any attempt to update ownership and will just leave it as written by</comment>
        <comment type="line">// the current user/group.  If there are existing files that are not owned by the current user/group then we will attempt</comment>
        <comment type="line">// to update them, which will generally cause an error, though some systems allow updates to the group ownership.</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>RESTORE_MANIFEST_OWNER_WARN</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RESTORE_MANIFEST_OWNER_WARN</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Clean the data directory of any paths/files/links that are not in the manifest and create missing links/paths
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>RestoreCleanCallbackData</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl>;</decl_stmt>                                       <comment type="line">// Manifest to compare against</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestTarget</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>                                   <comment type="line">// Current target being compared</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>targetName</name></decl>;</decl_stmt>                                       <comment type="line">// Name to use when finding files/paths/links</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>targetPath</name></decl>;</decl_stmt>                                       <comment type="line">// Path of target currently being compared</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>subPath</name></decl>;</decl_stmt>                                          <comment type="line">// Subpath in target currently being compared</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>basePath</name></decl>;</decl_stmt>                                                  <comment type="line">// Is this the base path?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>exists</name></decl>;</decl_stmt>                                                    <comment type="line">// Does the target path exist?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>delta</name></decl>;</decl_stmt>                                                     <comment type="line">// Is this a delta restore?</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>fileIgnore</name></decl>;</decl_stmt>                                         <comment type="line">// Files to ignore during clean</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>rootReplaceUser</name></decl>;</decl_stmt>                                  <comment type="line">// User to replace invalid users when root</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>rootReplaceGroup</name></decl>;</decl_stmt>                                 <comment type="line">// Group to replace invalid group when root</comment>
}</block></struct></type> <name>RestoreCleanCallbackData</name>;</typedef>

<comment type="line">// Helper to update ownership on a file/link/path</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restoreCleanOwnership</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pgPath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>manifestUserName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>rootReplaceUser</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>manifestGroupName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>rootReplaceGroup</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uid_t</name></type> <name>actualUserId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>gid_t</name></type> <name>actualGroupId</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>new</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>manifestUserName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>manifestGroupName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>actualUserId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>actualGroupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pgPath</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Get the expected user id</comment>
    <decl_stmt><decl><type><name>uid_t</name></type> <name>expectedUserId</name> <init>= <expr><call><name>userId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>manifestUserName</name> <operator>=</operator> <call><name>restoreManifestOwnerReplace</name><argument_list>(<argument><expr><name>manifestUserName</name></expr></argument>, <argument><expr><name>rootReplaceUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>manifestUserName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uid_t</name></type> <name>manifestUserId</name> <init>= <expr><call><name>userIdFromName</name><argument_list>(<argument><expr><name>manifestUserName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>manifestUserId</name> <operator>!=</operator> <operator>(</operator><name>uid_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>expectedUserId</name> <operator>=</operator> <name>manifestUserId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Get the expected group id</comment>
    <decl_stmt><decl><type><name>gid_t</name></type> <name>expectedGroupId</name> <init>= <expr><call><name>groupId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>manifestGroupName</name> <operator>=</operator> <call><name>restoreManifestOwnerReplace</name><argument_list>(<argument><expr><name>manifestGroupName</name></expr></argument>, <argument><expr><name>rootReplaceGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>manifestGroupName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uid_t</name></type> <name>manifestGroupId</name> <init>= <expr><call><name>groupIdFromName</name><argument_list>(<argument><expr><name>manifestGroupName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>manifestGroupId</name> <operator>!=</operator> <operator>(</operator><name>uid_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>expectedGroupId</name> <operator>=</operator> <name>manifestGroupId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Update ownership if not as expected</comment>
    <if_stmt><if>if <condition>(<expr><name>actualUserId</name> <operator>!=</operator> <name>expectedUserId</name> <operator>||</operator> <name>actualGroupId</name> <operator>!=</operator> <name>expectedGroupId</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// If this is a newly created file/link/path then there's no need to log updated permissions</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>new</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"update ownership for '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR_FMT</name><argument_list>(
            <argument><expr><call><name>lchown</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expectedUserId</name></expr></argument>, <argument><expr><name>expectedGroupId</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>FileOwnerError</name></expr></argument>, <argument><expr><literal type="string">"unable to set ownership for '%s'"</literal></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Helper to update mode on a file/path</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restoreCleanMode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pgPath</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>manifestMode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StorageInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name>manifestMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pgPath</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>info</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Update mode if not as expected</comment>
    <if_stmt><if>if <condition>(<expr><name>manifestMode</name> <operator>!=</operator> <name><name>info</name><operator>-&gt;</operator><name>mode</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"update mode for '%s' to %04o"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>manifestMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR_FMT</name><argument_list>(
            <argument><expr><call><name>chmod</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>manifestMode</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>FileModeError</name></expr></argument>, <argument><expr><literal type="string">"unable to set mode for '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Recurse paths</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restoreCleanBuildRecurse</name><parameter_list>(<parameter><decl><type><name>StorageIterator</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storageItr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RestoreCleanCallbackData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cleanData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STORAGE_ITERATOR</name></expr></argument>, <argument><expr><name>storageItr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>cleanData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>storageItr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>cleanData</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_RESET_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <while>while <condition>(<expr><call><name>storageItrMore</name><argument_list>(<argument><expr><name>storageItr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>StorageInfo</name></type> <name>info</name> <init>= <expr><call><name>storageItrNext</name><argument_list>(<argument><expr><name>storageItr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Don't include backup.manifest or recovery.conf (when preserved) in the comparison or empty directory check</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cleanData</name><operator>-&gt;</operator><name>basePath</name></name> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>storageTypeFile</name> <operator>&amp;&amp;</operator> <call><name>strLstExists</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>fileIgnore</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="line">// If this is not a delta then error because the directory is expected to be empty.  Ignore the . path.</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cleanData</name><operator>-&gt;</operator><name>delta</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>PathNotEmptyError</name></expr></argument>,
                    <argument><expr><literal type="string">"unable to restore to path '%s' because it contains files\n"</literal>
                    <literal type="string">"HINT: try using --delta if this is what you intended."</literal></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Construct the name used to find this file/link/path in the manifest</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>manifestName</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetName</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Construct the path of this file/link/path in the PostgreSQL data directory</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pgPath</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><name><name>info</name><operator>.</operator><name>type</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>storageTypeFile</name></expr>:</case>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>manifestFileExists</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                        <call><name>manifestLinkFindDefault</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFile</name></type> <name>manifestFile</name> <init>= <expr><call><name>manifestFileFind</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>restoreCleanOwnership</name><argument_list>(
                            <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><name><name>manifestFile</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>rootReplaceUser</name></name></expr></argument>, <argument><expr><name><name>manifestFile</name><operator>.</operator><name>group</name></name></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>rootReplaceGroup</name></name></expr></argument>,
                            <argument><expr><name><name>info</name><operator>.</operator><name>userId</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>restoreCleanMode</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>, <argument><expr><name><name>manifestFile</name><operator>.</operator><name>mode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"remove invalid file '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storageLocalWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <break>break;</break>
                </block_content>}</block>

                <case>case <expr><name>storageTypeLink</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestLink</name> <modifier>*</modifier></type><name>manifestLink</name> <init>= <expr><call><name>manifestLinkFindDefault</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>manifestLink</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>manifestLink</name><operator>-&gt;</operator><name>destination</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>linkDestination</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"remove link '%s' because destination changed"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storageLocalWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>restoreCleanOwnership</name><argument_list>(
                                <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><name><name>manifestLink</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>rootReplaceUser</name></name></expr></argument>, <argument><expr><name><name>manifestLink</name><operator>-&gt;</operator><name>group</name></name></expr></argument>,
                                <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>rootReplaceGroup</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>userId</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"remove invalid link '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storageLocalWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <break>break;</break>
                </block_content>}</block>

                <case>case <expr><name>storageTypePath</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestPath</name> <modifier>*</modifier></type><name>manifestPath</name> <init>= <expr><call><name>manifestPathFindDefault</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>manifestPath</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>manifestLinkFindDefault</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Check ownership/permissions</comment>
                        <expr_stmt><expr><call><name>restoreCleanOwnership</name><argument_list>(
                            <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><name><name>manifestPath</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>rootReplaceUser</name></name></expr></argument>, <argument><expr><name><name>manifestPath</name><operator>-&gt;</operator><name>group</name></name></expr></argument>,
                            <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>rootReplaceGroup</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>userId</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>restoreCleanMode</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>, <argument><expr><name><name>manifestPath</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Recurse into the path</comment>
                        <decl_stmt><decl><type><name>RestoreCleanCallbackData</name></type> <name>cleanDataSub</name> <init>= <expr><operator>*</operator><name>cleanData</name></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name><name>cleanDataSub</name><operator>.</operator><name>targetName</name></name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetName</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>cleanDataSub</name><operator>.</operator><name>targetPath</name></name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>cleanDataSub</name><operator>.</operator><name>basePath</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>restoreCleanBuildRecurse</name><argument_list>(
                            <argument><expr><call><name>storageNewItrP</name><argument_list>(
                                <argument><expr><call><name>storageLocalWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cleanDataSub</name><operator>.</operator><name>targetPath</name></name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>sortOrder</name> <operator>=</operator> <name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>cleanDataSub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"remove invalid path '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>storagePathRemoveP</name><argument_list>(<argument><expr><call><name>storageLocalWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>recurse</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <break>break;</break>
                </block_content>}</block>

                <comment type="line">// Special file types cannot exist in the manifest so just delete them</comment>
                <case>case <expr><name>storageTypeSpecial</name></expr>:</case>
                    <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"remove special file '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storageLocalWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>

            <comment type="line">// Reset the memory context occasionally so we don't use too much memory or slow down processing</comment>
            <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_RESET</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>restoreCleanBuild</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>rootReplaceUser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>rootReplaceGroup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>rootReplaceUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>rootReplaceGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Is this a delta restore?</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>delta</name> <init>= <expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDelta</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptForce</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Allocate data for each target</comment>
        <decl_stmt><decl><type><name>RestoreCleanCallbackData</name> <modifier>*</modifier></type><name>cleanDataList</name> <init>= <expr><call><name>memNew</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RestoreCleanCallbackData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>manifestTargetTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Step 1: Check permissions and validity (is the directory empty without delta?) if the target directory exists</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>pathChecked</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>manifestTargetTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>targetIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestoreCleanCallbackData</name> <modifier>*</modifier></type><name>cleanData</name> <init>= <expr><operator>&amp;</operator><name><name>cleanDataList</name><index>[<expr><name>targetIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><operator>*</operator><name>cleanData</name> <operator>=</operator> <operator>(</operator><name>RestoreCleanCallbackData</name><operator>)</operator>
            <block>{
                <expr><operator>.</operator><name>manifest</name> <operator>=</operator> <name>manifest</name></expr>,
                <expr><operator>.</operator><name>target</name> <operator>=</operator> <call><name>manifestTarget</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>delta</name> <operator>=</operator> <name>delta</name></expr>,
                <expr><operator>.</operator><name>fileIgnore</name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>,
                <expr><operator>.</operator><name>rootReplaceUser</name> <operator>=</operator> <name>rootReplaceUser</name></expr>,
                <expr><operator>.</operator><name>rootReplaceGroup</name> <operator>=</operator> <name>rootReplaceGroup</name></expr>,
            }</block></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetName</name></name> <operator>=</operator> <name><name>cleanData</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name> <operator>=</operator> <call><name>manifestTargetPath</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cleanData</name><operator>-&gt;</operator><name>basePath</name></name> <operator>=</operator> <call><name>strEq</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetName</name></name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGDATA_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Ignore backup.manifest while cleaning since it may exist from an prior incomplete restore</comment>
            <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>fileIgnore</name></name></expr></argument>, <argument><expr><name>BACKUP_MANIFEST_FILE_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Also ignore recovery files when recovery type = preserve</comment>
            <if_stmt><if>if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_TYPE_PRESERVE</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If recovery GUCs then three files must be preserved</comment>
                <if_stmt><if>if <condition>(<expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_RECOVERY_GUC</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>fileIgnore</name></name></expr></argument>, <argument><expr><name>PG_FILE_POSTGRESQLAUTOCONF_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>fileIgnore</name></name></expr></argument>, <argument><expr><name>PG_FILE_RECOVERYSIGNAL_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>fileIgnore</name></name></expr></argument>, <argument><expr><name>PG_FILE_STANDBYSIGNAL_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else just recovery.conf</comment>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>fileIgnore</name></name></expr></argument>, <argument><expr><name>PG_FILE_RECOVERYCONF_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// If this is a tablespace append the tablespace identifier</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cleanData</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>manifestTargetTypeLink</name> <operator>&amp;&amp;</operator> <name><name>cleanData</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>tablespaceId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>tablespaceId</name> <init>= <expr><call><name>pgTablespaceId</name><argument_list>(
                    <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pgVersion</name></expr></argument>, <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pgCatalogVersion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetName</name></name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetName</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>strLstSort</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>fileIgnore</name></name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Check that the path exists.  If not, there's no need to do any cleaning and we'll attempt to create it later.</comment>
            <comment type="line">// Don't log check for the same path twice.  There can be multiple links to files in the same path, but logging it more</comment>
            <comment type="line">// than once makes the logs noisy and looks like a bug.</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>pathChecked</name></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"check '%s' exists"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name>StorageInfo</name></type> <name>info</name> <init>= <expr><call><name>storageInfoP</name><argument_list>(<argument><expr><call><name>storageLocal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>followLink</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>pathChecked</name></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>exists</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Make sure our uid will be able to write to this directory</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>userRoot</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>userId</name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>info</name><operator>.</operator><name>userId</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                        <argument><expr><name>PathOpenError</name></expr></argument>, <argument><expr><literal type="string">"unable to restore to path '%s' not owned by current user"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>info</name><operator>.</operator><name>mode</name></name> <operator>&amp;</operator> <literal type="number">0700</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0700</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                        <argument><expr><name>PathOpenError</name></expr></argument>, <argument><expr><literal type="string">"unable to restore to path '%s' without rwx permissions"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// If not a delta restore then check that the directories are empty, or if a file link, that the file doesn't exist</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cleanData</name><operator>-&gt;</operator><name>delta</name></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>cleanData</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>restoreCleanBuildRecurse</name><argument_list>(
                            <argument><expr><call><name>storageNewItrP</name><argument_list>(<argument><expr><call><name>storageLocal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cleanData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storageLocal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                <argument><expr><name>FileExistsError</name></expr></argument>,
                                <argument><expr><literal type="string">"unable to restore file '%s' because it already exists\n"</literal>
                                <literal type="string">"HINT: try using --delta if this is what you intended."</literal></expr></argument>,
                                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></else></if_stmt>

                    <comment type="line">// Now that we know there are no files in this target enable delta for processing in step 2</comment>
                    <expr_stmt><expr><name><name>cleanData</name><operator>-&gt;</operator><name>delta</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// The target directory exists and is valid and will need to be cleaned</comment>
                <expr_stmt><expr><name><name>cleanData</name><operator>-&gt;</operator><name>exists</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Skip the tablespace_map file when present so PostgreSQL does not rewrite links in pg_tblspc. The tablespace links will be</comment>
        <comment type="line">// created after paths are cleaned.</comment>
        <if_stmt><if>if <condition>(<expr><call><name>manifestFileExists</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal> <name>PG_FILE_TABLESPACEMAP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_TABLESPACE_MAP</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"skip '"</literal> <name>PG_FILE_TABLESPACEMAP</name> <literal type="string">"' -- tablespace links will be created based on mappings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>manifestFileRemove</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal> <name>PG_FILE_TABLESPACEMAP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Skip postgresql.auto.conf if preserve is set and the PostgreSQL version supports recovery GUCs</comment>
        <if_stmt><if>if <condition>(<expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_RECOVERY_GUC</name> <operator>&amp;&amp;</operator> <call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_TYPE_PRESERVE</name> <operator>&amp;&amp;</operator>
            <call><name>manifestFileExists</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal> <name>PG_FILE_POSTGRESQLAUTOCONF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"skip '"</literal> <name>PG_FILE_POSTGRESQLAUTOCONF</name> <literal type="string">"' -- recovery type is preserve"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>manifestFileRemove</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal> <name>PG_FILE_POSTGRESQLAUTOCONF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Step 2: Clean target directories</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <comment type="line">// Delete the pg_control file (if it exists) so the cluster cannot be started if restore does not complete.  Sync the path</comment>
        <comment type="line">// so the file does not return, zombie-like, in the case of a host crash.</comment>
        <if_stmt><if>if <condition>(<expr><call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(
                <argument><expr><literal type="string">"remove '"</literal> <name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name> <literal type="string">"' so cluster will not start if restore does not complete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>storagePathSyncP</name><argument_list>(<argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PG_PATH_GLOBAL_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>manifestTargetTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>targetIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestoreCleanCallbackData</name> <modifier>*</modifier></type><name>cleanData</name> <init>= <expr><operator>&amp;</operator><name><name>cleanDataList</name><index>[<expr><name>targetIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Only clean if the target exists</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cleanData</name><operator>-&gt;</operator><name>exists</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Don't clean file links.  It doesn't matter whether the file exists or not since we know it is in the manifest.</comment>
                <if_stmt><if>if <condition>(<expr><name><name>cleanData</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Only log when doing a delta restore because otherwise the targets should be empty.  We'll still run the clean</comment>
                    <comment type="line">// to fix permissions/ownership on the target paths.</comment>
                    <if_stmt><if>if <condition>(<expr><name>delta</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"remove invalid files/links/paths from '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Check target ownership/permissions</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestPath</name> <modifier>*</modifier></type><name>manifestPath</name> <init>= <expr><call><name>manifestPathFind</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>StorageInfo</name></type> <name>info</name> <init>= <expr><call><name>storageInfoP</name><argument_list>(<argument><expr><call><name>storageLocal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>, <argument><expr><operator>.</operator><name>followLink</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>restoreCleanOwnership</name><argument_list>(
                        <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>, <argument><expr><name><name>manifestPath</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>rootReplaceUser</name></expr></argument>, <argument><expr><name><name>manifestPath</name><operator>-&gt;</operator><name>group</name></name></expr></argument>, <argument><expr><name>rootReplaceGroup</name></expr></argument>,
                        <argument><expr><name><name>info</name><operator>.</operator><name>userId</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>restoreCleanMode</name><argument_list>(<argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>, <argument><expr><name><name>manifestPath</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Clean the target</comment>
                    <expr_stmt><expr><call><name>restoreCleanBuildRecurse</name><argument_list>(
                        <argument><expr><call><name>storageNewItrP</name><argument_list>(
                            <argument><expr><call><name>storageLocalWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>sortOrder</name> <operator>=</operator> <name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>cleanData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <comment type="line">// If the target does not exist we'll attempt to create it</comment>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestPath</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <comment type="line">// There is no path information for a file link so we'll need to use the data directory</comment>
                <if_stmt><if>if <condition>(<expr><name><name>cleanData</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>file</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>manifestPathFind</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGDATA_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else grab the info for the path that matches the link name</comment>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>manifestPathFind</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><call><name>storagePathCreateP</name><argument_list>(<argument><expr><call><name>storageLocalWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>, <argument><expr><operator>.</operator><name>mode</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>restoreCleanOwnership</name><argument_list>(
                    <argument><expr><name><name>cleanData</name><operator>-&gt;</operator><name>targetPath</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>rootReplaceUser</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>group</name></name></expr></argument>, <argument><expr><name>rootReplaceGroup</name></expr></argument>, <argument><expr><call><name>userId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>groupId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Step 3: Create missing paths and path links</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>pathIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pathIdx</name> <operator>&lt;</operator> <call><name>manifestPathTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pathIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestPath</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>manifestPath</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>pathIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Skip the pg_tblspc path because it only maps to the manifest.  We should remove this in a future release but not much</comment>
            <comment type="line">// can be done about it for now.</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGTBLSPC_STR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="line">// If this path has been mapped as a link then create a link.  The path has already been created as part of target</comment>
            <comment type="line">// creation (or it might have already existed).</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestLink</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><call><name>manifestLinkFindDefault</name><argument_list>(
                <argument><expr><name>manifest</name></expr></argument>,
                <argument><expr><ternary><condition><expr><call><name>strBeginsWith</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGTBLSPC_STR</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
                    <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>path</name><operator>-&gt;</operator><name>name</name></name></expr></else></ternary></expr></argument>,
                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>link</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pgPath</name> <init>= <expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>manifestPathPg</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>StorageInfo</name></type> <name>linkInfo</name> <init>= <expr><call><name>storageInfoP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Create the link if it is missing.  If it exists it should already have the correct ownership and destination.</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>linkInfo</name><operator>.</operator><name>exists</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"create symlink '%s' to '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>destination</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>storageLinkCreateP</name><argument_list>(<argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>destination</name></name></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>restoreCleanOwnership</name><argument_list>(
                        <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>rootReplaceUser</name></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>group</name></name></expr></argument>, <argument><expr><name>rootReplaceGroup</name></expr></argument>, <argument><expr><call><name>userId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>groupId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <comment type="line">// Create the path normally</comment>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pgPath</name> <init>= <expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>manifestPathPg</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>StorageInfo</name></type> <name>pathInfo</name> <init>= <expr><call><name>storageInfoP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Create the path if it is missing. If it exists it should already have the correct ownership and mode.</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pathInfo</name><operator>.</operator><name>exists</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"create path '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>storagePathCreateP</name><argument_list>(<argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><operator>.</operator><name>mode</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><operator>.</operator><name>noParentCreate</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnExists</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>restoreCleanOwnership</name><argument_list>(
                        <argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>rootReplaceUser</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>group</name></name></expr></argument>, <argument><expr><name>rootReplaceGroup</name></expr></argument>, <argument><expr><call><name>userId</name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><call><name>groupId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Step 4: Create file links.  These don't get created during path creation because they do not have a matching path entry.</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>linkIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>linkIdx</name> <operator>&lt;</operator> <call><name>manifestLinkTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>linkIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestLink</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><call><name>manifestLink</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>linkIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pgPath</name> <init>= <expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>manifestPathPg</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>StorageInfo</name></type> <name>linkInfo</name> <init>= <expr><call><name>storageInfoP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Create the link if it is missing.  If it exists it should already have the correct ownership and destination.</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>linkInfo</name><operator>.</operator><name>exists</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"create symlink '%s' to '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>link</name><operator>-&gt;</operator><name>destination</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>storageLinkCreateP</name><argument_list>(<argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>destination</name></name></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>restoreCleanOwnership</name><argument_list>(
                    <argument><expr><name>pgPath</name></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>rootReplaceUser</name></expr></argument>, <argument><expr><name><name>link</name><operator>-&gt;</operator><name>group</name></name></expr></argument>, <argument><expr><name>rootReplaceGroup</name></expr></argument>, <argument><expr><call><name>userId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>groupId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Generate the expression to zero files that are not needed for selective restore
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>restoreSelectiveExpression</name><parameter_list>(<parameter><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Continue if databases to include or exclude have been specified</comment>
    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptDbExclude</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptDbInclude</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// Generate base expression</comment>
            <decl_stmt><decl><type><name>RegExp</name> <modifier>*</modifier></type><name>baseRegExp</name> <init>= <expr><call><name>regExpNew</name><argument_list>(<argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"^"</literal> <name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal> <name>PG_PATH_BASE</name> <literal type="string">"/[0-9]+/"</literal> <name>PG_FILE_PGVERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Generate tablespace expression</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>tablespaceId</name> <init>= <expr><call><name>pgTablespaceId</name><argument_list>(
                <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pgVersion</name></expr></argument>, <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pgCatalogVersion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RegExp</name> <modifier>*</modifier></type><name>tablespaceRegExp</name> <init>= <expr><call><name>regExpNew</name><argument_list>(
                    <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"^"</literal> <name>MANIFEST_TARGET_PGTBLSPC</name> <literal type="string">"/[0-9]+/%s/[0-9]+/"</literal> <name>PG_FILE_PGVERSION</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Generate a list of databases in base or in a tablespace and get all standard system databases, even in cases where</comment>
            <comment type="line">// users have recreated them</comment>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>systemDbIdList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>dbList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>systemDbIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>systemDbIdx</name> <operator>&lt;</operator> <call><name>manifestDbTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>systemDbIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestDb</name> <modifier>*</modifier></type><name>systemDb</name> <init>= <expr><call><name>manifestDb</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>systemDbIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>pgDbIsSystem</name><argument_list>(<argument><expr><name><name>systemDb</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>pgDbIsSystemId</name><argument_list>(<argument><expr><name><name>systemDb</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Build the system id list and add to the dbList for logging and checking</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>systemDbId</name> <init>= <expr><call><name>varStrForce</name><argument_list>(<argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>systemDb</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>systemDbIdList</name></expr></argument>, <argument><expr><name>systemDbId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>, <argument><expr><name>systemDbId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fileIdx</name> <operator>&lt;</operator> <call><name>manifestFileTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileName</name> <init>= <expr><call><name>manifestFileNameGet</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>regExpMatch</name><argument_list>(<argument><expr><name>baseRegExp</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>regExpMatch</name><argument_list>(<argument><expr><name>tablespaceRegExp</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>dbId</name> <init>= <expr><call><name>strBase</name><argument_list>(<argument><expr><call><name>strPath</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// In the highly unlikely event that a system database was somehow added after the backup began, it will only be</comment>
                    <comment type="line">// found in the file list and not the manifest db section, so add it to the system database list</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>pgDbIsSystemId</name><argument_list>(<argument><expr><call><name>cvtZToUInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>dbId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>strLstAddIfMissing</name><argument_list>(<argument><expr><name>systemDbIdList</name></expr></argument>, <argument><expr><name>dbId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name>strLstAddIfMissing</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>, <argument><expr><name>dbId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>strLstSort</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If no databases were found then this backup is not a valid cluster</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"no databases found for selective restore\nHINT: is this a valid cluster?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Log databases found</comment>
            <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"databases found for selective restore (%s)"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Generate list with ids of databases to exclude</comment>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>excludeDbIdList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>excludeList</name> <init>= <expr><call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>cfgOptionLst</name><argument_list>(<argument><expr><name>cfgOptDbExclude</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>excludeIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>excludeIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>excludeList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>excludeIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>excludeDb</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>excludeList</name></expr></argument>, <argument><expr><name>excludeIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// If the db to exclude is not in the list as an id then search by name</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>, <argument><expr><name>excludeDb</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestDb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>manifestDbFindDefault</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>excludeDb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>db</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>, <argument><expr><call><name>varStrForce</name><argument_list>(<argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>DbMissingError</name></expr></argument>, <argument><expr><literal type="string">"database to exclude '%s' does not exist"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>excludeDb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Set the exclude db to the id if the name mapping was successful</comment>
                    <expr_stmt><expr><name>excludeDb</name> <operator>=</operator> <call><name>varStrForce</name><argument_list>(<argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Add to exclude list</comment>
                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>excludeDbIdList</name></expr></argument>, <argument><expr><name>excludeDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="line">// Remove included databases from the list</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>includeList</name> <init>= <expr><call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>cfgOptionLst</name><argument_list>(<argument><expr><name>cfgOptDbInclude</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>includeIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>includeIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>includeList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>includeIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>includeDb</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>includeList</name></expr></argument>, <argument><expr><name>includeIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// If the db to include is not in the list as an id then search by name</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>, <argument><expr><name>includeDb</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestDb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>manifestDbFindDefault</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>includeDb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>db</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>, <argument><expr><call><name>varStrForce</name><argument_list>(<argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>DbMissingError</name></expr></argument>, <argument><expr><literal type="string">"database to include '%s' does not exist"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>includeDb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Set the include db to the id if the name mapping was successful</comment>
                    <expr_stmt><expr><name>includeDb</name> <operator>=</operator> <call><name>varStrForce</name><argument_list>(<argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Error if the db is a system db</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strLstExists</name><argument_list>(<argument><expr><name>systemDbIdList</name></expr></argument>, <argument><expr><name>includeDb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>DbInvalidError</name></expr></argument>, <argument><expr><literal type="string">"system databases (template0, postgres, etc.) are included by default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Error if the db id is in the exclude list</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strLstExists</name><argument_list>(<argument><expr><name>excludeDbIdList</name></expr></argument>, <argument><expr><name>includeDb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>DbInvalidError</name></expr></argument>, <argument><expr><literal type="string">"database to include '%s' is in the exclude list"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>includeDb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Remove from list of DBs to zero</comment>
                <expr_stmt><expr><call><name>strLstRemove</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>, <argument><expr><name>includeDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="line">// Only exclude specified db in case no db to include has been provided</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>includeList</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>dbList</name> <operator>=</operator> <call><name>strLstDup</name><argument_list>(<argument><expr><name>excludeDbIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else, remove the system databases from list of DBs to zero unless they are excluded explicitly</comment>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>strLstSort</name><argument_list>(<argument><expr><name>systemDbIdList</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strLstSort</name><argument_list>(<argument><expr><name>excludeDbIdList</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>systemDbIdList</name> <operator>=</operator> <call><name>strLstMergeAnti</name><argument_list>(<argument><expr><name>systemDbIdList</name></expr></argument>, <argument><expr><name>excludeDbIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>dbList</name> <operator>=</operator> <call><name>strLstMergeAnti</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>, <argument><expr><name>systemDbIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="line">// Build regular expression to identify files that will be zeroed</comment>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"databases excluded (zeroed) from selective restore (%s)"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Generate the expression from the list of databases to be zeroed. Only user created databases can be zeroed, never</comment>
                <comment type="line">// system databases.</comment>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>dbIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>dbIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>dbIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>dbList</name></expr></argument>, <argument><expr><name>dbIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Create expression string or append |</comment>
                    <if_stmt><if>if <condition>(<expr><name>expression</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>expression</name> <operator>=</operator> <call><name>strNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <comment type="line">// Filter files in base directory</comment>
                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><literal type="string">"(^"</literal> <name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal> <name>PG_PATH_BASE</name> <literal type="string">"/%s/)"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Filter files in tablespace directories</comment>
                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>manifestTargetTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>targetIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>manifestTarget</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><literal type="string">"|(^%s/%s/%s/)"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// If all user databases have been selected then nothing to do</comment>
            <if_stmt><if>if <condition>(<expr><name>expression</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"nothing to filter - all user databases have been selected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else return the expression</comment>
            <else>else
            <block>{<block_content>
                <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Generate the recovery file
***********************************************************************************************************************************/</comment>
<comment type="line">// Helper to generate recovery options</comment>
<function><type><specifier>static</specifier> <name>KeyValue</name> <modifier>*</modifier></type>
<name>restoreRecoveryOption</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>kvNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>recoveryOptionKey</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptRecoveryOption</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>KeyValue</name> <modifier>*</modifier></type><name>recoveryOption</name> <init>= <expr><call><name>cfgOptionKv</name><argument_list>(<argument><expr><name>cfgOptRecoveryOption</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>recoveryOptionKey</name> <operator>=</operator> <call><name>strLstSort</name><argument_list>(<argument><expr><call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>kvKeyList</name><argument_list>(<argument><expr><name>recoveryOption</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>keyIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>keyIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>recoveryOptionKey</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>keyIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="line">// Get the key and value</comment>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>recoveryOptionKey</name></expr></argument>, <argument><expr><name>keyIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>recoveryOption</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Replace - in key with _.  Since we use - users naturally will as well.</comment>
                <expr_stmt><expr><call><name>strReplaceChr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>strLstSort</name><argument_list>(<argument><expr><name>recoveryOptionKey</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If archive-mode is not preserve</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptArchiveMode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CFGOPTVAL_ARCHIVE_MODE_PRESERVE</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>pgVersion</name> <operator>&lt;</operator> <name>PG_VERSION_12</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>OptionInvalidError</name></expr></argument>,
                    <argument><expr><literal type="string">"option '"</literal> <name>CFGOPT_ARCHIVE_MODE</name> <literal type="string">"' is not supported on "</literal> <name>PG_NAME</name> <literal type="string">" &lt; "</literal> <name>PG_VERSION_12_STR</name> <literal type="string">"\n"</literal>
                        <literal type="string">"HINT: 'archive_mode' should be manually set to 'off' in postgresql.conf."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// The only other valid option is off</comment>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptArchiveMode</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_ARCHIVE_MODE_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If archive-mode=off then set archive_mode=off</comment>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>ARCHIVE_MODE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPTVAL_ARCHIVE_MODE_OFF_Z</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Write restore_command</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>recoveryOptionKey</name></expr></argument>, <argument><expr><name>RESTORE_COMMAND_STR</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Null out options that it does not make sense to pass from the restore command to archive-get.  All of these have</comment>
            <comment type="line">// reasonable defaults so there is no danger of an error -- they just might not be optimal.  In any case, it seems</comment>
            <comment type="line">// better than, for example, passing --process-max=32 to archive-get because it was specified for restore.</comment>
            <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>optionReplace</name> <init>= <expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_EXEC_ID</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_JOB_RETRY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_JOB_RETRY_INTERVAL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_CONSOLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_FILE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_STDERR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_SUBPROCESS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_TIMESTAMP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_PROCESS_MAX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_CMD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>kvPut</name><argument_list>(
                <argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSTRZ</name><argument_list>(<argument><expr><name>RESTORE_COMMAND</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>VARSTR</name><argument_list>(
                    <argument><expr><call><name>strNewFmt</name><argument_list>(
                        <argument><expr><literal type="string">"%s %s %%f \"%%p\""</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptCmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><call><name>cfgExecParam</name><argument_list>(<argument><expr><name>cfgCmdArchiveGet</name></expr></argument>, <argument><expr><name>cfgCmdRoleMain</name></expr></argument>, <argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If recovery type is immediate</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_TYPE_IMMEDIATE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSTRZ</name><argument_list>(<argument><expr><name>RECOVERY_TARGET</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRZ</name><argument_list>(<argument><expr><name>CFGOPTVAL_TYPE_IMMEDIATE_Z</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else recovery type is standby</comment>
        <if type="elseif">else if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_TYPE_STANDBY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Write standby_mode for PostgreSQL versions that support it</comment>
            <if_stmt><if>if <condition>(<expr><name>pgVersion</name> <operator>&lt;</operator> <name>PG_VERSION_RECOVERY_GUC</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>STANDBY_MODE_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else recovery type is not default so write target options</comment>
        <if type="elseif">else if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CFGOPTVAL_TYPE_DEFAULT</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Write the recovery target</comment>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(
                <argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>RECOVERY_TARGET</name> <literal type="string">"_%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptTarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Write recovery_target_inclusive</comment>
            <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptTargetExclusive</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptTargetExclusive</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSTRZ</name><argument_list>(<argument><expr><name>RECOVERY_TARGET_INCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>FALSE_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Write pause_at_recovery_target/recovery_target_action</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptTargetAction</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StringId</name></type> <name>targetAction</name> <init>= <expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptTargetAction</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>targetAction</name> <operator>!=</operator> <name>CFGOPTVAL_TARGET_ACTION_PAUSE</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Write recovery_target on supported PostgreSQL versions</comment>
                <if_stmt><if>if <condition>(<expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_RECOVERY_TARGET_ACTION</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSTRZ</name><argument_list>(<argument><expr><name>RECOVERY_TARGET_ACTION</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name>targetAction</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Write pause_at_recovery_target on supported PostgreSQL versions</comment>
                <if type="elseif">else if <condition>(<expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_RECOVERY_TARGET_PAUSE</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Shutdown action is not supported with pause_at_recovery_target setting</comment>
                    <if_stmt><if>if <condition>(<expr><name>targetAction</name> <operator>==</operator> <name>CFGOPTVAL_TARGET_ACTION_SHUTDOWN</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>OptionInvalidError</name></expr></argument>,
                            <argument><expr><name>CFGOPT_TARGET_ACTION</name> <literal type="string">"="</literal> <name>CFGOPTVAL_TARGET_ACTION_SHUTDOWN_Z</name> <literal type="string">" is only available in PostgreSQL &gt;= %s"</literal></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name>PG_VERSION_RECOVERY_TARGET_ACTION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSTRZ</name><argument_list>(<argument><expr><name>PAUSE_AT_RECOVERY_TARGET</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>FALSE_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else error on unsupported version</comment>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                        <argument><expr><name>OptionInvalidError</name></expr></argument>, <argument><expr><name>CFGOPT_TARGET_ACTION</name> <literal type="string">" option is only available in PostgreSQL &gt;= %s"</literal></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name>PG_VERSION_RECOVERY_TARGET_PAUSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Write recovery_target_timeline if set</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptTargetTimeline</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSTRZ</name><argument_list>(<argument><expr><name>RECOVERY_TARGET_TIMELINE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptTargetTimeline</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else explicitly set target timeline to "current" when type=immediate and PostgreSQL &gt;= 12. We do this because</comment>
        <comment type="line">// type=immediate means there won't be any actual attempt to change timelines, but if we leave the target timeline as the</comment>
        <comment type="line">// default of "latest" then PostgreSQL might fail to restore because it can't reach the "latest" timeline in the repository</comment>
        <comment type="line">// from this backup.</comment>
        <comment type="line">//</comment>
        <comment type="line">// This is really a PostgreSQL bug and will hopefully be addressed there, but we'll handle it here for older versions, at</comment>
        <comment type="line">// least until they aren't really seen in the wild any longer.</comment>
        <comment type="line">//</comment>
        <comment type="line">// PostgreSQL &lt; 12 defaults to "current" (but does not accept "current" as a parameter) so no need set it explicitly.</comment>
        <if type="elseif">else if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_TYPE_IMMEDIATE</name> <operator>&amp;&amp;</operator> <name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_12</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSTRZ</name><argument_list>(<argument><expr><name>RECOVERY_TARGET_TIMELINE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>RECOVERY_TARGET_TIMELINE_CURRENT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Move to prior context</comment>
        <expr_stmt><expr><call><name>kvMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>KEY_VALUE</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Helper to convert recovery options to text format</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>restoreRecoveryConf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>restoreLabel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>restoreLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"# Recovery settings generated by "</literal> <name>PROJECT_NAME</name> <literal type="string">" restore on %s\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>restoreLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Output all recovery options</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>KeyValue</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optionKv</name> <init>= <expr><call><name>restoreRecoveryOption</name><argument_list>(<argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>VariantList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optionKeyList</name> <init>= <expr><call><name>kvKeyList</name><argument_list>(<argument><expr><name>optionKv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optionKeyIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optionKeyIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>optionKeyList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>optionKeyIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optionKey</name> <init>= <expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>optionKeyList</name></expr></argument>, <argument><expr><name>optionKeyIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%s = '%s'\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>optionKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>optionKv</name></expr></argument>, <argument><expr><name>optionKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Helper to write recovery options into recovery.conf</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restoreRecoveryWriteConf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>restoreLabel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>restoreLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Only write recovery.conf if recovery type != none</comment>
    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CFGOPTVAL_TYPE_NONE</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"write %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PG_FILE_RECOVERYCONF_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Use the data directory to set permissions and ownership for recovery file</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestPath</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dataPath</name> <init>= <expr><call><name>manifestPathFind</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGDATA_STR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>mode_t</name></type> <name>recoveryFileMode</name> <init>= <expr><name><name>dataPath</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name> <operator>|</operator> <name>S_IRGRP</name> <operator>|</operator> <name>S_IROTH</name><operator>)</operator></expr></init></decl>;</decl_stmt>

            <comment type="line">// Write recovery.conf</comment>
            <expr_stmt><expr><call><name>storagePutP</name><argument_list>(
                <argument><expr><call><name>storageNewWriteP</name><argument_list>(
                    <argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PG_FILE_RECOVERYCONF_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>noCreatePath</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>modeFile</name> <operator>=</operator> <name>recoveryFileMode</name></expr></argument>,
                    <argument><expr><operator>.</operator><name>noAtomic</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noSyncPath</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>user</name> <operator>=</operator> <name><name>dataPath</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><operator>.</operator><name>group</name> <operator>=</operator> <name><name>dataPath</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>BUFSTR</name><argument_list>(<argument><expr><call><name>restoreRecoveryConf</name><argument_list>(<argument><expr><name>pgVersion</name></expr></argument>, <argument><expr><name>restoreLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Helper to write recovery options into postgresql.auto.conf</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restoreRecoveryWriteAutoConf</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>restoreLabel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>restoreLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>content</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Load postgresql.auto.conf so we can preserve the existing contents</comment>
        <decl_stmt><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>autoConf</name> <init>= <expr><call><name>storageGetP</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PG_FILE_POSTGRESQLAUTOCONF_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// It is unusual for the file not to exist, but we'll continue processing by creating a blank file</comment>
        <if_stmt><if>if <condition>(<expr><name>autoConf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><name>PG_FILE_POSTGRESQLAUTOCONF</name> <literal type="string">" does not exist -- creating to contain recovery settings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else the file does exist so comment out old recovery options that could interfere with the current recovery. Don't</comment>
        <comment type="line">// comment out *all* recovery options because some should only be commented out if there is a new option to replace it, e.g.</comment>
        <comment type="line">// primary_conninfo. If the option shouldn't be commented out all the time then it won't ever be commented out -- this may</comment>
        <comment type="line">// not be ideal but it is what was decided. PostgreSQL will use the last value set so this is safe as long as the option</comment>
        <comment type="line">// does not have dependencies on other options.</comment>
        <else>else
        <block>{<block_content>
            <comment type="line">// Generate a regexp that will match on all current recovery_target settings</comment>
            <decl_stmt><decl><type><name>RegExp</name> <modifier>*</modifier></type><name>recoveryExp</name> <init>=
                <expr><call><name>regExpNew</name><argument_list>(
                    <argument><expr><call><name>STRDEF</name><argument_list>(
                        <argument><expr><literal type="string">"^[\t ]*("</literal> <name>RECOVERY_TARGET</name> <literal type="string">"|"</literal> <name>RECOVERY_TARGET_ACTION</name> <literal type="string">"|"</literal> <name>RECOVERY_TARGET_INCLUSIVE</name> <literal type="string">"|"</literal>
                            <name>RECOVERY_TARGET_LSN</name> <literal type="string">"|"</literal> <name>RECOVERY_TARGET_NAME</name> <literal type="string">"|"</literal> <name>RECOVERY_TARGET_TIME</name> <literal type="string">"|"</literal> <name>RECOVERY_TARGET_TIMELINE</name> <literal type="string">"|"</literal>
                            <name>RECOVERY_TARGET_XID</name> <literal type="string">")[\t ]*="</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Check each line for recovery settings</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>contentList</name> <init>= <expr><call><name>strLstNewSplit</name><argument_list>(<argument><expr><call><name>strNewBuf</name><argument_list>(<argument><expr><name>autoConf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LF_STR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>contentIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>contentIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>contentList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>contentIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>contentIdx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>LF_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>contentList</name></expr></argument>, <argument><expr><name>contentIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>regExpMatch</name><argument_list>(<argument><expr><name>recoveryExp</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><literal type="string">"# Removed by "</literal> <name>PROJECT_NAME</name> <literal type="string">" restore on %s # "</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>restoreLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="line">// If settings will be appended then format the file so a blank line will be between old and new settings</comment>
            <if_stmt><if>if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CFGOPTVAL_TYPE_NONE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strTrim</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// If recovery was requested then write the recovery options</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CFGOPTVAL_TYPE_NONE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If the user specified standby_mode as a recovery option then error.  It's tempting to just set type=standby in this</comment>
            <comment type="line">// case but since config parsing has already happened the target options could be in an invalid state.</comment>
            <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptRecoveryOption</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>KeyValue</name> <modifier>*</modifier></type><name>recoveryOption</name> <init>= <expr><call><name>cfgOptionKv</name><argument_list>(<argument><expr><name>cfgOptRecoveryOption</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>recoveryOptionKey</name> <init>= <expr><call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>kvKeyList</name><argument_list>(<argument><expr><name>recoveryOption</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>keyIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>keyIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>recoveryOptionKey</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>keyIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="line">// Get the key and value</comment>
                    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>recoveryOptionKey</name></expr></argument>, <argument><expr><name>keyIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Replace - in key with _.  Since we use - users naturally will as well.</comment>
                    <expr_stmt><expr><call><name>strReplaceChr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>STANDBY_MODE_STR</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>OptionInvalidError</name></expr></argument>,
                            <argument><expr><literal type="string">"'"</literal> <name>STANDBY_MODE</name> <literal type="string">"' setting is not valid for "</literal> <name>PG_NAME</name> <literal type="string">" &gt;= %s\n"</literal>
                            <literal type="string">"HINT: use --"</literal> <name>CFGOPT_TYPE</name> <literal type="string">"="</literal> <name>CFGOPTVAL_TYPE_STANDBY_Z</name> <literal type="string">" instead of --"</literal> <name>CFGOPT_RECOVERY_OPTION</name> <literal type="string">"="</literal>
                                <name>STANDBY_MODE</name> <literal type="string">"=on."</literal></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name>PG_VERSION_RECOVERY_GUC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><call><name>restoreRecoveryConf</name><argument_list>(<argument><expr><name>pgVersion</name></expr></argument>, <argument><expr><name>restoreLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
            <argument><expr><literal type="string">"write %s%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>autoConf</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"updated "</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PG_FILE_POSTGRESQLAUTOCONF_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Use the data directory to set permissions and ownership for recovery file</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StorageInfo</name></type> <name>dataPath</name> <init>= <expr><call><name>storageInfoP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mode_t</name></type> <name>recoveryFileMode</name> <init>= <expr><name><name>dataPath</name><operator>.</operator><name>mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name> <operator>|</operator> <name>S_IRGRP</name> <operator>|</operator> <name>S_IROTH</name><operator>)</operator></expr></init></decl>;</decl_stmt>

        <comment type="line">// Write postgresql.auto.conf</comment>
        <expr_stmt><expr><call><name>storagePutP</name><argument_list>(
            <argument><expr><call><name>storageNewWriteP</name><argument_list>(
                <argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PG_FILE_POSTGRESQLAUTOCONF_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>noCreatePath</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>modeFile</name> <operator>=</operator> <name>recoveryFileMode</name></expr></argument>,
                <argument><expr><operator>.</operator><name>noAtomic</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noSyncPath</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>user</name> <operator>=</operator> <name><name>dataPath</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><operator>.</operator><name>group</name> <operator>=</operator> <name><name>dataPath</name><operator>.</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>BUFSTR</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// The standby.signal file is required for standby mode</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_TYPE_STANDBY</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>storagePutP</name><argument_list>(
                <argument><expr><call><name>storageNewWriteP</name><argument_list>(
                    <argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PG_FILE_STANDBYSIGNAL_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>noCreatePath</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>modeFile</name> <operator>=</operator> <name>recoveryFileMode</name></expr></argument>,
                    <argument><expr><operator>.</operator><name>noAtomic</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noSyncPath</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>user</name> <operator>=</operator> <name><name>dataPath</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><operator>.</operator><name>group</name> <operator>=</operator> <name><name>dataPath</name><operator>.</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else the recovery.signal file is required for targeted recovery</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>storagePutP</name><argument_list>(
                <argument><expr><call><name>storageNewWriteP</name><argument_list>(
                    <argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PG_FILE_RECOVERYSIGNAL_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>noCreatePath</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>modeFile</name> <operator>=</operator> <name>recoveryFileMode</name></expr></argument>,
                    <argument><expr><operator>.</operator><name>noAtomic</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noSyncPath</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>user</name> <operator>=</operator> <name><name>dataPath</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><operator>.</operator><name>group</name> <operator>=</operator> <name><name>dataPath</name><operator>.</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>restoreRecoveryWrite</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Get PostgreSQL version to write recovery for</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name> <init>= <expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pgVersion</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// If recovery type is preserve then leave recovery file as it is</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_TYPE_PRESERVE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Determine which file recovery setttings will be written to</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>recoveryFile</name> <init>= <expr><ternary><condition><expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_RECOVERY_GUC</name></expr> ?</condition><then>
                <expr><name>PG_FILE_POSTGRESQLAUTOCONF_STR</name></expr> </then><else>: <expr><name>PG_FILE_RECOVERYCONF_STR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>recoveryFile</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                    <argument><expr><literal type="string">"recovery type is "</literal> <name>CFGOPTVAL_TYPE_PRESERVE_Z</name> <literal type="string">" but recovery file does not exist at '%s'"</literal></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>recoveryFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else write recovery file</comment>
        <else>else
        <block>{<block_content>
            <comment type="line">// Generate a label used to identify this restore in the recovery file</comment>
            <decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type> <name>timePart</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name><name>restoreTimestamp</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>time_t</name></type> <name>timestamp</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>strftime</name><argument_list>(<argument><expr><name>restoreTimestamp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>restoreTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S"</literal></expr></argument>, <argument><expr><call><name>localtime_r</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timePart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>restoreLabel</name> <init>= <expr><call><name>STR</name><argument_list>(<argument><expr><name>restoreTimestamp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Write recovery file based on PostgreSQL version</comment>
            <if_stmt><if>if <condition>(<expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_RECOVERY_GUC</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>restoreRecoveryWriteAutoConf</name><argument_list>(<argument><expr><name>pgVersion</name></expr></argument>, <argument><expr><name>restoreLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>restoreRecoveryWriteConf</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>, <argument><expr><name>restoreLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Generate a list of queues that determine the order of file processing
***********************************************************************************************************************************/</comment>
<comment type="line">// Comparator to order ManifestFile objects by size then name</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier></type><name>restoreProcessQueueComparatorManifest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>restoreProcessQueueComparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item1</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item2</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Unpack files</comment>
    <decl_stmt><decl><type><name>ManifestFile</name></type> <name>file1</name> <init>= <expr><call><name>manifestFileUnpack</name><argument_list>(<argument><expr><name>restoreProcessQueueComparatorManifest</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>ManifestFilePack</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>item1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ManifestFile</name></type> <name>file2</name> <init>= <expr><call><name>manifestFileUnpack</name><argument_list>(<argument><expr><name>restoreProcessQueueComparatorManifest</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>ManifestFilePack</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>item2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Zero length files should be ordered at the end</comment>
    <if_stmt><if>if <condition>(<expr><name><name>file1</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>file2</name><operator>.</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>file2</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// If the bundle id differs that is enough to determine order</comment>
    <if_stmt><if>if <condition>(<expr><name><name>file1</name><operator>.</operator><name>bundleId</name></name> <operator>&lt;</operator> <name><name>file2</name><operator>.</operator><name>bundleId</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>file1</name><operator>.</operator><name>bundleId</name></name> <operator>&gt;</operator> <name><name>file2</name><operator>.</operator><name>bundleId</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// If the bundle ids are 0</comment>
    <if_stmt><if>if <condition>(<expr><name><name>file1</name><operator>.</operator><name>bundleId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// If the size differs then that's enough to determine order</comment>
        <if_stmt><if>if <condition>(<expr><name><name>file1</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <name><name>file2</name><operator>.</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>file1</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name><name>file2</name><operator>.</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// If size is the same then use name to generate a deterministic ordering (names must be unique)</comment>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>file1</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>file2</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><call><name>strCmp</name><argument_list>(<argument><expr><name><name>file1</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>file2</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If the reference differs that is enough to determine order</comment>
    <if_stmt><if>if <condition>(<expr><name><name>file1</name><operator>.</operator><name>reference</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>file2</name><operator>.</operator><name>reference</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>file2</name><operator>.</operator><name>reference</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>backupLabelCmp</name> <init>= <expr><call><name>strCmp</name><argument_list>(<argument><expr><name><name>file1</name><operator>.</operator><name>reference</name></name></expr></argument>, <argument><expr><name><name>file2</name><operator>.</operator><name>reference</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>backupLabelCmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>backupLabelCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// Finally order by bundle offset</comment>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>file1</name><operator>.</operator><name>bundleOffset</name></name> <operator>!=</operator> <name><name>file2</name><operator>.</operator><name>bundleOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>file1</name><operator>.</operator><name>bundleOffset</name></name> <operator>&lt;</operator> <name><name>file2</name><operator>.</operator><name>bundleOffset</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>restoreProcessQueue</name><parameter_list>(<parameter><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>queueList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>queueList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Create list of process queues (use void * instead of List * to avoid Coverity false positive)</comment>
        <expr_stmt><expr><operator>*</operator><name>queueList</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Generate the list of processing queues (there is always at least one)</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>strLstAddZ</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>manifestTargetTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>targetIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>manifestTarget</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strLstAddFmt</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Generate the processing queues</comment>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(*queueList)</argument>)</argument_list></macro>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>targetIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queue</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ManifestFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>restoreProcessQueueComparator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><operator>*</operator><name>queueList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Now put all files into the processing queues</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fileIdx</name> <operator>&lt;</operator> <call><name>manifestFileTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFilePack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>filePack</name> <init>= <expr><call><name>manifestFilePackGet</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFile</name></type> <name>file</name> <init>= <expr><call><name>manifestFileUnpack</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>filePack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Find the target that contains this file</comment>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <do>do
            <block>{<block_content>
                <comment type="line">// A target should always be found</comment>
                <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"backup target not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>strBeginsWith</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>targetIdx</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>

            <comment type="line">// Add file to queue</comment>
            <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><operator>*</operator><name>queueList</name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>filePack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Add size to total</comment>
            <expr_stmt><expr><name>result</name> <operator>+=</operator> <name><name>file</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Sort the queues</comment>
        <expr_stmt><expr><name>restoreProcessQueueComparatorManifest</name> <operator>=</operator> <name>manifest</name></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>targetIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>lstSort</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><operator>*</operator><name>queueList</name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <comment type="line">// Move process queues to prior context</comment>
        <expr_stmt><expr><call><name>lstMove</name><argument_list>(<argument><expr><operator>*</operator><name>queueList</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Log the results of a job and throw errors
***********************************************************************************************************************************/</comment>
<comment type="line">// Helper function to determine if a file should be zeroed</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>restoreFileZeroed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>manifestName</name></decl></parameter>, <parameter><decl><type><name>RegExp</name> <modifier>*</modifier></type><name>zeroExp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>REGEXP</name></expr></argument>, <argument><expr><name>zeroExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifestName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(
        <argument><expr><name>BOOL</name></expr></argument>,
        <argument><expr><ternary><condition><expr><name>zeroExp</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><call><name>regExpMatch</name><argument_list>(<argument><expr><name>zeroExp</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strEndsWith</name><argument_list>(<argument><expr><name>manifestName</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"/"</literal> <name>PG_FILE_PGVERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Helper function to construct the absolute pg path for any file</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>restoreFilePgPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifestName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifestName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pathPg</name> <init>= <expr><call><name>manifestPathPg</name><argument_list>(<argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(
        <argument><expr><literal type="string">"%s/%s%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>manifestTargetBase</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathPg</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><ternary><condition><expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>manifestName</name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal> <name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"."</literal> <name>STORAGE_FILE_TEMP_EXT</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><name>pathPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>restoreJobResult</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>, <parameter><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>, <parameter><decl><type><name>RegExp</name> <modifier>*</modifier></type><name>zeroExp</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>sizeTotal</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>sizeRestored</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_PARALLEL_JOB</name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>REGEXP</name></expr></argument>, <argument><expr><name>zeroExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>sizeTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>sizeRestored</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// The job was successful</comment>
    <if_stmt><if>if <condition>(<expr><call><name>protocolParallelJobErrorCode</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>jobResult</name> <init>= <expr><call><name>protocolParallelJobResult</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><operator>!</operator><call><name>pckReadNullP</name><argument_list>(<argument><expr><name>jobResult</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFile</name></type> <name>file</name> <init>= <expr><call><name>manifestFileFind</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>pckReadStrP</name><argument_list>(<argument><expr><name>jobResult</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>zeroed</name> <init>= <expr><call><name>restoreFileZeroed</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>zeroExp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>RestoreResult</name></type> <name>result</name> <init>= <expr><operator>(</operator><name>RestoreResult</name><operator>)</operator><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>jobResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>log</name> <init>= <expr><call><name>strCatZ</name><argument_list>(<argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"restore"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Note if file was zeroed (i.e. selective restore)</comment>
                <if_stmt><if>if <condition>(<expr><name>zeroed</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">" zeroed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Add filename</comment>
                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">" file %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>restoreFilePgPath</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// If preserved add details to explain why it was not copied or zeroed</comment>
                <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>restoreResultPreserve</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">" - "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// On force we match on size and modification time</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptForce</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                            <argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"exists and matches size %"</literal> <name>PRIu64</name> <literal type="string">" and modification time %"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>size</name></name></expr></argument>,
                            <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>file</name><operator>.</operator><name>timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Else a checksum delta or file is zero-length</comment>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"exists and "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// No need to copy zero-length files</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"is zero size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <comment type="line">// The file matched the manifest checksum so did not need to be copied</comment>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"matches backup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>


                <comment type="line">// Add bundle info</comment>
                <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>.</operator><name>bundleId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varUInt64</name><argument_list>(<argument><expr><call><name>protocolParallelJobKey</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>file</name><operator>.</operator><name>bundleId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"bundle "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>.</operator><name>reference</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>reference</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRIu64</name> <literal type="string">"/%"</literal> <name>PRIu64</name> <literal type="string">", "</literal></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>bundleId</name></name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>bundleOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Add size and percent complete</comment>
                <expr_stmt><expr><name>sizeRestored</name> <operator>+=</operator> <name><name>file</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">"%s, %.2lf%%)"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSizeFormat</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>sizeRestored</name> <operator>*</operator> <literal type="number">100.00</literal> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>sizeTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// If not zero-length add the checksum</comment>
                <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>.</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>zeroed</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="string">" checksum %s"</literal></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>checksumSha1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>LOG_DETAIL_PID</name><argument_list>(<argument><expr><call><name>protocolParallelJobProcessId</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Free the job</comment>
        <expr_stmt><expr><call><name>protocolParallelJobFree</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else the job errored</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_CODE</name><argument_list>(<argument><expr><call><name>protocolParallelJobErrorCode</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>protocolParallelJobErrorMessage</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>sizeRestored</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Return new restore jobs as requested
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>RestoreJobData</name>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl>;</decl_stmt>                                           <comment type="line">// Internal repo idx</comment>
    <decl_stmt><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl>;</decl_stmt>                                             <comment type="line">// Backup manifest</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queueList</name></decl>;</decl_stmt>                                                <comment type="line">// List of processing queues</comment>
    <decl_stmt><decl><type><name>RegExp</name> <modifier>*</modifier></type><name>zeroExp</name></decl>;</decl_stmt>                                                <comment type="line">// Identify files that should be sparse zeroed</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherSubPass</name></decl>;</decl_stmt>                                    <comment type="line">// Passphrase used to decrypt files in the backup</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>rootReplaceUser</name></decl>;</decl_stmt>                                  <comment type="line">// User to replace invalid users when root</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>rootReplaceGroup</name></decl>;</decl_stmt>                                 <comment type="line">// Group to replace invalid group when root</comment>
}</block></struct></type> <name>RestoreJobData</name>;</typedef>

<comment type="line">// Helper to calculate the next queue to scan based on the client index</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>restoreJobQueueNext</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>clientIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queueIdx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>queueTotal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>clientIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>queueIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>queueTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Move (forward or back) to the next queue</comment>
    <expr_stmt><expr><name>queueIdx</name> <operator>+=</operator> <ternary><condition><expr><name>clientIdx</name> <operator>%</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

    <comment type="line">// Deal with wrapping on either end</comment>
    <if_stmt><if>if <condition>(<expr><name>queueIdx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>queueTotal</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>queueIdx</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>queueTotal</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>queueIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Callback to fetch restore jobs for the parallel executor</comment>
<function><type><specifier>static</specifier> <name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>restoreJobCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>clientIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>clientIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get a new job if there are any left</comment>
        <decl_stmt><decl><type><name>RestoreJobData</name> <modifier>*</modifier></type><name>jobData</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Determine where to begin scanning the queue (we'll stop when we get back here)</comment>
        <decl_stmt><decl><type><name>ProtocolCommand</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>protocolCommandNew</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND_RESTORE_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>queueIdx</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>clientIdx</name> <operator>%</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>queueEnd</name> <init>= <expr><name>queueIdx</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Create restore job</comment>
        <do>do
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queue</name> <init>= <expr><operator>*</operator><operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>queueIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>fileAdded</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>bundleId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>reference</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFile</name></type> <name>file</name> <init>= <expr><call><name>manifestFileUnpack</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>ManifestFilePack</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Break if bundled files have already been added and 1) the bundleId has changed or 2) the reference has changed</comment>
                <if_stmt><if>if <condition>(<expr><name>fileAdded</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>bundleId</name> <operator>!=</operator> <name><name>file</name><operator>.</operator><name>bundleId</name></name> <operator>||</operator> <operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name>reference</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>reference</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="line">// Add common parameters before first file</comment>
                <if_stmt><if>if <condition>(<expr><name>param</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>protocolCommandParam</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>.</operator><name>bundleId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>bundleId</name> <operator>=</operator> <name><name>file</name><operator>.</operator><name>bundleId</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>reference</name> <operator>=</operator> <name><name>file</name><operator>.</operator><name>reference</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>fileName</name> <operator>=</operator> <name><name>file</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(
                        <argument><expr><name>param</name></expr></argument>,
                        <argument><expr><call><name>backupFileRepoPathP</name><argument_list>(
                            <argument><expr><ternary><condition><expr><name><name>file</name><operator>.</operator><name>reference</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>file</name><operator>.</operator><name>reference</name></name></expr> </then><else>: <expr><call><name>manifestData</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabel</name></expr></else></ternary></expr></argument>,
                            <argument><expr><operator>.</operator><name>manifestName</name> <operator>=</operator> <name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>.</operator><name>bundleId</name> <operator>=</operator> <name><name>file</name><operator>.</operator><name>bundleId</name></name></expr></argument>,
                            <argument><expr><operator>.</operator><name>compressType</name> <operator>=</operator> <call><name>manifestData</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupOptionCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>repoIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupOptionCompressType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pckWriteTimeP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupTimestampCopyStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDelta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDelta</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptForce</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>cipherSubPass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>fileAdded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>restoreFilePgPath</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>checksumSha1</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteTimeP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteModeP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>restoreFileZeroed</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>zeroExp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>restoreManifestOwnerReplace</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>rootReplaceUser</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>restoreManifestOwnerReplace</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>group</name></name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>rootReplaceGroup</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>.</operator><name>bundleId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>bundleOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>sizeRepo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Remove job from the queue</comment>
                <expr_stmt><expr><call><name>lstRemoveIdx</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Break if the file is not bundled</comment>
                <if_stmt><if>if <condition>(<expr><name>bundleId</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></while>

            <if_stmt><if>if <condition>(<expr><name>fileAdded</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Assign job to result</comment>
                <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>protocolParallelJobNew</name><argument_list>(<argument><expr><ternary><condition><expr><name>bundleId</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name>bundleId</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>queueIdx</name> <operator>=</operator> <call><name>restoreJobQueueNext</name><argument_list>(<argument><expr><name>clientIdx</name></expr></argument>, <argument><expr><name>queueIdx</name></expr></argument>, <argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        while <condition>(<expr><name>queueIdx</name> <operator>!=</operator> <name>queueEnd</name></expr>)</condition>;</do>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>PROTOCOL_PARALLEL_JOB</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>cmdRestore</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get information for the current user</comment>
        <expr_stmt><expr><call><name>userInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// PostgreSQL must be local</comment>
        <expr_stmt><expr><call><name>pgIsLocalVerify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Validate restore path</comment>
        <expr_stmt><expr><call><name>restorePathValidate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Remove stanza archive spool path so existing files do not interfere with the new cluster. For instance, old archive-push</comment>
        <comment type="line">// acknowledgements could cause a new cluster to skip archiving. This should not happen if a new timeline is selected but</comment>
        <comment type="line">// better to be safe. Missing stanza spool paths are ignored.</comment>
        <expr_stmt><expr><call><name>storagePathRemoveP</name><argument_list>(<argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>STORAGE_SPOOL_ARCHIVE_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>recurse</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Get the backup set</comment>
        <decl_stmt><decl><type><name>RestoreBackupData</name></type> <name>backupData</name> <init>= <expr><call><name>restoreBackupSet</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Load manifest</comment>
        <decl_stmt><decl><type><name>RestoreJobData</name></type> <name>jobData</name> <init>= <expr><block>{<expr><operator>.</operator><name>repoIdx</name> <operator>=</operator> <name><name>backupData</name><operator>.</operator><name>repoIdx</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name> <operator>=</operator> <call><name>manifestLoadFile</name><argument_list>(
            <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name><name>backupData</name><operator>.</operator><name>repoIdx</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>BACKUP_MANIFEST_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupData</name><operator>.</operator><name>backupSet</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>repoCipherType</name></name></expr></argument>,
            <argument><expr><name><name>backupData</name><operator>.</operator><name>backupCipherPass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Remotes (if any) are no longer needed since the rest of the repository reads will be done by the local processes</comment>
        <expr_stmt><expr><call><name>protocolFree</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Validate manifest.  Don't use strict mode because we'd rather ignore problems that won't affect a restore.</comment>
        <expr_stmt><expr><call><name>manifestValidate</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Get the cipher subpass used to decrypt files in the backup</comment>
        <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>cipherSubPass</name></name> <operator>=</operator> <call><name>manifestCipherSubPass</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Validate the manifest</comment>
        <expr_stmt><expr><call><name>restoreManifestValidate</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Log the backup set to restore. If the backup was online then append the time recovery will start from.</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>message</name> <init>= <expr><call><name>strCatFmt</name><argument_list>(
            <argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s: restore backup set %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>repoIdx</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupData</name><operator>.</operator><name>backupSet</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>manifestData</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupOptionOnline</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type> <name>timePart</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name><name>timeBuffer</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>time_t</name></type> <name>backupTimestampStart</name> <init>= <expr><call><name>manifestData</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupTimestampStart</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>strftime</name><argument_list>(<argument><expr><name>timeBuffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>timeBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S"</literal></expr></argument>, <argument><expr><call><name>localtime_r</name><argument_list>(<argument><expr><operator>&amp;</operator><name>backupTimestampStart</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timePart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="string">", recovery will start at %s"</literal></expr></argument>, <argument><expr><name>timeBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LOG_INFO</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Map manifest</comment>
        <expr_stmt><expr><call><name>restoreManifestMap</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Check that links are sane</comment>
        <expr_stmt><expr><call><name>manifestLinkCheck</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Update ownership</comment>
        <expr_stmt><expr><call><name>restoreManifestOwner</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>jobData</name><operator>.</operator><name>rootReplaceUser</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>jobData</name><operator>.</operator><name>rootReplaceGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Generate the selective restore expression</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><call><name>restoreSelectiveExpression</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>zeroExp</name></name> <operator>=</operator> <ternary><condition><expr><name>expression</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>regExpNew</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

        <comment type="line">// Clean the data directory and build path/link structure</comment>
        <expr_stmt><expr><call><name>restoreCleanBuild</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>, <argument><expr><name><name>jobData</name><operator>.</operator><name>rootReplaceUser</name></name></expr></argument>, <argument><expr><name><name>jobData</name><operator>.</operator><name>rootReplaceGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Generate processing queues</comment>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>sizeTotal</name> <init>= <expr><call><name>restoreProcessQueue</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>jobData</name><operator>.</operator><name>queueList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Save manifest to the data directory so we can restart a delta restore even if the PG_VERSION file is missing</comment>
        <expr_stmt><expr><call><name>manifestSave</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>, <argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><call><name>storageNewWriteP</name><argument_list>(<argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_MANIFEST_FILE_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Create the parallel executor</comment>
        <decl_stmt><decl><type><name>ProtocolParallel</name> <modifier>*</modifier></type><name>parallelExec</name> <init>= <expr><call><name>protocolParallelNew</name><argument_list>(
            <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptProtocolTimeout</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>restoreJobCallback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jobData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>processIdx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>processIdx</name> <operator>&lt;=</operator> <call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptProcessMax</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>processIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>protocolParallelClientAdd</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>, <argument><expr><call><name>protocolLocalGet</name><argument_list>(<argument><expr><name>protocolStorageTypeRepo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>processIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <comment type="line">// Process jobs</comment>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>sizeRestored</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <macro><name>MEM_CONTEXT_TEMP_RESET_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <do>do
            <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>completed</name> <init>= <expr><call><name>protocolParallelProcess</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>jobIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>jobIdx</name> <operator>&lt;</operator> <name>completed</name></expr>;</condition> <incr><expr><name>jobIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name>sizeRestored</name> <operator>=</operator> <call><name>restoreJobResult</name><argument_list>(
                        <argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>, <argument><expr><call><name>protocolParallelResult</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>jobData</name><operator>.</operator><name>zeroExp</name></name></expr></argument>, <argument><expr><name>sizeTotal</name></expr></argument>, <argument><expr><name>sizeRestored</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <comment type="line">// Reset the memory context occasionally so we don't use too much memory or slow down processing</comment>
                <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_RESET</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><operator>!</operator><call><name>protocolParallelDone</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Write recovery settings</comment>
        <expr_stmt><expr><call><name>restoreRecoveryWrite</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Remove backup.manifest</comment>
        <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_MANIFEST_FILE_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Sync file link paths. These need to be synced separately because they are not linked from the data directory.</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>pathSynced</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>manifestTargetTotal</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>targetIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>manifestTarget</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>manifestTargetTypeLink</name> <operator>&amp;&amp;</operator> <name><name>target</name><operator>-&gt;</operator><name>file</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pgPath</name> <init>= <expr><call><name>manifestTargetPath</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Don't sync the same path twice.  There can be multiple links to files in the same path, but syncing it more than</comment>
                <comment type="line">// once makes the logs noisy and looks like a bug even though it doesn't hurt anything or realistically affect</comment>
                <comment type="line">// performance.</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strLstExists</name><argument_list>(<argument><expr><name>pathSynced</name></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>pathSynced</name></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="line">// Sync the path</comment>
                <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"sync path '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>storagePathSyncP</name><argument_list>(<argument><expr><call><name>storageLocalWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Sync paths in the data directory</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>pathIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pathIdx</name> <operator>&lt;</operator> <call><name>manifestPathTotal</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pathIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>manifestName</name> <init>= <expr><call><name>manifestPath</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>pathIdx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>name</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Skip the pg_tblspc path because it only maps to the manifest.  We should remove this in a future release but not much</comment>
            <comment type="line">// can be done about it for now.</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>manifestName</name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGTBLSPC</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="line">// We'll sync global after pg_control is written</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>manifestName</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal> <name>PG_PATH_GLOBAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pgPath</name> <init>= <expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>manifestPathPg</name><argument_list>(<argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"sync path '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>storagePathSyncP</name><argument_list>(<argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Rename pg_control</comment>
        <if_stmt><if>if <condition>(<expr><call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name> <literal type="string">"."</literal> <name>STORAGE_FILE_TEMP_EXT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_INFO</name><argument_list>(
                <argument><expr><literal type="string">"restore "</literal> <name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name> <literal type="string">" (performed last to ensure aborted restores cannot be started)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>storageMoveP</name><argument_list>(
                <argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name> <literal type="string">"."</literal> <name>STORAGE_FILE_TEMP_EXT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>storageNewWriteP</name><argument_list>(<argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>noSyncPath</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"backup does not contain '"</literal> <name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name> <literal type="string">"' -- cluster will not start"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="line">// Sync global path</comment>
        <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"sync path '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PG_PATH_GLOBAL_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>storagePathSyncP</name><argument_list>(<argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PG_PATH_GLOBAL_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Restore info</comment>
        <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
            <argument><expr><literal type="string">"restore size = %s, file total = %u"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSizeFormat</name><argument_list>(<argument><expr><name>sizeRestored</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>manifestFileTotal</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
