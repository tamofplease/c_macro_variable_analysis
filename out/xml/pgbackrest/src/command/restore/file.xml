<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/command/restore/file.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Restore File
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/restore/file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/crypto/cipherBlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/crypto/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/filter/group.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/filter/size.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/manifest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>List</name> <modifier>*</modifier></type><name>restoreFile</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>repoFile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CompressType</name></type> <name>repoFileCompressType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>time_t</name></type> <name>copyTimeBegin</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>delta</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>deltaForce</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cipherPass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>repoFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>repoFileCompressType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>TIME</name></expr></argument>, <argument><expr><name>copyTimeBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>deltaForce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>fileList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                         <comment type="line">// List of files to restore</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>repoFile</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Restore file results</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RestoreFileResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Check files to determine which ones need to be restored</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fileIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>fileList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// Use a per-file mem context to reduce memory usage</comment>
            <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>RestoreFile</name> <modifier>*</modifier><specifier>const</specifier></type> <name>file</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>fileList</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>limit</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>varType</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeUInt64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>RestoreFileResult</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileResult</name> <init>= <macro><name>lstAdd</name><argument_list>(
                    <argument>result</argument>, <argument>&amp;(RestoreFileResult){.manifestFile = file-&gt;manifestFile</argument>, <argument>.result = restoreResultCopy}</argument>)</argument_list></macro></init></decl>;</decl_stmt>

                <comment type="line">// Perform delta if requested. Delta zero-length files to avoid overwriting the file if the timestamp is correct.</comment>
                <if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>file</name><operator>-&gt;</operator><name>zero</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Perform delta if the file exists</comment>
                    <decl_stmt><decl><type><name>StorageInfo</name></type> <name>info</name> <init>= <expr><call><name>storageInfoP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>followLink</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>exists</name></name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// If force then use size/timestamp delta</comment>
                        <if_stmt><if>if <condition>(<expr><name>deltaForce</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// Make sure that timestamp/size are equal and the timestamp is before the copy start time of the backup</comment>
                            <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>size</name></name> <operator>==</operator> <name><name>file</name><operator>-&gt;</operator><name>size</name></name> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>timeModified</name></name> <operator>==</operator> <name><name>file</name><operator>-&gt;</operator><name>timeModified</name></name> <operator>&amp;&amp;</operator>
                                <name><name>info</name><operator>.</operator><name>timeModified</name></name> <operator>&lt;</operator> <name>copyTimeBegin</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>restoreResultPreserve</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if>
                        <comment type="line">// Else use size and checksum</comment>
                        <else>else
                        <block>{<block_content>
                            <comment type="line">// Only continue delta if the file size is as expected or larger</comment>
                            <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>size</name></name> <operator>&gt;=</operator> <name><name>file</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
                            <block>{<block_content>
                                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileName</name> <init>= <expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <comment type="line">// If the file was extended since the backup, then truncate it to the size it was during the backup</comment>
                                <comment type="line">// as it might have only been appended to with the earlier portion being unchanged (we will verify</comment>
                                <comment type="line">// this using the checksum below)</comment>
                                <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name><name>file</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="line">// Open file for write</comment>
                                    <decl_stmt><decl><type><name>IoWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pgWriteTruncate</name> <init>= <expr><call><name>storageWriteIo</name><argument_list>(
                                        <argument><expr><call><name>storageNewWriteP</name><argument_list>(
                                            <argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>.</operator><name>noAtomic</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noCreatePath</name> <operator>=</operator> <name>true</name></expr></argument>,
                                            <argument><expr><operator>.</operator><name>noSyncPath</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noTruncate</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                    <expr_stmt><expr><call><name>ioWriteOpen</name><argument_list>(<argument><expr><name>pgWriteTruncate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <comment type="line">// Truncate to original size</comment>
                                    <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR_FMT</name><argument_list>(
                                        <argument><expr><call><name>ftruncate</name><argument_list>(<argument><expr><call><name>ioWriteFd</name><argument_list>(<argument><expr><name>pgWriteTruncate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator><name><name>file</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>FileWriteError</name></expr></argument>,
                                        <argument><expr><literal type="string">"unable to truncate file '%s'"</literal></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <comment type="line">// Close file</comment>
                                    <expr_stmt><expr><call><name>ioWriteClose</name><argument_list>(<argument><expr><name>pgWriteTruncate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <comment type="line">// Update info</comment>
                                    <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>storageInfoP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>.</operator><name>followLink</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <comment type="line">// Generate checksum for the file if size is not zero</comment>
                                <decl_stmt><decl><type><name>IoRead</name> <modifier>*</modifier></type><name>read</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                                <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>read</name> <operator>=</operator> <call><name>storageReadIo</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cryptoHashNew</name><argument_list>(<argument><expr><name>hashTypeSha1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>ioReadDrain</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <comment type="line">// If the checksum is the same (or file is zero size) then no need to copy the file</comment>
                                <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                                    <call><name>strEq</name><argument_list>(
                                        <argument><expr><name><name>file</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>,
                                        <argument><expr><call><name>bufHex</name><argument_list>(
                                            <argument><expr><call><name>pckReadBinP</name><argument_list>(<argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CRYPTO_HASH_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="line">// If the hash/size are now the same but the time is not, then set the time back to the backup</comment>
                                    <comment type="line">// time. This helps with unit testing, but also presents a pristine version of the database</comment>
                                    <comment type="line">// after restore.</comment>
                                    <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>timeModified</name></name> <operator>!=</operator> <name><name>file</name><operator>-&gt;</operator><name>timeModified</name></name></expr>)</condition>
                                    <block>{<block_content>
                                        <macro><name>THROW_ON_SYS_ERROR_FMT</name><argument_list>(
                                            <argument>utime(
                                                fileName,
                                                &amp;((struct utimbuf){
                                                    .actime = file-&gt;timeModified, .modtime = file-&gt;timeModified})) == -<literal type="number">1</literal></argument>,
                                            <argument>FileInfoError</argument>, <argument><literal type="string">"unable to set time for '%s'"</literal></argument>, <argument>fileName</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                                    </block_content>}</block></if></if_stmt>

                                    <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>restoreResultPreserve</name></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Create zeroed and zero-length files</comment>
                <if_stmt><if>if <condition>(<expr><name><name>fileResult</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>restoreResultCopy</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>file</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>file</name><operator>-&gt;</operator><name>zero</name></name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Create destination file</comment>
                    <decl_stmt><decl><type><name>StorageWrite</name> <modifier>*</modifier></type><name>pgFileWrite</name> <init>= <expr><call><name>storageNewWriteP</name><argument_list>(
                        <argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>.</operator><name>modeFile</name> <operator>=</operator> <name><name>file</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><operator>.</operator><name>user</name> <operator>=</operator> <name><name>file</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><operator>.</operator><name>group</name> <operator>=</operator> <name><name>file</name><operator>-&gt;</operator><name>group</name></name></expr></argument>,
                        <argument><expr><operator>.</operator><name>timeModified</name> <operator>=</operator> <name><name>file</name><operator>-&gt;</operator><name>timeModified</name></name></expr></argument>, <argument><expr><operator>.</operator><name>noAtomic</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noCreatePath</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noSyncPath</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>ioWriteOpen</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>pgFileWrite</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Truncate the file to specified length (note in this case the file will grow, not shrink)</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>zero</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR_FMT</name><argument_list>(
                            <argument><expr><call><name>ftruncate</name><argument_list>(<argument><expr><call><name>ioWriteFd</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>pgFileWrite</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator><name><name>file</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>FileWriteError</name></expr></argument>,
                            <argument><expr><literal type="string">"unable to truncate '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>ioWriteClose</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>pgFileWrite</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Report the file as zeroed or zero-length</comment>
                    <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>restoreResultZero</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Copy files from repository to database</comment>
        <decl_stmt><decl><type><name>StorageRead</name> <modifier>*</modifier></type><name>repoFileRead</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>repoFileLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fileIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>fileList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// Use a per-file mem context to reduce memory usage</comment>
            <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>RestoreFile</name> <modifier>*</modifier><specifier>const</specifier></type> <name>file</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>fileList</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>RestoreFileResult</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileResult</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Copy file from repository to database</comment>
                <if_stmt><if>if <condition>(<expr><name><name>fileResult</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>restoreResultCopy</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// If no repo file is currently open</comment>
                    <if_stmt><if>if <condition>(<expr><name>repoFileLimit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// If a limit is specified then we need to use it, even if there is only one pg file to copy, because we</comment>
                        <comment type="line">// might be reading from the middle of a repo file containing many pg files</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>limit</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varUInt64</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>repoFileLimit</name> <operator>=</operator> <call><name>varUInt64</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// Determine how many files can be copied with one read</comment>
                            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileNextIdx</name> <init>= <expr><name>fileIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>fileNextIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>fileList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileNextIdx</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <comment type="line">// Only files that are being copied are considered</comment>
                                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>RestoreFileResult</name> <operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>fileNextIdx</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>result</name> <operator>==</operator> <name>restoreResultCopy</name></expr>)</condition>
                                <block>{<block_content>
                                    <decl_stmt><decl><type><specifier>const</specifier> <name>RestoreFile</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileNext</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>fileList</name></expr></argument>, <argument><expr><name>fileNextIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>fileNext</name><operator>-&gt;</operator><name>limit</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>varUInt64</name><argument_list>(<argument><expr><name><name>fileNext</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <comment type="line">// Break if the offset is not the first file's offset + the limit of all additional files so far</comment>
                                    <if_stmt><if>if <condition>(<expr><name><name>fileNext</name><operator>-&gt;</operator><name>offset</name></name> <operator>!=</operator> <name><name>file</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>repoFileLimit</name></expr>)</condition><block type="pseudo"><block_content>
                                        <break>break;</break></block_content></block></if></if_stmt>

                                    <expr_stmt><expr><name>repoFileLimit</name> <operator>+=</operator> <call><name>varUInt64</name><argument_list>(<argument><expr><name><name>fileNext</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <comment type="line">// Else if the file was not copied then there is a gap so break</comment>
                                <else>else<block type="pseudo"><block_content>
                                    <break>break;</break></block_content></block></else></if_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// Create and open the repo file. It needs to be created in the prior context because it will live longer</comment>
                        <comment type="line">// than a single loop when more than one file is being read.</comment>
                        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                        <block>{<block_content>
                            <expr_stmt><expr><name>repoFileRead</name> <operator>=</operator> <call><name>storageNewReadP</name><argument_list>(
                                <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repoFile</name></expr></argument>,
                                <argument><expr><operator>.</operator><name>compressible</name> <operator>=</operator> <name>repoFileCompressType</name> <operator>==</operator> <name>compressTypeNone</name> <operator>&amp;&amp;</operator> <name>cipherPass</name> <operator>==</operator> <name>NULL</name></expr></argument>,
                                <argument><expr><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>file</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>.</operator><name>limit</name> <operator>=</operator> <ternary><condition><expr><name>repoFileLimit</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name>repoFileLimit</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>ioReadOpen</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>repoFileRead</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Create pg file</comment>
                    <decl_stmt><decl><type><name>StorageWrite</name> <modifier>*</modifier></type><name>pgFileWrite</name> <init>= <expr><call><name>storageNewWriteP</name><argument_list>(
                        <argument><expr><call><name>storagePgWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>.</operator><name>modeFile</name> <operator>=</operator> <name><name>file</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><operator>.</operator><name>user</name> <operator>=</operator> <name><name>file</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><operator>.</operator><name>group</name> <operator>=</operator> <name><name>file</name><operator>-&gt;</operator><name>group</name></name></expr></argument>,
                        <argument><expr><operator>.</operator><name>timeModified</name> <operator>=</operator> <name><name>file</name><operator>-&gt;</operator><name>timeModified</name></name></expr></argument>, <argument><expr><operator>.</operator><name>noAtomic</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noCreatePath</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noSyncPath</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>IoFilterGroup</name> <modifier>*</modifier></type><name>filterGroup</name> <init>= <expr><call><name>ioWriteFilterGroup</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>pgFileWrite</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Add decryption filter</comment>
                    <if_stmt><if>if <condition>(<expr><name>cipherPass</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(
                            <argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>cipherBlockNewP</name><argument_list>(<argument><expr><name>cipherModeDecrypt</name></expr></argument>, <argument><expr><name>cipherTypeAes256Cbc</name></expr></argument>, <argument><expr><call><name>BUFSTR</name><argument_list>(<argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Add decompression filter</comment>
                    <if_stmt><if>if <condition>(<expr><name>repoFileCompressType</name> <operator>!=</operator> <name>compressTypeNone</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>decompressFilter</name><argument_list>(<argument><expr><name>repoFileCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Add sha1 filter</comment>
                    <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>cryptoHashNew</name><argument_list>(<argument><expr><name>hashTypeSha1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Add size filter</comment>
                    <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>ioSizeNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Copy file</comment>
                    <expr_stmt><expr><call><name>ioWriteOpen</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>pgFileWrite</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ioCopyP</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>repoFileRead</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>pgFileWrite</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>limit</name> <operator>=</operator> <name><name>file</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ioWriteClose</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>pgFileWrite</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// If more than one file is being copied from a single read then decrement the limit</comment>
                    <if_stmt><if>if <condition>(<expr><name>repoFileLimit</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>repoFileLimit</name> <operator>-=</operator> <call><name>varUInt64</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Free the repo file when there are no more files to copy from it</comment>
                    <if_stmt><if>if <condition>(<expr><name>repoFileLimit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>storageReadFree</name><argument_list>(<argument><expr><name>repoFileRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Validate checksum</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>, <argument><expr><call><name>bufHex</name><argument_list>(<argument><expr><call><name>pckReadBinP</name><argument_list>(<argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><name>CRYPTO_HASH_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>ChecksumError</name></expr></argument>,
                            <argument><expr><literal type="string">"error restoring '%s': actual checksum '%s' does not match expected checksum '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>bufHex</name><argument_list>(<argument><expr><call><name>pckReadBinP</name><argument_list>(<argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><name>CRYPTO_HASH_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>lstMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
