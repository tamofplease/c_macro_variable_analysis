<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/command/info/info.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Info Command
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/archive/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/info/info.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/crypto/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/fdWrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/memContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/info.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoArchive.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoBackup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoPg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/manifest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Constants
***********************************************************************************************************************************/</comment>
<comment type="line">// Naming convention: &lt;sectionname&gt;_KEY_&lt;keyname&gt;_VAR. If the key exists in multiple sections, then &lt;sectionname&gt;_ is omitted.</comment>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>ARCHIVE_KEY_MIN_VAR</name></expr></argument>,                          <argument><expr><literal type="string">"min"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>ARCHIVE_KEY_MAX_VAR</name></expr></argument>,                          <argument><expr><literal type="string">"max"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKREST_KEY_FORMAT_VAR</name></expr></argument>,                      <argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKREST_KEY_VERSION_VAR</name></expr></argument>,                     <argument><expr><literal type="string">"version"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_ANNOTATION_VAR</name></expr></argument>,                    <argument><expr><literal type="string">"annotation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_BACKREST_VAR</name></expr></argument>,                      <argument><expr><literal type="string">"backrest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_ERROR_VAR</name></expr></argument>,                         <argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_ERROR_LIST_VAR</name></expr></argument>,                    <argument><expr><literal type="string">"error-list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_DATABASE_REF_VAR</name></expr></argument>,                  <argument><expr><literal type="string">"database-ref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_INFO_VAR</name></expr></argument>,                          <argument><expr><literal type="string">"info"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_LABEL_VAR</name></expr></argument>,                         <argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_LINK_VAR</name></expr></argument>,                          <argument><expr><literal type="string">"link"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_LSN_VAR</name></expr></argument>,                           <argument><expr><literal type="string">"lsn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_PRIOR_VAR</name></expr></argument>,                         <argument><expr><literal type="string">"prior"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_REFERENCE_VAR</name></expr></argument>,                     <argument><expr><literal type="string">"reference"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_TABLESPACE_VAR</name></expr></argument>,                    <argument><expr><literal type="string">"tablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_TIMESTAMP_VAR</name></expr></argument>,                     <argument><expr><literal type="string">"timestamp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>BACKUP_KEY_TYPE_VAR</name></expr></argument>,                          <argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>DB_KEY_ID_VAR</name></expr></argument>,                                <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>DB_KEY_SYSTEM_ID_VAR</name></expr></argument>,                         <argument><expr><literal type="string">"system-id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>DB_KEY_VERSION_VAR</name></expr></argument>,                           <argument><expr><literal type="string">"version"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>INFO_KEY_REPOSITORY_VAR</name></expr></argument>,                      <argument><expr><literal type="string">"repository"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>KEY_ARCHIVE_VAR</name></expr></argument>,                              <argument><expr><literal type="string">"archive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>KEY_CIPHER_VAR</name></expr></argument>,                               <argument><expr><literal type="string">"cipher"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>KEY_DATABASE_VAR</name></expr></argument>,                             <argument><expr><literal type="string">"database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>KEY_DELTA_VAR</name></expr></argument>,                                <argument><expr><literal type="string">"delta"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>KEY_DESTINATION_VAR</name></expr></argument>,                          <argument><expr><literal type="string">"destination"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>KEY_NAME_VAR</name></expr></argument>,                                 <argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>KEY_OID_VAR</name></expr></argument>,                                  <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>KEY_REPO_KEY_VAR</name></expr></argument>,                             <argument><expr><literal type="string">"repo-key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>KEY_SIZE_VAR</name></expr></argument>,                                 <argument><expr><literal type="string">"size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>KEY_START_VAR</name></expr></argument>,                                <argument><expr><literal type="string">"start"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>KEY_STOP_VAR</name></expr></argument>,                                 <argument><expr><literal type="string">"stop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>REPO_KEY_KEY_VAR</name></expr></argument>,                             <argument><expr><literal type="string">"key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>STANZA_KEY_BACKUP_VAR</name></expr></argument>,                        <argument><expr><literal type="string">"backup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>STANZA_KEY_REPO_VAR</name></expr></argument>,                          <argument><expr><literal type="string">"repo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>STANZA_KEY_STATUS_VAR</name></expr></argument>,                        <argument><expr><literal type="string">"status"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>STANZA_KEY_DB_VAR</name></expr></argument>,                            <argument><expr><literal type="string">"db"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>STATUS_KEY_CODE_VAR</name></expr></argument>,                          <argument><expr><literal type="string">"code"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>STATUS_KEY_LOCK_VAR</name></expr></argument>,                          <argument><expr><literal type="string">"lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>STATUS_KEY_LOCK_BACKUP_VAR</name></expr></argument>,                   <argument><expr><literal type="string">"backup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>STATUS_KEY_LOCK_BACKUP_HELD_VAR</name></expr></argument>,              <argument><expr><literal type="string">"held"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>STATUS_KEY_LOCK_BACKUP_PERCENT_COMPLETE_VAR</name></expr></argument>,  <argument><expr><literal type="string">"pct-cplt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_STRDEF_STATIC</name><argument_list>(<argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>,                       <argument><expr><literal type="string">"message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_STATUS_OK</name></cpp:macro>                                       <cpp:value>"ok"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_STATUS_ERROR</name></cpp:macro>                                    <cpp:value>"error"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_MIXED</name></cpp:macro>                                           <cpp:value>"mixed"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_STATUS_CODE_OK</name></cpp:macro>                                  <cpp:value>0</cpp:value></cpp:define>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_OK_STR</name></expr></argument>,                    <argument><expr><literal type="string">"ok"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_STATUS_CODE_MISSING_STANZA_PATH</name></cpp:macro>                 <cpp:value>1</cpp:value></cpp:define>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_MISSING_STANZA_PATH_STR</name></expr></argument>,   <argument><expr><literal type="string">"missing stanza path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_STATUS_CODE_NO_BACKUP</name></cpp:macro>                           <cpp:value>2</cpp:value></cpp:define>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_NO_BACKUP_STR</name></expr></argument>,             <argument><expr><literal type="string">"no valid backups"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_STATUS_CODE_MISSING_STANZA_DATA</name></cpp:macro>                 <cpp:value>3</cpp:value></cpp:define>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_MISSING_STANZA_DATA_STR</name></expr></argument>,   <argument><expr><literal type="string">"missing stanza data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_STATUS_CODE_MIXED</name></cpp:macro>                               <cpp:value>4</cpp:value></cpp:define>
<comment type="line">// If the cipher or status of the stanza is different across repos, then the overall cipher or status message is mixed</comment>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>INFO_STANZA_MESSAGE_MIXED_STR</name></expr></argument>,                        <argument><expr><literal type="string">"different across repos"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_STATUS_CODE_PG_MISMATCH</name></cpp:macro>                         <cpp:value>5</cpp:value></cpp:define>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_PG_MISMATCH_STR</name></expr></argument>,           <argument><expr><literal type="string">"database mismatch across repos"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_STATUS_CODE_BACKUP_MISSING</name></cpp:macro>                      <cpp:value>6</cpp:value></cpp:define>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_CODE_BACKUP_MISSING_STR</name></expr></argument>,           <argument><expr><literal type="string">"requested backup not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_STATUS_CODE_OTHER</name></cpp:macro>                               <cpp:value>99</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_STATUS_MESSAGE_OTHER</name></cpp:macro>                            <cpp:value>"other"</cpp:value></cpp:define>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_OTHER_STR</name></expr></argument>,                 <argument><expr><name>INFO_STANZA_STATUS_MESSAGE_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>INFO_STANZA_INVALID_STR</name></expr></argument>,                              <argument><expr><literal type="string">"[invalid]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_STANZA_STATUS_MESSAGE_LOCK_BACKUP</name></cpp:macro>                      <cpp:value>"backup/expire running"</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Data types and structures
***********************************************************************************************************************************/</comment>
<comment type="line">// Repository information for a stanza</comment>
<typedef>typedef <type><struct>struct <name>InfoRepoData</name>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>key</name></decl>;</decl_stmt>                                               <comment type="line">// User-defined repo key</comment>
    <decl_stmt><decl><type><name>CipherType</name></type> <name>cipher</name></decl>;</decl_stmt>                                              <comment type="line">// Encryption type</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPass</name></decl>;</decl_stmt>                                       <comment type="line">// Passphrase if the repo is encrypted (else NULL)</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>stanzaStatus</name></decl>;</decl_stmt>                                               <comment type="line">// Status code of the stanza on this repo</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name></decl>;</decl_stmt>                                         <comment type="line">// Index of the next backup that may be a candidate for sorting</comment>
    <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>backupInfo</name></decl>;</decl_stmt>                                         <comment type="line">// Contents of the backup.info file of the stanza on this repo</comment>
    <decl_stmt><decl><type><name>InfoArchive</name> <modifier>*</modifier></type><name>archiveInfo</name></decl>;</decl_stmt>                                       <comment type="line">// Contents of the archive.info file of the stanza on this repo</comment>
    <decl_stmt><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl>;</decl_stmt>                                             <comment type="line">// Contents of manifest if backup requested and is on this repo</comment>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>error</name></decl>;</decl_stmt>                                                  <comment type="line">// Formatted error</comment>
}</block></struct></type> <name>InfoRepoData</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_INFO_REPO_DATA_TYPE</name></cpp:macro>                                                                                           \
    <cpp:value>InfoRepoData *</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_INFO_REPO_DATA_FORMAT</name><parameter_list>(<parameter><type><name>value</name></type></parameter>, <parameter><type><name>buffer</name></type></parameter>, <parameter><type><name>bufferSize</name></type></parameter>)</parameter_list></cpp:macro>                                                              \
    <cpp:value>objToLog(value, "InfoRepoData", buffer, bufferSize)</cpp:value></cpp:define>

<comment type="line">// Stanza with repository list of information for each repository</comment>
<typedef>typedef <type><struct>struct <name>InfoStanzaRepo</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>                                             <comment type="line">// Name of the stanza</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>currentPgSystemId</name></decl>;</decl_stmt>                                     <comment type="line">// Current postgres system id for the stanza</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>currentPgVersion</name></decl>;</decl_stmt>                                  <comment type="line">// Current postgres version for the stanza</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>backupLockChecked</name></decl>;</decl_stmt>                                         <comment type="line">// Has the check for a backup lock already been performed?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>backupLockHeld</name></decl>;</decl_stmt>                                            <comment type="line">// Is backup lock held on the system where info command is run?</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>percentComplete</name></decl>;</decl_stmt>                                 <comment type="line">// Percentage of backup complete * 100 (when not NULL)</comment>
    <decl_stmt><decl><type><name>InfoRepoData</name> <modifier>*</modifier></type><name>repoList</name></decl>;</decl_stmt>                                         <comment type="line">// List of configured repositories</comment>
}</block></struct></type> <name>InfoStanzaRepo</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_INFO_STANZA_REPO_TYPE</name></cpp:macro>                                                                                         \
    <cpp:value>InfoStanzaRepo *</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_INFO_STANZA_REPO_FORMAT</name><parameter_list>(<parameter><type><name>value</name></type></parameter>, <parameter><type><name>buffer</name></type></parameter>, <parameter><type><name>bufferSize</name></type></parameter>)</parameter_list></cpp:macro>                                                            \
    <cpp:value>objToLog(value, "InfoStanzaRepo", buffer, bufferSize)</cpp:value></cpp:define>

<comment type="line">// Group all databases with the same system-id and version together regardless of db-id or repo</comment>
<typedef>typedef <type><struct>struct <name>DbGroup</name>
<block>{
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>systemId</name></decl>;</decl_stmt>                                              <comment type="line">// Postgres database system id</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>                                          <comment type="line">// Postgres database version</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>current</name></decl>;</decl_stmt>                                                   <comment type="line">// Is this the current postgres database?</comment>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveMin</name></decl>;</decl_stmt>                                             <comment type="line">// Minimum WAL found for this database over all repositories</comment>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveMax</name></decl>;</decl_stmt>                                             <comment type="line">// Maximum WAL found for this database over all repositories</comment>
    <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>backupList</name></decl>;</decl_stmt>                                        <comment type="line">// List of backups found for this database over all repositories</comment>
}</block></struct></type> <name>DbGroup</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_DB_GROUP_TYPE</name></cpp:macro>                                                                                                 \
    <cpp:value>DbGroup *</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_DB_GROUP_FORMAT</name><parameter_list>(<parameter><type><name>value</name></type></parameter>, <parameter><type><name>buffer</name></type></parameter>, <parameter><type><name>bufferSize</name></type></parameter>)</parameter_list></cpp:macro>                                                                    \
    <cpp:value>objToLog(value, "DbGroup", buffer, bufferSize)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Helper function for reporting errors
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>infoStanzaErrorAdd</name><parameter_list>(<parameter><decl><type><name>InfoRepoData</name> <modifier>*</modifier></type><name>repoList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ErrorType</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>repoList</name><operator>-&gt;</operator><name>stanzaStatus</name></name> <operator>=</operator> <name>INFO_STANZA_STATUS_CODE_OTHER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>repoList</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"[%s] %s"</literal></expr></argument>, <argument><expr><call><name>errorTypeName</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Free the info objects for this stanza since we cannot process it</comment>
    <expr_stmt><expr><call><name>infoBackupFree</name><argument_list>(<argument><expr><name><name>repoList</name><operator>-&gt;</operator><name>backupInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>infoArchiveFree</name><argument_list>(<argument><expr><name><name>repoList</name><operator>-&gt;</operator><name>archiveInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>manifestFree</name><argument_list>(<argument><expr><name><name>repoList</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>repoList</name><operator>-&gt;</operator><name>backupInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>repoList</name><operator>-&gt;</operator><name>archiveInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>repoList</name><operator>-&gt;</operator><name>manifest</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Set the overall error status code and message for the stanza to the code and message passed
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>stanzaStatus</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InfoStanzaRepo</name> <modifier>*</modifier><specifier>const</specifier></type> <name>stanzaData</name></decl></parameter>, <parameter><decl><type><name>Variant</name> <modifier>*</modifier></type><name>stanzaInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO_STANZA_REPO</name></expr></argument>, <argument><expr><name>stanzaData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>stanzaInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>code</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>code</name> <operator>&lt;=</operator> <literal type="number">6</literal><operator>)</operator> <operator>||</operator> <name>code</name> <operator>==</operator> <literal type="number">99</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>stanzaData</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>stanzaInfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>statusKv</name> <init>= <expr><call><name>kvPutKv</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STANZA_KEY_STATUS_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_CODE_VAR</name></expr></argument>, <argument><expr><call><name>VARINT</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>code</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>INFO_STANZA_STATUS_CODE_OK</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_OK_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>INFO_STANZA_STATUS_CODE_MISSING_STANZA_PATH</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_MISSING_STANZA_PATH_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>INFO_STANZA_STATUS_CODE_MISSING_STANZA_DATA</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_MISSING_STANZA_DATA_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>INFO_STANZA_STATUS_CODE_NO_BACKUP</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_NO_BACKUP_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>INFO_STANZA_STATUS_CODE_MIXED</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_MESSAGE_MIXED_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>INFO_STANZA_STATUS_CODE_PG_MISMATCH</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_PG_MISMATCH_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>INFO_STANZA_STATUS_CODE_BACKUP_MISSING</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_CODE_BACKUP_MISSING_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>INFO_STANZA_STATUS_CODE_OTHER</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_OTHER_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="line">// Construct a specific lock part</comment>
    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>lockKv</name> <init>= <expr><call><name>kvPutKv</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_LOCK_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>backupLockKv</name> <init>= <expr><call><name>kvPutKv</name><argument_list>(<argument><expr><name>lockKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_LOCK_BACKUP_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>backupLockKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_LOCK_BACKUP_HELD_VAR</name></expr></argument>, <argument><expr><call><name>VARBOOL</name><argument_list>(<argument><expr><name><name>stanzaData</name><operator>-&gt;</operator><name>backupLockHeld</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>stanzaData</name><operator>-&gt;</operator><name>percentComplete</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptOutput</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CFGOPTVAL_OUTPUT_JSON</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>backupLockKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_LOCK_BACKUP_PERCENT_COMPLETE_VAR</name></expr></argument>, <argument><expr><name><name>stanzaData</name><operator>-&gt;</operator><name>percentComplete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Set the error status code and message for the stanza on the repo to the code and message passed
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repoStanzaStatus</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Variant</name> <modifier>*</modifier></type><name>repoStanzaInfo</name></decl></parameter>, <parameter><decl><type><name>InfoRepoData</name> <modifier>*</modifier></type><name>repoData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>repoStanzaInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO_REPO_DATA</name></expr></argument>, <argument><expr><name>repoData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>code</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>code</name> <operator>&lt;=</operator> <literal type="number">3</literal><operator>)</operator> <operator>||</operator> <name>code</name> <operator>==</operator> <literal type="number">99</literal> <operator>||</operator> <name>code</name> <operator>==</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>repoStanzaInfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>statusKv</name> <init>= <expr><call><name>kvPutKv</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>repoStanzaInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STANZA_KEY_STATUS_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_CODE_VAR</name></expr></argument>, <argument><expr><call><name>VARINT</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>code</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>INFO_STANZA_STATUS_CODE_OK</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_OK_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>INFO_STANZA_STATUS_CODE_MISSING_STANZA_PATH</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_MISSING_STANZA_PATH_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>INFO_STANZA_STATUS_CODE_MISSING_STANZA_DATA</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_MISSING_STANZA_DATA_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>INFO_STANZA_STATUS_CODE_NO_BACKUP</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_MESSAGE_NO_BACKUP_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>INFO_STANZA_STATUS_CODE_BACKUP_MISSING</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>INFO_STANZA_STATUS_CODE_BACKUP_MISSING_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>INFO_STANZA_STATUS_CODE_OTHER</name></expr>:</case>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>statusKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Set the data for the archive section of the stanza for the database info from the backup.info file
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>archiveDbList</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>stanza</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InfoPgData</name> <modifier>*</modifier></type><name>pgData</name></decl></parameter>, <parameter><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>archiveSection</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InfoArchive</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>currentDb</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoKey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>stanza</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>INFO_PG_DATA</name></expr></argument>, <argument><expr><name>pgData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT_LIST</name></expr></argument>, <argument><expr><name>archiveSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>currentDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>stanza</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pgData</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>archiveSection</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// With multiple DB versions, the backup.info history-id may not be the same as archive.info history-id, so the archive path</comment>
    <comment type="line">// must be built by retrieving the archive id given the db version and system id of the backup.info file. If there is no match,</comment>
    <comment type="line">// an error will be thrown.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>archiveId</name> <init>= <expr><call><name>infoArchiveIdHistoryMatch</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name><name>pgData</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>pgData</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>pgData</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archivePath</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_PATH_ARCHIVE</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>stanza</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveStart</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveStop</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier></type><name>archiveInfo</name> <init>= <expr><call><name>varNewKv</name><argument_list>(<argument><expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storageRepo</name> <init>= <expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Get a list of WAL directories in the archive repo from oldest to newest, if any exist</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>walDir</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
        <argument><expr><call><name>storageListP</name><argument_list>(<argument><expr><name>storageRepo</name></expr></argument>, <argument><expr><name>archivePath</name></expr></argument>, <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <name>WAL_SEGMENT_DIR_REGEXP_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>walDir</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Not every WAL dir has WAL files so check each</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>walDir</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// Get a list of all WAL in this WAL dir</comment>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>storageListP</name><argument_list>(
                <argument><expr><name>storageRepo</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archivePath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>walDir</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <name>WAL_SEGMENT_FILE_REGEXP_STR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If wal segments are found, get the oldest one as the archive start</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Sort the list from oldest to newest to get the oldest starting WAL archived for this DB</comment>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>strLstSort</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>archiveStart</name> <operator>=</operator> <call><name>strSubN</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Iterate through the directory list in the reverse so processing newest first. Cast comparison to an int for readability.</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name> <init>= <expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>walDir</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><operator>(</operator><name>int</name><operator>)</operator><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>idx</name><operator>--</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// Get a list of all WAL in this WAL dir</comment>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>storageListP</name><argument_list>(
                <argument><expr><name>storageRepo</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archivePath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>walDir</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <name>WAL_SEGMENT_FILE_REGEXP_STR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If wal segments are found, get the newest one as the archive stop</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Sort the list from newest to oldest to get the newest ending WAL archived for this DB</comment>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>strLstSort</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>archiveStop</name> <operator>=</operator> <call><name>strSubN</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If there is an archive or the database is the current database then store it</comment>
    <if_stmt><if>if <condition>(<expr><name>currentDb</name> <operator>||</operator> <name>archiveStart</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Add empty database section to archiveInfo and then fill in database id from the backup.info</comment>
        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>databaseInfo</name> <init>= <expr><call><name>kvPutKv</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_DATABASE_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>databaseInfo</name></expr></argument>, <argument><expr><name>DB_KEY_ID_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>pgData</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>databaseInfo</name></expr></argument>, <argument><expr><name>KEY_REPO_KEY_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name>repoKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DB_KEY_ID_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ARCHIVE_KEY_MIN_VAR</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>archiveStart</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>archiveStart</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>(</operator><name>Variant</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ARCHIVE_KEY_MAX_VAR</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>archiveStop</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>archiveStop</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>(</operator><name>Variant</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>archiveSection</name></expr></argument>, <argument><expr><name>archiveInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Add the backup data to the backup section
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>backupListAdd</name><parameter_list>(
    <parameter><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>backupSection</name></decl></parameter>, <parameter><decl><type><name>InfoBackupData</name> <modifier>*</modifier></type><name>backupData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupLabel</name></decl></parameter>, <parameter><decl><type><name>InfoRepoData</name> <modifier>*</modifier></type><name>repoData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT_LIST</name></expr></argument>, <argument><expr><name>backupSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <comment type="line">// The section to add the backup data to</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>INFO_BACKUP_DATA</name></expr></argument>, <argument><expr><name>backupData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="line">// The data for the backup</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                   <comment type="line">// Backup label to filter if requested by the user</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO_REPO_DATA</name></expr></argument>, <argument><expr><name>repoData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>              <comment type="line">// The repo data where this backup is located</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>backupSection</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>backupData</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>repoData</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier></type><name>backupInfo</name> <init>= <expr><call><name>varNewKv</name><argument_list>(<argument><expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Flags used to decide what data to add</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>outputJson</name> <init>= <expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptOutput</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_OUTPUT_JSON</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// main keys</comment>
    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_LABEL_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_TYPE_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>kvPut</name><argument_list>(
        <argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_PRIOR_VAR</name></expr></argument>,
        <argument><expr><operator>(</operator><ternary><condition><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupPrior</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupPrior</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>kvPut</name><argument_list>(
        <argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_REFERENCE_VAR</name></expr></argument>,
        <argument><expr><operator>(</operator><ternary><condition><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupReference</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><call><name>varLstNewStrLst</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupReference</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// archive section</comment>
    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>archiveInfo</name> <init>= <expr><call><name>kvPutKv</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_ARCHIVE_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>kvPut</name><argument_list>(
        <argument><expr><name>archiveInfo</name></expr></argument>, <argument><expr><name>KEY_START_VAR</name></expr></argument>,
        <argument><expr><operator>(</operator><ternary><condition><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupArchiveStart</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupArchiveStart</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>kvPut</name><argument_list>(
        <argument><expr><name>archiveInfo</name></expr></argument>, <argument><expr><name>KEY_STOP_VAR</name></expr></argument>,
        <argument><expr><operator>(</operator><ternary><condition><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupArchiveStop</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupArchiveStop</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// backrest section</comment>
    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>backrestInfo</name> <init>= <expr><call><name>kvPutKv</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_BACKREST_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>backrestInfo</name></expr></argument>, <argument><expr><name>BACKREST_KEY_FORMAT_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backrestFormat</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>backrestInfo</name></expr></argument>, <argument><expr><name>BACKREST_KEY_VERSION_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backrestVersion</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// database section</comment>
    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>dbInfo</name> <init>= <expr><call><name>kvPutKv</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_DATABASE_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>dbInfo</name></expr></argument>, <argument><expr><name>DB_KEY_ID_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupPgId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>dbInfo</name></expr></argument>, <argument><expr><name>KEY_REPO_KEY_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// info section</comment>
    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>infoInfo</name> <init>= <expr><call><name>kvPutKv</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_INFO_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>infoInfo</name></expr></argument>, <argument><expr><name>KEY_SIZE_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupInfoSize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>infoInfo</name></expr></argument>, <argument><expr><name>KEY_DELTA_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupInfoSizeDelta</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// info:repository section</comment>
    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>repoInfo</name> <init>= <expr><call><name>kvPutKv</name><argument_list>(<argument><expr><name>infoInfo</name></expr></argument>, <argument><expr><name>INFO_KEY_REPOSITORY_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>repoInfo</name></expr></argument>, <argument><expr><name>KEY_SIZE_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupInfoRepoSize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>repoInfo</name></expr></argument>, <argument><expr><name>KEY_DELTA_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupInfoRepoSizeDelta</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// timestamp section</comment>
    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>timeInfo</name> <init>= <expr><call><name>kvPutKv</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_TIMESTAMP_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// time_t is generally a signed int so cast it to uint64 since it can never be negative (before 1970) in our system</comment>
    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>timeInfo</name></expr></argument>, <argument><expr><name>KEY_START_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT64</name><argument_list>(<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>backupData</name><operator>-&gt;</operator><name>backupTimestampStart</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>timeInfo</name></expr></argument>, <argument><expr><name>KEY_STOP_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT64</name><argument_list>(<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>backupData</name><operator>-&gt;</operator><name>backupTimestampStop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Report errors only if the error status is known</comment>
    <if_stmt><if>if <condition>(<expr><name><name>backupData</name><operator>-&gt;</operator><name>backupError</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_ERROR_VAR</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupError</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Add start/stop backup lsn info to json output or --set text</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>outputJson</name> <operator>||</operator> <name>backupLabel</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>backupData</name><operator>-&gt;</operator><name>backupLsnStart</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>backupData</name><operator>-&gt;</operator><name>backupLsnStop</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier><specifier>const</specifier></type> <name>lsnInfo</name> <init>= <expr><call><name>kvPutKv</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_LSN_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>lsnInfo</name></expr></argument>, <argument><expr><name>KEY_START_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupLsnStart</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>lsnInfo</name></expr></argument>, <argument><expr><name>KEY_STOP_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupLsnStop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Add annotations to json output or --set text</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>outputJson</name> <operator>||</operator> <name>backupLabel</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>backupData</name><operator>-&gt;</operator><name>backupAnnotation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_ANNOTATION_VAR</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>backupAnnotation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// If a backup label was specified and this is that label, then get the data from the loaded manifest</comment>
    <if_stmt><if>if <condition>(<expr><name>backupLabel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Get the list of databases in this backup</comment>
        <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>databaseSection</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>dbIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>dbIdx</name> <operator>&lt;</operator> <call><name>manifestDbTotal</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>dbIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestDb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>manifestDb</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>dbIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Do not display template databases</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgDbIsTemplate</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier></type><name>database</name> <init>= <expr><call><name>varNewKv</name><argument_list>(<argument><expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_NAME_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_OID_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>databaseSection</name></expr></argument>, <argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Add the database section even if none found</comment>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_DATABASE_REF_VAR</name></expr></argument>, <argument><expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><name>databaseSection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Get symlinks and tablespaces</comment>
        <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>linkSection</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>tablespaceSection</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>manifestTargetTotal</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>targetIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>manifestTarget</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><call><name>varNewKv</name><argument_list>(<argument><expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier></type><name>tablespace</name> <init>= <expr><call><name>varNewKv</name><argument_list>(<argument><expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>manifestTargetTypeLink</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceName</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_NAME_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_DESTINATION_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_OID_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>tablespaceSection</name></expr></argument>, <argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>file</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_NAME_VAR</name></expr></argument>, <argument><expr><call><name>varNewStr</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(
                        <argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_DESTINATION_VAR</name></expr></argument>, <argument><expr><call><name>varNewStr</name><argument_list>(<argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>linkSection</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_NAME_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>manifestPathPg</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_DESTINATION_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>linkSection</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_LINK_VAR</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><operator>!</operator><call><name>varLstEmpty</name><argument_list>(<argument><expr><name>linkSection</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><name>linkSection</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(
            <argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_TABLESPACE_VAR</name></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><operator>!</operator><call><name>varLstEmpty</name><argument_list>(<argument><expr><name>tablespaceSection</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><name>tablespaceSection</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Get the list of files with an error</comment>
        <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>checksumPageErrorList</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fileIdx</name> <operator>&lt;</operator> <call><name>manifestFileTotal</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFile</name></type> <name>file</name> <init>= <expr><call><name>manifestFile</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>.</operator><name>checksumPageError</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>checksumPageErrorList</name></expr></argument>, <argument><expr><call><name>varNewStr</name><argument_list>(<argument><expr><call><name>manifestPathPg</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>varLstEmpty</name><argument_list>(<argument><expr><name>checksumPageErrorList</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_ERROR_LIST_VAR</name></expr></argument>, <argument><expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><name>checksumPageErrorList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// It is possible that backup-error is not set in backup.info but there are errors in manifest because backup-error was</comment>
            <comment type="line">// added in a later version than manifest errors. However, it should not be possible for backup-error to be present but</comment>
            <comment type="line">// false if there are errors in the manifest. In production this condition will be ignored and error set to true.</comment>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(
                <argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_ERROR_VAR</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>varBool</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_ERROR_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BACKUP_KEY_ERROR_VAR</name></expr></argument>, <argument><expr><name>BOOL_TRUE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>manifestFree</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>repoData</name><operator>-&gt;</operator><name>manifest</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>backupSection</name></expr></argument>, <argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
For each current backup in the backup.info file of the stanza, set the data for the backup section
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>backupList</name><parameter_list>(
    <parameter><decl><type><name>VariantList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupSection</name></decl></parameter>, <parameter><decl><type><name>InfoStanzaRepo</name> <modifier>*</modifier><specifier>const</specifier></type> <name>stanzaData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupLabel</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>repoIdxMin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>repoIdxMax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT_LIST</name></expr></argument>, <argument><expr><name>backupSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <comment type="line">// The section to add the backup data to</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO_STANZA_REPO</name></expr></argument>, <argument><expr><name>stanzaData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          <comment type="line">// The data for the stanza</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                   <comment type="line">// Backup label to filter if requested by the user</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdxMin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                      <comment type="line">// The start index of the repo array to begin checking</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdxMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                      <comment type="line">// The index of the last repo to check</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>backupSection</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>stanzaData</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupNextRepoIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupTotalProcessed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// Get the number of backups to be processed</comment>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name> <init>= <expr><name>repoIdxMin</name></expr></init></decl>;</init> <condition><expr><name>repoIdx</name> <operator>&lt;=</operator> <name>repoIdxMax</name></expr>;</condition> <incr><expr><name>repoIdx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>InfoRepoData</name> <modifier>*</modifier></type><name>repoData</name> <init>= <expr><operator>&amp;</operator><name><name>stanzaData</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>backupTotal</name> <operator>+=</operator> <call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// Process any backups</comment>
    <while>while <condition>(<expr><name>backupTotalProcessed</name> <operator>&lt;</operator> <name>backupTotal</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>time_t</name></type> <name>backupNextTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// Backups are sorted for each repo, so iterate over the lists to create a single list ordered by backup-timestamp-stop</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name> <init>= <expr><name>repoIdxMin</name></expr></init></decl>;</init> <condition><expr><name>repoIdx</name> <operator>&lt;=</operator> <name>repoIdxMax</name></expr>;</condition> <incr><expr><name>repoIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>InfoRepoData</name> <modifier>*</modifier></type><name>repoData</name> <init>= <expr><operator>&amp;</operator><name><name>stanzaData</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// If there are current backups on this repo for this stanza and the end of this backup list has not been reached</comment>
            <comment type="line">// determine the next backup for display</comment>
            <if_stmt><if>if <condition>(<expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <name><name>repoData</name><operator>-&gt;</operator><name>backupIdx</name></name> <operator>&lt;</operator> <call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>backupData</name> <init>= <expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name></expr></argument>, <argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupIdx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// See if this backup should be next in the list, ordering from oldest to newest</comment>
                <if_stmt><if>if <condition>(<expr><name>backupNextTime</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>backupData</name><operator>.</operator><name>backupTimestampStop</name></name> <operator>&lt;</operator> <name>backupNextTime</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>backupNextTime</name> <operator>=</operator> <name><name>backupData</name><operator>.</operator><name>backupTimestampStop</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>backupNextRepoIdx</name> <operator>=</operator> <name>repoIdx</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <decl_stmt><decl><type><name>InfoRepoData</name> <modifier>*</modifier></type><name>repoData</name> <init>= <expr><operator>&amp;</operator><name><name>stanzaData</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>backupNextRepoIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>backupData</name> <init>= <expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name></expr></argument>, <argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupIdx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupIdx</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>backupTotalProcessed</name><operator>++</operator></expr>;</expr_stmt>

        <comment type="line">// Don't add the backup data to the backup section if a backup label was specified but this is not it</comment>
        <if_stmt><if>if <condition>(<expr><name>backupLabel</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>backupData</name><operator>.</operator><name>backupLabel</name></name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="line">// Add the backup data to the backup section</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>backupData</name><operator>.</operator><name>backupType</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>backupListAdd</name><argument_list>(<argument><expr><name>backupSection</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>backupData</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>, <argument><expr><name>repoData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Set the stanza data for each stanza found in the repo
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>VariantList</name> <modifier>*</modifier></type>
<name>stanzaInfoList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stanzaRepoList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupLabel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>repoIdxMin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>repoIdxMax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>stanzaRepoList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdxMin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdxMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>stanzaRepoList</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Sort the list of stanzas</comment>
    <expr_stmt><expr><name>stanzaRepoList</name> <operator>=</operator> <call><name>lstSort</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Process each stanza requested</comment>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>InfoStanzaRepo</name> <modifier>*</modifier></type><name>stanzaData</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Create the stanzaInfo and section variables</comment>
        <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier></type><name>stanzaInfo</name> <init>= <expr><call><name>varNewKv</name><argument_list>(<argument><expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>dbSection</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>backupSection</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>archiveSection</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>repoSection</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>stanzaStatusCode</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>stanzaCipherType</name> <init>= <expr><name>cipherTypeNone</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Set the stanza name and initialize the overall stanza variables</comment>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_NAME_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>stanzaData</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Get the stanza for each requested repo</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name> <init>= <expr><name>repoIdxMin</name></expr></init></decl>;</init> <condition><expr><name>repoIdx</name> <operator>&lt;=</operator> <name>repoIdxMax</name></expr>;</condition> <incr><expr><name>repoIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>InfoRepoData</name> <modifier>*</modifier></type><name>repoData</name> <init>= <expr><operator>&amp;</operator><name><name>stanzaData</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier></type><name>repoInfo</name> <init>= <expr><call><name>varNewKv</name><argument_list>(<argument><expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>repoInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>REPO_KEY_KEY_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>repoInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_CIPHER_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>cipher</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If the stanza on this repo has the default status of ok but the backupInfo was not read, then the stanza exists on</comment>
            <comment type="line">// other repos but not this one</comment>
            <if_stmt><if>if <condition>(<expr><name><name>repoData</name><operator>-&gt;</operator><name>stanzaStatus</name></name> <operator>==</operator> <name>INFO_STANZA_STATUS_CODE_OK</name> <operator>&amp;&amp;</operator> <name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>repoData</name><operator>-&gt;</operator><name>stanzaStatus</name></name> <operator>=</operator> <name>INFO_STANZA_STATUS_CODE_MISSING_STANZA_PATH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// If the backup.info file has been read, then get the backup and archive information on this repo</comment>
                <if_stmt><if>if <condition>(<expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// If the backup.info file exists, get the database history information (oldest to newest) and corresponding</comment>
                    <comment type="line">// archive</comment>
                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>pgIdx</name> <init>= <expr><call><name>infoPgDataTotal</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><operator>(</operator><name>int</name><operator>)</operator><name>pgIdx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>pgIdx</name><operator>--</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>InfoPgData</name></type> <name>pgData</name> <init>= <expr><call><name>infoPgData</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier></type><name>pgInfo</name> <init>= <expr><call><name>varNewKv</name><argument_list>(<argument><expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>pgInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DB_KEY_ID_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>pgData</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>pgInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DB_KEY_SYSTEM_ID_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name><name>pgData</name><operator>.</operator><name>systemId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>pgInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DB_KEY_VERSION_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name><name>pgData</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>pgInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_REPO_KEY_VAR</name></expr></argument>, <argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>dbSection</name></expr></argument>, <argument><expr><name>pgInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Get the archive info for the DB from the archive.info file</comment>
                        <expr_stmt><expr><call><name>archiveDbList</name><argument_list>(
                            <argument><expr><name><name>stanzaData</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgData</name></expr></argument>, <argument><expr><name>archiveSection</name></expr></argument>, <argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>archiveInfo</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>pgIdx</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr></argument>,
                            <argument><expr><name>repoIdx</name></expr></argument>, <argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>

                    <comment type="line">// Set stanza status if the current db sections do not match across repos</comment>
                    <decl_stmt><decl><type><name>InfoPgData</name></type> <name>backupInfoCurrentPg</name> <init>= <expr><call><name>infoPgData</name><argument_list>(
                        <argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>infoPgDataCurrentId</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// The current PG system and version must match across repos for the stanza, if not, a failure may have occurred</comment>
                    <comment type="line">// during an upgrade or the repo may have been disabled during the stanza upgrade to protect from error</comment>
                    <comment type="line">// propagation</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>stanzaData</name><operator>-&gt;</operator><name>currentPgVersion</name></name> <operator>!=</operator> <name><name>backupInfoCurrentPg</name><operator>.</operator><name>version</name></name> <operator>||</operator>
                        <name><name>stanzaData</name><operator>-&gt;</operator><name>currentPgSystemId</name></name> <operator>!=</operator> <name><name>backupInfoCurrentPg</name><operator>.</operator><name>systemId</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>stanzaStatusCode</name> <operator>=</operator> <name>INFO_STANZA_STATUS_CODE_PG_MISMATCH</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><call><name>infoStanzaErrorAdd</name><argument_list>(<argument><expr><name>repoData</name></expr></argument>, <argument><expr><call><name>errorType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If there are no current backups on this repo then set status to no backup</comment>
            <if_stmt><if>if <condition>(<expr><name><name>repoData</name><operator>-&gt;</operator><name>stanzaStatus</name></name> <operator>==</operator> <name>INFO_STANZA_STATUS_CODE_OK</name> <operator>&amp;&amp;</operator> <call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>backupInfo</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>repoData</name><operator>-&gt;</operator><name>stanzaStatus</name></name> <operator>=</operator> <name>INFO_STANZA_STATUS_CODE_NO_BACKUP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Track the status over all repos if the status for the stanza has not already been determined</comment>
            <if_stmt><if>if <condition>(<expr><name>stanzaStatusCode</name> <operator>!=</operator> <name>INFO_STANZA_STATUS_CODE_PG_MISMATCH</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>repoIdx</name> <operator>==</operator> <name>repoIdxMin</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>stanzaStatusCode</name> <operator>=</operator> <name><name>repoData</name><operator>-&gt;</operator><name>stanzaStatus</name></name></expr>;</expr_stmt></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>stanzaStatusCode</name> <operator>=</operator>
                        <ternary><condition><expr><name>stanzaStatusCode</name> <operator>!=</operator> <name><name>repoData</name><operator>-&gt;</operator><name>stanzaStatus</name></name></expr> ?</condition><then> <expr><name>INFO_STANZA_STATUS_CODE_MIXED</name></expr> </then><else>: <expr><name><name>repoData</name><operator>-&gt;</operator><name>stanzaStatus</name></name></expr></else></ternary></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Track cipher type over all repos</comment>
            <if_stmt><if>if <condition>(<expr><name>repoIdx</name> <operator>==</operator> <name>repoIdxMin</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>stanzaCipherType</name> <operator>=</operator> <name><name>repoData</name><operator>-&gt;</operator><name>cipher</name></name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>stanzaCipherType</name> <operator>=</operator> <ternary><condition><expr><name>stanzaCipherType</name> <operator>!=</operator> <name><name>repoData</name><operator>-&gt;</operator><name>cipher</name></name></expr> ?</condition><then> <expr><name>INFO_STANZA_STATUS_CODE_MIXED</name></expr> </then><else>: <expr><name><name>repoData</name><operator>-&gt;</operator><name>cipher</name></name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="line">// Add the status of the stanza on the repo to the repo section, and the repo to the repo array</comment>
            <expr_stmt><expr><call><name>repoStanzaStatus</name><argument_list>(<argument><expr><name><name>repoData</name><operator>-&gt;</operator><name>stanzaStatus</name></name></expr></argument>, <argument><expr><name>repoInfo</name></expr></argument>, <argument><expr><name>repoData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>repoSection</name></expr></argument>, <argument><expr><name>repoInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Add the database history, backup, archive and repo arrays to the stanza info</comment>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STANZA_KEY_DB_VAR</name></expr></argument>, <argument><expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><name>dbSection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_ARCHIVE_VAR</name></expr></argument>, <argument><expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><name>archiveSection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STANZA_KEY_REPO_VAR</name></expr></argument>, <argument><expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><name>repoSection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Get a sorted list of the data for all existing backups for this stanza over all repos</comment>
        <expr_stmt><expr><call><name>backupList</name><argument_list>(<argument><expr><name>backupSection</name></expr></argument>, <argument><expr><name>stanzaData</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>, <argument><expr><name>repoIdxMin</name></expr></argument>, <argument><expr><name>repoIdxMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STANZA_KEY_BACKUP_VAR</name></expr></argument>, <argument><expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><name>backupSection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Set the overall stanza status</comment>
        <expr_stmt><expr><call><name>stanzaStatus</name><argument_list>(<argument><expr><name>stanzaStatusCode</name></expr></argument>, <argument><expr><name>stanzaData</name></expr></argument>, <argument><expr><name>stanzaInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Set the overall cipher type</comment>
        <if_stmt><if>if <condition>(<expr><name>stanzaCipherType</name> <operator>!=</operator> <name>INFO_STANZA_STATUS_CODE_MIXED</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_CIPHER_VAR</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name>stanzaCipherType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_CIPHER_VAR</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>INFO_STANZA_MIXED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>stanzaInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Format the text output for archive and backups for a database group of a stanza
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>formatTextBackup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DbGroup</name> <modifier>*</modifier></type><name>dbGroup</name></decl></parameter>, <parameter><decl><type><name>String</name> <modifier>*</modifier></type><name>resultStr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>DB_GROUP</name></expr></argument>, <argument><expr><name>dbGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>resultStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>dbGroup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"\n        wal archive min/max (%s): "</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>dbGroup</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Get the archive min/max if there are any archives for the database</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dbGroup</name><operator>-&gt;</operator><name>archiveMin</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"%s/%s\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>dbGroup</name><operator>-&gt;</operator><name>archiveMin</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>dbGroup</name><operator>-&gt;</operator><name>archiveMax</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"none present\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name><name>dbGroup</name><operator>-&gt;</operator><name>backupList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupIdx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>backupInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name><name>dbGroup</name><operator>-&gt;</operator><name>backupList</name></name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
            <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"\n        %s backup: %s\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_TYPE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_LABEL_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Get and format the backup start/stop time</comment>
        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>timestampInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_TIMESTAMP_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type> <name>timePart</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>timeBufferStart</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>timeBufferStop</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>time_t</name></type> <name>timeStart</name> <init>= <expr><operator>(</operator><name>time_t</name><operator>)</operator><call><name>varUInt64</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>timestampInfo</name></expr></argument>, <argument><expr><name>KEY_START_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>time_t</name></type> <name>timeStop</name> <init>= <expr><operator>(</operator><name>time_t</name><operator>)</operator><call><name>varUInt64</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>timestampInfo</name></expr></argument>, <argument><expr><name>KEY_STOP_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>strftime</name><argument_list>(<argument><expr><name>timeBufferStart</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>timeBufferStart</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S"</literal></expr></argument>, <argument><expr><call><name>localtime_r</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timeStart</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timePart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strftime</name><argument_list>(<argument><expr><name>timeBufferStop</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>timeBufferStop</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S"</literal></expr></argument>, <argument><expr><call><name>localtime_r</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timeStop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timePart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"            timestamp start/stop: %s / %s\n"</literal></expr></argument>, <argument><expr><name>timeBufferStart</name></expr></argument>, <argument><expr><name>timeBufferStop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"            wal start/stop: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>archiveBackupInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>KEY_ARCHIVE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>kvGet</name><argument_list>(<argument><expr><name>archiveBackupInfo</name></expr></argument>, <argument><expr><name>KEY_START_VAR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>kvGet</name><argument_list>(<argument><expr><name>archiveBackupInfo</name></expr></argument>, <argument><expr><name>KEY_STOP_VAR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"%s / %s\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>archiveBackupInfo</name></expr></argument>, <argument><expr><name>KEY_START_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>archiveBackupInfo</name></expr></argument>, <argument><expr><name>KEY_STOP_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"n/a\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>KeyValue</name> <modifier>*</modifier><specifier>const</specifier></type> <name>lsnInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_LSN_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>lsnInfo</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"            lsn start/stop: %s / %s\n"</literal></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>lsnInfo</name></expr></argument>, <argument><expr><name>KEY_START_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>lsnInfo</name></expr></argument>, <argument><expr><name>KEY_STOP_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_INFO_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
            <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"            database size: %s, database backup size: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSizeFormat</name><argument_list>(<argument><expr><call><name>varUInt64Force</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>KEY_SIZE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSizeFormat</name><argument_list>(<argument><expr><call><name>varUInt64Force</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>KEY_DELTA_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>repoInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>INFO_KEY_REPOSITORY_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
            <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"            repo%u: backup set size: %s, backup size: %s\n"</literal></expr></argument>,
            <argument><expr><call><name>varUInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>KEY_DATABASE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>KEY_REPO_KEY_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSizeFormat</name><argument_list>(<argument><expr><call><name>varUInt64Force</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>repoInfo</name></expr></argument>, <argument><expr><name>KEY_SIZE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSizeFormat</name><argument_list>(<argument><expr><call><name>varUInt64Force</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>repoInfo</name></expr></argument>, <argument><expr><name>KEY_DELTA_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_REFERENCE_VAR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>referenceList</name> <init>= <expr><call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>varVarLst</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_REFERENCE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"            backup reference list: %s\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>referenceList</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_DATABASE_REF_VAR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>dbSection</name> <init>= <expr><call><name>kvGetList</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_DATABASE_REF_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"            database list:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>varLstEmpty</name><argument_list>(<argument><expr><name>dbSection</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">" none\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>dbIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>dbIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>dbSection</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>dbIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>dbSection</name></expr></argument>, <argument><expr><name>dbIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                        <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">" %s (%s)"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>KEY_NAME_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStrForce</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>KEY_OID_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>dbIdx</name> <operator>!=</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>dbSection</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>

                <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><name>LF_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_LINK_VAR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>linkSection</name> <init>= <expr><call><name>kvGetList</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_LINK_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"            symlinks:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>linkIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>linkIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>linkSection</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>linkIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>linkSection</name></expr></argument>, <argument><expr><name>linkIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                    <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"                %s =&gt; %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>link</name></expr></argument>, <argument><expr><name>KEY_NAME_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>link</name></expr></argument>, <argument><expr><name>KEY_DESTINATION_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>linkIdx</name> <operator>!=</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>linkSection</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><name>LF_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><name>LF_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_TABLESPACE_VAR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>tablespaceSection</name> <init>= <expr><call><name>kvGetList</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_TABLESPACE_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"            tablespaces:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>tblIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>tblIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>tablespaceSection</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>tblIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>tablespace</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>tablespaceSection</name></expr></argument>, <argument><expr><name>tblIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                    <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"                %s (%s) =&gt; %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>, <argument><expr><name>KEY_NAME_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStrForce</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>, <argument><expr><name>KEY_OID_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>, <argument><expr><name>KEY_DESTINATION_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>tblIdx</name> <operator>!=</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>tablespaceSection</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><name>LF_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><name>LF_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If errors were detected during the backup</comment>
        <if_stmt><if>if <condition>(<expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_ERROR_VAR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>varBool</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_ERROR_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Output error list if present</comment>
            <if_stmt><if>if <condition>(<expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_ERROR_LIST_VAR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>checksumPageErrorList</name> <init>= <expr><call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>varVarLst</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_ERROR_LIST_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"            error list: %s\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>checksumPageErrorList</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else output a general message</comment>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"            error(s) detected during backup\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Annotations metadata</comment>
        <if_stmt><if>if <condition>(<expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_ANNOTATION_VAR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>KeyValue</name> <modifier>*</modifier><specifier>const</specifier></type> <name>annotationKv</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>BACKUP_KEY_ANNOTATION_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>annotationKeyList</name> <init>= <expr><call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>kvKeyList</name><argument_list>(<argument><expr><name>annotationKv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>annotationStr</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>keyIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>keyIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>annotationKeyList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>keyIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>annotationKeyList</name></expr></argument>, <argument><expr><name>keyIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>value</name> <init>= <expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>annotationKv</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>annotationStr</name></expr></argument>, <argument><expr><literal type="string">"                %s: %s\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"            annotation(s)\n%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>annotationStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Format the text output for each database of the stanza
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>formatTextDb</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>KeyValue</name> <modifier>*</modifier></type><name>stanzaInfo</name></decl></parameter>, <parameter><decl><type><name>String</name> <modifier>*</modifier></type><name>resultStr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>currentPgVersion</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>currentPgSystemId</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupLabel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>KEY_VALUE</name></expr></argument>, <argument><expr><name>stanzaInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>resultStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>currentPgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>currentPgSystemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>stanzaInfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>currentPgVersion</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>dbSection</name> <init>= <expr><call><name>kvGetList</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>, <argument><expr><name>STANZA_KEY_DB_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>archiveSection</name> <init>= <expr><call><name>kvGetList</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>, <argument><expr><name>KEY_ARCHIVE_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>backupSection</name> <init>= <expr><call><name>kvGetList</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>, <argument><expr><name>STANZA_KEY_BACKUP_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dbGroupList</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DbGroup</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// For each database update the corresponding archive info</comment>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>dbIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>dbIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>dbSection</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>dbIdx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>pgInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>dbSection</name></expr></argument>, <argument><expr><name>dbIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>dbSysId</name> <init>= <expr><call><name>varUInt64</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>pgInfo</name></expr></argument>, <argument><expr><name>DB_KEY_SYSTEM_ID_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>dbVersion</name> <init>= <expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>pgInfo</name></expr></argument>, <argument><expr><name>DB_KEY_VERSION_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>dbId</name> <init>= <expr><call><name>varUInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>pgInfo</name></expr></argument>, <argument><expr><name>DB_KEY_ID_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>dbRepoKey</name> <init>= <expr><call><name>varUInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>pgInfo</name></expr></argument>, <argument><expr><name>KEY_REPO_KEY_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>DbGroup</name> <modifier>*</modifier></type><name>dbGroup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>dbGrpIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>dbGrpIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>dbGroupList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>dbGrpIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>DbGroup</name> <modifier>*</modifier></type><name>dbGroupInfo</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>dbGroupList</name></expr></argument>, <argument><expr><name>dbGrpIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>dbGroupInfo</name><operator>-&gt;</operator><name>systemId</name></name> <operator>==</operator> <name>dbSysId</name> <operator>&amp;&amp;</operator> <call><name>strEq</name><argument_list>(<argument><expr><name><name>dbGroupInfo</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name>dbVersion</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>dbGroup</name> <operator>=</operator> <name>dbGroupInfo</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// If the group was not found, then add it</comment>
        <if_stmt><if>if <condition>(<expr><name>dbGroup</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>DbGroup</name></type> <name>dbGroupInfo</name> <init>=
            <expr><block>{
                <expr><operator>.</operator><name>systemId</name> <operator>=</operator> <name>dbSysId</name></expr>,
                <expr><operator>.</operator><name>version</name> <operator>=</operator> <name>dbVersion</name></expr>,
                <expr><operator>.</operator><name>current</name> <operator>=</operator> <operator>(</operator><name>currentPgSystemId</name> <operator>==</operator> <name>dbSysId</name> <operator>&amp;&amp;</operator> <call><name>strEq</name><argument_list>(<argument><expr><name>currentPgVersion</name></expr></argument>, <argument><expr><name>dbVersion</name></expr></argument>)</argument_list></call><operator>)</operator></expr>,
                <expr><operator>.</operator><name>archiveMin</name> <operator>=</operator> <name>NULL</name></expr>,
                <expr><operator>.</operator><name>archiveMax</name> <operator>=</operator> <name>NULL</name></expr>,
                <expr><operator>.</operator><name>backupList</name> <operator>=</operator> <call><name>varLstNew</name><argument_list>()</argument_list></call></expr>,
            }</block></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name>dbGroupList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbGroupInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>dbGroup</name> <operator>=</operator> <call><name>lstGetLast</name><argument_list>(<argument><expr><name>dbGroupList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// For each archive of this stanza, update the archive min/max for this database group if necessary</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>archiveIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>archiveIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>archiveSection</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>archiveIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>archiveInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>archiveSection</name></expr></argument>, <argument><expr><name>archiveIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>archiveDbInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>, <argument><expr><name>KEY_DATABASE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>archiveDbId</name> <init>= <expr><call><name>varUInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>archiveDbInfo</name></expr></argument>, <argument><expr><name>DB_KEY_ID_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>archiveRepoKey</name> <init>= <expr><call><name>varUInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>archiveDbInfo</name></expr></argument>, <argument><expr><name>KEY_REPO_KEY_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If there are archives and the min is less than that for this database group, then update the group</comment>
            <if_stmt><if>if <condition>(<expr><name>archiveDbId</name> <operator>==</operator> <name>dbId</name> <operator>&amp;&amp;</operator> <name>archiveRepoKey</name> <operator>==</operator> <name>dbRepoKey</name> <operator>&amp;&amp;</operator> <call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>, <argument><expr><name>ARCHIVE_KEY_MIN_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Although archives should continue to increment over system-id/version with different db-ids, there may be cases</comment>
                <comment type="line">// where an archived WAL may exist on both, and if the archive id on a later db is less than a prior instance of</comment>
                <comment type="line">// the same PG, then ensure it is updated as the min. Any need to error should not be handled in the info command.</comment>
                <if_stmt><if>if <condition>(<expr><name><name>dbGroup</name><operator>-&gt;</operator><name>archiveMin</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strCmp</name><argument_list>(<argument><expr><name><name>dbGroup</name><operator>-&gt;</operator><name>archiveMin</name></name></expr></argument>, <argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>, <argument><expr><name>ARCHIVE_KEY_MIN_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>dbGroup</name><operator>-&gt;</operator><name>archiveMin</name></name> <operator>=</operator> <call><name>varStrForce</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>, <argument><expr><name>ARCHIVE_KEY_MIN_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>dbGroup</name><operator>-&gt;</operator><name>archiveMax</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strCmp</name><argument_list>(<argument><expr><name><name>dbGroup</name><operator>-&gt;</operator><name>archiveMax</name></name></expr></argument>, <argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>, <argument><expr><name>ARCHIVE_KEY_MAX_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>dbGroup</name><operator>-&gt;</operator><name>archiveMax</name></name> <operator>=</operator> <call><name>varStrForce</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>, <argument><expr><name>ARCHIVE_KEY_MAX_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupDbGrpIdxMin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupDbGrpIdxMax</name> <init>= <expr><call><name>lstSize</name><argument_list>(<argument><expr><name>dbGroupList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// For every backup (oldest to newest) for the stanza, add it to the database group based on system-id and version</comment>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>backupSection</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupIdx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>backupInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>backupSection</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>backupDbInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>KEY_DATABASE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupDbId</name> <init>= <expr><call><name>varUInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupDbInfo</name></expr></argument>, <argument><expr><name>DB_KEY_ID_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupRepoKey</name> <init>= <expr><call><name>varUInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupDbInfo</name></expr></argument>, <argument><expr><name>KEY_REPO_KEY_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Find the database group this backup belongs to and add it</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>dbIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>dbIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>dbSection</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>dbIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>pgInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>dbSection</name></expr></argument>, <argument><expr><name>dbIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>dbId</name> <init>= <expr><call><name>varUInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>pgInfo</name></expr></argument>, <argument><expr><name>DB_KEY_ID_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>dbRepoKey</name> <init>= <expr><call><name>varUInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>pgInfo</name></expr></argument>, <argument><expr><name>KEY_REPO_KEY_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>backupDbId</name> <operator>==</operator> <name>dbId</name> <operator>&amp;&amp;</operator> <name>backupRepoKey</name> <operator>==</operator> <name>dbRepoKey</name></expr>)</condition>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>dbGrpIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>dbGrpIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>dbGroupList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>dbGrpIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>DbGroup</name> <modifier>*</modifier></type><name>dbGroupInfo</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>dbGroupList</name></expr></argument>, <argument><expr><name>dbGrpIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>dbGroupInfo</name><operator>-&gt;</operator><name>systemId</name></name> <operator>==</operator> <call><name>varUInt64</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>pgInfo</name></expr></argument>, <argument><expr><name>DB_KEY_SYSTEM_ID_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                        <call><name>strEq</name><argument_list>(<argument><expr><name><name>dbGroupInfo</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>pgInfo</name></expr></argument>, <argument><expr><name>DB_KEY_VERSION_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name><name>dbGroupInfo</name><operator>-&gt;</operator><name>backupList</name></name></expr></argument>, <argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>backupSection</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// If we're only looking for one backup, then narrow the db group iterators</comment>
                        <if_stmt><if>if <condition>(<expr><name>backupLabel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>backupDbGrpIdxMin</name> <operator>=</operator> <name>dbGrpIdx</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>backupDbGrpIdxMax</name> <operator>=</operator> <name>dbGrpIdx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <expr_stmt><expr><name>dbGrpIdx</name> <operator>=</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>dbGroupList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <expr_stmt><expr><name>dbIdx</name> <operator>=</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>dbSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>resultCurrent</name> <init>= <expr><call><name>strCatZ</name><argument_list>(<argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"\n    db (current)"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>displayCurrent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>dbGrpIdx</name> <init>= <expr><name>backupDbGrpIdxMin</name></expr></init></decl>;</init> <condition><expr><name>dbGrpIdx</name> <operator>&lt;</operator> <name>backupDbGrpIdxMax</name></expr>;</condition> <incr><expr><name>dbGrpIdx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DbGroup</name> <modifier>*</modifier></type><name>dbGroupInfo</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>dbGroupList</name></expr></argument>, <argument><expr><name>dbGrpIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Sort the results based on current or prior and only show the prior if it has archives or backups</comment>
        <if_stmt><if>if <condition>(<expr><name><name>dbGroupInfo</name><operator>-&gt;</operator><name>current</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>formatTextBackup</name><argument_list>(<argument><expr><name>dbGroupInfo</name></expr></argument>, <argument><expr><name>resultCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>displayCurrent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>dbGroupInfo</name><operator>-&gt;</operator><name>archiveMin</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>varLstEmpty</name><argument_list>(<argument><expr><name><name>dbGroupInfo</name><operator>-&gt;</operator><name>backupList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"\n    db (prior)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>formatTextBackup</name><argument_list>(<argument><expr><name>dbGroupInfo</name></expr></argument>, <argument><expr><name>resultStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// Add the current results to the end if necessary (e.g. current not displayed if a specified backup label is only in prior)</comment>
    <if_stmt><if>if <condition>(<expr><name>displayCurrent</name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><name>resultCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the backup and archive info files on the specified repo for the stanza
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>infoUpdateStanza</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storage</name></decl></parameter>, <parameter><decl><type><name>InfoStanzaRepo</name> <modifier>*</modifier></type><name>stanzaRepo</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>stanzaExists</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupLabel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO_STANZA_REPO</name></expr></argument>, <argument><expr><name>stanzaRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>stanzaExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>storage</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>stanzaRepo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>stanzaStatus</name> <init>= <expr><name>INFO_STANZA_STATUS_CODE_OK</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the stanza exists, attempt to get the info files</comment>
    <if_stmt><if>if <condition>(<expr><name>stanzaExists</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// Catch certain errors</comment>
            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// Attempt to load the backup info file</comment>
                <expr_stmt><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>backupInfo</name> <operator>=</operator> <call><name>infoBackupLoadFile</name><argument_list>(
                    <argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_PATH_BACKUP</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INFO_BACKUP_FILE</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>cipher</name></expr></argument>, <argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>cipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <macro><name>CATCH</name><argument_list>(<argument>FileMissingError</argument>)</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// If there is no backup.info then set the status to indicate missing</comment>
                <expr_stmt><expr><name>stanzaStatus</name> <operator>=</operator> <name>INFO_STANZA_STATUS_CODE_MISSING_STANZA_DATA</name></expr>;</expr_stmt>
            </block_content>}</block>
            <macro><name>CATCH</name><argument_list>(<argument>CryptoError</argument>)</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// If a reason for the error is due to a an encryption error, add a hint</comment>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>CryptoError</name></expr></argument>,
                    <argument><expr><literal type="string">"%s\n"</literal>
                    <literal type="string">"HINT: use option --stanza if encryption settings are different for the stanza than the global settings."</literal></expr></argument>,
                    <argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If backup.info was found, then get the archive.info file, which must exist if the backup.info exists, else the failed</comment>
            <comment type="line">// load will throw an error which will be trapped and recorded</comment>
            <if_stmt><if>if <condition>(<expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>backupInfo</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>archiveInfo</name> <operator>=</operator> <call><name>infoArchiveLoadFile</name><argument_list>(
                    <argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_PATH_ARCHIVE</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INFO_ARCHIVE_FILE</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>cipher</name></expr></argument>, <argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>cipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// If a specific backup exists on this repo then attempt to load the manifest</comment>
                <if_stmt><if>if <condition>(<expr><name>backupLabel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>manifest</name> <operator>=</operator> <call><name>manifestLoadFile</name><argument_list>(
                        <argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>BACKUP_MANIFEST_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>cipher</name></expr></argument>,
                        <argument><expr><call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// If a backup lock check has not already been performed, then do so</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stanzaRepo</name><operator>-&gt;</operator><name>backupLockChecked</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// If there is a valid backup lock for this stanza then backup/expire must be running</comment>
                    <expr_stmt><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>backupLockHeld</name></name> <operator>=</operator> <call><name>lockRead</name><argument_list>(
                        <argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptLockPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockTypeBackup</name></expr></argument>)</argument_list></call><operator>.</operator><name>status</name> <operator>==</operator> <name>lockReadStatusValid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>backupLockChecked</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>backupLockHeld</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>percentComplete</name></name> <operator>=</operator>
                            <call><name>lockRead</name><argument_list>(<argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptLockPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockTypeBackup</name></expr></argument>)</argument_list></call><operator>.</operator><name><name>data</name><operator>.</operator><name>percentComplete</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>stanzaStatus</name> <operator>=</operator> <name>stanzaStatus</name></expr>;</expr_stmt>
        </block_content>}</block>
        <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>infoStanzaErrorAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>errorType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>stanzaStatus</name> <operator>=</operator> <name>INFO_STANZA_STATUS_CODE_MISSING_STANZA_PATH</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="line">// If the backup.info and therefore archive.info exist, and the currentPg has not been set for the stanza, then set it</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>currentPgVersion</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>backupInfo</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>InfoPgData</name></type> <name>backupInfoCurrentPg</name> <init>= <expr><call><name>infoPgData</name><argument_list>(
            <argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>infoPgDataCurrentId</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>currentPgVersion</name></name> <operator>=</operator> <name><name>backupInfoCurrentPg</name><operator>.</operator><name>version</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>currentPgSystemId</name></name> <operator>=</operator> <name><name>backupInfoCurrentPg</name><operator>.</operator><name>systemId</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Render the information for the stanza based on the command parameters
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>infoRender</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get stanza if specified</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>stanza</name> <init>= <expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptStanza</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Initialize the list of stanzas on all repos</comment>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stanzaRepoList</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>InfoStanzaRepo</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>sortOrder</name> <operator>=</operator> <name>sortOrderAsc</name></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get the backup label if specified</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupLabel</name> <init>= <expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptSet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>backupFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Initialize the repo index</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdxMin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoTotal</name> <init>= <expr><call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdxMax</name> <init>= <expr><name>repoTotal</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// If the repo was specified then set index to the array location and max to loop only once</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptRepo</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>repoIdxMin</name> <operator>=</operator> <call><name>cfgOptionGroupIdxDefault</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>repoIdxMax</name> <operator>=</operator> <name>repoIdxMin</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Initialize error reporting at the repo level</comment>
        <decl_stmt><decl><type><name>InfoRepoData</name> <modifier>*</modifier></type><name>repoErrorList</name> <init>= <expr><call><name>memNew</name><argument_list>(<argument><expr><name>repoTotal</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>InfoRepoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>repoError</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name> <init>= <expr><name>repoIdxMin</name></expr></init></decl>;</init> <condition><expr><name>repoIdx</name> <operator>&lt;=</operator> <name>repoIdxMax</name></expr>;</condition> <incr><expr><name>repoIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// Initialize the error list on this repo</comment>
            <expr_stmt><expr><name><name>repoErrorList</name><index>[<expr><name>repoIdx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>InfoRepoData</name><operator>)</operator>
            <block>{
                <expr><operator>.</operator><name>key</name> <operator>=</operator> <call><name>cfgOptionGroupIdxToKey</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>cipher</name> <operator>=</operator> <call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>cipherPass</name> <operator>=</operator> <call><name>cfgOptionIdxStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>error</name> <operator>=</operator> <name>NULL</name></expr>,
            }</block></expr>;</expr_stmt>

            <comment type="line">// Initialize backup label indicator</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupExistsOnRepo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Catch any repo errors</comment>
            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// Get the repo storage in case it is remote and encryption settings need to be pulled down</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storageRepo</name> <init>= <expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// If a backup set was specified, see if the manifest exists</comment>
                <if_stmt><if>if <condition>(<expr><name>backupLabel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// If the backup exists on this repo, set the global indicator that we found it on at least one repo and</comment>
                    <comment type="line">// set the exists label for later loading of the manifest</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>storageExistsP</name><argument_list>(<argument><expr><name>storageRepo</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>BACKUP_MANIFEST_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>backupFound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>backupExistsOnRepo</name> <operator>=</operator> <name>backupLabel</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Get a list of stanzas in the backup directory</comment>
                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>stanzaNameList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(<argument><expr><call><name>storageListP</name><argument_list>(<argument><expr><name>storageRepo</name></expr></argument>, <argument><expr><name>STORAGE_PATH_BACKUP_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// All stanzas will be "found" if they are in the storage list</comment>
                <decl_stmt><decl><type><name>bool</name></type> <name>stanzaExists</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>stanza</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// If a specific stanza was requested and it is not on this repo, then stanzaExists flag will be reset to false</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>stanzaNameList</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>stanzaNameList</name></expr></argument>, <argument><expr><name>stanza</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>stanzaExists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Narrow the list to only the requested stanza</comment>
                    <expr_stmt><expr><call><name>strLstFree</name><argument_list>(<argument><expr><name>stanzaNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>stanzaNameList</name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>stanzaNameList</name></expr></argument>, <argument><expr><name>stanza</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Process each stanza</comment>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>stanzaIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>stanzaIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>stanzaNameList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>stanzaIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>stanzaName</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>stanzaNameList</name></expr></argument>, <argument><expr><name>stanzaIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Get the stanza if it is already in the list</comment>
                    <decl_stmt><decl><type><name>InfoStanzaRepo</name> <modifier>*</modifier></type><name>stanzaRepo</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stanzaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// If the stanza was already added to the array, then update this repo for the stanza, else the stanza has not</comment>
                    <comment type="line">// yet been added to the list, so add it</comment>
                    <if_stmt><if>if <condition>(<expr><name>stanzaRepo</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>infoUpdateStanza</name><argument_list>(<argument><expr><name>storageRepo</name></expr></argument>, <argument><expr><name>stanzaRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>, <argument><expr><name>stanzaExists</name></expr></argument>, <argument><expr><name>backupExistsOnRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>InfoStanzaRepo</name></type> <name>stanzaRepo</name> <init>=
                        <expr><block>{
                            <expr><operator>.</operator><name>name</name> <operator>=</operator> <name>stanzaName</name></expr>,
                            <expr><operator>.</operator><name>currentPgVersion</name> <operator>=</operator> <literal type="number">0</literal></expr>,
                            <expr><operator>.</operator><name>currentPgSystemId</name> <operator>=</operator> <literal type="number">0</literal></expr>,
                            <expr><operator>.</operator><name>repoList</name> <operator>=</operator> <call><name>memNew</name><argument_list>(<argument><expr><name>repoTotal</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>InfoRepoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>,
                        }</block></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Initialize all the repos</comment>
                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoListIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>repoListIdx</name> <operator>&lt;</operator> <name>repoTotal</name></expr>;</condition> <incr><expr><name>repoListIdx</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>stanzaRepo</name><operator>.</operator><name>repoList</name><index>[<expr><name>repoListIdx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>InfoRepoData</name><operator>)</operator>
                            <block>{
                                <expr><operator>.</operator><name>key</name> <operator>=</operator> <call><name>cfgOptionGroupIdxToKey</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoListIdx</name></expr></argument>)</argument_list></call></expr>,
                                <expr><operator>.</operator><name>cipher</name> <operator>=</operator> <call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>repoListIdx</name></expr></argument>)</argument_list></call></expr>,
                                <expr><operator>.</operator><name>cipherPass</name> <operator>=</operator> <call><name>cfgOptionIdxStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>, <argument><expr><name>repoListIdx</name></expr></argument>)</argument_list></call></expr>,
                                <expr><operator>.</operator><name>error</name> <operator>=</operator> <name>NULL</name></expr>,
                            }</block></expr>;</expr_stmt>
                        </block_content>}</block></for>

                        <comment type="line">// Update the info for this repo</comment>
                        <expr_stmt><expr><call><name>infoUpdateStanza</name><argument_list>(<argument><expr><name>storageRepo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stanzaRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>, <argument><expr><name>stanzaExists</name></expr></argument>, <argument><expr><name>backupExistsOnRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stanzaRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block>
            <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// At this point, stanza-level errors were caught and stored in the stanza structure, any errors caught here are due</comment>
                <comment type="line">// to higher level problems (e.g. repo inaccessible, invalid permissions on the repo, etc) and will be reported</comment>
                <comment type="line">// later if there are valid stanzas. If there are no valid stanzas after the loop exits, then these errors will be</comment>
                <comment type="line">// reported with a stanza named "[invalid]".</comment>
                <expr_stmt><expr><call><name>infoStanzaErrorAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>repoErrorList</name><index>[<expr><name>repoIdx</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>errorType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>repoError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>infoList</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>resultStr</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Record any repository-level errors with each stanza -- if there are no stanzas and one was not requested, then create an</comment>
        <comment type="line">// "[invalid]" one for reporting</comment>
        <if_stmt><if>if <condition>(<expr><name>repoError</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>lstEmpty</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>InfoStanzaRepo</name></type> <name>stanzaRepo</name> <init>=
                <expr><block>{
                    <expr><operator>.</operator><name>name</name> <operator>=</operator> <name>stanza</name> <operator>!=</operator> <name>NULL</name> <operator>?</operator> <name>stanza</name> <operator>:</operator> <name>INFO_STANZA_INVALID_STR</name></expr>,
                    <expr><operator>.</operator><name>currentPgVersion</name> <operator>=</operator> <literal type="number">0</literal></expr>,
                    <expr><operator>.</operator><name>currentPgSystemId</name> <operator>=</operator> <literal type="number">0</literal></expr>,
                    <expr><operator>.</operator><name>repoList</name> <operator>=</operator> <name>repoErrorList</name></expr>,
                }</block></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stanzaRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// For each stanza report the repos that were in error</comment>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>InfoStanzaRepo</name> <modifier>*</modifier></type><name>stanzaData</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name> <init>= <expr><name>repoIdxMin</name></expr></init></decl>;</init> <condition><expr><name>repoIdx</name> <operator>&lt;=</operator> <name>repoIdxMax</name></expr>;</condition> <incr><expr><name>repoIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>repoErrorList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>error</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>stanzaData</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name> <operator>=</operator> <name><name>repoErrorList</name><index>[<expr><name>repoIdx</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></for>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If a backup label was requested but it was not found on any repo, report the error here rather than individually to avoid</comment>
        <comment type="line">// listing each repo as "requested backup not found"</comment>
        <if_stmt><if>if <condition>(<expr><name>backupLabel</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>backupFound</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Get the stanza record and update each repo to indicate backup not found where there is not already an error status</comment>
            <comment type="line">// so that errors on other repositories will be displayed and not overwritten</comment>
            <decl_stmt><decl><type><name>InfoStanzaRepo</name> <modifier>*</modifier></type><name>stanzaRepo</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stanza</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name> <init>= <expr><name>repoIdxMin</name></expr></init></decl>;</init> <condition><expr><name>repoIdx</name> <operator>&lt;=</operator> <name>repoIdxMax</name></expr>;</condition> <incr><expr><name>repoIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>stanzaStatus</name> <operator>==</operator> <name>INFO_STANZA_STATUS_CODE_OK</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>stanzaStatus</name> <operator>=</operator> <name>INFO_STANZA_STATUS_CODE_BACKUP_MISSING</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>infoBackupFree</name><argument_list>(<argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>backupInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>repoList</name><index>[<expr><name>repoIdx</name></expr>]</index></name><operator>.</operator><name>backupInfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If the backup storage exists, then search for and process any stanzas</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>infoList</name> <operator>=</operator> <call><name>stanzaInfoList</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>, <argument><expr><name>repoIdxMin</name></expr></argument>, <argument><expr><name>repoIdxMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Format text output</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptOutput</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_OUTPUT_TEXT</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Process any stanza directories</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>varLstEmpty</name><argument_list>(<argument><expr><name>infoList</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>stanzaIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>stanzaIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>infoList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>stanzaIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>stanzaInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>infoList</name></expr></argument>, <argument><expr><name>stanzaIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>stanzaName</name> <init>= <expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>, <argument><expr><name>KEY_NAME_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Add a carriage return between stanzas</comment>
                    <if_stmt><if>if <condition>(<expr><name>stanzaIdx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Stanza name and status</comment>
                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"stanza: %s\n    status: "</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>stanzaName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// If an error has occurred, provide the information that is available and move onto next stanza</comment>
                    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>stanzaStatus</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>, <argument><expr><name>STANZA_KEY_STATUS_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>statusCode</name> <init>= <expr><call><name>varInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>stanzaStatus</name></expr></argument>, <argument><expr><name>STATUS_KEY_CODE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Get the lock info</comment>
                    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>lockKv</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>stanzaStatus</name></expr></argument>, <argument><expr><name>STATUS_KEY_LOCK_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>backupLockKv</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>lockKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_LOCK_BACKUP_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type> <name>backupLockHeld</name> <init>= <expr><call><name>varBool</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupLockKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_LOCK_BACKUP_HELD_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier><specifier>const</specifier></type> <name>percentComplete</name> <init>= <expr><call><name>kvGet</name><argument_list>(<argument><expr><name>backupLockKv</name></expr></argument>, <argument><expr><name>STATUS_KEY_LOCK_BACKUP_PERCENT_COMPLETE_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>percentCompleteStr</name> <init>= <expr><ternary><condition><expr><name>percentComplete</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then>
                        <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">" - %u.%02u%% complete"</literal></expr></argument>, <argument><expr><call><name>varUInt</name><argument_list>(<argument><expr><name>percentComplete</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">100</literal></expr></argument>, <argument><expr><call><name>varUInt</name><argument_list>(<argument><expr><name>percentComplete</name></expr></argument>)</argument_list></call> <operator>%</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr> </then><else>:
                        <expr><name>EMPTY_STR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>statusCode</name> <operator>!=</operator> <name>INFO_STANZA_STATUS_CODE_OK</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Update the overall stanza status and change displayed status if backup lock is found</comment>
                        <if_stmt><if>if <condition>(<expr><name>statusCode</name> <operator>==</operator> <name>INFO_STANZA_STATUS_CODE_MIXED</name> <operator>||</operator> <name>statusCode</name> <operator>==</operator> <name>INFO_STANZA_STATUS_CODE_PG_MISMATCH</name> <operator>||</operator>
                            <name>statusCode</name> <operator>==</operator> <name>INFO_STANZA_STATUS_CODE_OTHER</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// Stanza status</comment>
                            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                                <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"%s%s\n"</literal></expr></argument>,
                                <argument><expr><ternary><condition><expr><name>statusCode</name> <operator>==</operator> <name>INFO_STANZA_STATUS_CODE_MIXED</name></expr> ?</condition><then>
                                    <expr><name>INFO_STANZA_MIXED</name></expr> </then><else>:
                                    <expr><call><name>zNewFmt</name><argument_list>(
                                        <argument><expr><name>INFO_STANZA_STATUS_ERROR</name> <literal type="string">" (%s)"</literal></expr></argument>,
                                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>stanzaStatus</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
                                <argument><expr><ternary><condition><expr><name>backupLockHeld</name> <operator>==</operator> <name>true</name></expr> ?</condition><then>
                                    <expr><call><name>zNewFmt</name><argument_list>(<argument><expr><literal type="string">" ("</literal> <name>INFO_STANZA_STATUS_MESSAGE_LOCK_BACKUP</name> <literal type="string">"%s)"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>percentCompleteStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// Output the status per repo</comment>
                            <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>repoSection</name> <init>= <expr><call><name>kvGetList</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>, <argument><expr><name>STANZA_KEY_REPO_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>bool</name></type> <name>multiRepo</name> <init>= <expr><call><name>varLstSize</name><argument_list>(<argument><expr><name>repoSection</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>formatSpacer</name> <init>= <expr><ternary><condition><expr><name>multiRepo</name></expr> ?</condition><then> <expr><literal type="string">"               "</literal></expr> </then><else>: <expr><literal type="string">"            "</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

                            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>repoIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>repoSection</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>repoIdx</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>repoInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>repoSection</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>repoStatus</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>repoInfo</name></expr></argument>, <argument><expr><name>STANZA_KEY_STATUS_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <comment type="line">// If more than one repo configured, then add the repo status per repo</comment>
                                <if_stmt><if>if <condition>(<expr><name>multiRepo</name></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"        repo%u: "</literal></expr></argument>, <argument><expr><call><name>varUInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>repoInfo</name></expr></argument>, <argument><expr><name>REPO_KEY_KEY_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                                <if_stmt><if>if <condition>(<expr><call><name>varInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>repoStatus</name></expr></argument>, <argument><expr><name>STATUS_KEY_CODE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>INFO_STANZA_STATUS_CODE_OK</name></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><name>INFO_STANZA_STATUS_OK</name> <literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                                <else>else
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><call><name>varInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>repoStatus</name></expr></argument>, <argument><expr><name>STATUS_KEY_CODE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>INFO_STANZA_STATUS_CODE_OTHER</name></expr>)</condition>
                                    <block>{<block_content>
                                        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>repoError</name> <init>= <expr><call><name>strLstNewSplit</name><argument_list>(
                                            <argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>repoStatus</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                                            <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s\n"</literal></expr></argument>,
                                            <argument><expr><ternary><condition><expr><name>multiRepo</name></expr> ?</condition><then> <expr><name>INFO_STANZA_STATUS_ERROR</name> <literal type="string">" ("</literal> <name>INFO_STANZA_STATUS_MESSAGE_OTHER</name> <literal type="string">")\n"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                                            <argument><expr><name>formatSpacer</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>repoError</name></expr></argument>, <argument><expr><call><name>zNewFmt</name><argument_list>(<argument><expr><literal type="string">"\n%s"</literal></expr></argument>, <argument><expr><name>formatSpacer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if>
                                    <else>else
                                    <block>{<block_content>

                                        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                                            <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><name>INFO_STANZA_STATUS_ERROR</name> <literal type="string">" (%s)\n"</literal></expr></argument>,
                                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>repoStatus</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></else></if_stmt>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                                <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"%s (%s%s\n"</literal></expr></argument>, <argument><expr><name>INFO_STANZA_STATUS_ERROR</name></expr></argument>,
                                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>stanzaStatus</name></expr></argument>, <argument><expr><name>STATUS_KEY_MESSAGE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><ternary><condition><expr><name>backupLockHeld</name> <operator>==</operator> <name>true</name></expr> ?</condition><then>
                                    <expr><call><name>zNewFmt</name><argument_list>(<argument><expr><literal type="string">", "</literal> <name>INFO_STANZA_STATUS_MESSAGE_LOCK_BACKUP</name> <literal type="string">"%s)"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>percentCompleteStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">")"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="line">// Change displayed status if backup lock is found</comment>
                        <if_stmt><if>if <condition>(<expr><name>backupLockHeld</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                                <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"%s (%s%s)\n"</literal></expr></argument>, <argument><expr><name>INFO_STANZA_STATUS_OK</name></expr></argument>, <argument><expr><name>INFO_STANZA_STATUS_MESSAGE_LOCK_BACKUP</name></expr></argument>,
                                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>percentCompleteStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>INFO_STANZA_STATUS_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></else></if_stmt>

                    <comment type="line">// Add cipher type if the stanza is found on at least one repo</comment>
                    <if_stmt><if>if <condition>(<expr><name>statusCode</name> <operator>!=</operator> <name>INFO_STANZA_STATUS_CODE_MISSING_STANZA_PATH</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"    cipher: %s\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>, <argument><expr><name>KEY_CIPHER_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// If the cipher is mixed across repos for this stanza then display the per-repo cipher type</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>, <argument><expr><name>KEY_CIPHER_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>INFO_STANZA_MIXED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>repoSection</name> <init>= <expr><call><name>kvGetList</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>, <argument><expr><name>STANZA_KEY_REPO_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>repoIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>repoSection</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>repoIdx</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>repoInfo</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>repoSection</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                                    <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"        repo%u: %s\n"</literal></expr></argument>, <argument><expr><call><name>varUInt</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>repoInfo</name></expr></argument>, <argument><expr><name>REPO_KEY_KEY_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>repoInfo</name></expr></argument>, <argument><expr><name>KEY_CIPHER_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Get the current database for this stanza</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>varLstEmpty</name><argument_list>(<argument><expr><call><name>kvGetList</name><argument_list>(<argument><expr><name>stanzaInfo</name></expr></argument>, <argument><expr><name>STANZA_KEY_DB_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>InfoStanzaRepo</name> <modifier>*</modifier></type><name>stanzaRepo</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>stanzaRepoList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stanzaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>formatTextDb</name><argument_list>(
                            <argument><expr><name>stanzaInfo</name></expr></argument>, <argument><expr><name>resultStr</name></expr></argument>, <argument><expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>currentPgVersion</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stanzaRepo</name><operator>-&gt;</operator><name>currentPgSystemId</name></name></expr></argument>,
                            <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>resultStr</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><literal type="string">"No stanzas exist in the repository.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <comment type="line">// Format json output</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptOutput</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_OUTPUT_JSON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>resultStr</name> <operator>=</operator> <call><name>jsonFromVar</name><argument_list>(<argument><expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><name>infoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>cmdInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ioFdWriteOneStr</name><argument_list>(<argument><expr><name>STDOUT_FILENO</name></expr></argument>, <argument><expr><call><name>infoRender</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
