<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/command/archive/get/get.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Archive Get Command
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/archive/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/archive/get/file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/archive/get/protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/command.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/memContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/regExp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/wait.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/exec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/load.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoArchive.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/write.intern.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Constants for log messages that are used multiple times to keep them consistent
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOUND_IN_ARCHIVE_MSG</name></cpp:macro>                                        <cpp:value>"found %s in the archive"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOUND_IN_REPO_ARCHIVE_MSG</name></cpp:macro>                                   <cpp:value>"found %s in the %s: %s archive"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNABLE_TO_FIND_IN_ARCHIVE_MSG</name></cpp:macro>                               <cpp:value>"unable to find %s in the archive"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNABLE_TO_FIND_VALID_REPO_MSG</name></cpp:macro>                               <cpp:value>"unable to find a valid repository"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPO_INVALID_OR_ERR_MSG</name></cpp:macro>                                     <cpp:value>"some repositories were invalid or encountered errors"</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Check for a list of archive files in the repository
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>ArchiveFileMap</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>request</name></decl>;</decl_stmt>                                          <comment type="line">// Archive file requested by archive_command</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>actualList</name></decl>;</decl_stmt>                                               <comment type="line">// Actual files in various repos/archiveIds</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>warnList</name></decl>;</decl_stmt>                                           <comment type="line">// Warnings that need to be reported by the async process</comment>
}</block></struct></type> <name>ArchiveFileMap</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ArchiveGetCheckResult</name>
<block>{
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>archiveFileMapList</name></decl>;</decl_stmt>                                       <comment type="line">// List of mapped archive files, i.e. found in the repo</comment>

    <comment type="line">// Global error that affects all repos</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ErrorType</name> <modifier>*</modifier></type><name>errorType</name></decl>;</decl_stmt>                                     <comment type="line">// Error type if there was an error</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>errorFile</name></decl>;</decl_stmt>                                        <comment type="line">// Error file if there was an error</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>errorMessage</name></decl>;</decl_stmt>                                     <comment type="line">// Error message if there was an error</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>warnList</name></decl>;</decl_stmt>                                     <comment type="line">// Warnings that need to be reported by the async process</comment>
}</block></struct></type> <name>ArchiveGetCheckResult</name>;</typedef>

<comment type="line">// Helper to add an error to an error list and warn if the error is not already in the list</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>archiveGetErrorAdd</name><parameter_list>(<parameter><decl><type><name>StringList</name> <modifier>*</modifier></type><name>warnList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>log</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ErrorType</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>warn</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s: [%s] %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>errorTypeName</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>warnList</name></expr></argument>, <argument><expr><name>warn</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>log</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>warn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>warnList</name></expr></argument>, <argument><expr><name>warn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Helper to find a single archive file in the repository using a cache to speed up the process and minimize storageListP() calls</comment>
<typedef>typedef <type><struct>struct <name>ArchiveGetFindCachePath</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>                                             <comment type="line">// Cached path in the archiveId</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>fileList</name></decl>;</decl_stmt>                                     <comment type="line">// List of files in the cache path</comment>
}</block></struct></type> <name>ArchiveGetFindCachePath</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ArchiveGetFindCacheArchive</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>archiveId</name></decl>;</decl_stmt>                                        <comment type="line">// ArchiveId in the repo</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pathList</name></decl>;</decl_stmt>                                                 <comment type="line">// List of paths cached for archiveId</comment>
}</block></struct></type> <name>ArchiveGetFindCacheArchive</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ArchiveGetFindCacheRepo</name>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CipherType</name></type> <name>cipherType</name></decl>;</decl_stmt>                                          <comment type="line">// Repo cipher type</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPassArchive</name></decl>;</decl_stmt>                                <comment type="line">// Repo archive cipher pass</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>archiveList</name></decl>;</decl_stmt>                                              <comment type="line">// Cached list of archiveIds and associated paths</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>warnList</name></decl>;</decl_stmt>                                           <comment type="line">// Track repo warnings so each is only reported once</comment>
}</block></struct></type> <name>ArchiveGetFindCacheRepo</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>archiveGetFind</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>archiveFileRequest</name></decl></parameter>, <parameter><decl><type><name>ArchiveGetCheckResult</name> <modifier>*</modifier></type><name>getCheckResult</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cacheRepoList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>warnList</name></decl></parameter>,
    <parameter><decl><type><name>bool</name></type> <name>single</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>archiveFileRequest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>getCheckResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>cacheRepoList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>warnList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>single</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>archiveFileRequest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>getCheckResult</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>cacheRepoList</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Is the archive file a WAL segment?</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>isSegment</name> <init>= <expr><call><name>walIsSegment</name><argument_list>(<argument><expr><name>archiveFileRequest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get the WAL segment path</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><ternary><condition><expr><name>isSegment</name></expr> ?</condition><then> <expr><call><name>strSubN</name><argument_list>(<argument><expr><name>archiveFileRequest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <comment type="line">// List to hold matches for the requested file</comment>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>matchList</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArchiveGetFile</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// List of file level warnings</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>fileWarnList</name> <init>= <expr><call><name>strLstDup</name><argument_list>(<argument><expr><name>warnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Errored repo total to track if all repos errored</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoErrorTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// Check each repo</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoCacheIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>repoCacheIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>cacheRepoList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>repoCacheIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ArchiveGetFindCacheRepo</name> <modifier>*</modifier></type><name>cacheRepo</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>cacheRepoList</name></expr></argument>, <argument><expr><name>repoCacheIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// Check each archiveId</comment>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>archiveCacheIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>archiveCacheIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>cacheRepo</name><operator>-&gt;</operator><name>archiveList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>archiveCacheIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ArchiveGetFindCacheArchive</name> <modifier>*</modifier></type><name>cacheArchive</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>cacheRepo</name><operator>-&gt;</operator><name>archiveList</name></name></expr></argument>, <argument><expr><name>archiveCacheIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// If a WAL segment then search among the possible file names</comment>
                    <if_stmt><if>if <condition>(<expr><name>isSegment</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>segmentList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                        <comment type="line">// If a single file is requested then optimize by adding a restrictive expression to reduce bandwidth</comment>
                        <if_stmt><if>if <condition>(<expr><name>single</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>segmentList</name> <operator>=</operator> <call><name>storageListP</name><argument_list>(
                                <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name><name>cacheRepo</name><operator>-&gt;</operator><name>repoIdx</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cacheArchive</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(
                                    <argument><expr><literal type="string">"^%s%s-[0-f]{40}"</literal> <name>COMPRESS_TYPE_REGEXP</name> <literal type="string">"{0,1}$"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>archiveFileRequest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><ternary><condition><expr><call><name>walIsPartial</name><argument_list>(<argument><expr><name>archiveFileRequest</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>WAL_SEGMENT_PARTIAL_EXT</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <comment type="line">// Else multiple files will be requested so cache list results</comment>
                        <else>else
                        <block>{<block_content>
                            <comment type="line">// Partial files cannot be in a list with multiple requests</comment>
                            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>walIsPartial</name><argument_list>(<argument><expr><name>archiveFileRequest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// If the path does not exist in the cache then fetch it</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>ArchiveGetFindCachePath</name> <modifier>*</modifier></type><name>cachePath</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name><name>cacheArchive</name><operator>-&gt;</operator><name>pathList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name>cachePath</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                            <block>{<block_content>
                                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(cacheArchive-&gt;pathList)</argument>)</argument_list></macro>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>cachePath</name> <operator>=</operator> <macro><name>lstAdd</name><argument_list>(
                                        <argument>cacheArchive-&gt;pathList</argument>,
                                        <argument>&amp;(ArchiveGetFindCachePath)
                                        {
                                            .path = strDup(path)</argument>,
                                            <argument>.fileList = storageListP(
                                                storageRepoIdx(cacheRepo-&gt;repoIdx),
                                                strNewFmt(STORAGE_REPO_ARCHIVE <literal type="string">"/%s/%s"</literal>, strZ(cacheArchive-&gt;archiveId), strZ(path)),
                                                .expression = strNewFmt(
                                                    <literal type="string">"^%s[0-F]{8}-[0-f]{40}"</literal> COMPRESS_TYPE_REGEXP <literal type="string">"{0,1}$"</literal>, strZ(path)))</argument>,
                                        <argument>}</argument>)</argument_list></macro></expr>;</expr_stmt>
                                </block_content>}</block>
                                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <comment type="line">// Get a list of all WAL segments that match</comment>
                            <expr_stmt><expr><name>segmentList</name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fileIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>cachePath</name><operator>-&gt;</operator><name>fileList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileIdx</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><call><name>strBeginsWith</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>cachePath</name><operator>-&gt;</operator><name>fileList</name></name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>archiveFileRequest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>segmentList</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>cachePath</name><operator>-&gt;</operator><name>fileList</name></name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            </block_content>}</block></for>
                        </block_content>}</block></else></if_stmt>

                        <comment type="line">// Add segments to match list</comment>
                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>segmentIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>segmentIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>segmentList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>segmentIdx</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(getCheckResult-&gt;archiveFileMapList)</argument>)</argument_list></macro>
                            <block>{<block_content>
                                <macro><name>lstAdd</name><argument_list>(
                                    <argument>matchList</argument>,
                                    <argument>&amp;(ArchiveGetFile)
                                    {
                                        .file = strNewFmt(
                                            <literal type="string">"%s/%s/%s"</literal>, strZ(cacheArchive-&gt;archiveId), strZ(path),
                                            strZ(strLstGet(segmentList, segmentIdx)))</argument>,
                                        <argument>.repoIdx = cacheRepo-&gt;repoIdx</argument>,
                                        <argument>.archiveId = cacheArchive-&gt;archiveId</argument>,
                                        <argument>.cipherType = cacheRepo-&gt;cipherType</argument>,
                                        <argument>.cipherPassArchive = cacheRepo-&gt;cipherPassArchive</argument>,
                                    <argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                            </block_content>}</block>
                            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></if>
                    <comment type="line">// Else if not a WAL segment, see if it exists in the archiveId path</comment>
                    <if type="elseif">else if <condition>(<expr><call><name>storageExistsP</name><argument_list>(
                        <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name><name>cacheRepo</name><operator>-&gt;</operator><name>repoIdx</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cacheArchive</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveFileRequest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(getCheckResult-&gt;archiveFileMapList)</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <macro><name>lstAdd</name><argument_list>(
                                <argument>matchList</argument>,
                                <argument>&amp;(ArchiveGetFile)
                                {
                                    .file = strNewFmt(<literal type="string">"%s/%s"</literal>, strZ(cacheArchive-&gt;archiveId), strZ(archiveFileRequest))</argument>,
                                    <argument>.repoIdx = cacheRepo-&gt;repoIdx</argument>,
                                    <argument>.archiveId = cacheArchive-&gt;archiveId</argument>,
                                    <argument>.cipherType = cacheRepo-&gt;cipherType</argument>,
                                    <argument>.cipherPassArchive = cacheRepo-&gt;cipherPassArchive</argument>,
                                <argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                        </block_content>}</block>
                        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block>
            <comment type="line">// Log errors as warnings and continue</comment>
            <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>repoErrorTotal</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>archiveGetErrorAdd</name><argument_list>(<argument><expr><name><name>cacheRepo</name><operator>-&gt;</operator><name>warnList</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>cacheRepo</name><operator>-&gt;</operator><name>repoIdx</name></name></expr></argument>, <argument><expr><call><name>errorType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>archiveGetErrorAdd</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>cacheRepo</name><operator>-&gt;</operator><name>repoIdx</name></name></expr></argument>, <argument><expr><call><name>errorType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// If all repos errored out then set the global error since processing cannot continue past this segment</comment>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>repoErrorTotal</name> <operator>&lt;=</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>cacheRepoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>repoErrorTotal</name> <operator>==</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>cacheRepoList</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(getCheckResult-&gt;archiveFileMapList)</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>getCheckResult</name><operator>-&gt;</operator><name>errorType</name></name> <operator>=</operator> <operator>&amp;</operator><name>RepoInvalidError</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>getCheckResult</name><operator>-&gt;</operator><name>errorFile</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>archiveFileRequest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>getCheckResult</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><name>UNABLE_TO_FIND_VALID_REPO_MSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>getCheckResult</name><operator>-&gt;</operator><name>warnList</name></name> <operator>=</operator> <call><name>strLstMove</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>, <argument><expr><call><name>memContextCurrent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></if>
        <comment type="line">// Else if a file was found</comment>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name>matchList</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// If a segment match list is &gt; 1 then check for duplicates</comment>
            <if_stmt><if>if <condition>(<expr><name>isSegment</name> <operator>&amp;&amp;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>matchList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Count the number of unique hashes</comment>
                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>hashList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>matchIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>matchIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>matchList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>matchIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strLstAddIfMissing</name><argument_list>(<argument><expr><name>hashList</name></expr></argument>, <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ArchiveGetFile</name> <operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><name>matchList</name></expr></argument>, <argument><expr><name>matchIdx</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>file</name></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <comment type="line">// If there is more than one unique hash then there are duplicates</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>hashList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Build list of duplicates</comment>
                    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoKeyLast</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>message</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Sort the matches so they are logged in a consistent order</comment>
                    <expr_stmt><expr><call><name>lstSort</name><argument_list>(<argument><expr><name>matchList</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>matchIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>matchIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>matchList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>matchIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>ArchiveGetFile</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>matchList</name></expr></argument>, <argument><expr><name>matchIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repoKey</name> <init>= <expr><call><name>cfgOptionGroupIdxToKey</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>repoIdx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>repoKey</name> <operator>!=</operator> <name>repoKeyLast</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="string">"\n%s:"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>repoIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>repoKeyLast</name> <operator>=</operator> <name>repoKey</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>

                    <comment type="line">// Set as global error since processing cannot continue past this segment</comment>
                    <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(getCheckResult-&gt;archiveFileMapList)</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>getCheckResult</name><operator>-&gt;</operator><name>errorType</name></name> <operator>=</operator> <operator>&amp;</operator><name>ArchiveDuplicateError</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>getCheckResult</name><operator>-&gt;</operator><name>errorFile</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>archiveFileRequest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>getCheckResult</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(
                            <argument><expr><literal type="string">"duplicates found for WAL segment %s:%s\n"</literal>
                                <literal type="string">"HINT: are multiple primaries archiving to this stanza?"</literal></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveFileRequest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>getCheckResult</name><operator>-&gt;</operator><name>warnList</name></name> <operator>=</operator> <call><name>strLstMove</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>, <argument><expr><call><name>memContextCurrent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>
                    <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Files are valid so add them to the map</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>error</name></expr>)</condition>
            <block>{<block_content>
                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(getCheckResult-&gt;archiveFileMapList)</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ArchiveFileMap</name></type> <name>map</name> <init>=
                    <expr><block>{
                        <expr><operator>.</operator><name>request</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>archiveFileRequest</name></expr></argument>)</argument_list></call></expr>,
                        <expr><operator>.</operator><name>actualList</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArchiveGetFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>,
                        <expr><operator>.</operator><name>warnList</name> <operator>=</operator> <call><name>strLstMove</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>, <argument><expr><call><name>memContextCurrent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
                    }</block></expr></init></decl>;</decl_stmt>

                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>matchIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>matchIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>matchList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>matchIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name><name>map</name><operator>.</operator><name>actualList</name></name></expr></argument>, <argument><expr><call><name>lstGet</name><argument_list>(<argument><expr><name>matchList</name></expr></argument>, <argument><expr><name>matchIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                    <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name><name>getCheckResult</name><operator>-&gt;</operator><name>archiveFileMapList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ArchiveGetCheckResult</name></type>
<name>archiveGetCheck</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>archiveRequestList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>archiveRequestList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>archiveRequestList</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>archiveRequestList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ArchiveGetCheckResult</name></type> <name>result</name> <init>= <expr><block>{<expr><operator>.</operator><name>archiveFileMapList</name> <operator>=</operator> <macro><name>lstNewP</name><argument_list>(<argument>sizeof(ArchiveFileMap)</argument>, <argument>.comparator = lstComparatorStr</argument>)</argument_list></macro></expr>}</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// List of warnings</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>warnList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get pg control info</comment>
        <decl_stmt><decl><type><name>PgControl</name></type> <name>controlInfo</name> <init>= <expr><call><name>pgControlFromFile</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Build list of repos/archiveIds where WAL may be found</comment>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cacheRepoList</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArchiveGetFindCacheRepo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>repoIdx</name> <operator>&lt;</operator> <call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>repoIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// If a repo was specified then skip all other repos</comment>
            <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptRepo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptRepo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>cfgOptionGroupIdxToKey</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// Get the repo storage in case it is remote and encryption settings need to be pulled down</comment>
                <expr_stmt><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>ArchiveGetFindCacheRepo</name></type> <name>cacheRepo</name> <init>=
                <expr><block>{
                    <expr><operator>.</operator><name>repoIdx</name> <operator>=</operator> <name>repoIdx</name></expr>,
                    <expr><operator>.</operator><name>cipherType</name> <operator>=</operator> <call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>,
                    <expr><operator>.</operator><name>archiveList</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArchiveGetFindCacheArchive</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>,
                    <expr><operator>.</operator><name>warnList</name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>,
                }</block></expr></init></decl>;</decl_stmt>

                <comment type="line">// Attempt to load the archive info file</comment>
                <decl_stmt><decl><type><name>InfoArchive</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>infoArchiveLoadFile</name><argument_list>(
                    <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INFO_ARCHIVE_PATH_FILE_STR</name></expr></argument>, <argument><expr><name><name>cacheRepo</name><operator>.</operator><name>cipherType</name></name></expr></argument>,
                    <argument><expr><call><name>cfgOptionIdxStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Copy cipher pass into the result list context once rather than making a copy per candidate file later</comment>
                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(result.archiveFileMapList)</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>cacheRepo</name><operator>.</operator><name>cipherPassArchive</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><call><name>infoArchiveCipherPass</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Loop through pg history and determine which archiveIds to use</comment>
                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>archivePathList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>pgIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pgIdx</name> <operator>&lt;</operator> <call><name>infoPgDataTotal</name><argument_list>(<argument><expr><call><name>infoArchivePg</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pgIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>InfoPgData</name></type> <name>pgData</name> <init>= <expr><call><name>infoPgData</name><argument_list>(<argument><expr><call><name>infoArchivePg</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Only use the archive id if it matches the current cluster</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>pgData</name><operator>.</operator><name>systemId</name></name> <operator>==</operator> <name><name>controlInfo</name><operator>.</operator><name>systemId</name></name> <operator>&amp;&amp;</operator> <name><name>pgData</name><operator>.</operator><name>version</name></name> <operator>==</operator> <name><name>controlInfo</name><operator>.</operator><name>version</name></name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>archiveId</name> <init>= <expr><call><name>infoPgArchiveId</name><argument_list>(<argument><expr><call><name>infoArchivePg</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

                        <comment type="line">// If the archiveId is in the past make sure the path exists</comment>
                        <if_stmt><if>if <condition>(<expr><name>pgIdx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// Get list of archiveId paths in the archive path</comment>
                            <if_stmt><if>if <condition>(<expr><name>archivePathList</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>archivePathList</name> <operator>=</operator> <call><name>storageListP</name><argument_list>(<argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STORAGE_REPO_ARCHIVE_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>archivePathList</name></expr></argument>, <argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// If the archiveId is most recent or has files then add it</comment>
                        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>ArchiveGetFindCacheArchive</name></type> <name>cacheArchive</name> <init>=
                            <expr><block>{
                                <expr><operator>.</operator><name>pathList</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArchiveGetFindCachePath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr>,
                            }</block></expr></init></decl>;</decl_stmt>

                            <comment type="line">// Copy archiveId into the result list context once rather than making a copy per candidate file later</comment>
                            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(result.archiveFileMapList)</argument>)</argument_list></macro>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>cacheArchive</name><operator>.</operator><name>archiveId</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block>
                            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name><name>cacheRepo</name><operator>.</operator><name>archiveList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cacheArchive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="line">// Error if no archive id was found -- this indicates a mismatch with the current cluster</comment>
                <if_stmt><if>if <condition>(<expr><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>cacheRepo</name><operator>.</operator><name>archiveList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>archiveGetErrorAdd</name><argument_list>(
                        <argument><expr><name>warnList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ArchiveMismatchError</name></expr></argument>,
                        <argument><expr><call><name>strNewFmt</name><argument_list>(
                            <argument><expr><literal type="string">"unable to retrieve the archive id for database version '%s' and system-id '%"</literal> <name>PRIu64</name> <literal type="string">"'"</literal></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name><name>controlInfo</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>controlInfo</name><operator>.</operator><name>systemId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else add repo to list</comment>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name>cacheRepoList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cacheRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <comment type="line">// Log errors as warnings and continue</comment>
            <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><call><name>archiveGetErrorAdd</name><argument_list>(<argument><expr><name>warnList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>, <argument><expr><call><name>errorType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Error if there are no repos to check</comment>
        <if_stmt><if>if <condition>(<expr><call><name>lstEmpty</name><argument_list>(<argument><expr><name>cacheRepoList</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>warnList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Set as global error since processing cannot continue past this segment</comment>
            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(result.archiveFileMapList)</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>errorType</name></name> <operator>=</operator> <operator>&amp;</operator><name>RepoInvalidError</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>errorMessage</name></name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><name>UNABLE_TO_FIND_VALID_REPO_MSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>warnList</name></name> <operator>=</operator> <call><name>strLstMove</name><argument_list>(<argument><expr><name>warnList</name></expr></argument>, <argument><expr><call><name>memContextCurrent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// Any remaining errors will be reported as warnings since at least one repo is valid</comment>
            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(result.archiveFileMapList)</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>warnList</name></name> <operator>=</operator> <call><name>strLstMove</name><argument_list>(<argument><expr><name>warnList</name></expr></argument>, <argument><expr><call><name>memContextCurrent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Find files in the list</comment>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>archiveRequestIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>archiveRequestIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>archiveRequestList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>archiveRequestIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>archiveGetFind</name><argument_list>(
                        <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>archiveRequestList</name></expr></argument>, <argument><expr><name>archiveRequestIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>cacheRepoList</name></expr></argument>, <argument><expr><name>warnList</name></expr></argument>,
                        <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>archiveRequestList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="line">// Sort the list to make searching for files faster</comment>
            <expr_stmt><expr><call><name>lstSort</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>archiveFileMapList</name></name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_STRUCT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Clean the queue and prepare a list of WAL segments that the async process should get
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>StringList</name> <modifier>*</modifier></type>
<name>queueNeed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>found</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>queueSize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>walSegmentSize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>queueSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>walSegmentSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walSegment</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Determine the first WAL segment for the async process to get.  If the WAL segment requested by</comment>
        <comment type="line">// PostgreSQL was not found then use that.  If the segment was found but the queue is not full then</comment>
        <comment type="line">// start with the next segment.</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegmentFirst</name> <init>=
            <expr><ternary><condition><expr><name>found</name></expr> ?</condition><then> <expr><call><name>walSegmentNext</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>, <argument><expr><name>walSegmentSize</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>walSegment</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <comment type="line">// Determine how many WAL segments should be in the queue.  The queue total must be at least 2 or it doesn't make sense to</comment>
        <comment type="line">// have async turned on at all.</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>walSegmentQueueTotal</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>queueSize</name> <operator>/</operator> <name>walSegmentSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>walSegmentQueueTotal</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>walSegmentQueueTotal</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Build the ideal queue -- the WAL segments we want in the queue after the async process has run</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>idealQueue</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
            <argument><expr><call><name>walSegmentRange</name><argument_list>(<argument><expr><name>walSegmentFirst</name></expr></argument>, <argument><expr><name>walSegmentSize</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>, <argument><expr><name>walSegmentQueueTotal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get the list of files actually in the queue</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>actualQueue</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
            <argument><expr><call><name>storageListP</name><argument_list>(<argument><expr><call><name>storageSpool</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>STORAGE_SPOOL_ARCHIVE_IN_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Build a list of WAL segments that are being kept so we can later make a list of what is needed</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>keepQueue</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>actualQueueIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>actualQueueIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>actualQueue</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>actualQueueIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// Get file from actual queue</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>actualQueue</name></expr></argument>, <argument><expr><name>actualQueueIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Does this match a file we want to preserve?</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strLstExists</name><argument_list>(<argument><expr><name>idealQueue</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>keepQueue</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else delete if it does not match an ok file for a WAL segment that has already been preserved. If an ok file exists</comment>
            <comment type="line">// in addition to the segment then it contains warnings which need to be preserved.</comment>
            <if type="elseif">else if <condition>(
                <expr><operator>!</operator><call><name>strEndsWithZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>STATUS_EXT_OK</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>actualQueue</name></expr></argument>, <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>STATUS_EXT_OK_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_IN</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Generate a list of the WAL that are needed by removing kept WAL from the ideal queue</comment>
        <expr_stmt><expr><call><name>strLstSort</name><argument_list>(<argument><expr><name>keepQueue</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>idealQueueIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idealQueueIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>idealQueue</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>idealQueueIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>keepQueue</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>idealQueue</name></expr></argument>, <argument><expr><name>idealQueueIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>idealQueue</name></expr></argument>, <argument><expr><name>idealQueueIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>int</name></type>
<name>cmdArchiveGet</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// PostgreSQL must be local</comment>
    <expr_stmt><expr><call><name>pgIsLocalVerify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Set the result assuming the archive file will not be found</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Check the parameters</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>commandParam</name> <init>= <expr><call><name>cfgCommandParam</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>commandParam</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>commandParam</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>ParamRequiredError</name></expr></argument>, <argument><expr><literal type="string">"WAL segment to get required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>commandParam</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>ParamRequiredError</name></expr></argument>, <argument><expr><literal type="string">"path to copy WAL segment required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>ParamInvalidError</name></expr></argument>, <argument><expr><literal type="string">"extra parameters found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Get the segment name</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>walSegment</name> <init>= <expr><call><name>strBase</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>commandParam</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Destination is wherever we were told to move the WAL segment</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walDestination</name> <init>=
            <expr><call><name>walPath</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>commandParam</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptPgPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>cfgCommandName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Async get can only be performed on WAL segments, history or other files must use synchronous mode</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveAsync</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>walIsSegment</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>                                          <comment type="line">// Is this the first time the loop has run?</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>                                         <comment type="line">// Has the WAL segment been found yet?</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>foundOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>                                       <comment type="line">// Was an OK file found which confirms the file was missing?</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>queueFull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>                                     <comment type="line">// Is the queue half or more full?</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>forked</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>                                        <comment type="line">// Has the async process been forked yet?</comment>

            <comment type="line">// Loop and wait for the WAL segment to be pushed</comment>
            <decl_stmt><decl><type><name>Wait</name> <modifier>*</modifier></type><name>wait</name> <init>= <expr><call><name>waitNew</name><argument_list>(<argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptArchiveTimeout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <do>do
            <block>{<block_content>
                <comment type="line">// Check if the WAL segment is already in the queue</comment>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storageSpool</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_IN</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Determine whether a missing WAL segment will be retried. Retrying is safer, but not retrying lets PostgreSQL</comment>
                <comment type="line">// know that there are probably no more WAL segments in the archive which means it can switch to streaming.</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>missingRetry</name> <init>= <expr><name>first</name> <operator>&amp;&amp;</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveMissingRetry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Check for errors or missing files. For archive-get ok indicates that the process succeeded but there is no WAL</comment>
                <comment type="line">// file to download, or that there was a warning. Do not error on the first run so the async process can be spawned</comment>
                <comment type="line">// to correct any errors from a previous run. Do not warn on the first run if the segment was not found so the async</comment>
                <comment type="line">// process can be spawned to check for the file again.</comment>
                <if_stmt><if>if <condition>(<expr><call><name>archiveAsyncStatus</name><argument_list>(<argument><expr><name>archiveModeGet</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>, <argument><expr><operator>!</operator><name>first</name></expr></argument>, <argument><expr><name>found</name> <operator>||</operator> <operator>!</operator><name>missingRetry</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(
                        <argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_IN</name> <literal type="string">"/%s"</literal> <name>STATUS_EXT_OK</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Break if an ok file was found but no segment exists, which means the segment was missing. However, don't</comment>
                    <comment type="line">// break if this is the first time through the loop since this means the ok file was written by an async process</comment>
                    <comment type="line">// spawned by a prior archive-get execution, which means we should spawn the async process again to see if the</comment>
                    <comment type="line">// file exists now. This also prevents spool files from a previous recovery interfering with the current</comment>
                    <comment type="line">// recovery.</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>missingRetry</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>foundOk</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// If found then move the WAL segment to the destination directory</comment>
                <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Source is the WAL segment in the spool queue</comment>
                    <decl_stmt><decl><type><name>StorageRead</name> <modifier>*</modifier></type><name>source</name> <init>= <expr><call><name>storageNewReadP</name><argument_list>(
                        <argument><expr><call><name>storageSpool</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_IN</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// A move will be attempted but if the spool queue and the WAL path are on different file systems then a copy</comment>
                    <comment type="line">// will be performed instead.</comment>
                    <comment type="line">//</comment>
                    <comment type="line">// It looks scary that we are disabling syncs and atomicity (in case we need to copy instead of move) but this</comment>
                    <comment type="line">// is safe because if the system crashes Postgres will not try to reuse a restored WAL segment but will instead</comment>
                    <comment type="line">// request it again using the restore_command. In the case of a move this hardly matters since path syncs are</comment>
                    <comment type="line">// cheap but if a copy is required we could save a lot of writes.</comment>
                    <decl_stmt><decl><type><name>StorageWrite</name> <modifier>*</modifier></type><name>destination</name> <init>= <expr><call><name>storageNewWriteP</name><argument_list>(
                        <argument><expr><call><name>storageLocalWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>walDestination</name></expr></argument>, <argument><expr><operator>.</operator><name>noCreatePath</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noSyncFile</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noSyncPath</name> <operator>=</operator> <name>true</name></expr></argument>,
                        <argument><expr><operator>.</operator><name>noAtomic</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Move (or copy if required) the file</comment>
                    <expr_stmt><expr><call><name>storageMoveP</name><argument_list>(<argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Return success</comment>
                    <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><name>FOUND_IN_ARCHIVE_MSG</name> <literal type="string">" asynchronously"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                    <comment type="line">// Get a list of WAL segments left in the queue</comment>
                    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>queue</name> <init>= <expr><call><name>storageListP</name><argument_list>(
                        <argument><expr><call><name>storageSpool</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>STORAGE_SPOOL_ARCHIVE_IN_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <name>WAL_SEGMENT_REGEXP_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Get size of the WAL segment</comment>
                        <decl_stmt><decl><type><name>uint64_t</name></type> <name>walSegmentSize</name> <init>= <expr><call><name>storageInfoP</name><argument_list>(<argument><expr><call><name>storageLocal</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>walDestination</name></expr></argument>)</argument_list></call><operator>.</operator><name>size</name></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Use WAL segment size to estimate queue size and determine if the async process should be launched</comment>
                        <expr_stmt><expr><name>queueFull</name> <operator>=</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>walSegmentSize</name> <operator>&gt;</operator> <call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptArchiveGetQueueMax</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// If the WAL segment has not already been found then start the async process to get it.  There's no point in</comment>
                <comment type="line">// forking the async process off more than once so track that as well.  Use an archive lock to prevent forking if</comment>
                <comment type="line">// the async process was launched by another process.</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>forked</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>found</name> <operator>||</operator> <operator>!</operator><name>queueFull</name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <call><name>lockAcquire</name><argument_list>(
                        <argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptLockPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptStanza</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptExecId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgLockType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                        <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Get control info</comment>
                    <decl_stmt><decl><type><name>PgControl</name></type> <name>pgControl</name> <init>= <expr><call><name>pgControlFromFile</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Create the queue</comment>
                    <expr_stmt><expr><call><name>storagePathCreateP</name><argument_list>(<argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>STORAGE_SPOOL_ARCHIVE_IN_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// The async process should not output on the console at all</comment>
                    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>optionReplace</name> <init>= <expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_CONSOLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_STDERR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Generate command options</comment>
                    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>commandExec</name> <init>= <expr><call><name>cfgExecParam</name><argument_list>(<argument><expr><name>cfgCmdArchiveGet</name></expr></argument>, <argument><expr><name>cfgCmdRoleAsync</name></expr></argument>, <argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>strLstInsert</name><argument_list>(<argument><expr><name>commandExec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>cfgExe</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Clean the current queue using the list of WAL that we ideally want in the queue.  queueNeed()</comment>
                    <comment type="line">// will return the list of WAL needed to fill the queue and this will be passed to the async process.</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>queue</name> <init>= <expr><call><name>queueNeed</name><argument_list>(
                        <argument><expr><name>walSegment</name></expr></argument>, <argument><expr><name>found</name></expr></argument>, <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptArchiveGetQueueMax</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pgControl</name><operator>.</operator><name>walSegmentSize</name></name></expr></argument>,
                        <argument><expr><name><name>pgControl</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>queueIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>queueIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>queueIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>commandExec</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>queueIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                    <comment type="line">// Clear errors for the current wal segment</comment>
                    <expr_stmt><expr><call><name>archiveAsyncErrorClear</name><argument_list>(<argument><expr><name>archiveModeGet</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Release the lock so the child process can acquire it</comment>
                    <expr_stmt><expr><call><name>lockRelease</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Execute the async process</comment>
                    <expr_stmt><expr><call><name>archiveAsyncExec</name><argument_list>(<argument><expr><name>archiveModeGet</name></expr></argument>, <argument><expr><name>commandExec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Mark the async process as forked so it doesn't get forked again.  A single run of the async process should be</comment>
                    <comment type="line">// enough to do the job, running it again won't help anything.</comment>
                    <expr_stmt><expr><name>forked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Exit loop if WAL was found</comment>
                <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <comment type="line">// No longer the first run, so errors will be thrown and missing files will be reported</comment>
                <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><call><name>waitMore</name><argument_list>(<argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

            <comment type="line">// If the WAL segment was not found</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If no ok file was found then something may be wrong with the async process. It's better to throw an error here</comment>
                <comment type="line">// than report not found for debugging purposes. Either way PostgreSQL will halt if it has not reached consistency.</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>foundOk</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                        <argument><expr><name>ArchiveTimeoutError</name></expr></argument>,
                        <argument><expr><literal type="string">"unable to get WAL file '%s' from the archive asynchronously after %s second(s)\n"</literal>
                        <literal type="string">"HINT: check '%s' for errors."</literal></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strNewDbl</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><call><name>cfgOptionInt64</name><argument_list>(<argument><expr><name>cfgOptArchiveTimeout</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>MSEC_PER_SEC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgLoadLogFileName</name><argument_list>(<argument><expr><name>cfgCmdRoleAsync</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else report that the WAL segment could not be found</comment>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><name>UNABLE_TO_FIND_IN_ARCHIVE_MSG</name> <literal type="string">" asynchronously"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else perform synchronous get</comment>
        <else>else
        <block>{<block_content>
            <comment type="line">// Check for the archive file</comment>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>archiveRequestList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>archiveRequestList</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>ArchiveGetCheckResult</name></type> <name>checkResult</name> <init>= <expr><call><name>archiveGetCheck</name><argument_list>(<argument><expr><name>archiveRequestList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If there was an error then throw it</comment>
            <if_stmt><if>if <condition>(<expr><name><name>checkResult</name><operator>.</operator><name>errorType</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_CODE</name><argument_list>(<argument><expr><call><name>errorTypeCode</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>errorType</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Get the archive file</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>archiveFileMapList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// There can only be one file mapping since only one file was requested</comment>
                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>archiveFileMapList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>ArchiveFileMap</name> <modifier>*</modifier></type><name>fileMap</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>archiveFileMapList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Get the file</comment>
                <decl_stmt><decl><type><name>ArchiveGetFileResult</name></type> <name>fileResult</name> <init>= <expr><call><name>archiveGetFile</name><argument_list>(
                    <argument><expr><call><name>storageLocalWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>fileMap</name><operator>-&gt;</operator><name>request</name></name></expr></argument>, <argument><expr><name><name>fileMap</name><operator>-&gt;</operator><name>actualList</name></name></expr></argument>, <argument><expr><name>walDestination</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Output file warnings</comment>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>warnIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>warnIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>fileResult</name><operator>.</operator><name>warnList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>warnIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>fileResult</name><operator>.</operator><name>warnList</name></name></expr></argument>, <argument><expr><name>warnIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <comment type="line">// If there was no error then the file existed</comment>
                <decl_stmt><decl><type><name>ArchiveGetFile</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>fileMap</name><operator>-&gt;</operator><name>actualList</name></name></expr></argument>, <argument><expr><name><name>fileResult</name><operator>.</operator><name>actualIdx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                    <argument><expr><name>FOUND_IN_REPO_ARCHIVE_MSG</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>repoIdx</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else log that the file was not found</comment>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><name>UNABLE_TO_FIND_IN_ARCHIVE_MSG</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>ArchiveGetAsyncData</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>archiveFileMapList</name></decl>;</decl_stmt>                           <comment type="line">// List of wal segments to process</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>archiveFileIdx</name></decl>;</decl_stmt>                                    <comment type="line">// Current index in the list to be processed</comment>
}</block></struct></type> <name>ArchiveGetAsyncData</name>;</typedef>

<function><type><specifier>static</specifier> <name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>archiveGetAsyncCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>clientIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>clientIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// No special logic based on the client, we'll just get the next job</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>clientIdx</name></expr>;</expr_stmt>

        <comment type="line">// Get a new job if there are any left</comment>
        <decl_stmt><decl><type><name>ArchiveGetAsyncData</name> <modifier>*</modifier></type><name>jobData</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveFileIdx</name></name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveFileMapList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ArchiveFileMap</name> <modifier>*</modifier></type><name>archiveFileMap</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveFileMapList</name></name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveFileIdx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveFileIdx</name></name><operator>++</operator></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>ProtocolCommand</name> <modifier>*</modifier><specifier>const</specifier></type> <name>command</name> <init>= <expr><call><name>protocolCommandNew</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND_ARCHIVE_GET_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>param</name> <init>= <expr><call><name>protocolCommandParam</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>archiveFileMap</name><operator>-&gt;</operator><name>request</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Add actual files to get</comment>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>actualIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>actualIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>archiveFileMap</name><operator>-&gt;</operator><name>actualList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>actualIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>ArchiveGetFile</name> <modifier>*</modifier><specifier>const</specifier></type> <name>actual</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>archiveFileMap</name><operator>-&gt;</operator><name>actualList</name></name></expr></argument>, <argument><expr><name>actualIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>actual</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>actual</name><operator>-&gt;</operator><name>repoIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>actual</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>actual</name><operator>-&gt;</operator><name>cipherType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>actual</name><operator>-&gt;</operator><name>cipherPassArchive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>protocolParallelJobNew</name><argument_list>(<argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name><name>archiveFileMap</name><operator>-&gt;</operator><name>request</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>PROTOCOL_PARALLEL_JOB</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>cmdArchiveGetAsync</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// PostgreSQL must be local</comment>
            <expr_stmt><expr><call><name>pgIsLocalVerify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Check the parameters</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strLstSize</name><argument_list>(<argument><expr><call><name>cfgCommandParam</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>ParamInvalidError</name></expr></argument>, <argument><expr><literal type="string">"at least one wal segment is required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                <argument><expr><literal type="string">"get %u WAL file(s) from archive: %s%s"</literal></expr></argument>,
                <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><call><name>cfgCommandParam</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><call><name>cfgCommandParam</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><ternary><condition><expr><call><name>strLstSize</name><argument_list>(<argument><expr><call><name>cfgCommandParam</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then>
                    <expr><literal type="string">""</literal></expr> </then><else>: <expr><call><name>zNewFmt</name><argument_list>(<argument><expr><literal type="string">"...%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><call><name>cfgCommandParam</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><call><name>cfgCommandParam</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Check for archive files</comment>
            <decl_stmt><decl><type><name>ArchiveGetCheckResult</name></type> <name>checkResult</name> <init>= <expr><call><name>archiveGetCheck</name><argument_list>(<argument><expr><call><name>cfgCommandParam</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If any files are missing get the first one (used to construct the "unable to find" warning)</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>archiveFileMissing</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>lstSize</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>archiveFileMapList</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><call><name>cfgCommandParam</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>archiveFileMissing</name> <operator>=</operator> <call><name>strLstGet</name><argument_list>(<argument><expr><call><name>cfgCommandParam</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>archiveFileMapList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Get archive files that were found</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>archiveFileMapList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Create the parallel executor</comment>
                <decl_stmt><decl><type><name>ArchiveGetAsyncData</name></type> <name>jobData</name> <init>= <expr><block>{<expr><operator>.</operator><name>archiveFileMapList</name> <operator>=</operator> <name><name>checkResult</name><operator>.</operator><name>archiveFileMapList</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>ProtocolParallel</name> <modifier>*</modifier></type><name>parallelExec</name> <init>= <expr><call><name>protocolParallelNew</name><argument_list>(
                    <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptProtocolTimeout</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>archiveGetAsyncCallback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jobData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>processIdx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>processIdx</name> <operator>&lt;=</operator> <call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptProcessMax</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>processIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>protocolParallelClientAdd</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>, <argument><expr><call><name>protocolLocalGet</name><argument_list>(<argument><expr><name>protocolStorageTypeRepo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>processIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <comment type="line">// Process jobs</comment>
                <macro><name>MEM_CONTEXT_TEMP_RESET_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <do>do
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>completed</name> <init>= <expr><call><name>protocolParallelProcess</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>jobIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>jobIdx</name> <operator>&lt;</operator> <name>completed</name></expr>;</condition> <incr><expr><name>jobIdx</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <comment type="line">// Get the job</comment>
                            <decl_stmt><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>protocolParallelResult</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>processId</name> <init>= <expr><call><name>protocolParallelJobProcessId</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <comment type="line">// Get wal segment name and archive file map</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegment</name> <init>= <expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>protocolParallelJobKey</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>ArchiveFileMap</name> <modifier>*</modifier></type><name>fileMap</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>archiveFileMapList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>walSegment</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>fileMap</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// Build warnings for status file</comment>
                            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>warning</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>fileMap</name><operator>-&gt;</operator><name>warnList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>warning</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name><name>fileMap</name><operator>-&gt;</operator><name>warnList</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <comment type="line">// The job was successful</comment>
                            <if_stmt><if>if <condition>(<expr><call><name>protocolParallelJobErrorCode</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <comment type="line">// Get the actual file retrieved</comment>
                                <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileResult</name> <init>= <expr><call><name>protocolParallelJobResult</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><name>ArchiveGetFile</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>fileMap</name><operator>-&gt;</operator><name>actualList</name></name></expr></argument>, <argument><expr><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>fileResult</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <comment type="line">// Output file warnings</comment>
                                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>fileWarnList</name> <init>= <expr><call><name>pckReadStrLstP</name><argument_list>(<argument><expr><name>fileResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>warnIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>warnIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>warnIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>LOG_WARN_PID</name><argument_list>(<argument><expr><name>processId</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>, <argument><expr><name>warnIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                                <comment type="line">// Build file warnings for status file</comment>
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                                        <argument><expr><name>warning</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>strSize</name><argument_list>(<argument><expr><name>warning</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"\n"</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>warning</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>archiveAsyncStatusOkWrite</name><argument_list>(<argument><expr><name>archiveModeGet</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>, <argument><expr><name>warning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                                <expr_stmt><expr><call><name>LOG_DETAIL_PID_FMT</name><argument_list>(
                                    <argument><expr><name>processId</name></expr></argument>, <argument><expr><name>FOUND_IN_REPO_ARCHIVE_MSG</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>repoIdx</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <comment type="line">// Rename temp WAL segment to actual name. This is done after the ok file is written so the ok file</comment>
                                <comment type="line">// is guaranteed to exist before the foreground process finds the WAL segment.</comment>
                                <expr_stmt><expr><call><name>storageMoveP</name><argument_list>(
                                    <argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>storageNewReadP</name><argument_list>(
                                        <argument><expr><call><name>storageSpool</name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_IN</name> <literal type="string">"/%s."</literal> <name>STORAGE_FILE_TEMP_EXT</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>storageNewWriteP</name><argument_list>(
                                        <argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_IN</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Else the job errored</comment>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>LOG_WARN_PID_FMT</name><argument_list>(
                                    <argument><expr><name>processId</name></expr></argument>, <argument><expr><literal type="string">"[%s] %s"</literal></expr></argument>, <argument><expr><call><name>errorTypeName</name><argument_list>(<argument><expr><call><name>errorTypeFromCode</name><argument_list>(<argument><expr><call><name>protocolParallelJobErrorCode</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>protocolParallelJobErrorMessage</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>archiveAsyncStatusErrorWrite</name><argument_list>(
                                    <argument><expr><name>archiveModeGet</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>, <argument><expr><call><name>protocolParallelJobErrorCode</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>strNewFmt</name><argument_list>(
                                        <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>protocolParallelJobErrorMessage</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><ternary><condition><expr><call><name>strSize</name><argument_list>(<argument><expr><name>warning</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><call><name>zNewFmt</name><argument_list>(<argument><expr><literal type="string">"\n%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>warning</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>

                            <expr_stmt><expr><call><name>protocolParallelJobFree</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>

                        <comment type="line">// Reset the memory context occasionally so we don't use too much memory or slow down processing</comment>
                        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_RESET</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>
                    while <condition>(<expr><operator>!</operator><call><name>protocolParallelDone</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Log an error from archiveGetCheck() after any existing files have been fetched. This ordering is important because we</comment>
            <comment type="line">// need to fetch as many valid files as possible before throwing an error.</comment>
            <if_stmt><if>if <condition>(<expr><name><name>checkResult</name><operator>.</operator><name>errorType</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"[%s] %s"</literal></expr></argument>, <argument><expr><call><name>errorTypeName</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>errorType</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>message</name> <init>= <expr><call><name>strCat</name><argument_list>(<argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>checkResult</name><operator>.</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>warnList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="string">"\n%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>warnList</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>archiveAsyncStatusErrorWrite</name><argument_list>(
                    <argument><expr><name>archiveModeGet</name></expr></argument>, <argument><expr><name><name>checkResult</name><operator>.</operator><name>errorFile</name></name></expr></argument>, <argument><expr><call><name>errorTypeCode</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>errorType</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// If any files were missing write an ok file for the first missing file and add any warnings. It is important that this</comment>
            <comment type="line">// happen right before the async process exits so the main process can immediately respawn the async process to retry</comment>
            <comment type="line">// missing files.</comment>
            <if type="elseif">else if <condition>(<expr><name>archiveFileMissing</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><name>UNABLE_TO_FIND_IN_ARCHIVE_MSG</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveFileMissing</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>warnList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>message</name> <operator>=</operator> <call><name>strLstJoin</name><argument_list>(<argument><expr><name><name>checkResult</name><operator>.</operator><name>warnList</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>archiveAsyncStatusOkWrite</name><argument_list>(<argument><expr><name>archiveModeGet</name></expr></argument>, <argument><expr><name>archiveFileMissing</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <comment type="line">// On any global error write a single error file to cover all unprocessed files</comment>
        <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>archiveAsyncStatusErrorWrite</name><argument_list>(<argument><expr><name>archiveModeGet</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>errorCode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETHROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
