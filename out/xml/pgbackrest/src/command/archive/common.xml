<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/command/archive/common.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Archive Common
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/archive/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/fork.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/memContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/regExp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/wait.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
WAL segment constants
***********************************************************************************************************************************/</comment>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>WAL_SEGMENT_REGEXP_STR</name></expr></argument>,                               <argument><expr><name>WAL_SEGMENT_REGEXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>WAL_SEGMENT_PARTIAL_REGEXP_STR</name></expr></argument>,                       <argument><expr><name>WAL_SEGMENT_PARTIAL_REGEXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>WAL_SEGMENT_DIR_REGEXP_STR</name></expr></argument>,                           <argument><expr><name>WAL_SEGMENT_DIR_REGEXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>WAL_SEGMENT_FILE_REGEXP_STR</name></expr></argument>,                          <argument><expr><name>WAL_SEGMENT_FILE_REGEXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>WAL_TIMELINE_HISTORY_REGEXP_STR</name></expr></argument>,                      <argument><expr><name>WAL_TIMELINE_HISTORY_REGEXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Global error file constant
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATUS_FILE_GLOBAL</name></cpp:macro>                                          <cpp:value>"global"</cpp:value></cpp:define>
    <expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>STATUS_FILE_GLOBAL_STR</name></expr></argument>,                           <argument><expr><name>STATUS_FILE_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATUS_FILE_GLOBAL_ERROR</name></cpp:macro>                                    <cpp:value>STATUS_FILE_GLOBAL STATUS_EXT_ERROR</cpp:value></cpp:define>
    <expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>STATUS_FILE_GLOBAL_ERROR_STR</name></expr></argument>,                         <argument><expr><name>STATUS_FILE_GLOBAL_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the correct spool queue based on the archive mode
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>String</name> <modifier>*</modifier></type>
<name>archiveAsyncSpoolQueue</name><parameter_list>(<parameter><decl><type><name>ArchiveMode</name></type> <name>archiveMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>archiveMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(
        <argument><expr><name>STRING</name></expr></argument>, <argument><expr><ternary><condition><expr><name>archiveMode</name> <operator>==</operator> <name>archiveModeGet</name></expr> ?</condition><then> <expr><name>STORAGE_SPOOL_ARCHIVE_IN_STR</name></expr> </then><else>: <expr><name>STORAGE_SPOOL_ARCHIVE_OUT_STR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>archiveAsyncErrorClear</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArchiveMode</name></type> <name>archiveMode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>archiveFile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>archiveMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>archiveFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>archiveFile</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>errorFile</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_OUT</name> <literal type="string">"/%s"</literal> <name>STATUS_EXT_ERROR</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>errorFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_OUT</name> <literal type="string">"/"</literal> <name>STATUS_FILE_GLOBAL_ERROR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><name>errorFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>archiveAsyncStatus</name><parameter_list>(<parameter><decl><type><name>ArchiveMode</name></type> <name>archiveMode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>throwOnError</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>warnOnOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>archiveMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>throwOnError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>warnOnOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walSegment</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>errorFile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>errorFileExists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>spoolQueue</name> <init>= <expr><call><name>archiveAsyncSpoolQueue</name><argument_list>(<argument><expr><name>archiveMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>okFile</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s"</literal> <name>STATUS_EXT_OK</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>okFileExists</name> <init>= <expr><call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storageSpool</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>spoolQueue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>okFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If the ok file does not exist then check to see if a file-specific or global error exists</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>okFileExists</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Check for a file-specific error first</comment>
            <expr_stmt><expr><name>errorFile</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s"</literal> <name>STATUS_EXT_ERROR</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>errorFileExists</name> <operator>=</operator> <call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storageSpool</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>spoolQueue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>errorFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If that doesn't exist then check for a global error</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>errorFileExists</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>errorFile</name> <operator>=</operator> <name>STATUS_FILE_GLOBAL_ERROR_STR</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>errorFileExists</name> <operator>=</operator> <call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storageSpool</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>spoolQueue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>errorFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If either of them exists then check what happened and report back</comment>
        <if_stmt><if>if <condition>(<expr><name>okFileExists</name> <operator>||</operator> <name>errorFileExists</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Get the status file content</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>statusFile</name> <init>= <expr><ternary><condition><expr><name>okFileExists</name></expr> ?</condition><then> <expr><name>okFile</name></expr></then><else>: <expr><name>errorFile</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>content</name> <init>= <expr><call><name>strNewBuf</name><argument_list>(
                <argument><expr><call><name>storageGetP</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><call><name>storageSpool</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>spoolQueue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>statusFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Get the code and message if the file has content</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>code</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Find the line feed after the error code -- should be the first one</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>linefeedPtr</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Error if linefeed not found</comment>
                <if_stmt><if>if <condition>(<expr><name>linefeedPtr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"%s content must have at least two lines"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>statusFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Error if message is zero-length</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>linefeedPtr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"%s message must be &gt; 0"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>statusFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Get contents</comment>
                <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>varIntForce</name><argument_list>(<argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>strNewZN</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>linefeedPtr</name> <operator>-</operator> <call><name>strZ</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>message</name> <operator>=</operator> <call><name>strTrim</name><argument_list>(<argument><expr><call><name>strNewZ</name><argument_list>(<argument><expr><name>linefeedPtr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Process OK files</comment>
            <if_stmt><if>if <condition>(<expr><name>okFileExists</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If there is content in the status file it is a warning</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>warnOnOk</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// If error code is not success, then this was a renamed error file</comment>
                    <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>message</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(
                            <argument><expr><literal type="string">"WAL segment '%s' was not pushed due to error [%d] and was manually skipped: %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>code</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>throwOnError</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Error status files must have content</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"status file '%s' has no content"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>statusFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Throw error using the code passed in the file</comment>
                <expr_stmt><expr><call><name>THROW_CODE</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>archiveAsyncStatusErrorWrite</name><parameter_list>(<parameter><decl><type><name>ArchiveMode</name></type> <name>archiveMode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegment</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>archiveMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>code</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>message</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>errorFile</name> <init>= <expr><ternary><condition><expr><name>walSegment</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>STATUS_FILE_GLOBAL_STR</name></expr> </then><else>: <expr><name>walSegment</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>storagePutP</name><argument_list>(
            <argument><expr><call><name>storageNewWriteP</name><argument_list>(
                <argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal> <name>STATUS_EXT_ERROR</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>archiveAsyncSpoolQueue</name><argument_list>(<argument><expr><name>archiveMode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>errorFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>BUFSTR</name><argument_list>(<argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%d\n%s"</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>archiveAsyncStatusOkWrite</name><parameter_list>(<parameter><decl><type><name>ArchiveMode</name></type> <name>archiveMode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegment</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>warning</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>archiveMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>warning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walSegment</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Write file</comment>
        <expr_stmt><expr><call><name>storagePutP</name><argument_list>(
            <argument><expr><call><name>storageNewWriteP</name><argument_list>(
                <argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal> <name>STATUS_EXT_OK</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>archiveAsyncSpoolQueue</name><argument_list>(<argument><expr><name>archiveMode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><ternary><condition><expr><name>warning</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>BUFSTR</name><argument_list>(<argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"0\n%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>warning</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>archiveAsyncExec</name><parameter_list>(<parameter><decl><type><name>ArchiveMode</name></type> <name>archiveMode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>commandExec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>archiveMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>commandExec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>commandExec</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Fork off the async process</comment>
    <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><call><name>forkSafe</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Disable logging and close log file</comment>
        <expr_stmt><expr><call><name>logClose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Detach from parent process</comment>
        <expr_stmt><expr><call><name>forkDetach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Close any open file descriptors above the standard three (stdin, stdout, stderr). Don't check the return value since we</comment>
        <comment type="line">// don't know which file descriptors are actually open (might be none). It's possible that there are open files &gt;= 1024 but</comment>
        <comment type="line">// there is no easy way to detect that and this should give us enough descriptors to do our work.</comment>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</init> <condition><expr><name>fd</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>;</condition> <incr><expr><name>fd</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <comment type="line">// Execute the binary.  This statement will not return if it is successful.</comment>
        <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR_FMT</name><argument_list>(
            <argument><expr><call><name>execvp</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>commandExec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator> <specifier>const</specifier><operator>)</operator><call><name>strLstPtr</name><argument_list>(<argument><expr><name>commandExec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ExecuteError</name></expr></argument>,
            <argument><expr><literal type="string">"unable to execute asynchronous '%s'"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>archiveMode</name> <operator>==</operator> <name>archiveModeGet</name></expr> ?</condition><then> <expr><name>CFGCMD_ARCHIVE_GET</name></expr> </then><else>: <expr><name>CFGCMD_ARCHIVE_PUSH</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_EXEC_TIME</name></cpp:ifdef>
    <comment type="line">// Get the time to measure how long it takes for the forked process to exit</comment>
    <decl_stmt><decl><type><name>TimeMSec</name></type> <name>timeBegin</name> <init>= <expr><call><name>timeMSec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// The process that was just forked should return immediately</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>processStatus</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR</name><argument_list>(<argument><expr><call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>processStatus</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ExecuteError</name></expr></argument>, <argument><expr><literal type="string">"unable to wait for forked process"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// The first fork should exit with success.  If not, something went wrong during the second fork.</comment>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>ExecuteError</name></expr></argument>, <argument><expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>processStatus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>processStatus</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"error on first fork"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_EXEC_TIME</name></cpp:ifdef>
    <comment type="line">// If the process does not exit immediately then something probably went wrong with the double fork.  It's possible that this</comment>
    <comment type="line">// test will fail on very slow systems so it may need to be tuned.  The idea is to make sure that the waitpid() above is not</comment>
    <comment type="line">// waiting on the async process.</comment>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><call><name>timeMSec</name><argument_list>()</argument_list></call> <operator>-</operator> <name>timeBegin</name> <operator>&lt;</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"the process does not exit immediately"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>int</name></type>
<name>archiveIdComparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>archiveSort1</name> <init>= <expr><call><name>strLstNewSplitZ</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>String</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>item1</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>archiveSort2</name> <init>= <expr><call><name>strLstNewSplitZ</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>String</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>item2</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>int1</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>archiveSort1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>int2</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>archiveSort2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>(</operator><name>int1</name> <operator>-</operator> <name>int2</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>walIsPartial</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walSegment</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>walIsSegment</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><call><name>strEndsWithZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>, <argument><expr><name>WAL_SEGMENT_PARTIAL_EXT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>walPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walFile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pgPath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walFile</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>command</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strBeginsWithZ</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Error if walFile has a relative path and pgPath is not set</comment>
        <if_stmt><if>if <condition>(<expr><name>pgPath</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                <argument><expr><name>OptionRequiredError</name></expr></argument>,
                <argument><expr><literal type="string">"option '%s' must be specified when relative wal paths are used\n"</literal>
                    <literal type="string">"HINT: is %%f passed to %s instead of %%p?\n"</literal>
                    <literal type="string">"HINT: PostgreSQL may pass relative paths even with %%p depending on the environment."</literal></expr></argument>,
                <argument><expr><call><name>cfgOptionName</name><argument_list>(<argument><expr><name>cfgOptPgPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Get the working directory</comment>
        <decl_stmt><decl><type><name>char</name></type> <name><name>currentWorkDir</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR</name><argument_list>(<argument><expr><call><name>getcwd</name><argument_list>(<argument><expr><name>currentWorkDir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>currentWorkDir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to get cwd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Check if the working directory is the same as pgPath</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEqZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>, <argument><expr><name>currentWorkDir</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If not we'll change the working directory to pgPath and see if that equals the working directory we got called with</comment>
            <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR_FMT</name><argument_list>(<argument><expr><call><name>chdir</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>PathMissingError</name></expr></argument>, <argument><expr><literal type="string">"unable to chdir() to '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Get the new working directory</comment>
            <decl_stmt><decl><type><name>char</name></type> <name><name>newWorkDir</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR</name><argument_list>(<argument><expr><call><name>getcwd</name><argument_list>(<argument><expr><name>newWorkDir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>newWorkDir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to get cwd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Error if the new working directory is not equal to the original current working directory. This means that PostgreSQL</comment>
            <comment type="line">// and pgBackrest have a different idea about where the PostgreSQL data directory is located.</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>currentWorkDir</name></expr></argument>, <argument><expr><name>newWorkDir</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>OptionInvalidValueError</name></expr></argument>,
                    <argument><expr><name>PG_NAME</name> <literal type="string">" working directory '%s' is not the same as option %s '%s'\n"</literal>
                        <literal type="string">"HINT: is the "</literal> <name>PG_NAME</name> <literal type="string">" data_directory configured the same as the %s option?"</literal></expr></argument>,
                    <argument><expr><name>currentWorkDir</name></expr></argument>, <argument><expr><call><name>cfgOptionName</name><argument_list>(<argument><expr><name>cfgOptPgPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionName</name><argument_list>(<argument><expr><name>cfgOptPgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>walIsSegment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walSegment</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Create the regular expression to identify WAL segments if it does not already exist</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>RegExp</name> <modifier>*</modifier></type><name>regExpSegment</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>regExpSegment</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>memContextTop()</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>regExpSegment</name> <operator>=</operator> <call><name>regExpNew</name><argument_list>(<argument><expr><name>WAL_SEGMENT_PARTIAL_REGEXP_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><call><name>regExpMatch</name><argument_list>(<argument><expr><name>regExpSegment</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>walSegmentFind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storage</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>archiveId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegment</name></decl></parameter>, <parameter><decl><type><name>TimeMSec</name></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>TIME_MSEC</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>storage</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>archiveId</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walSegment</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>walIsSegment</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Wait</name> <modifier>*</modifier></type><name>wait</name> <init>= <expr><call><name>waitNew</name><argument_list>(<argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <do>do
        <block>{<block_content>
            <comment type="line">// Get a list of all WAL segments that match</comment>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>storageListP</name><argument_list>(
                <argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(
                    <argument><expr><literal type="string">"^%s%s-[0-f]{40}"</literal> <name>COMPRESS_TYPE_REGEXP</name> <literal type="string">"{0,1}$"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><ternary><condition><expr><call><name>walIsPartial</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>WAL_SEGMENT_PARTIAL_EXT</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><operator>.</operator><name>nullOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If there are results</comment>
            <if_stmt><if>if <condition>(<expr><name>list</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Error if there is more than one match</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                        <argument><expr><name>ArchiveDuplicateError</name></expr></argument>,
                        <argument><expr><literal type="string">"duplicates found in archive for WAL segment %s: %s\n"</literal>
                            <literal type="string">"HINT: are multiple primaries archiving to this stanza?"</literal></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><call><name>strLstSort</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Copy file name of WAL segment found into the prior context</comment>
                <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        while <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>waitMore</name><argument_list>(<argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>timeout</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
            <argument><expr><name>ArchiveTimeoutError</name></expr></argument>,
            <argument><expr><literal type="string">"WAL segment %s was not archived before the %"</literal> <name>PRIu64</name> <literal type="string">"ms timeout\n"</literal>
                <literal type="string">"HINT: check the archive_command to ensure that all options are correct (especially --stanza).\n"</literal>
                <literal type="string">"HINT: check the PostgreSQL server log for errors.\n"</literal>
                <literal type="string">"HINT: run the 'start' command if the stanza was previously stopped."</literal></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>walSegmentNext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegment</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>walSegmentSize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>walSegmentSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walSegment</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>UINT32_MAX</name> <operator>%</operator> <name>walSegmentSize</name> <operator>==</operator> <name>walSegmentSize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_11</name> <operator>||</operator> <name>walSegmentSize</name> <operator>==</operator> <name>PG_WAL_SEGMENT_SIZE_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Extract WAL parts</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>timeline</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>major</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>minor</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>timeline</name> <operator>=</operator> <call><name>pgTimelineFromWalSegment</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>major</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>strtol</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>minor</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>strtol</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Increment minor and adjust major dir on overflow</comment>
        <expr_stmt><expr><name>minor</name><operator>++</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>minor</name> <operator>&gt;</operator> <name>UINT32_MAX</name> <operator>/</operator> <name>walSegmentSize</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>major</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>minor</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Special hack for PostgreSQL &lt; 9.3 which skipped minor FF</comment>
        <if_stmt><if>if <condition>(<expr><name>minor</name> <operator>==</operator> <literal type="number">0xFF</literal> <operator>&amp;&amp;</operator> <name>pgVersion</name> <operator>&lt;</operator> <name>PG_VERSION_93</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>major</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>minor</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%08X%08X%08X"</literal></expr></argument>, <argument><expr><name>timeline</name></expr></argument>, <argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StringList</name> <modifier>*</modifier></type>
<name>walSegmentRange</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegmentBegin</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>walSegmentSize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>range</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walSegmentBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>walSegmentSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>range</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>walSegmentBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>range</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>current</name> <init>= <expr><call><name>strDup</name><argument_list>(<argument><expr><name>walSegmentBegin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>rangeIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rangeIdx</name> <operator>&lt;</operator> <name>range</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>rangeIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>walSegmentNext</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>walSegmentSize</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>current</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>strLstMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
