<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/command/archive/push/push.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Archive Push Command
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/archive/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/archive/push/file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/archive/push/protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/command.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/control/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/compress/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/memContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/wait.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/load.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/exec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoArchive.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Constants for log messages that are used multiple times to keep them consistent
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNABLE_TO_FIND_VALID_REPO_MSG</name></cpp:macro>                               <cpp:value>"unable to find a valid repository"</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Ready file extension constants
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATUS_EXT_READY</name></cpp:macro>                                            <cpp:value>".ready"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATUS_EXT_READY_SIZE</name></cpp:macro>                                       <cpp:value>(sizeof(STATUS_EXT_READY) - 1)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Format the warning when a file is dropped
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>archivePushDropWarning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walFile</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>queueMax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>queueMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(
        <argument><expr><name>STRING</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"dropped WAL file '%s' because archive queue exceeded %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSizeFormat</name><argument_list>(<argument><expr><name>queueMax</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Determine if the WAL process list has become large enough to drop
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>archivePushDrop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walPath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>processList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>processList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>queueMax</name> <init>= <expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptArchivePushQueueMax</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>queueSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_RESET_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>processIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>processIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>processList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>processIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>queueSize</name> <operator>+=</operator> <call><name>storageInfoP</name><argument_list>(
                <argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>processList</name></expr></argument>, <argument><expr><name>processIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><name>size</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>queueSize</name> <operator>&gt;</operator> <name>queueMax</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Reset the memory context occasionally so we don't use too much memory or slow down processing</comment>
            <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_RESET</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the list of WAL files ready to be pushed according to PostgreSQL
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>StringList</name> <modifier>*</modifier></type>
<name>archivePushReadyList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walPath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walPath</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Read the ready files from the archive_status directory</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>readyListRaw</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
            <argument><expr><call><name>storageListP</name><argument_list>(
                <argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/"</literal> <name>PG_PATH_ARCHIVE_STATUS</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"\\"</literal> <name>STATUS_EXT_READY</name> <literal type="string">"$"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>readyIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>readyIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>readyListRaw</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>readyIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ready</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>readyListRaw</name></expr></argument>, <argument><expr><name>readyIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>strLstAddSub</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ready</name></expr></argument>, <argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>ready</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>STATUS_EXT_READY_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>strLstMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Determine which WAL files need to be pushed to the archive when in async mode

This is the heart of the "look ahead" functionality in async archiving.  Any files in the out directory that do not end in ok are
removed and any ok files that do not have a corresponding ready file in archive_status (meaning it has been acknowledged by
PostgreSQL) are removed.  Then all ready files that do not have a corresponding ok file (meaning it has already been processed) are
returned for processing.
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>StringList</name> <modifier>*</modifier></type>
<name>archivePushProcessList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walPath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walPath</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Create the spool out path if it does not already exist</comment>
        <expr_stmt><expr><call><name>storagePathCreateP</name><argument_list>(<argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>STORAGE_SPOOL_ARCHIVE_OUT_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Read the status files from the spool directory, then remove any files that do not end in ok and create a list of the</comment>
        <comment type="line">// ok files for further processing</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>statusList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
            <argument><expr><call><name>storageListP</name><argument_list>(<argument><expr><call><name>storageSpool</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>STORAGE_SPOOL_ARCHIVE_OUT_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>okList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>statusIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>statusIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>statusList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>statusIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>statusFile</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>statusList</name></expr></argument>, <argument><expr><name>statusIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strEndsWithZ</name><argument_list>(<argument><expr><name>statusFile</name></expr></argument>, <argument><expr><name>STATUS_EXT_OK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strLstAddSub</name><argument_list>(<argument><expr><name>okList</name></expr></argument>, <argument><expr><name>statusFile</name></expr></argument>, <argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>statusFile</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>STATUS_EXT_OK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(
                    <argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_OUT</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>statusFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Read the ready files from the archive_status directory</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>readyList</name> <init>= <expr><call><name>archivePushReadyList</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Remove ok files that are not in the ready list</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>okRemoveList</name> <init>= <expr><call><name>strLstMergeAnti</name><argument_list>(<argument><expr><name>okList</name></expr></argument>, <argument><expr><name>readyList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>okRemoveIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>okRemoveIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>okRemoveList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>okRemoveIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(
                <argument><expr><call><name>storageSpoolWrite</name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_OUT</name> <literal type="string">"/%s"</literal> <name>STATUS_EXT_OK</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>okRemoveList</name></expr></argument>, <argument><expr><name>okRemoveIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Return all ready files that are not in the ok list</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strLstMove</name><argument_list>(<argument><expr><call><name>strLstMergeAnti</name><argument_list>(<argument><expr><name>readyList</name></expr></argument>, <argument><expr><name>okList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Check that pg_control and archive.info match and get the archive id and archive cipher passphrase (if present)

As much information as possible is collected here so that async archiving has as little work as possible to do for each file.  Sync
archiving does not benefit but it makes sense to use the same function.
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>ArchivePushCheckResult</name>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl>;</decl_stmt>                                         <comment type="line">// PostgreSQL version</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>pgSystemId</name></decl>;</decl_stmt>                                            <comment type="line">// PostgreSQL system id</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>repoList</name></decl>;</decl_stmt>                                                 <comment type="line">// Data for each repo</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>errorList</name></decl>;</decl_stmt>                                          <comment type="line">// Errors while checking repos</comment>
}</block></struct></type> <name>ArchivePushCheckResult</name>;</typedef>

<function><type><specifier>static</specifier> <name>ArchivePushCheckResult</name></type>
<name>archivePushCheck</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>pgPathSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>pgPathSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ArchivePushCheckResult</name></type> <name>result</name> <init>= <expr><block>{<expr><operator>.</operator><name>repoList</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArchivePushFileRepoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>, <expr><operator>.</operator><name>errorList</name> <operator>=</operator> <macro><name>strLstNew</name><argument_list>()</argument_list></macro></expr>}</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// If we have access to pg_control then load it to get the pg version and system id. If we can't load pg_control then we'll</comment>
        <comment type="line">// still compare the pg info stored in the repo to the WAL segment and also all the repos against each other.</comment>
        <if_stmt><if>if <condition>(<expr><name>pgPathSet</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Get info from pg_control</comment>
            <decl_stmt><decl><type><name>PgControl</name></type> <name>pgControl</name> <init>= <expr><call><name>pgControlFromFile</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>pgVersion</name></name> <operator>=</operator> <name><name>pgControl</name><operator>.</operator><name>version</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>pgSystemId</name></name> <operator>=</operator> <name><name>pgControl</name><operator>.</operator><name>systemId</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>repoIdx</name> <operator>&lt;</operator> <call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>repoIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// Get the repo storage in case it is remote and encryption settings need to be pulled down</comment>
                <expr_stmt><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Get cipher type</comment>
                <decl_stmt><decl><type><name>CipherType</name></type> <name>repoCipherType</name> <init>= <expr><call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Attempt to load the archive info file</comment>
                <decl_stmt><decl><type><name>InfoArchive</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>infoArchiveLoadFile</name><argument_list>(
                    <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INFO_ARCHIVE_PATH_FILE_STR</name></expr></argument>, <argument><expr><name>repoCipherType</name></expr></argument>,
                    <argument><expr><call><name>cfgOptionIdxStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Get archive id for the most recent version -- archive-push will only operate against the most recent version</comment>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveId</name> <init>= <expr><call><name>infoPgArchiveId</name><argument_list>(<argument><expr><call><name>infoArchivePg</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>infoPgDataCurrentId</name><argument_list>(<argument><expr><call><name>infoArchivePg</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>InfoPgData</name></type> <name>archiveInfo</name> <init>= <expr><call><name>infoPgData</name><argument_list>(<argument><expr><call><name>infoArchivePg</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>infoPgDataCurrentId</name><argument_list>(<argument><expr><call><name>infoArchivePg</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Ensure that stanza version and system identifier match pg_control when available or the other repos when</comment>
                <comment type="line">// pg_control is not available</comment>
                <if_stmt><if>if <condition>(<expr><name>pgPathSet</name> <operator>||</operator> <name>repoIdx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>pgVersion</name></name> <operator>!=</operator> <name><name>archiveInfo</name><operator>.</operator><name>version</name></name> <operator>||</operator> <name><name>result</name><operator>.</operator><name>pgSystemId</name></name> <operator>!=</operator> <name><name>archiveInfo</name><operator>.</operator><name>systemId</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                            <argument><expr><name>ArchiveMismatchError</name></expr></argument>,
                            <argument><expr><literal type="string">"%s version %s, system-id %"</literal> <name>PRIu64</name> <literal type="string">" do not match %s stanza version %s, system-id %"</literal> <name>PRIu64</name>
                            <literal type="string">"\nHINT: are you archiving to the correct stanza?"</literal></expr></argument>,
                            <argument><expr><ternary><condition><expr><name>pgPathSet</name></expr> ?</condition><then> <expr><name>PG_NAME</name></expr> </then><else>: <expr><call><name>zNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s stanza"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>pgVersion</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>pgSystemId</name></name></expr></argument>,
                            <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name><name>archiveInfo</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name><name>archiveInfo</name><operator>.</operator><name>systemId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>pgVersion</name></name> <operator>=</operator> <name><name>archiveInfo</name><operator>.</operator><name>version</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>pgSystemId</name></name> <operator>=</operator> <name><name>archiveInfo</name><operator>.</operator><name>systemId</name></name></expr>;</expr_stmt>

                    <macro><name>lstAdd</name><argument_list>(
                        <argument>result.repoList</argument>,
                        <argument>&amp;(ArchivePushFileRepoData)
                        {
                            .repoIdx = repoIdx</argument>,
                            <argument>.archiveId = strDup(archiveId)</argument>,
                            <argument>.cipherType = repoCipherType</argument>,
                            <argument>.cipherPass = strDup(infoArchiveCipherPass(info))</argument>,
                        <argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strLstAddFmt</name><argument_list>(
                    <argument><expr><name><name>result</name><operator>.</operator><name>errorList</name></name></expr></argument>, <argument><expr><literal type="string">"%s: [%s] %s"</literal></expr></argument>, <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>errorTypeName</name><argument_list>(<argument><expr><call><name>errorType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If no valid repos were found then error</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>repoList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>errorList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>RepoInvalidError</name></expr></argument>, <argument><expr><name>UNABLE_TO_FIND_VALID_REPO_MSG</name> <literal type="string">":\n%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>errorList</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_STRUCT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>cmdArchivePush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cfgCommand</name><argument_list>()</argument_list></call> <operator>==</operator> <name>cfgCmdArchivePush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// PostgreSQL must be local</comment>
    <expr_stmt><expr><call><name>pgIsLocalVerify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Make sure there is a parameter to retrieve the WAL segment from</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>commandParam</name> <init>= <expr><call><name>cfgCommandParam</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>commandParam</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>ParamRequiredError</name></expr></argument>, <argument><expr><literal type="string">"WAL segment to push required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Test for stop file</comment>
        <expr_stmt><expr><call><name>lockStopTest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Get the segment name</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>walFile</name> <init>= <expr><call><name>walPath</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>commandParam</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptPgPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>cfgCommandName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveFile</name> <init>= <expr><call><name>strBase</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveAsync</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>pushed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>                                        <comment type="line">// Has the WAL segment been pushed yet?</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>forked</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>                                        <comment type="line">// Has the async process been forked yet?</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>throwOnError</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>                                  <comment type="line">// Should we throw errors?</comment>

            <comment type="line">// pg1-path is not optional for async mode</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptPgPath</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>OptionRequiredError</name></expr></argument>, <argument><expr><literal type="string">"'"</literal> <name>CFGCMD_ARCHIVE_PUSH</name> <literal type="string">"' command in async mode requires option '%s'"</literal></expr></argument>,
                    <argument><expr><call><name>cfgOptionName</name><argument_list>(<argument><expr><name>cfgOptPgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Loop and wait for the WAL segment to be pushed</comment>
            <decl_stmt><decl><type><name>Wait</name> <modifier>*</modifier></type><name>wait</name> <init>= <expr><call><name>waitNew</name><argument_list>(<argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptArchiveTimeout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <do>do
            <block>{<block_content>
                <comment type="line">// Check if the WAL segment has been pushed.  Errors will not be thrown on the first try to allow the async process</comment>
                <comment type="line">// a chance to fix them.</comment>
                <expr_stmt><expr><name>pushed</name> <operator>=</operator> <call><name>archiveAsyncStatus</name><argument_list>(<argument><expr><name>archiveModePush</name></expr></argument>, <argument><expr><name>archiveFile</name></expr></argument>, <argument><expr><name>throwOnError</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// If the WAL segment has not already been pushed then start the async process to push it.  There's no point in</comment>
                <comment type="line">// forking the async process off more than once so track that as well.  Use an archive lock to prevent more than</comment>
                <comment type="line">// one async process being launched.</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pushed</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forked</name> <operator>&amp;&amp;</operator>
                    <call><name>lockAcquire</name><argument_list>(
                        <argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptLockPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptStanza</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptExecId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgLockType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                        <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// The async process should not output on the console at all</comment>
                    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>optionReplace</name> <init>= <expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_CONSOLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_STDERR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Generate command options</comment>
                    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>commandExec</name> <init>= <expr><call><name>cfgExecParam</name><argument_list>(<argument><expr><name>cfgCmdArchivePush</name></expr></argument>, <argument><expr><name>cfgCmdRoleAsync</name></expr></argument>, <argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>strLstInsert</name><argument_list>(<argument><expr><name>commandExec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>cfgExe</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>commandExec</name></expr></argument>, <argument><expr><call><name>strPath</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Clear errors for the current archive file</comment>
                    <expr_stmt><expr><call><name>archiveAsyncErrorClear</name><argument_list>(<argument><expr><name>archiveModePush</name></expr></argument>, <argument><expr><name>archiveFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Release the lock so the child process can acquire it</comment>
                    <expr_stmt><expr><call><name>lockRelease</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Execute the async process</comment>
                    <expr_stmt><expr><call><name>archiveAsyncExec</name><argument_list>(<argument><expr><name>archiveModePush</name></expr></argument>, <argument><expr><name>commandExec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Mark the async process as forked so it doesn't get forked again.  A single run of the async process should be</comment>
                    <comment type="line">// enough to do the job, running it again won't help anything.</comment>
                    <expr_stmt><expr><name>forked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Now that the async process has been launched, throw any errors that are found</comment>
                <expr_stmt><expr><name>throwOnError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><operator>!</operator><name>pushed</name> <operator>&amp;&amp;</operator> <call><name>waitMore</name><argument_list>(<argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

            <comment type="line">// If the WAL segment was not pushed then error</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pushed</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>ArchiveTimeoutError</name></expr></argument>,
                    <argument><expr><literal type="string">"unable to push WAL file '%s' to the archive asynchronously after %s second(s)\n"</literal>
                    <literal type="string">"HINT: check '%s' for errors."</literal></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionDisplay</name><argument_list>(<argument><expr><name>cfgOptArchiveTimeout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgLoadLogFileName</name><argument_list>(<argument><expr><name>cfgCmdRoleAsync</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Log success</comment>
            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"pushed WAL file '%s' to the archive asynchronously"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// Check if the push queue has been exceeded</comment>
            <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptArchivePushQueueMax</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>archivePushDrop</name><argument_list>(<argument><expr><call><name>strPath</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>archivePushReadyList</name><argument_list>(<argument><expr><call><name>strPath</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>archivePushDropWarning</name><argument_list>(<argument><expr><name>archiveFile</name></expr></argument>, <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptArchivePushQueueMax</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else push the file</comment>
            <else>else
            <block>{<block_content>
                <comment type="line">// Check archive info for each repo</comment>
                <decl_stmt><decl><type><name>ArchivePushCheckResult</name></type> <name>archiveInfo</name> <init>= <expr><call><name>archivePushCheck</name><argument_list>(<argument><expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptPgPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Push the file to the archive</comment>
                <decl_stmt><decl><type><name>ArchivePushFileResult</name></type> <name>fileResult</name> <init>= <expr><call><name>archivePushFile</name><argument_list>(
                    <argument><expr><name>walFile</name></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveHeaderCheck</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveModeCheck</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>archiveInfo</name><operator>.</operator><name>pgVersion</name></name></expr></argument>,
                    <argument><expr><name><name>archiveInfo</name><operator>.</operator><name>pgSystemId</name></name></expr></argument>, <argument><expr><name>archiveFile</name></expr></argument>, <argument><expr><call><name>compressTypeEnum</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>cfgOptionInt</name><argument_list>(<argument><expr><name>cfgOptCompressLevel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>archiveInfo</name><operator>.</operator><name>repoList</name></name></expr></argument>, <argument><expr><name><name>archiveInfo</name><operator>.</operator><name>errorList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// If a warning was returned then log it</comment>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>warnIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>warnIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>fileResult</name><operator>.</operator><name>warnList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>warnIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>fileResult</name><operator>.</operator><name>warnList</name></name></expr></argument>, <argument><expr><name>warnIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <comment type="line">// Log success</comment>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"pushed WAL file '%s' to the archive"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>ArchivePushAsyncData</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walPath</name></decl>;</decl_stmt>                                          <comment type="line">// Path to pg_wal/pg_xlog</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>walFileList</name></decl>;</decl_stmt>                                  <comment type="line">// List of wal files to process</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>walFileIdx</name></decl>;</decl_stmt>                                        <comment type="line">// Current index in the list to be processed</comment>
    <decl_stmt><decl><type><name>CompressType</name></type> <name>compressType</name></decl>;</decl_stmt>                                      <comment type="line">// Type of compression for WAL segments</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>compressLevel</name></decl>;</decl_stmt>                                              <comment type="line">// Compression level for wal files</comment>
    <decl_stmt><decl><type><name>ArchivePushCheckResult</name></type> <name>archiveInfo</name></decl>;</decl_stmt>                             <comment type="line">// Archive info</comment>
}</block></struct></type> <name>ArchivePushAsyncData</name>;</typedef>

<function><type><specifier>static</specifier> <name>ProtocolParallelJob</name> <modifier>*</modifier></type>
<name>archivePushAsyncCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>clientIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>clientIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// No special logic based on the client, we'll just get the next job</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>clientIdx</name></expr>;</expr_stmt>

        <comment type="line">// Get a new job if there are any left</comment>
        <decl_stmt><decl><type><name>ArchivePushAsyncData</name> <modifier>*</modifier></type><name>jobData</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileIdx</name></name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walFile</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileIdx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileIdx</name></name><operator>++</operator></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>ProtocolCommand</name> <modifier>*</modifier><specifier>const</specifier></type> <name>command</name> <init>= <expr><call><name>protocolCommandNew</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND_ARCHIVE_PUSH_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>param</name> <init>= <expr><call><name>protocolCommandParam</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walPath</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveHeaderCheck</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveModeCheck</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveInfo</name><operator>.</operator><name>pgVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveInfo</name><operator>.</operator><name>pgSystemId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>compressType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteI32P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>compressLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteStrLstP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveInfo</name><operator>.</operator><name>errorList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Add data for each repo to push to</comment>
            <expr_stmt><expr><call><name>pckWriteArrayBeginP</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>repoListIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>repoListIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveInfo</name><operator>.</operator><name>repoList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>repoListIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ArchivePushFileRepoData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveInfo</name><operator>.</operator><name>repoList</name></name></expr></argument>, <argument><expr><name>repoListIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>pckWriteObjBeginP</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>repoIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>cipherType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>cipherPass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteObjEndP</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>pckWriteArrayEndP</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>protocolParallelJobNew</name><argument_list>(<argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>PROTOCOL_PARALLEL_JOB</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>cmdArchivePushAsync</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cfgCommand</name><argument_list>()</argument_list></call> <operator>==</operator> <name>cfgCmdArchivePush</name> <operator>&amp;&amp;</operator> <call><name>cfgCommandRole</name><argument_list>()</argument_list></call> <operator>==</operator> <name>cfgCmdRoleAsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// PostgreSQL must be local</comment>
    <expr_stmt><expr><call><name>pgIsLocalVerify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Make sure there is a parameter with the wal path</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>commandParam</name> <init>= <expr><call><name>cfgCommandParam</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>commandParam</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>ParamRequiredError</name></expr></argument>, <argument><expr><literal type="string">"WAL path to push required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>ArchivePushAsyncData</name></type> <name>jobData</name> <init>=
        <expr><block>{
            <expr><operator>.</operator><name>walPath</name> <operator>=</operator> <call><name>strLstGet</name><argument_list>(<argument><expr><name>commandParam</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
            <expr><operator>.</operator><name>compressType</name> <operator>=</operator> <call><name>compressTypeEnum</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
            <expr><operator>.</operator><name>compressLevel</name> <operator>=</operator> <call><name>cfgOptionInt</name><argument_list>(<argument><expr><name>cfgOptCompressLevel</name></expr></argument>)</argument_list></call></expr>,
        }</block></expr></init></decl>;</decl_stmt>

        <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// Test for stop file</comment>
            <expr_stmt><expr><call><name>lockStopTest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Get a list of WAL files that are ready for processing</comment>
            <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>walFileList</name></name> <operator>=</operator> <call><name>archivePushProcessList</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>walPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// The archive-push:async command should not have been called unless there are WAL files to process</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>walFileList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"no WAL files to process"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                <argument><expr><literal type="string">"push %u WAL file(s) to archive: %s%s"</literal></expr></argument>, <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>walFileList</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>walFileList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><ternary><condition><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>walFileList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then>
                    <expr><literal type="string">""</literal></expr> </then><else>: <expr><call><name>zNewFmt</name><argument_list>(<argument><expr><literal type="string">"...%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>walFileList</name></name></expr></argument>, <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>walFileList</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Drop files if queue max has been exceeded</comment>
            <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptArchivePushQueueMax</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>archivePushDrop</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>walPath</name></name></expr></argument>, <argument><expr><name><name>jobData</name><operator>.</operator><name>walFileList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>walFileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>walFileIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>walFileList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>walFileIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walFile</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>walFileList</name></name></expr></argument>, <argument><expr><name>walFileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>warning</name> <init>= <expr><call><name>archivePushDropWarning</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>, <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptArchivePushQueueMax</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>archiveAsyncStatusOkWrite</name><argument_list>(<argument><expr><name>archiveModePush</name></expr></argument>, <argument><expr><name>walFile</name></expr></argument>, <argument><expr><name>warning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>warning</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if>
            <comment type="line">// Else continue processing</comment>
            <else>else
            <block>{<block_content>
                <comment type="line">// Check archive info for each repo</comment>
                <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>archiveInfo</name></name> <operator>=</operator> <call><name>archivePushCheck</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Create the parallel executor</comment>
                <decl_stmt><decl><type><name>ProtocolParallel</name> <modifier>*</modifier></type><name>parallelExec</name> <init>= <expr><call><name>protocolParallelNew</name><argument_list>(
                    <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptProtocolTimeout</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>archivePushAsyncCallback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jobData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>processIdx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>processIdx</name> <operator>&lt;=</operator> <call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptProcessMax</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>processIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>protocolParallelClientAdd</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>, <argument><expr><call><name>protocolLocalGet</name><argument_list>(<argument><expr><name>protocolStorageTypeRepo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>processIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <comment type="line">// Process jobs</comment>
                <macro><name>MEM_CONTEXT_TEMP_RESET_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <do>do
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>completed</name> <init>= <expr><call><name>protocolParallelProcess</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>jobIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>jobIdx</name> <operator>&lt;</operator> <name>completed</name></expr>;</condition> <incr><expr><name>jobIdx</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>protocolKeepAlive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// Get the job and job key</comment>
                            <decl_stmt><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>protocolParallelResult</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>processId</name> <init>= <expr><call><name>protocolParallelJobProcessId</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walFile</name> <init>= <expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>protocolParallelJobKey</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <comment type="line">// The job was successful</comment>
                            <if_stmt><if>if <condition>(<expr><call><name>protocolParallelJobErrorCode</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <comment type="line">// Output file warnings</comment>
                                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>fileWarnList</name> <init>= <expr><call><name>pckReadStrLstP</name><argument_list>(<argument><expr><call><name>protocolParallelJobResult</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>warnIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>warnIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>warnIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>LOG_WARN_PID</name><argument_list>(<argument><expr><name>processId</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>, <argument><expr><name>warnIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                                <comment type="line">// Log success</comment>
                                <expr_stmt><expr><call><name>LOG_DETAIL_PID_FMT</name><argument_list>(<argument><expr><name>processId</name></expr></argument>, <argument><expr><literal type="string">"pushed WAL file '%s' to the archive"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <comment type="line">// Write the status file</comment>
                                <expr_stmt><expr><call><name>archiveAsyncStatusOkWrite</name><argument_list>(
                                    <argument><expr><name>archiveModePush</name></expr></argument>, <argument><expr><name>walFile</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>fileWarnList</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Else the job errored</comment>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>LOG_WARN_PID_FMT</name><argument_list>(
                                    <argument><expr><name>processId</name></expr></argument>,
                                    <argument><expr><literal type="string">"could not push WAL file '%s' to the archive (will be retried): [%d] %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>protocolParallelJobErrorCode</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>protocolParallelJobErrorMessage</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>archiveAsyncStatusErrorWrite</name><argument_list>(
                                    <argument><expr><name>archiveModePush</name></expr></argument>, <argument><expr><name>walFile</name></expr></argument>, <argument><expr><call><name>protocolParallelJobErrorCode</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>protocolParallelJobErrorMessage</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>

                            <expr_stmt><expr><call><name>protocolParallelJobFree</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>

                        <comment type="line">// Reset the memory context occasionally so we don't use too much memory or slow down processing</comment>
                        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_RESET</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>
                    while <condition>(<expr><operator>!</operator><call><name>protocolParallelDone</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>
        <comment type="line">// On any global error write a single error file to cover all unprocessed files</comment>
        <macro><name>CATCH_FATAL</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>archiveAsyncStatusErrorWrite</name><argument_list>(<argument><expr><name>archiveModePush</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>errorCode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETHROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
