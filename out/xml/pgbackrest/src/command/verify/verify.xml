<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/command/verify/verify.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Verify Command

Verify contents of the repository.
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/archive/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/check/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/verify/file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/verify/protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/verify/verify.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/compress/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/crypto/cipherBlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/fdWrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoArchive.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoBackup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/manifest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Constants
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERIFY_STATUS_OK</name></cpp:macro>                                            <cpp:value>"ok"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERIFY_STATUS_ERROR</name></cpp:macro>                                         <cpp:value>"error"</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Data Types and Structures
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_VERIFY_ARCHIVE_RESULT_TYPE</name></cpp:macro>                                                                                    \
    <cpp:value>VerifyArchiveResult</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_VERIFY_ARCHIVE_RESULT_FORMAT</name><parameter_list>(<parameter><type><name>value</name></type></parameter>, <parameter><type><name>buffer</name></type></parameter>, <parameter><type><name>bufferSize</name></type></parameter>)</parameter_list></cpp:macro>                                                       \
    <cpp:value>objToLog(&amp;value, "VerifyArchiveResult", buffer, bufferSize)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_VERIFY_BACKUP_RESULT_TYPE</name></cpp:macro>                                                                                     \
    <cpp:value>VerifyBackupResult</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_VERIFY_BACKUP_RESULT_FORMAT</name><parameter_list>(<parameter><type><name>value</name></type></parameter>, <parameter><type><name>buffer</name></type></parameter>, <parameter><type><name>bufferSize</name></type></parameter>)</parameter_list></cpp:macro>                                                        \
    <cpp:value>objToLog(&amp;value, "VerifyBackupResult", buffer, bufferSize)</cpp:value></cpp:define>

<comment type="line">// Structure for verifying repository info files</comment>
<typedef>typedef <type><struct>struct <name>VerifyInfoFile</name>
<block>{
    <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>backup</name></decl>;</decl_stmt>                                             <comment type="line">// Backup.info file contents</comment>
    <decl_stmt><decl><type><name>InfoArchive</name> <modifier>*</modifier></type><name>archive</name></decl>;</decl_stmt>                                           <comment type="line">// Archive.info file contents</comment>
    <decl_stmt><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl>;</decl_stmt>                                             <comment type="line">// Manifest file contents</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>checksum</name></decl>;</decl_stmt>                                         <comment type="line">// File checksum</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>errorCode</name></decl>;</decl_stmt>                                                  <comment type="line">// Error code else 0 for no error</comment>
}</block></struct></type> <name>VerifyInfoFile</name>;</typedef>

<comment type="line">// Job data results structures for archive and backup</comment>
<typedef>typedef <type><struct>struct <name>VerifyArchiveResult</name>
<block>{
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveId</name></decl>;</decl_stmt>                                              <comment type="line">// Archive Id (e.g. 9.6-1, 10-2)</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>totalWalFile</name></decl>;</decl_stmt>                                      <comment type="line">// Total number of WAL files listed in directory on first read</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>totalValidWal</name></decl>;</decl_stmt>                                     <comment type="line">// Total number of WAL that were verified and valid</comment>
    <decl_stmt><decl><type><name>PgWal</name></type> <name>pgWalInfo</name></decl>;</decl_stmt>                                                <comment type="line">// PG version, WAL size, system id</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>walRangeList</name></decl>;</decl_stmt>                                             <comment type="line">// List of WAL file ranges - new item is when WAL is missing</comment>
}</block></struct></type> <name>VerifyArchiveResult</name>;</typedef>

<comment type="line">// WAL range includes the start/stop of sequential WAL and start/stop includes the timeline (e.g. 000000020000000100000005)</comment>
<typedef>typedef <type><struct>struct <name>VerifyWalRange</name>
<block>{
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>stop</name></decl>;</decl_stmt>                                                   <comment type="line">// Last WAL segment in this sequential range</comment>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>                                                  <comment type="line">// First WAL segment in this sequential range</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>invalidFileList</name></decl>;</decl_stmt>                                          <comment type="line">// After all jobs complete, list of VerifyInvalidFile</comment>
}</block></struct></type> <name>VerifyWalRange</name>;</typedef>

<comment type="line">// Invalid file information (not missing but files failing verification) - for archive and backup</comment>
<typedef>typedef <type><struct>struct <name>VerifyInvalidFile</name>
<block>{
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>fileName</name></decl>;</decl_stmt>                                               <comment type="line">// Name of the file (includes path within the stanza)</comment>
    <decl_stmt><decl><type><name>VerifyResult</name></type> <name>reason</name></decl>;</decl_stmt>                                            <comment type="line">// Reason file is invalid (e.g. incorrect checksum)</comment>
}</block></struct></type> <name>VerifyInvalidFile</name>;</typedef>

<comment type="line">// Status result of a backup</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>backupValid</name></decl>,                                                    <comment type="line">// Default: All files in backup label repo passed verification</comment>
    <decl><name>backupInvalid</name></decl>,                                                  <comment type="line">// One of more files in backup label repo failed verification</comment>
    <decl><name>backupMissingManifest</name></decl>,                                          <comment type="line">// Backup manifest missing (backup may have expired)</comment>
    <decl><name>backupInProgress</name></decl>,                                               <comment type="line">// Backup appeared to be in progress (so was skipped)</comment>
}</block></enum></type> <name>VerifyBackupResultStatus</name>;</typedef>

<typedef>typedef <type><struct>struct <name>VerifyBackupResult</name>
<block>{
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>backupLabel</name></decl>;</decl_stmt>                                            <comment type="line">// Label assigned to the backup</comment>
    <decl_stmt><decl><type><name>VerifyBackupResultStatus</name></type> <name>status</name></decl>;</decl_stmt>                                <comment type="line">// Final status of the backup</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fileVerifyComplete</name></decl>;</decl_stmt>                                        <comment type="line">// Have all the files of the backup completed verification?</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>totalFileManifest</name></decl>;</decl_stmt>                                 <comment type="line">// Total number of backup files in the manifest</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>totalFileVerify</name></decl>;</decl_stmt>                                   <comment type="line">// Total number of backup files being verified</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>totalFileValid</name></decl>;</decl_stmt>                                    <comment type="line">// Total number of backup files that were verified and valid</comment>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>backupPrior</name></decl>;</decl_stmt>                                            <comment type="line">// Prior backup that this backup depends on, if any</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pgId</name></decl>;</decl_stmt>                                              <comment type="line">// PG id will be used to find WAL for the backup in the repo</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl>;</decl_stmt>                                         <comment type="line">// PG version will be used with PG id to find WAL in the repo</comment>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveStart</name></decl>;</decl_stmt>                                           <comment type="line">// First WAL segment in the backup</comment>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveStop</name></decl>;</decl_stmt>                                            <comment type="line">// Last WAL segment in the backup</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>invalidFileList</name></decl>;</decl_stmt>                                          <comment type="line">// List of invalid files found in the backup</comment>
}</block></struct></type> <name>VerifyBackupResult</name>;</typedef>

<comment type="line">// Job data stucture for processing and results collection</comment>
<typedef>typedef <type><struct>struct <name>VerifyJobData</name>
<block>{
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>memContext</name></decl>;</decl_stmt>                                         <comment type="line">// Context for memory allocations in this struct</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>archiveIdList</name></decl>;</decl_stmt>                                      <comment type="line">// List of archive ids to verify</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>walPathList</name></decl>;</decl_stmt>                                        <comment type="line">// WAL path list for a single archive id</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>walFileList</name></decl>;</decl_stmt>                                        <comment type="line">// WAL file list for a single WAL path</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>backupList</name></decl>;</decl_stmt>                                         <comment type="line">// List of backups to verify</comment>
    <decl_stmt><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl>;</decl_stmt>                                             <comment type="line">// Manifest contents with list of files to verify</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>manifestFileIdx</name></decl>;</decl_stmt>                                   <comment type="line">// Index of the file within the manifest file list to process</comment>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>currentBackup</name></decl>;</decl_stmt>                                          <comment type="line">// In progress backup, if any</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>InfoPg</name> <modifier>*</modifier></type><name>pgHistory</name></decl>;</decl_stmt>                                        <comment type="line">// Database history list</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>backupProcessing</name></decl>;</decl_stmt>                                          <comment type="line">// Are we processing WAL or are we processing backups</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>manifestCipherPass</name></decl>;</decl_stmt>                               <comment type="line">// Cipher pass for reading backup manifests</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walCipherPass</name></decl>;</decl_stmt>                                    <comment type="line">// Cipher pass for reading WAL files</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupCipherPass</name></decl>;</decl_stmt>                                 <comment type="line">// Cipher pass for reading backup files referenced in a manifest</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>jobErrorTotal</name></decl>;</decl_stmt>                                     <comment type="line">// Total errors that occurred during the job execution</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>archiveIdResultList</name></decl>;</decl_stmt>                                      <comment type="line">// Archive results</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>backupResultList</name></decl>;</decl_stmt>                                         <comment type="line">// Backup results</comment>
}</block></struct></type> <name>VerifyJobData</name>;</typedef>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Helper function to add a file to an invalid file list
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>verifyInvalidFileAdd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>invalidFileList</name></decl></parameter>, <parameter><decl><type><name>VerifyResult</name></type> <name>reason</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>invalidFileList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                 <comment type="line">// Invalid file list to add the filename to</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                          <comment type="line">// Reason for invalid file</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                      <comment type="line">// Name of invalid file</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>invalidFileList</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>fileName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(invalidFileList)</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>VerifyInvalidFile</name></type> <name>invalidFile</name> <init>=
        <expr><block>{
            <expr><operator>.</operator><name>fileName</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>,
            <expr><operator>.</operator><name>reason</name> <operator>=</operator> <name>reason</name></expr>,
        }</block></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name>invalidFileList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>invalidFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Load a file into memory
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>StorageRead</name> <modifier>*</modifier></type>
<name>verifyFileLoad</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pathFileName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pathFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                  <comment type="line">// Fully qualified path/file name</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// Password to open file if encrypted</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pathFileName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Read the file and error if missing</comment>
    <decl_stmt><decl><type><name>StorageRead</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pathFileName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// *read points to a location within result so update result with contents based on necessary filters</comment>
    <decl_stmt><decl><type><name>IoRead</name> <modifier>*</modifier></type><name>read</name> <init>= <expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>cipherBlockFilterGroupAdd</name><argument_list>(
        <argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cipherModeDecrypt</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cryptoHashNew</name><argument_list>(<argument><expr><name>hashTypeSha1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If the file is compressed, add a decompression filter</comment>
    <if_stmt><if>if <condition>(<expr><call><name>compressTypeFromName</name><argument_list>(<argument><expr><name>pathFileName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>compressTypeNone</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>decompressFilter</name><argument_list>(<argument><expr><call><name>compressTypeFromName</name><argument_list>(<argument><expr><name>pathFileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STORAGE_READ</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get status of info files in the repository
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>VerifyInfoFile</name></type>
<name>verifyInfoFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pathFileName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keepFile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pathFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                   <comment type="line">// Fully qualified path/file name</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>keepFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                         <comment type="line">// Should the file be kept in memory?</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// Password to open file if encrypted</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pathFileName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VerifyInfoFile</name></type> <name>result</name> <init>= <expr><block>{<expr><operator>.</operator><name>errorCode</name> <operator>=</operator> <literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>IoRead</name> <modifier>*</modifier></type><name>infoRead</name> <init>= <expr><call><name>storageReadIo</name><argument_list>(<argument><expr><call><name>verifyFileLoad</name><argument_list>(<argument><expr><name>pathFileName</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If directed to keep the loaded file in memory, then move the file into the result, else drain the io and close it</comment>
            <if_stmt><if>if <condition>(<expr><name>keepFile</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>strBeginsWith</name><argument_list>(<argument><expr><name>pathFileName</name></expr></argument>, <argument><expr><name>INFO_BACKUP_PATH_FILE_STR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>backup</name></name> <operator>=</operator> <call><name>infoBackupMove</name><argument_list>(<argument><expr><call><name>infoBackupNewLoad</name><argument_list>(<argument><expr><name>infoRead</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><call><name>strBeginsWith</name><argument_list>(<argument><expr><name>pathFileName</name></expr></argument>, <argument><expr><name>INFO_ARCHIVE_PATH_FILE_STR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>archive</name></name> <operator>=</operator> <call><name>infoArchiveMove</name><argument_list>(<argument><expr><call><name>infoArchiveNewLoad</name><argument_list>(<argument><expr><name>infoRead</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>manifest</name></name> <operator>=</operator> <call><name>manifestMove</name><argument_list>(<argument><expr><call><name>manifestNewLoad</name><argument_list>(<argument><expr><name>infoRead</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ioReadDrain</name><argument_list>(<argument><expr><name>infoRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <decl_stmt><decl><type><specifier>const</specifier> <name>Buffer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>filterResult</name> <init>= <expr><call><name>pckReadBinP</name><argument_list>(
                <argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>infoRead</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CRYPTO_HASH_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>checksum</name></name> <operator>=</operator> <call><name>bufHex</name><argument_list>(<argument><expr><name>filterResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>errorCode</name></name> <operator>=</operator> <call><name>errorCode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>errorMsg</name> <init>= <expr><call><name>strCatZ</name><argument_list>(<argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <call><name>errorTypeCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ChecksumError</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>errorMsg</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathFileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>LOG_DETAIL</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>errorMsg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_STRUCT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the archive.info file
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>InfoArchive</name> <modifier>*</modifier></type>
<name>verifyArchiveInfoFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>InfoArchive</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get the main info file</comment>
        <decl_stmt><decl><type><name>VerifyInfoFile</name></type> <name>verifyArchiveInfo</name> <init>= <expr><call><name>verifyInfoFile</name><argument_list>(<argument><expr><name>INFO_ARCHIVE_PATH_FILE_STR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If the main file did not error, then report on the copy's status and check checksums</comment>
        <if_stmt><if>if <condition>(<expr><name><name>verifyArchiveInfo</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>verifyArchiveInfo</name><operator>.</operator><name>archive</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>infoArchiveMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Attempt to load the copy and report on it's status but don't keep it in memory</comment>
            <decl_stmt><decl><type><name>VerifyInfoFile</name></type> <name>verifyArchiveInfoCopy</name> <init>= <expr><call><name>verifyInfoFile</name><argument_list>(
                <argument><expr><name>INFO_ARCHIVE_PATH_FILE_COPY_STR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If the copy loaded successfully, then check the checksums</comment>
            <if_stmt><if>if <condition>(<expr><name><name>verifyArchiveInfoCopy</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If the info and info.copy checksums don't match each other than one (or both) of the files could be corrupt so</comment>
                <comment type="line">// log a warning but must trust main</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>verifyArchiveInfo</name><operator>.</operator><name>checksum</name></name></expr></argument>, <argument><expr><name><name>verifyArchiveInfoCopy</name><operator>.</operator><name>checksum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL</name><argument_list>(<argument><expr><literal type="string">"archive.info.copy does not match archive.info"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// Attempt to load the copy</comment>
            <decl_stmt><decl><type><name>VerifyInfoFile</name></type> <name>verifyArchiveInfoCopy</name> <init>= <expr><call><name>verifyInfoFile</name><argument_list>(
                <argument><expr><name>INFO_ARCHIVE_PATH_FILE_COPY_STR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If loaded successfully, then return the copy as usable</comment>
            <if_stmt><if>if <condition>(<expr><name><name>verifyArchiveInfoCopy</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>verifyArchiveInfoCopy</name><operator>.</operator><name>archive</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>infoArchiveMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>INFO_ARCHIVE</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the backup.info file
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>InfoBackup</name> <modifier>*</modifier></type>
<name>verifyBackupInfoFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get the main info file</comment>
        <decl_stmt><decl><type><name>VerifyInfoFile</name></type> <name>verifyBackupInfo</name> <init>= <expr><call><name>verifyInfoFile</name><argument_list>(<argument><expr><name>INFO_BACKUP_PATH_FILE_STR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If the main file did not error, then report on the copy's status and check checksums</comment>
        <if_stmt><if>if <condition>(<expr><name><name>verifyBackupInfo</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>verifyBackupInfo</name><operator>.</operator><name>backup</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>infoBackupMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Attempt to load the copy and report on it's status but don't keep it in memory</comment>
            <decl_stmt><decl><type><name>VerifyInfoFile</name></type> <name>verifyBackupInfoCopy</name> <init>= <expr><call><name>verifyInfoFile</name><argument_list>(
                <argument><expr><name>INFO_BACKUP_PATH_FILE_COPY_STR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If the copy loaded successfully, then check the checksums</comment>
            <if_stmt><if>if <condition>(<expr><name><name>verifyBackupInfoCopy</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If the info and info.copy checksums don't match each other than one (or both) of the files could be corrupt so</comment>
                <comment type="line">// log a warning but must trust main</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>verifyBackupInfo</name><operator>.</operator><name>checksum</name></name></expr></argument>, <argument><expr><name><name>verifyBackupInfoCopy</name><operator>.</operator><name>checksum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL</name><argument_list>(<argument><expr><literal type="string">"backup.info.copy does not match backup.info"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// Attempt to load the copy</comment>
            <decl_stmt><decl><type><name>VerifyInfoFile</name></type> <name>verifyBackupInfoCopy</name> <init>= <expr><call><name>verifyInfoFile</name><argument_list>(
                <argument><expr><name>INFO_BACKUP_PATH_FILE_COPY_STR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If loaded successfully, then return the copy as usable</comment>
            <if_stmt><if>if <condition>(<expr><name><name>verifyBackupInfoCopy</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>verifyBackupInfoCopy</name><operator>.</operator><name>backup</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>infoBackupMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the manifest file
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>Manifest</name> <modifier>*</modifier></type>
<name>verifyManifestFile</name><parameter_list>(
    <parameter><decl><type><name>VerifyBackupResult</name> <modifier>*</modifier></type><name>backupResult</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPass</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>currentBackup</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InfoPg</name> <modifier>*</modifier></type><name>pgHistory</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>jobErrorTotal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VERIFY_BACKUP_RESULT</name></expr></argument>, <argument><expr><name>backupResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// The result set for the backup being processed</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// Passphrase to access the manifest file</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>currentBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// Is this possibly a backup currently in progress?</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO_PG</name></expr></argument>, <argument><expr><name>pgHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// Database history</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>jobErrorTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                 <comment type="line">// Pointer to the overall job error total</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>fileName</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>BACKUP_MANIFEST_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get the main manifest file</comment>
        <decl_stmt><decl><type><name>VerifyInfoFile</name></type> <name>verifyManifestInfo</name> <init>= <expr><call><name>verifyInfoFile</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If the main file did not error, then report on the copy's status and check checksums</comment>
        <if_stmt><if>if <condition>(<expr><name><name>verifyManifestInfo</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>verifyManifestInfo</name><operator>.</operator><name>manifest</name></name></expr>;</expr_stmt>

            <comment type="line">// The current in-progress backup is only notional until the main file is checked because the backup may have</comment>
            <comment type="line">// completed by the time the main manifest is checked here. So having a main manifest file means this backup is not</comment>
            <comment type="line">// (or is no longer) the currentBackup.</comment>
            <expr_stmt><expr><name>currentBackup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <comment type="line">// Attempt to load the copy and report on it's status but don't keep it in memory</comment>
            <decl_stmt><decl><type><name>VerifyInfoFile</name></type> <name>verifyManifestInfoCopy</name> <init>= <expr><call><name>verifyInfoFile</name><argument_list>(
                <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INFO_COPY_EXT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If the copy loaded successfully, then check the checksums</comment>
            <if_stmt><if>if <condition>(<expr><name><name>verifyManifestInfoCopy</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If the manifest and manifest.copy checksums don't match each other than one (or both) of the files could be</comment>
                <comment type="line">// corrupt so log a warning but trust main</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>verifyManifestInfo</name><operator>.</operator><name>checksum</name></name></expr></argument>, <argument><expr><name><name>verifyManifestInfoCopy</name><operator>.</operator><name>checksum</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"backup '%s' manifest.copy does not match manifest"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// If this might be an in-progress backup and the main manifest is simply missing, it is assumed the backup is an</comment>
            <comment type="line">// actual in-progress backup and verification is skipped, otherwise, if the main is not simply missing, or this is not</comment>
            <comment type="line">// an in-progress backup then attempt to load the copy.</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>currentBackup</name> <operator>&amp;&amp;</operator> <name><name>verifyManifestInfo</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <call><name>errorTypeCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>FileMissingError</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>currentBackup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>VerifyInfoFile</name></type> <name>verifyManifestInfoCopy</name> <init>= <expr><call><name>verifyInfoFile</name><argument_list>(
                    <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INFO_COPY_EXT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// If loaded successfully, then return the copy as usable</comment>
                <if_stmt><if>if <condition>(<expr><name><name>verifyManifestInfoCopy</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"%s/backup.manifest is missing or unusable, using copy"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>verifyManifestInfoCopy</name><operator>.</operator><name>manifest</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>verifyManifestInfo</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <call><name>errorTypeCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>FileMissingError</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <name><name>verifyManifestInfoCopy</name><operator>.</operator><name>errorCode</name></name> <operator>==</operator> <call><name>errorTypeCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>FileMissingError</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>backupMissingManifest</name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"manifest missing for '%s' - backup may have expired"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>backupInProgress</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"backup '%s' appears to be in progress, skipping"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// If found a usable manifest then check that the database it was based on is in the history</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestData</name> <modifier>*</modifier></type><name>manData</name> <init>= <expr><call><name>manifestData</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Confirm the PG database information from the manifest is in the history list</comment>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>infoPgIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>infoPgIdx</name> <operator>&lt;</operator> <call><name>infoPgDataTotal</name><argument_list>(<argument><expr><name>pgHistory</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>infoPgIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>InfoPgData</name></type> <name>pgHistoryData</name> <init>= <expr><call><name>infoPgData</name><argument_list>(<argument><expr><name>pgHistory</name></expr></argument>, <argument><expr><name>infoPgIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>pgHistoryData</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name><name>manData</name><operator>-&gt;</operator><name>pgId</name></name> <operator>&amp;&amp;</operator> <name><name>pgHistoryData</name><operator>.</operator><name>systemId</name></name> <operator>==</operator> <name><name>manData</name><operator>-&gt;</operator><name>pgSystemId</name></name> <operator>&amp;&amp;</operator>
                    <name><name>pgHistoryData</name><operator>.</operator><name>version</name></name> <operator>==</operator> <name><name>manData</name><operator>-&gt;</operator><name>pgVersion</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="line">// If the PG data is not found in the backup.info history, then error and reset the result</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                    <argument><expr><literal type="string">"'%s' may not be recoverable - PG data (id %u, version %s, system-id %"</literal> <name>PRIu64</name> <literal type="string">") is not in the backup.info"</literal>
                        <literal type="string">" history, skipping"</literal></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>manData</name><operator>-&gt;</operator><name>pgId</name></name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>pgVersion</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>manData</name><operator>-&gt;</operator><name>pgSystemId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>manifestFree</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>manifestMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If the result is NULL and the backup status has not yet been set, then the backup is unusable (invalid)</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>backupResult</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>backupValid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>backupInvalid</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>jobErrorTotal</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Check the history in the info files
***********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>verifyPgHistory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InfoPg</name> <modifier>*</modifier></type><name>archiveInfoPg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InfoPg</name> <modifier>*</modifier></type><name>backupInfoPg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO_PG</name></expr></argument>, <argument><expr><name>archiveInfoPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <comment type="line">// Postgres information from the archive.info file</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO_PG</name></expr></argument>, <argument><expr><name>backupInfoPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                 <comment type="line">// Postgres information from the backup.info file</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Check archive.info and backup.info current PG data matches. If there is a mismatch, verify cannot continue since</comment>
        <comment type="line">// the database is not considered accessible during the verify command so no way to tell which would be valid.</comment>
        <decl_stmt><decl><type><name>InfoPgData</name></type> <name>archiveInfoPgData</name> <init>= <expr><call><name>infoPgData</name><argument_list>(<argument><expr><name>archiveInfoPg</name></expr></argument>, <argument><expr><call><name>infoPgDataCurrentId</name><argument_list>(<argument><expr><name>archiveInfoPg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>InfoPgData</name></type> <name>backupInfoPgData</name> <init>= <expr><call><name>infoPgData</name><argument_list>(<argument><expr><name>backupInfoPg</name></expr></argument>, <argument><expr><call><name>infoPgDataCurrentId</name><argument_list>(<argument><expr><name>backupInfoPg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>checkStanzaInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>archiveInfoPgData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>backupInfoPgData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>archiveInfoHistoryTotal</name> <init>= <expr><call><name>infoPgDataTotal</name><argument_list>(<argument><expr><name>archiveInfoPg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupInfoHistoryTotal</name> <init>= <expr><call><name>infoPgDataTotal</name><argument_list>(<argument><expr><name>backupInfoPg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>errMsg</name> <init>= <expr><call><name>strNewZ</name><argument_list>(<argument><expr><literal type="string">"archive and backup history lists do not match"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>archiveInfoHistoryTotal</name> <operator>!=</operator> <name>backupInfoHistoryTotal</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>errMsg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Confirm the lists are the same</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>infoPgIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>infoPgIdx</name> <operator>&lt;</operator> <name>archiveInfoHistoryTotal</name></expr>;</condition> <incr><expr><name>infoPgIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>InfoPgData</name></type> <name>archiveInfoPgHistory</name> <init>= <expr><call><name>infoPgData</name><argument_list>(<argument><expr><name>archiveInfoPg</name></expr></argument>, <argument><expr><name>infoPgIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>InfoPgData</name></type> <name>backupInfoPgHistory</name> <init>= <expr><call><name>infoPgData</name><argument_list>(<argument><expr><name>backupInfoPg</name></expr></argument>, <argument><expr><name>infoPgIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>archiveInfoPgHistory</name><operator>.</operator><name>id</name></name> <operator>!=</operator> <name><name>backupInfoPgHistory</name><operator>.</operator><name>id</name></name> <operator>||</operator>
                <name><name>archiveInfoPgHistory</name><operator>.</operator><name>systemId</name></name> <operator>!=</operator> <name><name>backupInfoPgHistory</name><operator>.</operator><name>systemId</name></name> <operator>||</operator>
                <name><name>archiveInfoPgHistory</name><operator>.</operator><name>version</name></name> <operator>!=</operator> <name><name>backupInfoPgHistory</name><operator>.</operator><name>version</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>errMsg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Populate the WAL ranges from the provided, sorted, WAL files list for a given archiveId
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>verifyCreateArchiveIdRange</name><parameter_list>(<parameter><decl><type><name>VerifyArchiveResult</name> <modifier>*</modifier></type><name>archiveIdResult</name></decl></parameter>, <parameter><decl><type><name>StringList</name> <modifier>*</modifier></type><name>walFileList</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>jobErrorTotal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VERIFY_ARCHIVE_RESULT</name></expr></argument>, <argument><expr><name>archiveIdResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// The result set for the archive Id being processed</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>walFileList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                  <comment type="line">// Sorted (ascending) list of WAL files in a timeline</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>jobErrorTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                     <comment type="line">// Pointer to the overall job error total</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>archiveIdResult</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walFileList</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>walFileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// Initialize the WAL range</comment>
    <decl_stmt><decl><type><name>VerifyWalRange</name> <modifier>*</modifier></type><name>walRange</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// If there is a WAL range for this archiveID, get the last one. If there is no timeline change then continue updating the last</comment>
    <comment type="line">// WAL range.</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>walRangeList</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>strEq</name><argument_list>(
            <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>VerifyWalRange</name> <operator>*</operator><operator>)</operator><call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>walRangeList</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>stop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>walFileList</name></expr></argument>, <argument><expr><name>walFileIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAL_SEGMENT_NAME_SIZE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>walRange</name> <operator>=</operator> <call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>walRangeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <do>do
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>walSegment</name> <init>= <expr><call><name>strSubN</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>walFileList</name></expr></argument>, <argument><expr><name>walFileIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAL_SEGMENT_NAME_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If walSegment found ends in FF for PG versions 9.2 or less then skip it but log error because it should not exist and</comment>
        <comment type="line">// PostgreSQL will ignore it</comment>
        <if_stmt><if>if <condition>(<expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>pgWalInfo</name><operator>.</operator><name>version</name></name> <operator>&lt;=</operator> <name>PG_VERSION_92</name> <operator>&amp;&amp;</operator> <call><name>strEndsWithZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>, <argument><expr><literal type="string">"FF"</literal></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"invalid WAL '%s' for '%s' exists, skipping"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>jobErrorTotal</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

            <comment type="line">// Remove the file from the original list so no attempt is made to verify it</comment>
            <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name>walFileList</name></expr></argument>, <argument><expr><name>walFileIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// The lists are sorted so look ahead to see if this is a duplicate of the next one in the list</comment>
        <if_stmt><if>if <condition>(<expr><name>walFileIdx</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>walFileList</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>, <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>walFileList</name></expr></argument>, <argument><expr><name>walFileIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAL_SEGMENT_NAME_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"duplicate WAL '%s' for '%s' exists, skipping"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>jobErrorTotal</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>bool</name></type> <name>foundDup</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

                <comment type="line">// Remove all duplicates of this WAL, including this WAL, from the list</comment>
                <while>while <condition>(<expr><name>walFileIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>walFileList</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>foundDup</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>, <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>walFileList</name></expr></argument>, <argument><expr><name>walFileIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAL_SEGMENT_NAME_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name>walFileList</name></expr></argument>, <argument><expr><name>walFileIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>foundDup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></while>

                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Initialize the range if it has not yet been initialized and continue to next</comment>
        <if_stmt><if>if <condition>(<expr><name>walRange</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <operator>!</operator><call><name>strEq</name><argument_list>(
                <argument><expr><call><name>walSegmentNext</name><argument_list>(<argument><expr><name><name>walRange</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>archiveIdResult</name><operator>-&gt;</operator><name>pgWalInfo</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>pgWalInfo</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Add the initialized wal range to the range list</comment>
            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(archiveIdResult-&gt;walRangeList)</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>VerifyWalRange</name></type> <name>walRangeNew</name> <init>=
                <expr><block>{
                    <expr><operator>.</operator><name>start</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>,
                    <expr><operator>.</operator><name>stop</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>,
                    <expr><operator>.</operator><name>invalidFileList</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VerifyInvalidFile</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr>,
                }</block></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>walRangeList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>walRangeNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Set the current wal range being processed to what was just added</comment>
            <expr_stmt><expr><name>walRange</name> <operator>=</operator> <call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>walRangeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// If the next WAL is the appropriate distance away, then there is no gap</comment>
        <else>else
        <block>{<block_content>
            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(archiveIdResult-&gt;walRangeList)</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><name><name>walRange</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>walRange</name><operator>-&gt;</operator><name>stop</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>walFileIdx</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
    while <condition>(<expr><name>walFileIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>walFileList</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Return verify jobs for the archive
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>ProtocolParallelJob</name> <modifier>*</modifier></type>
<name>verifyArchive</name><parameter_list>(<parameter><decl><type><name>VerifyJobData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>jobData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>jobData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Process archive files, if any</comment>
        <while>while <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveIdList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Add archiveId to the result list if the list is empty or the last processed is not equal to the current archiveId</comment>
            <if_stmt><if>if <condition>(<expr><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveIdResultList</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>!</operator><call><name>strEq</name><argument_list>(
                    <argument><expr><operator>(</operator><operator>(</operator><name>VerifyArchiveResult</name> <operator>*</operator><operator>)</operator><call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveIdResultList</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>archiveId</name></expr></argument>,
                    <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveIdList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>archiveId</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveIdList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(jobData-&gt;archiveIdResultList)</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>VerifyArchiveResult</name></type> <name>archiveIdResult</name> <init>=
                    <expr><block>{
                        <expr><operator>.</operator><name>archiveId</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr>,
                        <expr><operator>.</operator><name>walRangeList</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VerifyWalRange</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr>,
                    }</block></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveIdResultList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>archiveIdResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Free the old WAL path list</comment>
                <expr_stmt><expr><call><name>strLstFree</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walPathList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Get the WAL paths for the archive Id</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>archiveIdPath</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>jobData-&gt;memContext</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>walPathList</name></name> <operator>=</operator> <call><name>strLstSort</name><argument_list>(
                        <argument><expr><call><name>storageListP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>archiveIdPath</name></expr></argument>, <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <name>WAL_SEGMENT_DIR_REGEXP_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// If there are WAL paths then get the file lists</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walPathList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Get the archive id info for the current (last) archive id being processed</comment>
                <decl_stmt><decl><type><name>VerifyArchiveResult</name> <modifier>*</modifier></type><name>archiveResult</name> <init>= <expr><call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveIdResultList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <do>do
                <block>{<block_content>
                    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>walPath</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walPathList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Get the WAL files for the first item in the WAL paths list and initialize WAL info and ranges</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Free the old WAL file list</comment>
                        <expr_stmt><expr><call><name>strLstFree</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Get WAL file list</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walFilePath</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(
                            <argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveResult</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>jobData-&gt;memContext</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name> <operator>=</operator> <call><name>strLstSort</name><argument_list>(
                                <argument><expr><call><name>storageListP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>walFilePath</name></expr></argument>, <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <name>WAL_SEGMENT_FILE_REGEXP_STR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>archiveResult</name><operator>-&gt;</operator><name>pgWalInfo</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <comment type="line">// Initialize the WAL segment size from the first WAL</comment>
                                <decl_stmt><decl><type><name>StorageRead</name> <modifier>*</modifier></type><name>walRead</name> <init>= <expr><call><name>verifyFileLoad</name><argument_list>(
                                    <argument><expr><call><name>strNewFmt</name><argument_list>(
                                        <argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveResult</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walCipherPass</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <decl_stmt><decl><type><name>PgWal</name></type> <name>walInfo</name> <init>= <expr><call><name>pgWalFromBuffer</name><argument_list>(<argument><expr><call><name>storageGetP</name><argument_list>(<argument><expr><name>walRead</name></expr></argument>, <argument><expr><operator>.</operator><name>exactSize</name> <operator>=</operator> <name>PG_WAL_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <expr_stmt><expr><name><name>archiveResult</name><operator>-&gt;</operator><name>pgWalInfo</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>walInfo</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>archiveResult</name><operator>-&gt;</operator><name>pgWalInfo</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name><name>walInfo</name><operator>.</operator><name>version</name></name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <comment type="line">// Add total number of WAL files in the directory to the total WAL - this number will include</comment>
                            <comment type="line">// duplicates, if any, that will be filtered out and not checked but will be reported as errors in the</comment>
                            <comment type="line">// log</comment>
                            <expr_stmt><expr><name><name>archiveResult</name><operator>-&gt;</operator><name>totalWalFile</name></name> <operator>+=</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>verifyCreateArchiveIdRange</name><argument_list>(<argument><expr><name>archiveResult</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>jobData</name><operator>-&gt;</operator><name>jobErrorTotal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// If there are WAL files, then verify them</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Get the fully qualified file name and checksum</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileName</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>filePathName</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(
                            <argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveResult</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>checksum</name> <init>= <expr><call><name>strSubN</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>WAL_SEGMENT_NAME_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>HASH_TYPE_SHA1_SIZE_HEX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Set up the job</comment>
                        <decl_stmt><decl><type><name>ProtocolCommand</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>protocolCommandNew</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND_VERIFY_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>param</name> <init>= <expr><call><name>protocolCommandParam</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>compressTypeFromName</name><argument_list>(<argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>archiveResult</name><operator>-&gt;</operator><name>pgWalInfo</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walCipherPass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Assign job to result, prepending the archiveId to the key for consistency with backup processing</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>jobKey</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveResult</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                        <block>{<block_content>
                            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>protocolParallelJobNew</name><argument_list>(<argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>jobKey</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Remove the file to process from the list</comment>
                        <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// If this is the last file to process for this timeline, then remove the path</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walFileList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walPathList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="line">// No valid WAL to process (may be only duplicates or nothing in WAL path) - remove WAL path from the list</comment>
                        <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(
                            <argument><expr><literal type="string">"path '%s/%s' does not contain any valid WAL to be processed"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveResult</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walPathList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <comment type="line">// If a job was found to be processed then break out to process it</comment>
                    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block>
                while <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walPathList</name></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

                <comment type="line">// If this is the last timeline to process for this archiveId, then remove the archiveId</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>walPathList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveIdList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// If a file was sent to be processed then break so we can process it</comment>
                <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// Log that no WAL paths exist in the archive Id dir - remove the archive Id from the list (nothing to process)</comment>
                <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"archive path '%s' is empty"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveIdList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveIdList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>PROTOCOL_PARALLEL_JOB</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Verify the job data backups
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>ProtocolParallelJob</name> <modifier>*</modifier></type>
<name>verifyBackup</name><parameter_list>(<parameter><decl><type><name>VerifyJobData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>jobData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>jobData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Process backup files, if any</comment>
        <while>while <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If result list is empty or the last processed is not equal to the backup being processed, then initialize the backup</comment>
            <comment type="line">// data and results</comment>
            <if_stmt><if>if <condition>(<expr><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupResultList</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>!</operator><call><name>strEq</name><argument_list>(
                    <argument><expr><operator>(</operator><operator>(</operator><name>VerifyBackupResult</name> <operator>*</operator><operator>)</operator><call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupResultList</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>backupLabel</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(jobData-&gt;backupResultList)</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>VerifyBackupResult</name></type> <name>backupResultNew</name> <init>=
                    <expr><block>{
                        <expr><operator>.</operator><name>backupLabel</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
                        <expr><operator>.</operator><name>invalidFileList</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VerifyInvalidFile</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr>,
                    }</block></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Add the backup to the result list</comment>
                    <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupResultList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>backupResultNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Get the result just added so it can be updated directly</comment>
                <decl_stmt><decl><type><name>VerifyBackupResult</name> <modifier>*</modifier></type><name>backupResult</name> <init>= <expr><call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupResultList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// If currentBackup is set (meaning the newest backup label on disk was not in the db:current section when the</comment>
                <comment type="line">// backup.info file was read) and this is the same label, then set inProgessBackup to true, else false.</comment>
                <comment type="line">// inProgressBackup may be changed in verifyManifestFile if a main backup.manifest exists since that would indicate</comment>
                <comment type="line">// the backup completed during the verify process.</comment>
                <decl_stmt><decl><type><name>bool</name></type> <name>inProgressBackup</name> <init>= <expr><call><name>strEq</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>currentBackup</name></name></expr></argument>, <argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Get a usable backup manifest file</comment>
                <decl_stmt><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name> <init>= <expr><call><name>verifyManifestFile</name><argument_list>(
                    <argument><expr><name>backupResult</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifestCipherPass</name></name></expr></argument>, <argument><expr><name>inProgressBackup</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>pgHistory</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>jobData</name><operator>-&gt;</operator><name>jobErrorTotal</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// If a usable backup.manifest file is not found</comment>
                <if_stmt><if>if <condition>(<expr><name>manifest</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Remove this backup from the processing list</comment>
                    <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// No files to process so continue to the next backup in the list</comment>
                    <continue>continue;</continue>
                </block_content>}</block></if>
                <comment type="line">// Initialize the backup results and manifest for processing</comment>
                <else>else
                <block>{<block_content>
                    <comment type="line">// Move the manifest to the jobData for processing</comment>
                    <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name> <operator>=</operator> <call><name>manifestMove</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>memContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Initialize the jobData</comment>
                    <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>jobData-&gt;memContext</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <comment type="line">// Get the cipher subpass used to decrypt files in the backup and initialize the file list index</comment>
                        <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupCipherPass</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><call><name>manifestCipherSubPass</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifestFileIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block>
                    <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestData</name> <modifier>*</modifier></type><name>manData</name> <init>= <expr><call><name>manifestData</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(jobData-&gt;backupResultList)</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>totalFileManifest</name></name> <operator>=</operator> <call><name>manifestFileTotal</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>backupPrior</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>backupLabelPrior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>pgId</name></name> <operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>pgId</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>pgVersion</name></name> <operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>pgVersion</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>archiveStart</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>archiveStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>archiveStop</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>archiveStop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>
                    <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <decl_stmt><decl><type><name>VerifyBackupResult</name> <modifier>*</modifier></type><name>backupResult</name> <init>= <expr><call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupResultList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Process any files in the manifest</comment>
            <if_stmt><if>if <condition>(<expr><name><name>jobData</name><operator>-&gt;</operator><name>manifestFileIdx</name></name> <operator>&lt;</operator> <call><name>manifestFileTotal</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <do>do
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFile</name></type> <name>fileData</name> <init>= <expr><call><name>manifestFile</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifestFileIdx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Track the files verified in order to determine when the processing of the backup is complete</comment>
                    <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>totalFileVerify</name></name><operator>++</operator></expr>;</expr_stmt>

                    <comment type="line">// Check the file if it is not zero-length or not bundled</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>fileData</name><operator>.</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>manifestData</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>bundle</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Check if the file is referenced in a prior backup</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileBackupLabel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>fileData</name><operator>.</operator><name>reference</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// If the prior backup is not in the result list, then that backup was never processed (likely due to</comment>
                            <comment type="line">// the --set option) so verify the file</comment>
                            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupPriorIdx</name> <init>= <expr><call><name>lstFindIdx</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupResultList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fileData</name><operator>.</operator><name>reference</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name>backupPriorIdx</name> <operator>==</operator> <name>LIST_NOT_FOUND</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>fileBackupLabel</name> <operator>=</operator> <name><name>fileData</name><operator>.</operator><name>reference</name></name></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Else the backup this file references has a result so check the processing state for the referenced</comment>
                            <comment type="line">// backup</comment>
                            <else>else
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>VerifyBackupResult</name> <modifier>*</modifier></type><name>backupResultPrior</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupResultList</name></name></expr></argument>, <argument><expr><name>backupPriorIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <comment type="line">// If the verify-state of the backup is not complete then verify the file</comment>
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>backupResultPrior</name><operator>-&gt;</operator><name>fileVerifyComplete</name></name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>fileBackupLabel</name> <operator>=</operator> <name><name>fileData</name><operator>.</operator><name>reference</name></name></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <comment type="line">// Else skip verification</comment>
                                <else>else
                                <block>{<block_content>
                                    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>priorFile</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(
                                        <argument><expr><literal type="string">"%s/%s%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>fileData</name><operator>.</operator><name>reference</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>fileData</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>compressExtStr</name><argument_list>(<argument><expr><operator>(</operator><call><name>manifestData</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>backupOptionCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupPriorInvalidIdx</name> <init>= <expr><call><name>lstFindIdx</name><argument_list>(<argument><expr><name><name>backupResultPrior</name><operator>-&gt;</operator><name>invalidFileList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>priorFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                    <comment type="line">// If the file is in the invalid file list of the prior backup where it is referenced then add</comment>
                                    <comment type="line">// the file as invalid to this backup result and set the backup result status; since already</comment>
                                    <comment type="line">// logged an error on this file, don't log again</comment>
                                    <if_stmt><if>if <condition>(<expr><name>backupPriorInvalidIdx</name> <operator>!=</operator> <name>LIST_NOT_FOUND</name></expr>)</condition>
                                    <block>{<block_content>
                                        <decl_stmt><decl><type><name>VerifyInvalidFile</name> <modifier>*</modifier></type><name>invalidFile</name> <init>= <expr><call><name>lstGet</name><argument_list>(
                                            <argument><expr><name><name>backupResultPrior</name><operator>-&gt;</operator><name>invalidFileList</name></name></expr></argument>, <argument><expr><name>backupPriorInvalidIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                        <expr_stmt><expr><call><name>verifyInvalidFileAdd</name><argument_list>(
                                            <argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>invalidFileList</name></name></expr></argument>, <argument><expr><name><name>invalidFile</name><operator>-&gt;</operator><name>reason</name></name></expr></argument>, <argument><expr><name><name>invalidFile</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>backupInvalid</name></expr>;</expr_stmt>
                                    </block_content>}</block></if>
                                    <comment type="line">// Else file in prior backup was valid so increment total valid files for this backup</comment>
                                    <else>else
                                    <block>{<block_content>
                                        <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>totalFileValid</name></name><operator>++</operator></expr>;</expr_stmt>
                                    </block_content>}</block></else></if_stmt>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if>
                        <comment type="line">// Else file is not referenced in a prior backup</comment>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>fileBackupLabel</name> <operator>=</operator> <name><name>backupResult</name><operator>-&gt;</operator><name>backupLabel</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                        <comment type="line">// If backup label is not null then send it off for processing</comment>
                        <if_stmt><if>if <condition>(<expr><name>fileBackupLabel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// Set up the job</comment>
                            <decl_stmt><decl><type><name>ProtocolCommand</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>protocolCommandNew</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND_VERIFY_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>param</name> <init>= <expr><call><name>protocolCommandParam</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>filePathName</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(
                                    <argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/%s%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileBackupLabel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>fileData</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>compressExtStr</name><argument_list>(<argument><expr><operator>(</operator><call><name>manifestData</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>backupOptionCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name><name>fileData</name><operator>.</operator><name>bundleId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(
                                    <argument><expr><name>param</name></expr></argument>,
                                    <argument><expr><call><name>strNewFmt</name><argument_list>(
                                        <argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>MANIFEST_PATH_BUNDLE</name> <literal type="string">"/%"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileBackupLabel</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name><name>fileData</name><operator>.</operator><name>bundleId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>fileData</name><operator>.</operator><name>bundleOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>fileData</name><operator>.</operator><name>sizeRepo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>

                            <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupOptionCompressType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <comment type="line">// If the checksum is not present in the manifest, it will be calculated by manifest load</comment>
                            <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name><name>fileData</name><operator>.</operator><name>checksumSha1</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>fileData</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupCipherPass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// Assign job to result (prepend backup label being processed to the key since some files are in a prior</comment>
                            <comment type="line">// backup)</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>jobKey</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                            <block>{<block_content>
                                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>protocolParallelJobNew</name><argument_list>(<argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>jobKey</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block>
                            <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Else mark the zero-length file as valid</comment>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>totalFileValid</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <comment type="line">// Increment the index to point to the next file</comment>
                    <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifestFileIdx</name></name><operator>++</operator></expr>;</expr_stmt>

                    <comment type="line">// If this was the last file to process for this backup, then free the manifest and remove this backup from the</comment>
                    <comment type="line">// processing list</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>jobData</name><operator>-&gt;</operator><name>manifestFileIdx</name></name> <operator>==</operator> <name><name>backupResult</name><operator>-&gt;</operator><name>totalFileManifest</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>manifestFree</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// If a job was found to be processed then break out to process it</comment>
                    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block>
                while <condition>(<expr><name><name>jobData</name><operator>-&gt;</operator><name>manifestFileIdx</name></name> <operator>&lt;</operator> <name><name>backupResult</name><operator>-&gt;</operator><name>totalFileManifest</name></name></expr>)</condition>;</do>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">// Nothing to process so report an error, free the manifest, set the status, and remove the backup from processing</comment>
                <comment type="line">// list</comment>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"backup '%s' manifest does not contain any target files to verify"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>jobErrorTotal</name></name><operator>++</operator></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>manifestFree</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>backupInvalid</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="line">// If a job was found to be processed then break out to process it</comment>
            <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>PROTOCOL_PARALLEL_JOB</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Process the job data
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>ProtocolParallelJob</name> <modifier>*</modifier></type>
<name>verifyJobCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>clientIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                          <comment type="line">// Pointer to the job data</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>clientIdx</name></expr>;</expr_stmt>                                            <comment type="line">// Client index (not used for this process)</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Initialize the result</comment>
    <decl_stmt><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VerifyJobData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>jobData</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>jobData</name><operator>-&gt;</operator><name>backupProcessing</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>verifyArchive</name><argument_list>(<argument><expr><name>jobData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Set the backupProcessing flag if the archive processing is finished so backup processing can begin immediately after</comment>
        <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupProcessing</name></name> <operator>=</operator> <call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>archiveIdList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>jobData</name><operator>-&gt;</operator><name>backupProcessing</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Only begin backup verification if the last archive result was processed</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>verifyBackup</name><argument_list>(<argument><expr><name>jobData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>PROTOCOL_PARALLEL_JOB</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Helper function for returning a string corresponding to the result code
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>verifyErrorMsg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VerifyResult</name></type> <name>verifyResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>verifyResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// Result code from the verifyFile() function</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>verifyResult</name> <operator>!=</operator> <name>verifyOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>verifyResult</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>verifyFileMissing</name></expr>:</case>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><literal type="string">"file missing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <case>case <expr><name>verifyChecksumMismatch</name></expr>:</case>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><literal type="string">"invalid checksum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <case>case <expr><name>verifySizeInvalid</name></expr>:</case>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><literal type="string">"invalid size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <default>default:</default>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>verifyResult</name> <operator>==</operator> <name>verifyOtherError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><literal type="string">"invalid result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Helper function to output a log message based on job result that is not verifyOk and return an error count
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>verifyLogInvalidResult</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileType</name></decl></parameter>, <parameter><decl><type><name>VerifyResult</name></type> <name>verifyResult</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>processId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>filePathName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>fileType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                      <comment type="line">// Indicates archive or backup file</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>verifyResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// Result code from the verifyFile() function</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>processId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                       <comment type="line">// Process Id reporting the result</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                  <comment type="line">// File for which results are being reported</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>fileType</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>filePathName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Log a warning because the WAL may have gone missing if expire came through and removed it</comment>
    <comment type="line">// legitimately so it is not necessarily an error so the jobErrorTotal should not be incremented</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>fileType</name></expr></argument>, <argument><expr><name>STORAGE_REPO_ARCHIVE_STR</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>verifyResult</name> <operator>==</operator> <name>verifyFileMissing</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOG_WARN_PID_FMT</name><argument_list>(<argument><expr><name>processId</name></expr></argument>, <argument><expr><literal type="string">"%s '%s'"</literal></expr></argument>, <argument><expr><call><name>verifyErrorMsg</name><argument_list>(<argument><expr><name>verifyResult</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LOG_INFO_PID_FMT</name><argument_list>(<argument><expr><name>processId</name></expr></argument>, <argument><expr><literal type="string">"%s '%s'"</literal></expr></argument>, <argument><expr><call><name>verifyErrorMsg</name><argument_list>(<argument><expr><name>verifyResult</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Helper function to set the currently processing backup label, if any, and check that the archiveIds are in the db history
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>verifySetBackupCheckArchive</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>backupList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InfoBackup</name> <modifier>*</modifier></type><name>backupInfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>archiveIdList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InfoPg</name> <modifier>*</modifier></type><name>pgHistory</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>jobErrorTotal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>backupList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <comment type="line">// List of backup labels in the backup directory</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <comment type="line">// Contents of the backup.info file</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>archiveIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="line">// List of archiveIds in the archive directory</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO_PG</name></expr></argument>, <argument><expr><name>pgHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// Pointer to InfoPg of archive.info for accessing PG history</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>jobErrorTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                 <comment type="line">// Pointer to overall job error total</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// If there are backups, set the last backup as current if it is not in backup.info - if it is, then it is complete, else</comment>
        <comment type="line">// it will be checked later</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Get the last backup as current if it is not in backup.info current list</comment>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>backupLabel</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>, <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>infoBackupLabelExists</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Duplicate the string into the prior context</comment>
                <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If there are archive directories on disk, make sure they are in the database history list</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>archiveIdList</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>archiveIdHistoryList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>histIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>histIdx</name> <operator>&lt;</operator> <call><name>infoPgDataTotal</name><argument_list>(<argument><expr><name>pgHistory</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>histIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>archiveIdHistoryList</name></expr></argument>, <argument><expr><call><name>infoPgArchiveId</name><argument_list>(<argument><expr><name>pgHistory</name></expr></argument>, <argument><expr><name>histIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <comment type="line">// Sort the history list</comment>
            <expr_stmt><expr><call><name>strLstSort</name><argument_list>(<argument><expr><call><name>strLstComparatorSet</name><argument_list>(<argument><expr><name>archiveIdHistoryList</name></expr></argument>, <argument><expr><name>archiveIdComparator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>missingFromHistory</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Check if the archiveId on disk exists in the archive.info history list and report it if not</comment>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>archiveIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>archiveIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>archiveIdList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>archiveIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>archiveId</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>archiveIdList</name></expr></argument>, <argument><expr><name>archiveIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>archiveIdHistoryList</name></expr></argument>, <argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>missingFromHistory</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><call><name>strEmpty</name><argument_list>(<argument><expr><name>missingFromHistory</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>archiveId</name></expr> </then><else>: <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">", %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEmpty</name><argument_list>(<argument><expr><name>missingFromHistory</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"archiveIds '%s' are not in the archive.info history list"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>missingFromHistory</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>jobErrorTotal</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Add the file to the invalid file list for the range in which it exists
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>verifyAddInvalidWalFile</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>walRangeList</name></decl></parameter>, <parameter><decl><type><name>VerifyResult</name></type> <name>fileResult</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>walRangeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// List of WAL ranges for an archive Id</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>fileResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                      <comment type="line">// Result of verifyFile()</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                      <comment type="line">// File name (without the REPO prefix)</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// WAL segment, i.e. 000000010000000000000005</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walRangeList</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>fileName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walSegment</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>walIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>walIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>walRangeList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>walIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>VerifyWalRange</name> <modifier>*</modifier></type><name>walRange</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>walRangeList</name></expr></argument>, <argument><expr><name>walIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If the WAL segment is less/equal to the stop file then it falls in this range since ranges are sorted by stop file in</comment>
            <comment type="line">// ascending order, therefore first one found is the range</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><name><name>walRange</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Add the file to the range where it was found and exit the loop</comment>
                <expr_stmt><expr><call><name>verifyInvalidFileAdd</name><argument_list>(<argument><expr><name><name>walRange</name><operator>-&gt;</operator><name>invalidFileList</name></name></expr></argument>, <argument><expr><name>fileResult</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Create file errors string
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>verifyCreateFileErrorsStr</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>errMissing</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>errChecksum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>errSize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>errOther</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>verboseText</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>errMissing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                      <comment type="line">// Number of files missing</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>errChecksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                     <comment type="line">// Number of files with checksum errors</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>errSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                         <comment type="line">// Number of files with invalid size</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>errOther</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                        <comment type="line">// Number of files with other errors</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>verboseText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                     <comment type="line">// Is verbose output requested</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// List all if verbose text, otherwise only list if type has errors</comment>
        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
            <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\n    %s%s%s%s"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name>verboseText</name> <operator>||</operator> <name>errMissing</name></expr> ?</condition><then> <expr><call><name>zNewFmt</name><argument_list>(<argument><expr><literal type="string">"missing: %u, "</literal></expr></argument>, <argument><expr><name>errMissing</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
            <argument><expr><ternary><condition><expr><name>verboseText</name> <operator>||</operator> <name>errChecksum</name></expr> ?</condition><then> <expr><call><name>zNewFmt</name><argument_list>(<argument><expr><literal type="string">"checksum invalid: %u, "</literal></expr></argument>, <argument><expr><name>errChecksum</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
            <argument><expr><ternary><condition><expr><name>verboseText</name> <operator>||</operator> <name>errSize</name></expr> ?</condition><then> <expr><call><name>zNewFmt</name><argument_list>(<argument><expr><literal type="string">"size invalid: %u, "</literal></expr></argument>, <argument><expr><name>errSize</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
            <argument><expr><ternary><condition><expr><name>verboseText</name> <operator>||</operator> <name>errOther</name></expr> ?</condition><then> <expr><call><name>zNewFmt</name><argument_list>(<argument><expr><literal type="string">"other: %u"</literal></expr></argument>, <argument><expr><name>errOther</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Clean up trailing comma when necessary</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strEndsWithZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strTruncIdx</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strSize</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Render the results of the verify command
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>verifyRender</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>archiveIdResultList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupResultList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>verboseText</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>archiveIdResultList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="line">// Result list for all archive Ids in the repo</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>backupResultList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <comment type="line">// Result list for all backups in the repo</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>verboseText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                     <comment type="line">// Is verbose output requested?</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>archiveIdResultList</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>backupResultList</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Render archive results</comment>
    <if_stmt><if>if <condition>(<expr><name>verboseText</name> <operator>&amp;&amp;</operator> <call><name>lstEmpty</name><argument_list>(<argument><expr><name>archiveIdResultList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\n  archiveId: none found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>archiveIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>archiveIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>archiveIdResultList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>archiveIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>VerifyArchiveResult</name> <modifier>*</modifier></type><name>archiveIdResult</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>archiveIdResultList</name></expr></argument>, <argument><expr><name>archiveIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>verboseText</name> <operator>||</operator> <name><name>archiveIdResult</name><operator>-&gt;</operator><name>totalWalFile</name></name> <operator>-</operator> <name><name>archiveIdResult</name><operator>-&gt;</operator><name>totalValidWal</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                    <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\n  archiveId: %s, total WAL checked: %u, total valid WAL: %u"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>totalWalFile</name></name></expr></argument>, <argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>totalValidWal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>totalWalFile</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errMissing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errChecksum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errOther</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>walIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>walIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>walRangeList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>walIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>VerifyWalRange</name> <modifier>*</modifier></type><name>walRange</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>walRangeList</name></name></expr></argument>, <argument><expr><name>walIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(
                        <argument><expr><literal type="string">"archiveId: %s, wal start: %s, wal stop: %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>walRange</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>walRange</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>invalidIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                    <while>while <condition>(<expr><name>invalidIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>walRange</name><operator>-&gt;</operator><name>invalidFileList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>VerifyInvalidFile</name> <modifier>*</modifier></type><name>invalidFile</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>walRange</name><operator>-&gt;</operator><name>invalidFileList</name></name></expr></argument>, <argument><expr><name>invalidIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>invalidFile</name><operator>-&gt;</operator><name>reason</name></name> <operator>==</operator> <name>verifyFileMissing</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>errMissing</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
                        <if type="elseif">else if <condition>(<expr><name><name>invalidFile</name><operator>-&gt;</operator><name>reason</name></name> <operator>==</operator> <name>verifyChecksumMismatch</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>errChecksum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
                        <if type="elseif">else if <condition>(<expr><name><name>invalidFile</name><operator>-&gt;</operator><name>reason</name></name> <operator>==</operator> <name>verifySizeInvalid</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>errSize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>errOther</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

                        <expr_stmt><expr><name>invalidIdx</name><operator>++</operator></expr>;</expr_stmt>
                    </block_content>}</block></while>
                </block_content>}</block></for>

                <comment type="line">// Create/append file errors string</comment>
                <if_stmt><if>if <condition>(<expr><name>verboseText</name> <operator>||</operator> <name>errMissing</name> <operator>+</operator> <name>errChecksum</name> <operator>+</operator> <name>errSize</name> <operator>+</operator> <name>errOther</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>verifyCreateFileErrorsStr</name><argument_list>(<argument><expr><name>errMissing</name></expr></argument>, <argument><expr><name>errChecksum</name></expr></argument>, <argument><expr><name>errSize</name></expr></argument>, <argument><expr><name>errOther</name></expr></argument>, <argument><expr><name>verboseText</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// Render backup results</comment>
    <if_stmt><if>if <condition>(<expr><name>verboseText</name> <operator>&amp;&amp;</operator> <call><name>lstEmpty</name><argument_list>(<argument><expr><name>backupResultList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\n  backup: none found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>backupResultList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>VerifyBackupResult</name> <modifier>*</modifier></type><name>backupResult</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>backupResultList</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>status</name></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><name><name>backupResult</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>backupInvalid</name></expr>:</case>
                    <expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"invalid"</literal></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>backupMissingManifest</name></expr>:</case>
                    <expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"manifest missing"</literal></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>backupInProgress</name></expr>:</case>
                    <expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"in-progress"</literal></expr>;</expr_stmt>
                    <break>break;</break>

                <default>default:</default>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>backupValid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"valid"</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block>
            </block_content>}</block></switch>

            <if_stmt><if>if <condition>(<expr><name>verboseText</name> <operator>||</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><literal type="string">"valid"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><literal type="string">"in-progress"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                    <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\n  backup: %s, status: %s, total files checked: %u, total valid files: %u"</literal></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>totalFileVerify</name></name></expr></argument>, <argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>totalFileValid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>backupResult</name><operator>-&gt;</operator><name>totalFileVerify</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errMissing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errChecksum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errOther</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>invalidIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>invalidIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>invalidFileList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>invalidIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>VerifyInvalidFile</name> <modifier>*</modifier></type><name>invalidFile</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>invalidFileList</name></name></expr></argument>, <argument><expr><name>invalidIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>invalidFile</name><operator>-&gt;</operator><name>reason</name></name> <operator>==</operator> <name>verifyFileMissing</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>errMissing</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>invalidFile</name><operator>-&gt;</operator><name>reason</name></name> <operator>==</operator> <name>verifyChecksumMismatch</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>errChecksum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>invalidFile</name><operator>-&gt;</operator><name>reason</name></name> <operator>==</operator> <name>verifySizeInvalid</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>errSize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>errOther</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></for>

                <comment type="line">// Create/append file errors string</comment>
                <if_stmt><if>if <condition>(<expr><name>verboseText</name> <operator>||</operator> <name>errMissing</name> <operator>+</operator> <name>errChecksum</name> <operator>+</operator> <name>errSize</name> <operator>+</operator> <name>errOther</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>verifyCreateFileErrorsStr</name><argument_list>(<argument><expr><name>errMissing</name></expr></argument>, <argument><expr><name>errChecksum</name></expr></argument>, <argument><expr><name>errSize</name></expr></argument>, <argument><expr><name>errOther</name></expr></argument>, <argument><expr><name>verboseText</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Process the verify command
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>verifyProcess</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>verboseText</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>verboseText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                     <comment type="line">// Is verbose output requested?</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errorTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>resultStr</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get the repo storage in case it is remote and encryption settings need to be pulled down</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storage</name> <init>= <expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get a usable backup info file</comment>
        <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>backupInfo</name> <init>= <expr><call><name>verifyBackupInfoFile</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If a usable backup.info file is not found, then report an error in the log</comment>
        <if_stmt><if>if <condition>(<expr><name>backupInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"\n  No usable backup.info file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>errorTotal</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Get a usable archive info file</comment>
        <decl_stmt><decl><type><name>InfoArchive</name> <modifier>*</modifier></type><name>archiveInfo</name> <init>= <expr><call><name>verifyArchiveInfoFile</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If a usable archive.info file is not found, then report an error in the log</comment>
        <if_stmt><if>if <condition>(<expr><name>archiveInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"\n  No usable archive.info file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>errorTotal</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If both a usable archive info and backup info file were found, then proceed with verification</comment>
        <if_stmt><if>if <condition>(<expr><name>archiveInfo</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>backupInfo</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// Verify that the archive.info and backup.info current database info and history lists are the same</comment>
                <expr_stmt><expr><call><name>verifyPgHistory</name><argument_list>(<argument><expr><call><name>infoArchivePg</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"\n%s"</literal></expr></argument>, <argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>errorTotal</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If valid info files, then begin process of checking backups and archives in the repo</comment>
        <if_stmt><if>if <condition>(<expr><name>errorTotal</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Initialize the job data</comment>
            <decl_stmt><decl><type><name>VerifyJobData</name></type> <name>jobData</name> <init>=
            <expr><block>{
                <expr><operator>.</operator><name>memContext</name> <operator>=</operator> <call><name>memContextCurrent</name><argument_list>()</argument_list></call></expr>,
                <expr><operator>.</operator><name>walPathList</name> <operator>=</operator> <name>NULL</name></expr>,
                <expr><operator>.</operator><name>walFileList</name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>,
                <expr><operator>.</operator><name>pgHistory</name> <operator>=</operator> <call><name>infoArchivePg</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>manifestCipherPass</name> <operator>=</operator> <call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>backupInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>walCipherPass</name> <operator>=</operator> <call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoArchivePg</name><argument_list>(<argument><expr><name>archiveInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>archiveIdResultList</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VerifyArchiveResult</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>archiveIdComparator</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>backupResultList</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VerifyBackupResult</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr>,
            }</block></expr></init></decl>;</decl_stmt>

            <comment type="line">// Get a list of backups in the repo sorted ascending</comment>
            <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>backupList</name></name> <operator>=</operator> <call><name>strLstSort</name><argument_list>(
                <argument><expr><call><name>storageListP</name><argument_list>(
                    <argument><expr><name>storage</name></expr></argument>, <argument><expr><name>STORAGE_REPO_BACKUP_STR</name></expr></argument>,
                    <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>differential</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>incremental</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Get a list of archive Ids in the repo (e.g. 9.4-1, 10-2, etc) sorted ascending by the db-id (number after the dash)</comment>
            <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>archiveIdList</name></name> <operator>=</operator> <call><name>strLstSort</name><argument_list>(
                <argument><expr><call><name>strLstComparatorSet</name><argument_list>(
                    <argument><expr><call><name>storageListP</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>STORAGE_REPO_ARCHIVE_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>STRDEF</name><argument_list>(<argument><expr><name>REGEX_ARCHIVE_DIR_DB_VERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>archiveIdComparator</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Only begin processing if there are some archives or backups in the repo</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>archiveIdList</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>backupList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Warn if there are no archives or there are no backups in the repo so that the callback need not try to</comment>
                <comment type="line">// distinguish between having processed all of the list or if the list was missing in the first place</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>archiveIdList</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>backupList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"no %s exist in the repo"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>archiveIdList</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"archives"</literal></expr> </then><else>: <expr><literal type="string">"backups"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// If there are no archives to process, then set the processing flag to skip to processing the backups</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>archiveIdList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>backupProcessing</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Set current backup if there is one and verify the archive history on disk is in the database history</comment>
                <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>currentBackup</name></name> <operator>=</operator> <call><name>verifySetBackupCheckArchive</name><argument_list>(
                    <argument><expr><name><name>jobData</name><operator>.</operator><name>backupList</name></name></expr></argument>, <argument><expr><name>backupInfo</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>.</operator><name>archiveIdList</name></name></expr></argument>, <argument><expr><name><name>jobData</name><operator>.</operator><name>pgHistory</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>jobData</name><operator>.</operator><name>jobErrorTotal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Create the parallel executor</comment>
                <decl_stmt><decl><type><name>ProtocolParallel</name> <modifier>*</modifier></type><name>parallelExec</name> <init>= <expr><call><name>protocolParallelNew</name><argument_list>(
                    <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptProtocolTimeout</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>verifyJobCallback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jobData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>processIdx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>processIdx</name> <operator>&lt;=</operator> <call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptProcessMax</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>processIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>protocolParallelClientAdd</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>, <argument><expr><call><name>protocolLocalGet</name><argument_list>(<argument><expr><name>protocolStorageTypeRepo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>processIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <comment type="line">// Process jobs</comment>
                <macro><name>MEM_CONTEXT_TEMP_RESET_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <do>do
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>completed</name> <init>= <expr><call><name>protocolParallelProcess</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Process completed jobs</comment>
                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>jobIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>jobIdx</name> <operator>&lt;</operator> <name>completed</name></expr>;</condition> <incr><expr><name>jobIdx</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <comment type="line">// Get the job and job key</comment>
                            <decl_stmt><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>protocolParallelResult</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>processId</name> <init>= <expr><call><name>protocolParallelJobProcessId</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>filePathLst</name> <init>= <expr><call><name>strLstNewSplit</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>protocolParallelJobKey</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FSLASH_STR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <comment type="line">// Remove the result and file type identifier and recreate the path file name</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>resultId</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>filePathLst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name>filePathLst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileType</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>filePathLst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name>filePathLst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>filePathName</name> <init>= <expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>filePathLst</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <comment type="line">// Initialize the result sets</comment>
                            <decl_stmt><decl><type><name>VerifyArchiveResult</name> <modifier>*</modifier></type><name>archiveIdResult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>VerifyBackupResult</name> <modifier>*</modifier></type><name>backupResult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                            <comment type="line">// Get archiveId result data</comment>
                            <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>fileType</name></expr></argument>, <argument><expr><name>STORAGE_REPO_ARCHIVE_STR</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <comment type="line">// Find the archiveId in the list - assert if not found since this should never happen</comment>
                                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name> <init>= <expr><call><name>lstFindIdx</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>archiveIdResultList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>index</name> <operator>!=</operator> <name>LIST_NOT_FOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><name>archiveIdResult</name> <operator>=</operator> <call><name>lstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>archiveIdResultList</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Else get the backup result data</comment>
                            <else>else
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name> <init>= <expr><call><name>lstFindIdx</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>backupResultList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>index</name> <operator>!=</operator> <name>LIST_NOT_FOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><name>backupResult</name> <operator>=</operator> <call><name>lstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>backupResultList</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>

                            <comment type="line">// The job was successful</comment>
                            <if_stmt><if>if <condition>(<expr><call><name>protocolParallelJobErrorCode</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <decl_stmt><decl><type><specifier>const</specifier> <name>VerifyResult</name></type> <name>verifyResult</name> <init>= <expr><operator>(</operator><name>VerifyResult</name><operator>)</operator><call><name>pckReadU32P</name><argument_list>(<argument><expr><call><name>protocolParallelJobResult</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <comment type="line">// Update the result set for the type of file being processed</comment>
                                <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>fileType</name></expr></argument>, <argument><expr><name>STORAGE_REPO_ARCHIVE_STR</name></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><name>verifyResult</name> <operator>==</operator> <name>verifyOk</name></expr>)</condition><block type="pseudo"><block_content>
                                        <expr_stmt><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>totalValidWal</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
                                    <else>else
                                    <block>{<block_content>
                                        <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>jobErrorTotal</name></name> <operator>+=</operator> <call><name>verifyLogInvalidResult</name><argument_list>(
                                            <argument><expr><name>fileType</name></expr></argument>, <argument><expr><name>verifyResult</name></expr></argument>, <argument><expr><name>processId</name></expr></argument>, <argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                        <comment type="line">// Add invalid file to the WAL range</comment>
                                        <expr_stmt><expr><call><name>verifyAddInvalidWalFile</name><argument_list>(
                                            <argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>walRangeList</name></name></expr></argument>, <argument><expr><name>verifyResult</name></expr></argument>, <argument><expr><name>filePathName</name></expr></argument>,
                                            <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>filePathLst</name></expr></argument>, <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>filePathLst</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                            <argument><expr><name>WAL_SEGMENT_NAME_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></else></if_stmt>
                                </block_content>}</block></if>
                                <else>else
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><name>verifyResult</name> <operator>==</operator> <name>verifyOk</name></expr>)</condition><block type="pseudo"><block_content>
                                        <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>totalFileValid</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
                                    <else>else
                                    <block>{<block_content>
                                        <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>jobErrorTotal</name></name> <operator>+=</operator> <call><name>verifyLogInvalidResult</name><argument_list>(
                                            <argument><expr><name>fileType</name></expr></argument>, <argument><expr><name>verifyResult</name></expr></argument>, <argument><expr><name>processId</name></expr></argument>, <argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>backupInvalid</name></expr>;</expr_stmt>
                                        <expr_stmt><expr><call><name>verifyInvalidFileAdd</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>invalidFileList</name></name></expr></argument>, <argument><expr><name>verifyResult</name></expr></argument>, <argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></else></if_stmt>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Else the job errored</comment>
                            <else>else
                            <block>{<block_content>
                                <comment type="line">// Log a protocol error and increment the jobErrorTotal</comment>
                                <expr_stmt><expr><call><name>LOG_INFO_PID_FMT</name><argument_list>(
                                    <argument><expr><name>processId</name></expr></argument>,
                                    <argument><expr><literal type="string">"%s %s: [%d] %s"</literal></expr></argument>, <argument><expr><call><name>verifyErrorMsg</name><argument_list>(<argument><expr><name>verifyOtherError</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>protocolParallelJobErrorCode</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>protocolParallelJobErrorMessage</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>jobErrorTotal</name></name><operator>++</operator></expr>;</expr_stmt>

                                <comment type="line">// Add invalid file with "OtherError" reason to invalid file list</comment>
                                <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>fileType</name></expr></argument>, <argument><expr><name>STORAGE_REPO_ARCHIVE_STR</name></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="line">// Add invalid file to the WAL range</comment>
                                    <expr_stmt><expr><call><name>verifyAddInvalidWalFile</name><argument_list>(
                                        <argument><expr><name><name>archiveIdResult</name><operator>-&gt;</operator><name>walRangeList</name></name></expr></argument>, <argument><expr><name>verifyOtherError</name></expr></argument>, <argument><expr><name>filePathName</name></expr></argument>,
                                        <argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>filePathLst</name></expr></argument>, <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>filePathLst</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAL_SEGMENT_NAME_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <else>else
                                <block>{<block_content>
                                    <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>backupInvalid</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>verifyInvalidFileAdd</name><argument_list>(<argument><expr><name><name>backupResult</name><operator>-&gt;</operator><name>invalidFileList</name></name></expr></argument>, <argument><expr><name>verifyOtherError</name></expr></argument>, <argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></else></if_stmt>

                            <comment type="line">// Set backup verification complete for a backup if all files have run through verification</comment>
                            <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>fileType</name></expr></argument>, <argument><expr><name>STORAGE_REPO_BACKUP_STR</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                                <name><name>backupResult</name><operator>-&gt;</operator><name>totalFileVerify</name></name> <operator>==</operator> <name><name>backupResult</name><operator>-&gt;</operator><name>totalFileManifest</name></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>backupResult</name><operator>-&gt;</operator><name>fileVerifyComplete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <comment type="line">// Free the job</comment>
                            <expr_stmt><expr><call><name>protocolParallelJobFree</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>

                        <comment type="line">// Reset the memory context occasionally so we don't use too much memory or slow down processing</comment>
                        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_RESET</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>
                    while <condition>(<expr><operator>!</operator><call><name>protocolParallelDone</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// ??? Need to do the final reconciliation - checking backup required WAL against, valid WAL</comment>

                <comment type="line">// Report results</comment>
                <expr_stmt><expr><name>resultStr</name> <operator>=</operator> <call><name>verifyRender</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>archiveIdResultList</name></name></expr></argument>, <argument><expr><name><name>jobData</name><operator>.</operator><name>backupResultList</name></name></expr></argument>, <argument><expr><name>verboseText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>, <argument><expr><literal type="string">"\n    no archives or backups exist in the repo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name>errorTotal</name> <operator>+=</operator> <name><name>jobData</name><operator>.</operator><name>jobErrorTotal</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If verbose output or errors then output results</comment>
        <if_stmt><if>if <condition>(<expr><name>verboseText</name> <operator>||</operator> <name>errorTotal</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"stanza: %s\nstatus: %s%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptStanza</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><ternary><condition><expr><name>errorTotal</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>VERIFY_STATUS_ERROR</name></expr> </then><else>: <expr><name>VERIFY_STATUS_OK</name></expr></else></ternary></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>resultStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>cmdVerify</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>verifyProcess</name><argument_list>(<argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptVerbose</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Output results if any</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEmpty</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Log results</comment>
            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Output to console when requested</comment>
            <if_stmt><if>if <condition>(<expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptOutput</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CFGOPTVAL_OUTPUT_TEXT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ioFdWriteOneStr</name><argument_list>(<argument><expr><name>STDOUT_FILENO</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ioFdWriteOneStr</name><argument_list>(<argument><expr><name>STDOUT_FILENO</name></expr></argument>, <argument><expr><name>LF_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
