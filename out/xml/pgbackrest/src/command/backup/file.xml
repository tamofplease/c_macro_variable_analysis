<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/command/backup/file.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Backup File
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/backup/file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/backup/pageChecksum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/crypto/cipherBlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/crypto/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/filter/group.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/filter/size.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/regExp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/convert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/manifest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Helper functions
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>segmentNumber</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pgFile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pgFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Determine which segment number this is by checking for a numeric extension.  No extension means segment 0.</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>regExpMatchOne</name><argument_list>(<argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"\\.[0-9]+$"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pgFile</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>cvtZToUInt</name><argument_list>(<argument><expr><call><name>strrchr</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>backupFile</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>repoFile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CompressType</name></type> <name>repoFileCompressType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>repoFileCompressLevel</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>CipherType</name></type> <name>cipherType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cipherPass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>repoFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                       <comment type="line">// Repo file</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>repoFileCompressType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="line">// Compress type for repo file</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>repoFileCompressLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="line">// Compression level for repo file</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>cipherType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                  <comment type="line">// Encryption type</comment>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    <comment type="line">// Password to access the repo file if encrypted</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>fileList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                         <comment type="line">// List of files to backup</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>repoFile</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>cipherType</name> <operator>==</operator> <name>cipherTypeNone</name> <operator>&amp;&amp;</operator> <name>cipherPass</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>cipherType</name> <operator>!=</operator> <name>cipherTypeNone</name> <operator>&amp;&amp;</operator> <name>cipherPass</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>fileList</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name>fileList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Backup file results</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackupFileResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Check files to determine which ones need to be copied</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fileIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>fileList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// Use a per-file mem context to reduce memory usage</comment>
            <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BackupFile</name> <modifier>*</modifier><specifier>const</specifier></type> <name>file</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>fileList</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>pgFile</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>manifestFile</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><name><name>file</name><operator>-&gt;</operator><name>pgFileDelta</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>file</name><operator>-&gt;</operator><name>manifestFileResume</name></name><operator>)</operator> <operator>||</operator> <name><name>file</name><operator>-&gt;</operator><name>pgFileChecksum</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>BackupFileResult</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileResult</name> <init>= <macro><name>lstAdd</name><argument_list>(
                    <argument>result</argument>, <argument>&amp;(BackupFileResult){.manifestFile = file-&gt;manifestFile</argument>, <argument>.backupCopyResult = backupCopyResultCopy}</argument>)</argument_list></macro></init></decl>;</decl_stmt>

                <comment type="line">// Does the file in pg match the checksum and size passed?</comment>
                <decl_stmt><decl><type><name>bool</name></type> <name>pgFileMatch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

                <comment type="line">// If delta then check the pg checksum</comment>
                <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>pgFileDelta</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Generate checksum/size for the pg file. Only read as many bytes as passed in pgFileSize. If the file has</comment>
                    <comment type="line">// grown since the manifest was built we don't need to consider the extra bytes since they will be replayed from</comment>
                    <comment type="line">// WAL during recovery.</comment>
                    <decl_stmt><decl><type><name>IoRead</name> <modifier>*</modifier></type><name>read</name> <init>= <expr><call><name>storageReadIo</name><argument_list>(
                        <argument><expr><call><name>storageNewReadP</name><argument_list>(
                            <argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>pgFile</name></name></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <name><name>file</name><operator>-&gt;</operator><name>pgFileIgnoreMissing</name></name></expr></argument>,
                            <argument><expr><operator>.</operator><name>limit</name> <operator>=</operator> <ternary><condition><expr><name><name>file</name><operator>-&gt;</operator><name>pgFileCopyExactSize</name></name></expr> ?</condition><then> <expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>pgFileSize</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cryptoHashNew</name><argument_list>(<argument><expr><name>hashTypeSha1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ioSizeNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// If the pg file exists check the checksum/size</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>ioReadDrain</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pgTestChecksum</name> <init>= <expr><call><name>bufHex</name><argument_list>(
                            <argument><expr><call><name>pckReadBinP</name><argument_list>(<argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CRYPTO_HASH_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>uint64_t</name></type> <name>pgTestSize</name> <init>= <expr><call><name>pckReadU64P</name><argument_list>(<argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SIZE_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Does the pg file match?</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>pgFileSize</name></name> <operator>==</operator> <name>pgTestSize</name> <operator>&amp;&amp;</operator> <call><name>strEq</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>pgFileChecksum</name></name></expr></argument>, <argument><expr><name>pgTestChecksum</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>pgFileMatch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                            <comment type="line">// If it matches and is a reference to a previous backup then no need to copy the file</comment>
                            <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>manifestFileHasReference</name></name></expr>)</condition>
                            <block>{<block_content>
                                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(result)</argument>)</argument_list></macro>
                                <block>{<block_content>
                                    <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>backupCopyResult</name></name> <operator>=</operator> <name>backupCopyResultNoOp</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>copySize</name></name> <operator>=</operator> <name>pgTestSize</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>copyChecksum</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>pgTestChecksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block>
                                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Else the source file is missing from the database so skip this file</comment>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>backupCopyResult</name></name> <operator>=</operator> <name>backupCopyResultSkip</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// On resume check the manifest file</comment>
                <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>manifestFileResume</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Resumed files should never have a reference to a prior backup</comment>
                    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>file</name><operator>-&gt;</operator><name>manifestFileHasReference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// If the file is missing from pg, then remove it from the repo (backupJobResult() will remove it from the</comment>
                    <comment type="line">// manifest)</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>fileResult</name><operator>-&gt;</operator><name>backupCopyResult</name></name> <operator>==</operator> <name>backupCopyResultSkip</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>repoFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Else if the pg file matches or is unknown because delta was not performed then check the repo file</comment>
                    <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>file</name><operator>-&gt;</operator><name>pgFileDelta</name></name> <operator>||</operator> <name>pgFileMatch</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Check the repo file in a try block because on error (e.g. missing or corrupt file that can't be decrypted</comment>
                        <comment type="line">// or decompressed) we should recopy rather than ending the backup.</comment>
                        <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
                        <block>{<block_content>
                            <comment type="line">// Generate checksum/size for the repo file</comment>
                            <decl_stmt><decl><type><name>IoRead</name> <modifier>*</modifier></type><name>read</name> <init>= <expr><call><name>storageReadIo</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>repoFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name>cipherType</name> <operator>!=</operator> <name>cipherTypeNone</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(
                                    <argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>cipherBlockNewP</name><argument_list>(<argument><expr><name>cipherModeDecrypt</name></expr></argument>, <argument><expr><name>cipherType</name></expr></argument>, <argument><expr><call><name>BUFSTR</name><argument_list>(<argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <comment type="line">// Decompress the file if compressed</comment>
                            <if_stmt><if>if <condition>(<expr><name>repoFileCompressType</name> <operator>!=</operator> <name>compressTypeNone</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>decompressFilter</name><argument_list>(<argument><expr><name>repoFileCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cryptoHashNew</name><argument_list>(<argument><expr><name>hashTypeSha1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ioSizeNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>ioReadDrain</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// Test checksum/size</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pgTestChecksum</name> <init>= <expr><call><name>bufHex</name><argument_list>(
                                <argument><expr><call><name>pckReadBinP</name><argument_list>(<argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CRYPTO_HASH_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>uint64_t</name></type> <name>pgTestSize</name> <init>= <expr><call><name>pckReadU64P</name><argument_list>(<argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SIZE_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <comment type="line">// No need to recopy if checksum/size match</comment>
                            <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>pgFileSize</name></name> <operator>==</operator> <name>pgTestSize</name> <operator>&amp;&amp;</operator> <call><name>strEq</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>pgFileChecksum</name></name></expr></argument>, <argument><expr><name>pgTestChecksum</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(result)</argument>)</argument_list></macro>
                                <block>{<block_content>
                                    <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>backupCopyResult</name></name> <operator>=</operator> <name>backupCopyResultChecksum</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>copySize</name></name> <operator>=</operator> <name>pgTestSize</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>copyChecksum</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>pgTestChecksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block>
                                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Else recopy when repo file is not as expected</comment>
                            <else>else<block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>backupCopyResult</name></name> <operator>=</operator> <name>backupCopyResultReCopy</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        </block_content>}</block>
                        <comment type="line">// Recopy on any kind of error</comment>
                        <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>backupCopyResult</name></name> <operator>=</operator> <name>backupCopyResultReCopy</name></expr>;</expr_stmt>
                        </block_content>}</block>
                        <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Are the files compressible during the copy?</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>compressible</name> <init>= <expr><name>repoFileCompressType</name> <operator>==</operator> <name>compressTypeNone</name> <operator>&amp;&amp;</operator> <name>cipherType</name> <operator>==</operator> <name>cipherTypeNone</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Copy files that need to be copied</comment>
        <decl_stmt><decl><type><name>StorageWrite</name> <modifier>*</modifier></type><name>write</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>bundleOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fileIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>fileList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// Use a per-file mem context to reduce memory usage</comment>
            <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BackupFile</name> <modifier>*</modifier><specifier>const</specifier></type> <name>file</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>fileList</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>BackupFileResult</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileResult</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>fileResult</name><operator>-&gt;</operator><name>backupCopyResult</name></name> <operator>==</operator> <name>backupCopyResultCopy</name> <operator>||</operator> <name><name>fileResult</name><operator>-&gt;</operator><name>backupCopyResult</name></name> <operator>==</operator> <name>backupCopyResultReCopy</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Setup pg file for read. Only read as many bytes as passed in pgFileSize.  If the file is growing it does no</comment>
                    <comment type="line">// good to copy data past the end of the size recorded in the manifest since those blocks will need to be</comment>
                    <comment type="line">// replayed from WAL during recovery.</comment>
                    <decl_stmt><decl><type><name>StorageRead</name> <modifier>*</modifier></type><name>read</name> <init>= <expr><call><name>storageNewReadP</name><argument_list>(
                        <argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>pgFile</name></name></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <name><name>file</name><operator>-&gt;</operator><name>pgFileIgnoreMissing</name></name></expr></argument>, <argument><expr><operator>.</operator><name>compressible</name> <operator>=</operator> <name>compressible</name></expr></argument>,
                        <argument><expr><operator>.</operator><name>limit</name> <operator>=</operator> <ternary><condition><expr><name><name>file</name><operator>-&gt;</operator><name>pgFileCopyExactSize</name></name></expr> ?</condition><then> <expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>pgFileSize</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cryptoHashNew</name><argument_list>(<argument><expr><name>hashTypeSha1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ioSizeNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Add page checksum filter</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>pgFileChecksumPage</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(
                            <argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>pageChecksumNew</name><argument_list>(
                                <argument><expr><call><name>segmentNumber</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>pgFile</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PG_SEGMENT_PAGE_DEFAULT</name></expr></argument>, <argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storagePg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>pgFile</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Add compression</comment>
                    <if_stmt><if>if <condition>(<expr><name>repoFileCompressType</name> <operator>!=</operator> <name>compressTypeNone</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(
                            <argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>compressFilter</name><argument_list>(<argument><expr><name>repoFileCompressType</name></expr></argument>, <argument><expr><name>repoFileCompressLevel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// If there is a cipher then add the encrypt filter</comment>
                    <if_stmt><if>if <condition>(<expr><name>cipherType</name> <operator>!=</operator> <name>cipherTypeNone</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(
                            <argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>cipherBlockNewP</name><argument_list>(<argument><expr><name>cipherModeEncrypt</name></expr></argument>, <argument><expr><name>cipherType</name></expr></argument>, <argument><expr><call><name>BUFSTR</name><argument_list>(<argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Add size filter last to calculate repo size</comment>
                    <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ioSizeNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Open the source and destination and copy the file</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>ioReadOpen</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Setup the repo file for write. There is no need to write the file atomically (e.g. via a temp file on</comment>
                        <comment type="line">// Posix) because checksums are tested on resume after a failed backup. The path does not need to be synced</comment>
                        <comment type="line">// for each file because all paths are synced at the end of the backup. It needs to be created in the prior</comment>
                        <comment type="line">// context because it will live longer than a single loop when more than one file is being written.</comment>
                        <if_stmt><if>if <condition>(<expr><name>write</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                        <block>{<block_content>
                            <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                            <block>{<block_content>
                                <expr_stmt><expr><name>write</name> <operator>=</operator> <call><name>storageNewWriteP</name><argument_list>(
                                    <argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>repoFile</name></expr></argument>, <argument><expr><operator>.</operator><name>compressible</name> <operator>=</operator> <name>compressible</name></expr></argument>, <argument><expr><operator>.</operator><name>noAtomic</name> <operator>=</operator> <name>true</name></expr></argument>,
                                    <argument><expr><operator>.</operator><name>noSyncPath</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>ioWriteOpen</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>write</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block>
                            <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// Copy data from source to destination</comment>
                        <expr_stmt><expr><call><name>ioCopyP</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>write</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Close the source</comment>
                        <expr_stmt><expr><call><name>ioReadClose</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(result)</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <comment type="line">// Get sizes and checksum</comment>
                            <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>copySize</name></name> <operator>=</operator> <call><name>pckReadU64P</name><argument_list>(
                                <argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SIZE_FILTER_TYPE</name></expr></argument>, <argument><expr><operator>.</operator><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>bundleOffset</name></name> <operator>=</operator> <name>bundleOffset</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>copyChecksum</name></name> <operator>=</operator> <call><name>bufHex</name><argument_list>(
                                <argument><expr><call><name>pckReadBinP</name><argument_list>(<argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CRYPTO_HASH_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>repoSize</name></name> <operator>=</operator> <call><name>pckReadU64P</name><argument_list>(
                                <argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SIZE_FILTER_TYPE</name></expr></argument>, <argument><expr><operator>.</operator><name>idx</name> <operator>=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// Get results of page checksum validation</comment>
                            <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>pgFileChecksumPage</name></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>pageChecksumResult</name></name> <operator>=</operator> <call><name>pckDup</name><argument_list>(
                                    <argument><expr><call><name>ioFilterGroupResultPackP</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PAGE_CHECKSUM_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block>
                        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>bundleOffset</name> <operator>+=</operator> <name><name>fileResult</name><operator>-&gt;</operator><name>repoSize</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Else if source file is missing and the read setup indicated ignore a missing file, the database removed it so</comment>
                    <comment type="line">// skip it</comment>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>fileResult</name><operator>-&gt;</operator><name>backupCopyResult</name></name> <operator>=</operator> <name>backupCopyResultSkip</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Close the repository file if it was opened</comment>
        <if_stmt><if>if <condition>(<expr><name>write</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ioWriteClose</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>write</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>lstMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_STRUCT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
