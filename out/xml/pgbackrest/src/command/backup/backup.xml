<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/command/backup/backup.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Backup Command
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/archive/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/control/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/backup/backup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/backup/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/backup/file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/backup/protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/check/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/stanza/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/crypto/cipherBlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/compress/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/filter/size.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/regExp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/convert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoArchive.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoBackup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/manifest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/**********************************************************************************************************************************
Generate a unique backup label that does not contain a timestamp from a previous backup
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>backupLabelCreate</name><parameter_list>(<parameter><decl><type><name>BackupType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupLabelPrior</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupLabelPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>TIME</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>backupTypeFull</name> <operator>&amp;&amp;</operator> <name>backupLabelPrior</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>type</name> <operator>!=</operator> <name>backupTypeFull</name> <operator>&amp;&amp;</operator> <name>backupLabelPrior</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>timestamp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupLabelLatest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get the newest backup</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>backupList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
            <argument><expr><call><name>storageListP</name><argument_list>(
                <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>differential</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>incremental</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>backupLabelLatest</name> <operator>=</operator> <call><name>strLstGet</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Get the newest history</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>historyYearList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
            <argument><expr><call><name>storageListP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/"</literal> <name>BACKUP_PATH_HISTORY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"^2[0-9]{3}$"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>historyYearList</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>historyList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
                <argument><expr><call><name>storageListP</name><argument_list>(
                    <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/"</literal> <name>BACKUP_PATH_HISTORY</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>historyYearList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(
                        <argument><expr><literal type="string">"%s\\.manifest\\.%s$"</literal></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>differential</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>incremental</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>noAnchorEnd</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>compressTypeStr</name><argument_list>(<argument><expr><name>compressTypeGz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>historyList</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>historyLabelLatest</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>historyList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>backupLabelLatest</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strCmp</name><argument_list>(<argument><expr><name>historyLabelLatest</name></expr></argument>, <argument><expr><name>backupLabelLatest</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Strip off the compression and manifest extensions in case this ends up in an error message</comment>
                    <expr_stmt><expr><name>backupLabelLatest</name> <operator>=</operator> <call><name>compressExtStrip</name><argument_list>(<argument><expr><name>historyLabelLatest</name></expr></argument>, <argument><expr><call><name>compressTypeFromName</name><argument_list>(<argument><expr><name>historyLabelLatest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>backupLabelLatest</name> <operator>=</operator> <call><name>strSubN</name><argument_list>(<argument><expr><name>backupLabelLatest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>backupLabelLatest</name></expr></argument>)</argument_list></call> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BACKUP_MANIFEST_EXT</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Now that we have the latest label check if the provided timestamp will give us an even later label</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>backupLabelFormat</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>backupLabelPrior</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>backupLabelLatest</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strCmp</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>backupLabelLatest</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If that didn't give us a later label then add one second.  It's possible that two backups (they would need to be</comment>
            <comment type="line">// offline or halted online) have run very close together.</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>backupLabelFormat</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>backupLabelPrior</name></expr></argument>, <argument><expr><name>timestamp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If the label is still not latest then error.  There is probably a timezone change or massive clock skew.</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>backupLabelLatest</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>ClockError</name></expr></argument>,
                    <argument><expr><literal type="string">"new backup label '%s' is not later than latest backup label '%s'\n"</literal>
                    <literal type="string">"HINT: has the timezone changed?\n"</literal>
                    <literal type="string">"HINT: is there clock skew?"</literal></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabelLatest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// If adding a second worked then sleep the remainder of the current second so we don't start early</comment>
            <expr_stmt><expr><call><name>sleepMSec</name><argument_list>(<argument><expr><name>MSEC_PER_SEC</name> <operator>-</operator> <operator>(</operator><call><name>timeMSec</name><argument_list>()</argument_list></call> <operator>%</operator> <name>MSEC_PER_SEC</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the postgres database and storage objects
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_BACKUP_DATA_TYPE</name></cpp:macro>                                                                                              \
    <cpp:value>BackupData *</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_BACKUP_DATA_FORMAT</name><parameter_list>(<parameter><type><name>value</name></type></parameter>, <parameter><type><name>buffer</name></type></parameter>, <parameter><type><name>bufferSize</name></type></parameter>)</parameter_list></cpp:macro>                                                                 \
    <cpp:value>objToLog(value, "BackupData", buffer, bufferSize)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>BackupData</name>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pgIdxPrimary</name></decl>;</decl_stmt>                                      <comment type="line">// cfgOptGrpPg index of the primary</comment>
    <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>dbPrimary</name></decl>;</decl_stmt>                                                  <comment type="line">// Database connection to the primary</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storagePrimary</name></decl>;</decl_stmt>                                  <comment type="line">// Storage object for the primary</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>hostPrimary</name></decl>;</decl_stmt>                                      <comment type="line">// Host name of the primary</comment>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pgIdxStandby</name></decl>;</decl_stmt>                                      <comment type="line">// cfgOptGrpPg index of the standby</comment>
    <decl_stmt><decl><type><name>Db</name> <modifier>*</modifier></type><name>dbStandby</name></decl>;</decl_stmt>                                                  <comment type="line">// Database connection to the standby</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storageStandby</name></decl>;</decl_stmt>                                  <comment type="line">// Storage object for the standby</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>hostStandby</name></decl>;</decl_stmt>                                      <comment type="line">// Host name of the standby</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>InfoArchive</name> <modifier>*</modifier></type><name>archiveInfo</name></decl>;</decl_stmt>                                 <comment type="line">// Archive info</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>archiveId</name></decl>;</decl_stmt>                                        <comment type="line">// Archive where backup WAL will be stored</comment>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>timeline</name></decl>;</decl_stmt>                                          <comment type="line">// Primary timeline</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>version</name></decl>;</decl_stmt>                                           <comment type="line">// PostgreSQL version</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>walSegmentSize</name></decl>;</decl_stmt>                                    <comment type="line">// PostgreSQL wal segment size</comment>
}</block></struct></type> <name>BackupData</name>;</typedef>

<function><type><specifier>static</specifier> <name>BackupData</name> <modifier>*</modifier></type>
<name>backupInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoBackup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Initialize for offline backup</comment>
    <decl_stmt><decl><type><name>BackupData</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>memNew</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackupData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>BackupData</name><operator>)</operator><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>

    <comment type="line">// Check that the PostgreSQL version supports backup from standby. The check is done using the stanza info because pg_control</comment>
    <comment type="line">// cannot be loaded until a primary is found -- which will also lead to an error if the version does not support standby. If the</comment>
    <comment type="line">// pg_control version does not match the stanza version then there will be an error further down.</comment>
    <decl_stmt><decl><type><name>InfoPgData</name></type> <name>infoPg</name> <init>= <expr><call><name>infoPgDataCurrent</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptOnline</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptBackupStandby</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>infoPg</name><operator>.</operator><name>version</name></name> <operator>&lt;</operator> <name>PG_VERSION_BACKUP_STANDBY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
            <argument><expr><name>ConfigError</name></expr></argument>, <argument><expr><literal type="string">"option '"</literal> <name>CFGOPT_BACKUP_STANDBY</name> <literal type="string">"' not valid for "</literal> <name>PG_NAME</name> <literal type="string">" &lt; %s"</literal></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name>PG_VERSION_BACKUP_STANDBY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Don't allow backup from standby when offline</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptOnline</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptBackupStandby</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(
            <argument><expr><literal type="string">"option "</literal> <name>CFGOPT_BACKUP_STANDBY</name> <literal type="string">" is enabled but backup is offline - backups will be performed from the primary"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(<argument><expr><name>cfgOptBackupStandby</name></expr></argument>, <argument><expr><name>cfgSourceParam</name></expr></argument>, <argument><expr><name>BOOL_FALSE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Get database info when online</comment>
    <decl_stmt><decl><type><name>PgControl</name></type> <name>pgControl</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptOnline</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>backupStandby</name> <init>= <expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptBackupStandby</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DbGetResult</name></type> <name>dbInfo</name> <init>= <expr><call><name>dbGet</name><argument_list>(<argument><expr><operator>!</operator><name>backupStandby</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>backupStandby</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>pgIdxPrimary</name></name> <operator>=</operator> <name><name>dbInfo</name><operator>.</operator><name>primaryIdx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dbPrimary</name></name> <operator>=</operator> <name><name>dbInfo</name><operator>.</operator><name>primary</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>backupStandby</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>dbInfo</name><operator>.</operator><name>standby</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>pgIdxStandby</name></name> <operator>=</operator> <name><name>dbInfo</name><operator>.</operator><name>standbyIdx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dbStandby</name></name> <operator>=</operator> <name><name>dbInfo</name><operator>.</operator><name>standby</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>storageStandby</name></name> <operator>=</operator> <call><name>storagePgIdx</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>pgIdxStandby</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>hostStandby</name></name> <operator>=</operator> <call><name>cfgOptionIdxStrNull</name><argument_list>(<argument><expr><name>cfgOptPgHost</name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>pgIdxStandby</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Get pg_control info from the primary</comment>
        <expr_stmt><expr><name>pgControl</name> <operator>=</operator> <call><name>dbPgControl</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>dbPrimary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else get pg_control info directly from the file</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>pgControl</name> <operator>=</operator> <call><name>pgControlFromFile</name><argument_list>(<argument><expr><call><name>storagePgIdx</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>pgIdxPrimary</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="line">// Add primary info</comment>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>storagePrimary</name></name> <operator>=</operator> <call><name>storagePgIdx</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>pgIdxPrimary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>hostPrimary</name></name> <operator>=</operator> <call><name>cfgOptionIdxStrNull</name><argument_list>(<argument><expr><name>cfgOptPgHost</name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>pgIdxPrimary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>timeline</name></name> <operator>=</operator> <name><name>pgControl</name><operator>.</operator><name>timeline</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <name><name>pgControl</name><operator>.</operator><name>version</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>walSegmentSize</name></name> <operator>=</operator> <name><name>pgControl</name><operator>.</operator><name>walSegmentSize</name></name></expr>;</expr_stmt>

    <comment type="line">// Validate pg_control info against the stanza</comment>
    <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>version</name></name> <operator>!=</operator> <name><name>infoPg</name><operator>.</operator><name>version</name></name> <operator>||</operator> <name><name>pgControl</name><operator>.</operator><name>systemId</name></name> <operator>!=</operator> <name><name>infoPg</name><operator>.</operator><name>systemId</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
            <argument><expr><name>BackupMismatchError</name></expr></argument>,
            <argument><expr><name>PG_NAME</name> <literal type="string">" version %s, system-id %"</literal> <name>PRIu64</name> <literal type="string">" do not match stanza version %s, system-id %"</literal> <name>PRIu64</name> <literal type="string">"\n"</literal>
            <literal type="string">"HINT: is this the correct stanza?"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name><name>pgControl</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pgControl</name><operator>.</operator><name>systemId</name></name></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name><name>infoPg</name><operator>.</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>infoPg</name><operator>.</operator><name>systemId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Only allow stop auto in PostgreSQL &gt;= 9.3</comment>
    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptStopAuto</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>version</name></name> <operator>&lt;</operator> <name>PG_VERSION_93</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><name>CFGOPT_STOP_AUTO</name> <literal type="string">" option is only available in "</literal> <name>PG_NAME</name> <literal type="string">" &gt;= "</literal> <name>PG_VERSION_93_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(<argument><expr><name>cfgOptStopAuto</name></expr></argument>, <argument><expr><name>cfgSourceParam</name></expr></argument>, <argument><expr><name>BOOL_FALSE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If checksum page is not explicitly set then automatically enable it when checksums are available</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptChecksumPage</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// If online then use the value in pg_control to set checksum-page</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptOnline</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(<argument><expr><name>cfgOptChecksumPage</name></expr></argument>, <argument><expr><name>cfgSourceParam</name></expr></argument>, <argument><expr><call><name>VARBOOL</name><argument_list>(<argument><expr><name><name>pgControl</name><operator>.</operator><name>pageChecksum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else set to false.  An offline cluster is likely to have false positives so better if the user enables manually.</comment>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(<argument><expr><name>cfgOptChecksumPage</name></expr></argument>, <argument><expr><name>cfgSourceParam</name></expr></argument>, <argument><expr><name>BOOL_FALSE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else if checksums have been explicitly enabled but are not available then warn and reset. ??? We should be able to make this</comment>
    <comment type="line">// determination when offline as well, but the integration tests don't write pg_control accurately enough to support it.</comment>
    <if type="elseif">else if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptOnline</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pgControl</name><operator>.</operator><name>pageChecksum</name></name> <operator>&amp;&amp;</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptChecksumPage</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><name>CFGOPT_CHECKSUM_PAGE</name> <literal type="string">" option set to true but checksums are not enabled on the cluster, resetting to false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(<argument><expr><name>cfgOptChecksumPage</name></expr></argument>, <argument><expr><name>cfgSourceParam</name></expr></argument>, <argument><expr><name>BOOL_FALSE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Get archive info</comment>
    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveCheck</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>archiveInfo</name></name> <operator>=</operator> <call><name>infoArchiveLoadFile</name><argument_list>(
                <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>INFO_ARCHIVE_PATH_FILE_STR</name></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>archiveId</name></name> <operator>=</operator> <call><name>infoArchiveId</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>archiveInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BACKUP_DATA</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************
Get time from the database or locally depending on online
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>time_t</name></type>
<name>backupTime</name><parameter_list>(<parameter><decl><type><name>BackupData</name> <modifier>*</modifier></type><name>backupData</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>waitRemainder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BACKUP_DATA</name></expr></argument>, <argument><expr><name>backupData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>waitRemainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Offline backups will just grab the time from the local system since the value of copyStart is not important in this context.</comment>
    <comment type="line">// No worries about causing a delta backup since switching online will do that anyway.</comment>
    <decl_stmt><decl><type><name>time_t</name></type> <name>result</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// When online get the time from the database server</comment>
    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptOnline</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Get time from the database</comment>
        <decl_stmt><decl><type><name>TimeMSec</name></type> <name>timeMSec</name> <init>= <expr><call><name>dbTimeMSec</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>dbPrimary</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><operator>(</operator><name>timeMSec</name> <operator>/</operator> <name>MSEC_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>

        <comment type="line">// Sleep the remainder of the second when requested (this is so copyStart is not subject to one second resolution issues)</comment>
        <if_stmt><if>if <condition>(<expr><name>waitRemainder</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="line">// Just to be safe we'll loop until PostgreSQL reports that we have slept long enough</comment>
            <do>do
            <block>{<block_content>
                <comment type="line">// Error if the clock has not advanced after several attempts</comment>
                <if_stmt><if>if <condition>(<expr><name>retry</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>KernelError</name></expr></argument>, <argument><expr><name>PG_NAME</name> <literal type="string">" clock has not advanced to the next second after %u tries"</literal></expr></argument>, <argument><expr><name>retry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Sleep remainder of current second</comment>
                <expr_stmt><expr><call><name>sleepMSec</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>TimeMSec</name><operator>)</operator><operator>(</operator><name>result</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>MSEC_PER_SEC</name><operator>)</operator> <operator>-</operator> <name>timeMSec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Check time again to be sure we slept long enough</comment>
                <expr_stmt><expr><name>timeMSec</name> <operator>=</operator> <call><name>dbTimeMSec</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>dbPrimary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Increment retry to prevent an infinite loop</comment>
                <expr_stmt><expr><name>retry</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><operator>(</operator><name>time_t</name><operator>)</operator><operator>(</operator><name>timeMSec</name> <operator>/</operator> <name>MSEC_PER_SEC</name><operator>)</operator> <operator>&lt;=</operator> <name>result</name></expr>)</condition>;</do>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>TIME</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Create an incremental backup if type is not full and a compatible prior backup exists
***********************************************************************************************************************************/</comment>
<comment type="line">// Helper to find a compatible prior backup</comment>
<function><type><specifier>static</specifier> <name>Manifest</name> <modifier>*</modifier></type>
<name>backupBuildIncrPrior</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoBackup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// No incremental if backup type is full</comment>
    <decl_stmt><decl><type><name>BackupType</name></type> <name>type</name> <init>= <expr><operator>(</operator><name>BackupType</name><operator>)</operator><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>backupTypeFull</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>InfoPgData</name></type> <name>infoPg</name> <init>= <expr><call><name>infoPgDataCurrent</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupLabelPrior</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>backupTotal</name> <init>= <expr><call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name> <init>= <expr><name>backupTotal</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>backupIdx</name> <operator>&lt;</operator> <name>backupTotal</name></expr>;</condition> <incr><expr><name>backupIdx</name><operator>--</operator></expr></incr>)</control>
            <block>{<block_content>
                 <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>backupPrior</name> <init>= <expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// The prior backup for a diff must be full</comment>
                <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>backupTypeDiff</name> <operator>&amp;&amp;</operator> <name><name>backupPrior</name><operator>.</operator><name>backupType</name></name> <operator>!=</operator> <name>backupTypeFull</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="line">// The backups must come from the same cluster ??? This should enable delta instead</comment>
                <if_stmt><if>if <condition>(<expr><name><name>infoPg</name><operator>.</operator><name>id</name></name> <operator>!=</operator> <name><name>backupPrior</name><operator>.</operator><name>backupPgId</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="line">// This backup is a candidate for prior</comment>
                <expr_stmt><expr><name>backupLabelPrior</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>backupPrior</name><operator>.</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></for>

            <comment type="line">// If there is a prior backup then check that options for the new backup are compatible</comment>
            <if_stmt><if>if <condition>(<expr><name>backupLabelPrior</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>manifestLoadFile</name><argument_list>(
                    <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>BACKUP_MANIFEST_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabelPrior</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestData</name> <modifier>*</modifier></type><name>manifestPriorData</name> <init>= <expr><call><name>manifestData</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                    <argument><expr><literal type="string">"last backup label = %s, version = %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backrestVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Warn if compress-type option changed</comment>
                <if_stmt><if>if <condition>(<expr><call><name>compressTypeEnum</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>manifestPriorData</name><operator>-&gt;</operator><name>backupOptionCompressType</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                        <argument><expr><literal type="string">"%s backup cannot alter "</literal> <name>CFGOPT_COMPRESS_TYPE</name> <literal type="string">" option to '%s', reset to value in %s"</literal></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionDisplay</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionDisplay</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabelPrior</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Set the compression type back to whatever was in the prior backup.  This is not strictly needed since we</comment>
                    <comment type="line">// could store compression type on a per file basis, but it seems simplest and safest for now.</comment>
                    <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(
                        <argument><expr><name>cfgOptCompressType</name></expr></argument>, <argument><expr><name>cfgSourceParam</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>compressTypeStr</name><argument_list>(<argument><expr><name><name>manifestPriorData</name><operator>-&gt;</operator><name>backupOptionCompressType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// There's a small chance that the prior manifest is old enough that backupOptionCompressLevel was not recorded.</comment>
                    <comment type="line">// There's an even smaller chance that the user will also alter compression-type in this scenario right after</comment>
                    <comment type="line">// upgrading to a newer version. Because we judge this combination of events to be nearly impossible just check</comment>
                    <comment type="line">// here so no test coverage is needed.</comment>
                    <expr_stmt><expr><call><name>CHECK</name><argument_list>(
                        <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><name><name>manifestPriorData</name><operator>-&gt;</operator><name>backupOptionCompressLevel</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>,
                        <argument><expr><literal type="string">"compress-level missing in prior manifest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Set the compression level back to whatever was in the prior backup</comment>
                    <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(
                        <argument><expr><name>cfgOptCompressLevel</name></expr></argument>, <argument><expr><name>cfgSourceParam</name></expr></argument>, <argument><expr><call><name>VARINT64</name><argument_list>(<argument><expr><call><name>varUInt</name><argument_list>(<argument><expr><name><name>manifestPriorData</name><operator>-&gt;</operator><name>backupOptionCompressLevel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// If not defined this backup was done in a version prior to page checksums being introduced.  Just set</comment>
                <comment type="line">// checksum-page to false and move on without a warning.  Page checksums will start on the next full backup.</comment>
                <if_stmt><if>if <condition>(<expr><call><name>manifestData</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupOptionChecksumPage</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(<argument><expr><name>cfgOptChecksumPage</name></expr></argument>, <argument><expr><name>cfgSourceParam</name></expr></argument>, <argument><expr><name>BOOL_FALSE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Don't allow the checksum-page option to change in a diff or incr backup.  This could be confusing as only</comment>
                <comment type="line">// certain files would be checksummed and the list could be incomplete during reporting.</comment>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type> <name>checksumPagePrior</name> <init>= <expr><call><name>varBool</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupOptionChecksumPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Warn if an incompatible setting was explicitly requested</comment>
                    <if_stmt><if>if <condition>(<expr><name>checksumPagePrior</name> <operator>!=</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptChecksumPage</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                            <argument><expr><literal type="string">"%s backup cannot alter '"</literal> <name>CFGOPT_CHECKSUM_PAGE</name> <literal type="string">"' option to '%s', reset to '%s' from %s"</literal></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionDisplay</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionDisplay</name><argument_list>(<argument><expr><name>cfgOptChecksumPage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>cvtBoolToConstZ</name><argument_list>(<argument><expr><name>checksumPagePrior</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(<argument><expr><name>cfgOptChecksumPage</name></expr></argument>, <argument><expr><name>cfgSourceParam</name></expr></argument>, <argument><expr><call><name>VARBOOL</name><argument_list>(<argument><expr><name>checksumPagePrior</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><call><name>manifestMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"no prior backup exists, %s backup has been changed to full"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionDisplay</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>, <argument><expr><name>cfgSourceParam</name></expr></argument>, <argument><expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name>backupTypeFull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>backupBuildIncr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl></parameter>, <parameter><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>, <parameter><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifestPrior</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>archiveStart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifestPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>archiveStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoBackup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// No incremental if no prior manifest</comment>
    <if_stmt><if>if <condition>(<expr><name>manifestPrior</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// Move the manifest to this context so it will be freed when we are done</comment>
            <expr_stmt><expr><call><name>manifestMove</name><argument_list>(<argument><expr><name>manifestPrior</name></expr></argument>, <argument><expr><call><name>MEM_CONTEXT_TEMP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Build incremental manifest</comment>
            <expr_stmt><expr><call><name>manifestBuildIncr</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>manifestPrior</name></expr></argument>, <argument><expr><operator>(</operator><name>BackupType</name><operator>)</operator><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>archiveStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Set the cipher subpass from prior manifest since we want a single subpass for the entire backup set</comment>
            <expr_stmt><expr><call><name>manifestCipherSubPassSet</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>manifestCipherSubPass</name><argument_list>(<argument><expr><name>manifestPrior</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Incremental was built</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Check for a backup that can be resumed and merge into the manifest if found
***********************************************************************************************************************************/</comment>
<comment type="line">// Helper to clean invalid paths/files/links out of the resumable backup path</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>backupResumeClean</name><parameter_list>(
    <parameter><decl><type><name>StorageIterator</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storageItr</name></decl></parameter>, <parameter><decl><type><name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifestResume</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>CompressType</name></type> <name>compressType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>delta</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupParentPath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifestParentName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_ITERATOR</name></expr></argument>, <argument><expr><name>storageItr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <comment type="line">// Storage info</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                     <comment type="line">// New manifest</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifestResume</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <comment type="line">// Resumed manifest</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>compressType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                     <comment type="line">// Backup compression type</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                            <comment type="line">// Is this a delta backup?</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupParentPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <comment type="line">// Path to the current level of the backup being cleaned</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>manifestParentName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="line">// Parent manifest name used to construct manifest name</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>storageItr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifestResume</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>backupParentPath</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_RESET_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <while>while <condition>(<expr><call><name>storageItrMore</name><argument_list>(<argument><expr><name>storageItr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>StorageInfo</name></type> <name>info</name> <init>= <expr><call><name>storageItrNext</name><argument_list>(<argument><expr><name>storageItr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Skip backup.manifest.copy -- it must be preserved to allow resume again if this process throws an error before</comment>
            <comment type="line">// writing the manifest for the first time</comment>
            <if_stmt><if>if <condition>(<expr><name>manifestParentName</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <macro><name>strEqZ</name><argument_list>(<argument>info.name</argument>, <argument>BACKUP_MANIFEST_FILE INFO_COPY_EXT</argument>)</argument_list></macro></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="line">// Build the name used to lookup files in the manifest</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>manifestName</name> <init>= <expr><ternary><condition><expr><name>manifestParentName</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then>
                <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>manifestParentName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>info</name><operator>.</operator><name>name</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <comment type="line">// Build the backup path used to remove files/links/paths that are invalid</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupPath</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupParentPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Process file types</comment>
            <switch>switch <condition>(<expr><name><name>info</name><operator>.</operator><name>type</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Check paths</comment>
                <comment type="line">// -----------------------------------------------------------------------------------------------------------------</comment>
                <case>case <expr><name>storageTypePath</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// If the path was not found in the new manifest then remove it</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>manifestPathFindDefault</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"remove path '%s' from resumed backup"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>backupPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>storagePathRemoveP</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>backupPath</name></expr></argument>, <argument><expr><operator>.</operator><name>recurse</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Else recurse into the path</comment>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>backupResumeClean</name><argument_list>(
                            <argument><expr><call><name>storageNewItrP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>backupPath</name></expr></argument>, <argument><expr><operator>.</operator><name>sortOrder</name> <operator>=</operator> <name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>manifestResume</name></expr></argument>,
                            <argument><expr><name>compressType</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><name>backupPath</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <break>break;</break>
                </block_content>}</block>

                <comment type="line">// Check files</comment>
                <comment type="line">// -----------------------------------------------------------------------------------------------------------------</comment>
                <case>case <expr><name>storageTypeFile</name></expr>:</case>
                <block>{<block_content>
                    <comment type="line">// If the file is compressed then strip off the extension before doing the lookup</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>CompressType</name></type> <name>fileCompressType</name> <init>= <expr><call><name>compressTypeFromName</name><argument_list>(<argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>fileCompressType</name> <operator>!=</operator> <name>compressTypeNone</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>manifestName</name> <operator>=</operator> <call><name>compressExtStrip</name><argument_list>(<argument><expr><name>manifestName</name></expr></argument>, <argument><expr><name>fileCompressType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Check if the file can be resumed or must be removed</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>removeReason</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>fileCompressType</name> <operator>!=</operator> <name>compressType</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>removeReason</name> <operator>=</operator> <literal type="string">"mismatched compression type"</literal></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>manifestFileExists</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>removeReason</name> <operator>=</operator> <literal type="string">"missing in manifest"</literal></expr>;</expr_stmt></block_content></block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>ManifestFile</name></type> <name>file</name> <init>= <expr><call><name>manifestFileFind</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>.</operator><name>reference</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>removeReason</name> <operator>=</operator> <literal type="string">"reference in manifest"</literal></expr>;</expr_stmt></block_content></block></if>
                        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>manifestFileExists</name><argument_list>(<argument><expr><name>manifestResume</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>removeReason</name> <operator>=</operator> <literal type="string">"missing in resumed manifest"</literal></expr>;</expr_stmt></block_content></block></if>
                        <else>else
                        <block>{<block_content>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFile</name></type> <name>fileResume</name> <init>= <expr><call><name>manifestFileFind</name><argument_list>(<argument><expr><name>manifestResume</name></expr></argument>, <argument><expr><name>manifestName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name><name>fileResume</name><operator>.</operator><name>reference</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>removeReason</name> <operator>=</operator> <literal type="string">"reference in resumed manifest"</literal></expr>;</expr_stmt></block_content></block></if>
                            <if type="elseif">else if <condition>(<expr><name><name>fileResume</name><operator>.</operator><name>checksumSha1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>removeReason</name> <operator>=</operator> <literal type="string">"no checksum in resumed manifest"</literal></expr>;</expr_stmt></block_content></block></if>
                            <if type="elseif">else if <condition>(<expr><name><name>file</name><operator>.</operator><name>size</name></name> <operator>!=</operator> <name><name>fileResume</name><operator>.</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>removeReason</name> <operator>=</operator> <literal type="string">"mismatched size"</literal></expr>;</expr_stmt></block_content></block></if>
                            <if type="elseif">else if <condition>(<expr><operator>!</operator><name>delta</name> <operator>&amp;&amp;</operator> <name><name>file</name><operator>.</operator><name>timestamp</name></name> <operator>!=</operator> <name><name>fileResume</name><operator>.</operator><name>timestamp</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>removeReason</name> <operator>=</operator> <literal type="string">"mismatched timestamp"</literal></expr>;</expr_stmt></block_content></block></if>
                            <if type="elseif">else if <condition>(<expr><name><name>file</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                <comment type="line">// ??? don't resume zero size files because Perl wouldn't -- can be removed after the migration)</comment>
                                <expr_stmt><expr><name>removeReason</name> <operator>=</operator> <literal type="string">"zero size"</literal></expr>;</expr_stmt></block_content></block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>copy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>bundleId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><name><name>file</name><operator>.</operator><name>sizeRepo</name></name> <operator>=</operator> <name><name>fileResume</name><operator>.</operator><name>sizeRepo</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>checksumSha1</name></name></expr></argument>, <argument><expr><name><name>fileResume</name><operator>.</operator><name>checksumSha1</name></name></expr></argument>, <argument><expr><name>HASH_TYPE_SHA1_SIZE_HEX</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>file</name><operator>.</operator><name>checksumPage</name></name> <operator>=</operator> <name><name>fileResume</name><operator>.</operator><name>checksumPage</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>file</name><operator>.</operator><name>checksumPageError</name></name> <operator>=</operator> <name><name>fileResume</name><operator>.</operator><name>checksumPageError</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>file</name><operator>.</operator><name>checksumPageErrorList</name></name> <operator>=</operator> <name><name>fileResume</name><operator>.</operator><name>checksumPageErrorList</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>file</name><operator>.</operator><name>resume</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>file</name><operator>.</operator><name>delta</name></name> <operator>=</operator> <name>delta</name></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>manifestFileUpdate</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></else></if_stmt>

                    <comment type="line">// Remove the file if it could not be resumed</comment>
                    <if_stmt><if>if <condition>(<expr><name>removeReason</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(
                            <argument><expr><literal type="string">"remove file '%s' from resumed backup (%s)"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>backupPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>removeReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>backupPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <break>break;</break>
                </block_content>}</block>

                <comment type="line">// Remove links. We could check that the link has not changed and preserve it but it doesn't seem worth the extra</comment>
                <comment type="line">// testing. The link will be recreated during the backup if needed.</comment>
                <comment type="line">// -----------------------------------------------------------------------------------------------------------------</comment>
                <case>case <expr><name>storageTypeLink</name></expr>:</case>
                    <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>backupPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <comment type="line">// Remove special files</comment>
                <comment type="line">// -----------------------------------------------------------------------------------------------------------------</comment>
                <case>case <expr><name>storageTypeSpecial</name></expr>:</case>
                    <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"remove special file '%s' from resumed backup"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>backupPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>backupPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></while>

        <comment type="line">// Reset the memory context occasionally so we don't use too much memory or slow down processing</comment>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_RESET</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Helper to find a resumable backup</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier></type>
<name>backupResumeFind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPassBackup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Only the last backup can be resumed</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>backupList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
            <argument><expr><call><name>storageListP</name><argument_list>(
                <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>differential</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>incremental</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupLabel</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>manifestFile</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>BACKUP_MANIFEST_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Resumable backups do not have backup.manifest</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>manifestFile</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>resume</name> <init>= <expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptResume</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type> <name>usable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>reason</name> <init>= <expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"partially deleted by prior resume or invalid"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifestResume</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <comment type="line">// Resumable backups must have backup.manifest.copy</comment>
                <if_stmt><if>if <condition>(<expr><call><name>storageExistsP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s"</literal> <name>INFO_COPY_EXT</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>manifestFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>reason</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><literal type="string">"resume is disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Attempt to read the manifest file in the resumable backup to see if it can be used. If any error at all</comment>
                    <comment type="line">// occurs then the backup will be considered unusable and a resume will not be attempted.</comment>
                    <if_stmt><if>if <condition>(<expr><name>resume</name></expr>)</condition>
                    <block>{<block_content>
                        <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
                        <block>{<block_content>
                            <expr_stmt><expr><name>manifestResume</name> <operator>=</operator> <call><name>manifestLoadFile</name><argument_list>(
                                <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>manifestFile</name></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
                        <block>{<block_content>
                            <expr_stmt><expr><name>reason</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"unable to read %s"</literal> <name>INFO_COPY_EXT</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>manifestFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name>manifestResume</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestData</name> <modifier>*</modifier></type><name>manifestResumeData</name> <init>= <expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifestResume</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <comment type="line">// Check pgBackRest version. This allows the resume implementation to be changed with each version of</comment>
                            <comment type="line">// pgBackRest at the expense of users losing a resumable back after an upgrade, which seems worth the</comment>
                            <comment type="line">// cost.</comment>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>manifestResumeData</name><operator>-&gt;</operator><name>backrestVersion</name></name></expr></argument>, <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backrestVersion</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>reason</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(
                                    <argument><expr><literal type="string">"new "</literal> <name>PROJECT_NAME</name> <literal type="string">" version '%s' does not match resumable "</literal> <name>PROJECT_NAME</name> <literal type="string">" version '%s'"</literal></expr></argument>,
                                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backrestVersion</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>manifestResumeData</name><operator>-&gt;</operator><name>backrestVersion</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Check backup type because new backup label must be the same type as resume backup label</comment>
                            <if type="elseif">else if <condition>(<expr><name><name>manifestResumeData</name><operator>-&gt;</operator><name>backupType</name></name> <operator>!=</operator> <call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>reason</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(
                                    <argument><expr><literal type="string">"new backup type '%s' does not match resumable backup type '%s'"</literal></expr></argument>,
                                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionDisplay</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name><name>manifestResumeData</name><operator>-&gt;</operator><name>backupType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Check prior backup label ??? Do we really care about the prior backup label?</comment>
                            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>manifestResumeData</name><operator>-&gt;</operator><name>backupLabelPrior</name></name></expr></argument>, <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabelPrior</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>reason</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(
                                    <argument><expr><literal type="string">"new prior backup label '%s' does not match resumable prior backup label '%s'"</literal></expr></argument>,
                                    <argument><expr><ternary><condition><expr><name><name>manifestResumeData</name><operator>-&gt;</operator><name>backupLabelPrior</name></name></expr> ?</condition><then> <expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>manifestResumeData</name><operator>-&gt;</operator><name>backupLabelPrior</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"&lt;undef&gt;"</literal></expr></else></ternary></expr></argument>,
                                    <argument><expr><ternary><condition><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabelPrior</name></expr> ?</condition><then>
                                        <expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabelPrior</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"&lt;undef&gt;"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Check compression. Compression can't be changed between backups so resume won't work either.</comment>
                            <if type="elseif">else if <condition>(
                                <expr><name><name>manifestResumeData</name><operator>-&gt;</operator><name>backupOptionCompressType</name></name> <operator>!=</operator>
                                    <call><name>compressTypeEnum</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>reason</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(
                                    <argument><expr><literal type="string">"new compression '%s' does not match resumable compression '%s'"</literal></expr></argument>,
                                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionDisplay</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>compressTypeStr</name><argument_list>(<argument><expr><name><name>manifestResumeData</name><operator>-&gt;</operator><name>backupOptionCompressType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else<block type="pseudo"><block_content>
                                <expr_stmt><expr><name>usable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// If the backup is usable then return the manifest</comment>
                <if_stmt><if>if <condition>(<expr><name>usable</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>manifestMove</name><argument_list>(<argument><expr><name>manifestResume</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else warn and remove the unusable backup</comment>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_FMT</name><argument_list>(
                        <argument><expr><ternary><condition><expr><name>resume</name></expr> ?</condition><then> <expr><name>logLevelWarn</name></expr> </then><else>: <expr><name>logLevelInfo</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"backup '%s' cannot be resumed: %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>storagePathRemoveP</name><argument_list>(
                        <argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>recurse</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>backupResume</name><parameter_list>(<parameter><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPassBackup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier></type><name>manifestResume</name> <init>= <expr><call><name>backupResumeFind</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If a resumable backup was found set the label and cipher subpass</comment>
        <if_stmt><if>if <condition>(<expr><name>manifestResume</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Resuming</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="line">// Set the backup label to the resumed backup</comment>
            <expr_stmt><expr><call><name>manifestBackupLabelSet</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifestResume</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                <argument><expr><literal type="string">"resumable backup %s of same type exists -- invalid files will be removed then the backup will resume"</literal></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If resuming a full backup then copy cipher subpass since it was used to encrypt the resumable files</comment>
            <if_stmt><if>if <condition>(<expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupType</name> <operator>==</operator> <name>backupTypeFull</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>manifestCipherSubPassSet</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>manifestCipherSubPass</name><argument_list>(<argument><expr><name>manifestResume</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Clean resumed backup</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupPath</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>backupResumeClean</name><argument_list>(
                <argument><expr><call><name>storageNewItrP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>backupPath</name></expr></argument>, <argument><expr><operator>.</operator><name>sortOrder</name> <operator>=</operator> <name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>manifestResume</name></expr></argument>,
                <argument><expr><call><name>compressTypeEnum</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDelta</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>backupPath</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Start the backup
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>BackupStartResult</name>
<block>{
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>lsn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>walSegmentName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pack</name> <modifier>*</modifier></type><name>dbList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pack</name> <modifier>*</modifier></type><name>tablespaceList</name></decl>;</decl_stmt>
}</block></struct></type> <name>BackupStartResult</name>;</typedef>

<function><type><specifier>static</specifier> <name>BackupStartResult</name></type>
<name>backupStart</name><parameter_list>(<parameter><decl><type><name>BackupData</name> <modifier>*</modifier></type><name>backupData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BACKUP_DATA</name></expr></argument>, <argument><expr><name>backupData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>BackupStartResult</name></type> <name>result</name> <init>= <expr><block>{<expr><operator>.</operator><name>lsn</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// If this is an offline backup</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptOnline</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Check if Postgres is running and if so only continue when forced</comment>
            <if_stmt><if>if <condition>(<expr><call><name>storageExistsP</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>storagePrimary</name></name></expr></argument>, <argument><expr><name>PG_FILE_POSTMTRPID_STR</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptForce</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(
                        <argument><expr><literal type="string">"--no-"</literal> <name>CFGOPT_ONLINE</name> <literal type="string">" passed and "</literal> <name>PG_FILE_POSTMTRPID</name> <literal type="string">" exists but --"</literal> <name>CFGOPT_FORCE</name> <literal type="string">" was passed so"</literal>
                        <literal type="string">" backup will continue though it looks like "</literal> <name>PG_NAME</name> <literal type="string">" is running and the backup will probably not be"</literal>
                        <literal type="string">" consistent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW</name><argument_list>(
                        <argument><expr><name>PgRunningError</name></expr></argument>,
                        <argument><expr><literal type="string">"--no-"</literal> <name>CFGOPT_ONLINE</name> <literal type="string">" passed but "</literal> <name>PG_FILE_POSTMTRPID</name> <literal type="string">" exists - looks like "</literal> <name>PG_NAME</name> <literal type="string">" is running. Shut"</literal>
                            <literal type="string">" down "</literal> <name>PG_NAME</name> <literal type="string">" and try again, or use --force."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else start the backup normally</comment>
        <else>else
        <block>{<block_content>
            <comment type="line">// Check database configuration</comment>
            <expr_stmt><expr><call><name>checkDbConfig</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>pgIdxPrimary</name></name></expr></argument>, <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>dbPrimary</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Start backup</comment>
            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                <argument><expr><literal type="string">"execute %sexclusive backup start: backup begins after the %s checkpoint completes"</literal></expr></argument>,
                <argument><expr><ternary><condition><expr><name><name>backupData</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>PG_VERSION_96</name></expr> ?</condition><then> <expr><literal type="string">"non-"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                <argument><expr><ternary><condition><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptStartFast</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"requested immediate"</literal></expr> </then><else>: <expr><literal type="string">"next regular"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>DbBackupStartResult</name></type> <name>dbBackupStartResult</name> <init>= <expr><call><name>dbBackupStart</name><argument_list>(
                <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>dbPrimary</name></name></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptStartFast</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptStopAuto</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveCheck</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>lsn</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>dbBackupStartResult</name><operator>.</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>walSegmentName</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>dbBackupStartResult</name><operator>.</operator><name>walSegmentName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>dbList</name></name> <operator>=</operator> <call><name>dbList</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>dbPrimary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>tablespaceList</name></name> <operator>=</operator> <call><name>dbTablespaceList</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>dbPrimary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"backup start archive = %s, lsn = %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>walSegmentName</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Wait for replay on the standby to catch up</comment>
            <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptBackupStandby</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"wait for replay on the standby to reach %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>dbReplayWait</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>dbStandby</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>lsn</name></name></expr></argument>, <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptArchiveTimeout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"replay on the standby reached %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Check that WAL segments are being archived. If archiving is not working then the backup will eventually fail so</comment>
            <comment type="line">// better to catch it as early as possible. A segment to check may not be available on older versions of PostgreSQL or</comment>
            <comment type="line">// if archive-check is false.</comment>
            <if_stmt><if>if <condition>(<expr><name><name>dbBackupStartResult</name><operator>.</operator><name>walSegmentCheck</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                    <argument><expr><literal type="string">"check archive for %ssegment %s"</literal></expr></argument>,
                    <argument><expr><ternary><condition><expr><call><name>strEq</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>walSegmentName</name></name></expr></argument>, <argument><expr><name><name>dbBackupStartResult</name><operator>.</operator><name>walSegmentCheck</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"prior "</literal></expr></else></ternary></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>dbBackupStartResult</name><operator>.</operator><name>walSegmentCheck</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>walSegmentFind</name><argument_list>(
                    <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>, <argument><expr><name><name>dbBackupStartResult</name><operator>.</operator><name>walSegmentCheck</name></name></expr></argument>,
                    <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptArchiveTimeout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_STRUCT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Stop the backup
***********************************************************************************************************************************/</comment>
<comment type="line">// Helper to write a file from a string to the repository and update the manifest</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>backupFilePut</name><parameter_list>(<parameter><decl><type><name>BackupData</name> <modifier>*</modifier></type><name>backupData</name></decl></parameter>, <parameter><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>content</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BACKUP_DATA</name></expr></argument>, <argument><expr><name>backupData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>TIME</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Skip files with no content</comment>
    <if_stmt><if>if <condition>(<expr><name>content</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// Create file</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>manifestName</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CompressType</name></type> <name>compressType</name> <init>= <expr><call><name>compressTypeEnum</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>StorageWrite</name> <modifier>*</modifier></type><name>write</name> <init>= <expr><call><name>storageNewWriteP</name><argument_list>(
                <argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name>backupFileRepoPathP</name><argument_list>(
                    <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabel</name></expr></argument>, <argument><expr><operator>.</operator><name>manifestName</name> <operator>=</operator> <name>manifestName</name></expr></argument>,
                    <argument><expr><operator>.</operator><name>compressType</name> <operator>=</operator> <call><name>compressTypeEnum</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><operator>.</operator><name>compressible</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>IoFilterGroup</name> <modifier>*</modifier></type><name>filterGroup</name> <init>= <expr><call><name>ioWriteFilterGroup</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>write</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Add SHA1 filter</comment>
            <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>cryptoHashNew</name><argument_list>(<argument><expr><name>hashTypeSha1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Add compression</comment>
            <if_stmt><if>if <condition>(<expr><name>compressType</name> <operator>!=</operator> <name>compressTypeNone</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(
                    <argument><expr><call><name>ioWriteFilterGroup</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>write</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>compressFilter</name><argument_list>(<argument><expr><name>compressType</name></expr></argument>, <argument><expr><call><name>cfgOptionInt</name><argument_list>(<argument><expr><name>cfgOptCompressLevel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Add encryption filter if required</comment>
            <expr_stmt><expr><call><name>cipherBlockFilterGroupAdd</name><argument_list>(
                <argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cipherModeEncrypt</name></expr></argument>, <argument><expr><call><name>manifestCipherSubPass</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Add size filter last to calculate repo size</comment>
            <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>ioSizeNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Write file</comment>
            <expr_stmt><expr><call><name>storagePutP</name><argument_list>(<argument><expr><name>write</name></expr></argument>, <argument><expr><call><name>BUFSTR</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Use base path to set ownership and mode</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestPath</name> <modifier>*</modifier></type><name>basePath</name> <init>= <expr><call><name>manifestPathFind</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGDATA_STR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Add to manifest</comment>
            <decl_stmt><decl><type><name>ManifestFile</name></type> <name>file</name> <init>=
            <expr><block>{
                <expr><operator>.</operator><name>name</name> <operator>=</operator> <name>manifestName</name></expr>,
                <expr><operator>.</operator><name>mode</name> <operator>=</operator> <name><name>basePath</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name> <operator>|</operator> <name>S_IRGRP</name> <operator>|</operator> <name>S_IROTH</name><operator>)</operator></expr>,
                <expr><operator>.</operator><name>user</name> <operator>=</operator> <name><name>basePath</name><operator>-&gt;</operator><name>user</name></name></expr>,
                <expr><operator>.</operator><name>group</name> <operator>=</operator> <name><name>basePath</name><operator>-&gt;</operator><name>group</name></name></expr>,
                <expr><operator>.</operator><name>size</name> <operator>=</operator> <call><name>strSize</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>sizeRepo</name> <operator>=</operator> <call><name>pckReadU64P</name><argument_list>(<argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><name>SIZE_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <name>timestamp</name></expr>,
            }</block></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(
                <argument><expr><name><name>file</name><operator>.</operator><name>checksumSha1</name></name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>bufHex</name><argument_list>(<argument><expr><call><name>pckReadBinP</name><argument_list>(<argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><name>CRYPTO_HASH_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>HASH_TYPE_SHA1_SIZE_HEX</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>manifestFileAdd</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"wrote '%s' file returned from backup stop function"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*--------------------------------------------------------------------------------------------------------------------------------*/</comment>
<typedef>typedef <type><struct>struct <name>BackupStopResult</name>
<block>{
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>lsn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>walSegmentName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>timestamp</name></decl>;</decl_stmt>
}</block></struct></type> <name>BackupStopResult</name>;</typedef>

<function><type><specifier>static</specifier> <name>BackupStopResult</name></type>
<name>backupStop</name><parameter_list>(<parameter><decl><type><name>BackupData</name> <modifier>*</modifier></type><name>backupData</name></decl></parameter>, <parameter><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BACKUP_DATA</name></expr></argument>, <argument><expr><name>backupData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>BackupStopResult</name></type> <name>result</name> <init>= <expr><block>{<expr><operator>.</operator><name>lsn</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptOnline</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// Stop the backup</comment>
            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                <argument><expr><literal type="string">"execute %sexclusive backup stop and wait for all WAL segments to archive"</literal></expr></argument>,
                <argument><expr><ternary><condition><expr><name><name>backupData</name><operator>-&gt;</operator><name>version</name></name> <operator>&gt;=</operator> <name>PG_VERSION_96</name></expr> ?</condition><then> <expr><literal type="string">"non-"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>DbBackupStopResult</name></type> <name>dbBackupStopResult</name> <init>= <expr><call><name>dbBackupStop</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>dbPrimary</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>timestamp</name></name> <operator>=</operator> <call><name>backupTime</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>lsn</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>dbBackupStopResult</name><operator>.</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>walSegmentName</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>dbBackupStopResult</name><operator>.</operator><name>walSegmentName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"backup stop archive = %s, lsn = %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>walSegmentName</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Save files returned by stop backup</comment>
            <expr_stmt><expr><call><name>backupFilePut</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>PG_FILE_BACKUPLABEL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>timestamp</name></name></expr></argument>, <argument><expr><name><name>dbBackupStopResult</name><operator>.</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>backupFilePut</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>PG_FILE_TABLESPACEMAP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>timestamp</name></name></expr></argument>, <argument><expr><name><name>dbBackupStopResult</name><operator>.</operator><name>tablespaceMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>timestamp</name></name> <operator>=</operator> <call><name>backupTime</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_STRUCT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Convert page checksum error pack to a VariantList
***********************************************************************************************************************************/</comment>
<comment type="line">// Helper to output pages and page ranges</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>backupJobResultPageChecksumOut</name><parameter_list>(<parameter><decl><type><name>VariantList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>pageBegin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>pageEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pageBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pageEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Output a single page</comment>
    <if_stmt><if>if <condition>(<expr><name>pageBegin</name> <operator>==</operator> <name>pageEnd</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>varNewUInt64</name><argument_list>(<argument><expr><name>pageBegin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else output a page range</comment>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>errorListSub</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>errorListSub</name></expr></argument>, <argument><expr><call><name>varNewUInt64</name><argument_list>(<argument><expr><name>pageBegin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>errorListSub</name></expr></argument>, <argument><expr><call><name>varNewUInt64</name><argument_list>(<argument><expr><name>pageEnd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><name>errorListSub</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VariantList</name> <modifier>*</modifier></type>
<name>backupJobResultPageChecksum</name><parameter_list>(<parameter><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>checksumPageResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PACK_READ</name></expr></argument>, <argument><expr><name>checksumPageResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// If there is an error result array</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pckReadNullP</name><argument_list>(<argument><expr><name>checksumPageResult</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pckReadArrayBeginP</name><argument_list>(<argument><expr><name>checksumPageResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pageBegin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pageEnd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// Combine results into a more compact form</comment>
        <while>while <condition>(<expr><call><name>pckReadNext</name><argument_list>(<argument><expr><name>checksumPageResult</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pageId</name> <init>= <expr><call><name>pckReadId</name><argument_list>(<argument><expr><name>checksumPageResult</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>pckReadObjBeginP</name><argument_list>(<argument><expr><name>checksumPageResult</name></expr></argument>, <argument><expr><operator>.</operator><name>id</name> <operator>=</operator> <name>pageId</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// If first error then just store page</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>pageBegin</name> <operator>=</operator> <name>pageId</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pageEnd</name> <operator>=</operator> <name>pageId</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Expand list when the page is in sequence</comment>
            <if type="elseif">else if <condition>(<expr><name>pageId</name> <operator>==</operator> <name>pageEnd</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>pageEnd</name> <operator>=</operator> <name>pageId</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else output the page or page range</comment>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>backupJobResultPageChecksumOut</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>pageBegin</name></expr></argument>, <argument><expr><name>pageEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Start again with a single page range</comment>
                <expr_stmt><expr><name>pageBegin</name> <operator>=</operator> <name>pageId</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pageEnd</name> <operator>=</operator> <name>pageId</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>pckReadObjEndP</name><argument_list>(<argument><expr><name>checksumPageResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="line">// Check that the array was not empty</comment>
        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><literal type="string">"page checksum result array is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Output last page or page range</comment>
        <expr_stmt><expr><call><name>backupJobResultPageChecksumOut</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>pageBegin</name></expr></argument>, <argument><expr><name>pageEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pckReadArrayEndP</name><argument_list>(<argument><expr><name>checksumPageResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>VARIANT_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Log the results of a job and throw errors
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>backupJobResult</name><parameter_list>(
    <parameter><decl><type><name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>host</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storagePg</name></decl></parameter>, <parameter><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileRemove</name></decl></parameter>,
    <parameter><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier><specifier>const</specifier></type> <name>job</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>bundle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>sizeTotal</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sizeProgress</name></decl></parameter>,
    <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier><specifier>const</specifier></type> <name>currentPercentComplete</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>storagePg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>fileRemove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_PARALLEL_JOB</name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>bundle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>sizeTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>sizeProgress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>currentPercentComplete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>storagePg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>fileRemove</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>job</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// The job was successful</comment>
    <if_stmt><if>if <condition>(<expr><call><name>protocolParallelJobErrorCode</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>processId</name> <init>= <expr><call><name>protocolParallelJobProcessId</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>bundleId</name> <init>= <expr><ternary><condition><expr><call><name>varType</name><argument_list>(<argument><expr><call><name>protocolParallelJobKey</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeUInt64</name></expr> ?</condition><then>
                <expr><call><name>varUInt64</name><argument_list>(<argument><expr><call><name>protocolParallelJobKey</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>jobResult</name> <init>= <expr><call><name>protocolParallelJobResult</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>percentComplete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><operator>!</operator><call><name>pckReadNullP</name><argument_list>(<argument><expr><name>jobResult</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ManifestFile</name></type> <name>file</name> <init>= <expr><call><name>manifestFileFind</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>pckReadStrP</name><argument_list>(<argument><expr><name>jobResult</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BackupCopyResult</name></type> <name>copyResult</name> <init>= <expr><operator>(</operator><name>BackupCopyResult</name><operator>)</operator><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>jobResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>copySize</name> <init>= <expr><call><name>pckReadU64P</name><argument_list>(<argument><expr><name>jobResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>bundleOffset</name> <init>= <expr><call><name>pckReadU64P</name><argument_list>(<argument><expr><name>jobResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>repoSize</name> <init>= <expr><call><name>pckReadU64P</name><argument_list>(<argument><expr><name>jobResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>copyChecksum</name> <init>= <expr><call><name>pckReadStrP</name><argument_list>(<argument><expr><name>jobResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>checksumPageResult</name> <init>= <expr><call><name>pckReadPackReadP</name><argument_list>(<argument><expr><name>jobResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Increment backup copy progress</comment>
                <expr_stmt><expr><operator>*</operator><name>sizeProgress</name> <operator>+=</operator> <name>copySize</name></expr>;</expr_stmt>

                <comment type="line">// Create log file name</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileName</name> <init>= <expr><call><name>storagePathP</name><argument_list>(<argument><expr><name>storagePg</name></expr></argument>, <argument><expr><call><name>manifestPathPg</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileLog</name> <init>= <expr><ternary><condition><expr><name>host</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>fileName</name></expr> </then><else>: <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s:%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

                <comment type="line">// Format log progress</comment>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>logProgress</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>bundleId</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>copyResult</name> <operator>!=</operator> <name>backupCopyResultNoOp</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>logProgress</name></expr></argument>, <argument><expr><literal type="string">"bundle %"</literal> <name>PRIu64</name> <literal type="string">"/%"</literal> <name>PRIu64</name> <literal type="string">", "</literal></expr></argument>, <argument><expr><name>bundleId</name></expr></argument>, <argument><expr><name>bundleOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Store percentComplete as an integer</comment>
                <expr_stmt><expr><name>percentComplete</name> <operator>=</operator> <ternary><condition><expr><name>sizeTotal</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">10000</literal></expr> </then><else>: <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><operator>*</operator><name>sizeProgress</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>sizeTotal</name><operator>)</operator> <operator>*</operator> <literal type="number">10000</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                    <argument><expr><name>logProgress</name></expr></argument>, <argument><expr><literal type="string">"%s, %u.%02u%%"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSizeFormat</name><argument_list>(<argument><expr><name>copySize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>percentComplete</name> <operator>/</operator> <literal type="number">100</literal></expr></argument>, <argument><expr><name>percentComplete</name> <operator>%</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Format log checksum</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>logChecksum</name> <init>= <expr><ternary><condition><expr><name>copySize</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">" checksum %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>copyChecksum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>EMPTY_STR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

                <comment type="line">// If the file is in a prior backup and nothing changed, just log it</comment>
                <if_stmt><if>if <condition>(<expr><name>copyResult</name> <operator>==</operator> <name>backupCopyResultNoOp</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL_PID_FMT</name><argument_list>(
                        <argument><expr><name>processId</name></expr></argument>, <argument><expr><literal type="string">"match file from prior backup %s (%s)%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileLog</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>logProgress</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>logChecksum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else if the repo matched the expect checksum, just log it</comment>
                <if type="elseif">else if <condition>(<expr><name>copyResult</name> <operator>==</operator> <name>backupCopyResultChecksum</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL_PID_FMT</name><argument_list>(
                        <argument><expr><name>processId</name></expr></argument>, <argument><expr><literal type="string">"checksum resumed file %s (%s)%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileLog</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>logProgress</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>logChecksum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else if the file was removed during backup add it to the list of files to be removed from the manifest when the</comment>
                <comment type="line">// backup is complete. It can't be removed right now because that will invalidate the pointers that are being used</comment>
                <comment type="line">// for processing.</comment>
                <if type="elseif">else if <condition>(<expr><name>copyResult</name> <operator>==</operator> <name>backupCopyResultSkip</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL_PID_FMT</name><argument_list>(<argument><expr><name>processId</name></expr></argument>, <argument><expr><literal type="string">"skip file removed by database %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileLog</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>fileRemove</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else file was copied so update manifest</comment>
                <else>else
                <block>{<block_content>
                    <comment type="line">// If the file had to be recopied then warn that there may be an issue with corruption in the repository</comment>
                    <comment type="line">// ??? This should really be below the message below for more context -- can be moved after the migration</comment>
                    <comment type="line">// ??? The name should be a pg path not manifest name -- can be fixed after the migration</comment>
                    <if_stmt><if>if <condition>(<expr><name>copyResult</name> <operator>==</operator> <name>backupCopyResultReCopy</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                            <argument><expr><literal type="string">"resumed backup file %s does not have expected checksum %s. The file will be recopied and backup will"</literal>
                            <literal type="string">" continue but this may be an issue unless the resumed backup path in the repository is known to be"</literal>
                            <literal type="string">" corrupted.\n"</literal>
                            <literal type="string">"NOTE: this does not indicate a problem with the PostgreSQL page checksums."</literal></expr></argument>,
                            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>checksumSha1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>LOG_DETAIL_PID_FMT</name><argument_list>(<argument><expr><name>processId</name></expr></argument>, <argument><expr><literal type="string">"backup file %s (%s)%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileLog</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>logProgress</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>logChecksum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// If the file had page checksums calculated during the copy</comment>
                    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><name><name>file</name><operator>.</operator><name>checksumPage</name></name> <operator>&amp;&amp;</operator> <name>checksumPageResult</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>file</name><operator>.</operator><name>checksumPage</name></name> <operator>&amp;&amp;</operator> <name>checksumPageResult</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><name>bool</name></type> <name>checksumPageError</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>VariantList</name> <modifier>*</modifier></type><name>checksumPageErrorList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>checksumPageResult</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>checksumPageErrorList</name> <operator>=</operator> <call><name>backupJobResultPageChecksum</name><argument_list>(<argument><expr><name>checksumPageResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// If the checksum was valid</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pckReadBoolP</name><argument_list>(<argument><expr><name>checksumPageResult</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>checksumPageError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pckReadBoolP</name><argument_list>(<argument><expr><name>checksumPageResult</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>checksumPageErrorList</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                                <comment type="line">// ??? Update formatting after migration</comment>
                                <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                                    <argument><expr><literal type="string">"page misalignment in file %s: file size %"</literal> <name>PRIu64</name> <literal type="string">" is not divisible by page size %u"</literal></expr></argument>,
                                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileLog</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>copySize</name></expr></argument>, <argument><expr><name>PG_PAGE_SIZE_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <comment type="line">// Format the page checksum errors</comment>
                                <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><name>checksumPageErrorList</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"page checksum error list is missing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><operator>!</operator><call><name>varLstEmpty</name><argument_list>(<argument><expr><name>checksumPageErrorList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"page checksum error list is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errorTotalMin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>errorIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>errorIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>checksumPageErrorList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>errorIdx</name><operator>++</operator></expr></incr>)</control>
                                <block>{<block_content>
                                    <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier><specifier>const</specifier></type> <name>errorItem</name> <init>= <expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>checksumPageErrorList</name></expr></argument>, <argument><expr><name>errorIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                    <comment type="line">// Add a comma if this is not the first item</comment>
                                    <if_stmt><if>if <condition>(<expr><name>errorIdx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                                    <comment type="line">// If an error range</comment>
                                    <if_stmt><if>if <condition>(<expr><call><name>varType</name><argument_list>(<argument><expr><name>errorItem</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeVariantList</name></expr>)</condition>
                                    <block>{<block_content>
                                        <decl_stmt><decl><type><specifier>const</specifier> <name>VariantList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>errorItemList</name> <init>= <expr><call><name>varVarLst</name><argument_list>(<argument><expr><name>errorItem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varLstSize</name><argument_list>(<argument><expr><name>errorItemList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                                            <argument><expr><name>error</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRIu64</name> <literal type="string">"-%"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><call><name>varUInt64</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>errorItemList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>varUInt64</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>errorItemList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <expr_stmt><expr><name>errorTotalMin</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                                    </block_content>}</block></if>
                                    <comment type="line">// Else a single error</comment>
                                    <else>else
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varType</name><argument_list>(<argument><expr><name>errorItem</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeUInt64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><call><name>varUInt64</name><argument_list>(<argument><expr><name>errorItem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <expr_stmt><expr><name>errorTotalMin</name><operator>++</operator></expr>;</expr_stmt>
                                    </block_content>}</block></else></if_stmt>
                                </block_content>}</block></for>

                                <comment type="line">// Make message plural when appropriate</comment>
                                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>plural</name> <init>= <expr><ternary><condition><expr><name>errorTotalMin</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>EMPTY_STR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

                                <comment type="line">// ??? Update formatting after migration</comment>
                                <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(
                                    <argument><expr><literal type="string">"invalid page checksum%s found in file %s at page%s %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>plural</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileLog</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>plural</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Update file info and remove any reference to the file's existence in a prior backup</comment>
                    <expr_stmt><expr><name><name>file</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>copySize</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>file</name><operator>.</operator><name>sizeRepo</name></name> <operator>=</operator> <name>repoSize</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>checksumSha1</name></name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>copyChecksum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>HASH_TYPE_SHA1_SIZE_HEX</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>file</name><operator>.</operator><name>reference</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>file</name><operator>.</operator><name>checksumPageError</name></name> <operator>=</operator> <name>checksumPageError</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>file</name><operator>.</operator><name>checksumPageErrorList</name></name> <operator>=</operator> <ternary><condition><expr><name>checksumPageErrorList</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then>
                        <expr><call><name>jsonFromVar</name><argument_list>(<argument><expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><name>checksumPageErrorList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>file</name><operator>.</operator><name>bundleId</name></name> <operator>=</operator> <name>bundleId</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>file</name><operator>.</operator><name>bundleOffset</name></name> <operator>=</operator> <name>bundleOffset</name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>manifestFileUpdate</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>

            <comment type="line">// Update currentPercentComplete and lock file when the change is significant enough</comment>
            <if_stmt><if>if <condition>(<expr><name>percentComplete</name> <operator>-</operator> <operator>*</operator><name>currentPercentComplete</name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>currentPercentComplete</name> <operator>=</operator> <name>percentComplete</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>lockWriteDataP</name><argument_list>(<argument><expr><name>lockTypeBackup</name></expr></argument>, <argument><expr><operator>.</operator><name>percentComplete</name> <operator>=</operator> <call><name>VARUINT</name><argument_list>(<argument><expr><operator>*</operator><name>currentPercentComplete</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Free the job</comment>
        <expr_stmt><expr><call><name>protocolParallelJobFree</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else the job errored</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_CODE</name><argument_list>(<argument><expr><call><name>protocolParallelJobErrorCode</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>protocolParallelJobErrorMessage</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Save a copy of the backup manifest during processing to preserve checksums for a possible resume. Only save the final copy when
resume is disabled since an incremental copy will not be used in a future backup unless resume is enabled beforehand.
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>backupManifestSaveCopy</name><parameter_list>(<parameter><decl><type><name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cipherPassBackup</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>final</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>final</name> <operator>||</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptResume</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// Open file for write</comment>
            <decl_stmt><decl><type><name>IoWrite</name> <modifier>*</modifier></type><name>write</name> <init>= <expr><call><name>storageWriteIo</name><argument_list>(
                <argument><expr><call><name>storageNewWriteP</name><argument_list>(
                    <argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><macro><name>strNewFmt</name><argument_list>(
                        <argument>STORAGE_REPO_BACKUP <literal type="string">"/%s/"</literal> BACKUP_MANIFEST_FILE INFO_COPY_EXT</argument>, <argument>strZ(manifestData(manifest)-&gt;backupLabel)</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Add encryption filter if required</comment>
            <expr_stmt><expr><call><name>cipherBlockFilterGroupAdd</name><argument_list>(
                <argument><expr><call><name>ioWriteFilterGroup</name><argument_list>(<argument><expr><name>write</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cipherModeEncrypt</name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Save file</comment>
            <expr_stmt><expr><call><name>manifestSave</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Check that the clusters are alive and correctly configured during the backup
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>backupDbPing</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BackupData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BACKUP_DATA</name></expr></argument>, <argument><expr><name>backupData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>backupData</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptOnline</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>dbPing</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>dbPrimary</name></name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptBackupStandby</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>dbPing</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>dbStandby</name></name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Process the backup manifest
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>BackupJobData</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifest</name></decl>;</decl_stmt>                                 <comment type="line">// Backup manifest</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupLabel</name></decl>;</decl_stmt>                                <comment type="line">// Backup label (defines the backup path)</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>backupStandby</name></decl>;</decl_stmt>                                       <comment type="line">// Backup from standby</comment>
    <decl_stmt><decl><type><name>RegExp</name> <modifier>*</modifier></type><name>standbyExp</name></decl>;</decl_stmt>                                             <comment type="line">// Identify files that may be copied from the standby</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CipherType</name></type> <name>cipherType</name></decl>;</decl_stmt>                                    <comment type="line">// Cipher type</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cipherSubPass</name></decl>;</decl_stmt>                              <comment type="line">// Passphrase used to encrypt files in the backup</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CompressType</name></type> <name>compressType</name></decl>;</decl_stmt>                                <comment type="line">// Backup compression type</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>compressLevel</name></decl>;</decl_stmt>                                        <comment type="line">// Compress level if backup is compressed</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>delta</name></decl>;</decl_stmt>                                               <comment type="line">// Is this a checksum delta backup?</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>bundle</name></decl>;</decl_stmt>                                              <comment type="line">// Bundle files?</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>bundleSize</name></decl>;</decl_stmt>                                            <comment type="line">// Target bundle size</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>bundleLimit</name></decl>;</decl_stmt>                                           <comment type="line">// Limit on files to bundle</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>bundleId</name></decl>;</decl_stmt>                                              <comment type="line">// Bundle id</comment>

    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queueList</name></decl>;</decl_stmt>                                                <comment type="line">// List of processing queues</comment>
}</block></struct></type> <name>BackupJobData</name>;</typedef>

<comment type="line">// Identify files that must be copied from the primary</comment>
<function><type><name>bool</name></type>
<name>backupProcessFilePrimary</name><parameter_list>(<parameter><decl><type><name>RegExp</name> <modifier>*</modifier><specifier>const</specifier></type> <name>standbyExp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>REGEXP</name></expr></argument>, <argument><expr><name>standbyExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>standbyExp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(
        <argument><expr><name>BOOL</name></expr></argument>, <argument><expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal> <name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>regExpMatch</name><argument_list>(<argument><expr><name>standbyExp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Comparator to order ManifestFile objects by size, date, and name</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier></type><name>backupProcessQueueComparatorManifest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>backupProcessQueueComparatorBundle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>backupProcessQueueComparatorBundleLimit</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>backupProcessQueueComparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item1</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item2</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Unpack files</comment>
    <decl_stmt><decl><type><name>ManifestFile</name></type> <name>file1</name> <init>= <expr><call><name>manifestFileUnpack</name><argument_list>(<argument><expr><name>backupProcessQueueComparatorManifest</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>ManifestFilePack</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>item1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ManifestFile</name></type> <name>file2</name> <init>= <expr><call><name>manifestFileUnpack</name><argument_list>(<argument><expr><name>backupProcessQueueComparatorManifest</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>ManifestFilePack</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>item2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the size differs then that's enough to determine order</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>backupProcessQueueComparatorBundle</name> <operator>||</operator> <name><name>file1</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name>backupProcessQueueComparatorBundleLimit</name> <operator>||</operator>
        <name><name>file2</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name>backupProcessQueueComparatorBundleLimit</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>file1</name><operator>.</operator><name>size</name></name> <operator>&lt;</operator> <name><name>file2</name><operator>.</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>file1</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name><name>file2</name><operator>.</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If bundling order by time ascending so that older files are bundled with older files and newer with newer</comment>
    <if_stmt><if>if <condition>(<expr><name>backupProcessQueueComparatorBundle</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>file1</name><operator>.</operator><name>timestamp</name></name> <operator>&gt;</operator> <name><name>file2</name><operator>.</operator><name>timestamp</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>file1</name><operator>.</operator><name>timestamp</name></name> <operator>&lt;</operator> <name><name>file2</name><operator>.</operator><name>timestamp</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If size/time is the same then use name to generate a deterministic ordering (names must be unique)</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><call><name>strCmp</name><argument_list>(<argument><expr><name><name>file1</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>file2</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Helper to generate the backup queues</comment>
<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>backupProcessQueue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BackupData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupData</name></decl></parameter>, <parameter><decl><type><name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifest</name></decl></parameter>, <parameter><decl><type><name>BackupJobData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>jobData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BACKUP_DATA</name></expr></argument>, <argument><expr><name>backupData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>jobData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Create list of process queues (use void * instead of List * to avoid Coverity false positive)</comment>
        <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Generate the list of targets</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>strLstAddZ</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>manifestTargetTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>targetIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>manifestTarget</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strLstAddFmt</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Generate the processing queues (there is always at least one)</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>queueOffset</name> <init>= <expr><ternary><condition><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupStandby</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(jobData-&gt;queueList)</argument>)</argument_list></macro>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>queueIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>queueIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>queueOffset</name></expr>;</condition> <incr><expr><name>queueIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queue</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ManifestFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>backupProcessQueueComparator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Now put all files into the processing queues</comment>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>fileTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>pgControlFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fileIdx</name> <operator>&lt;</operator> <call><name>manifestFileTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFilePack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>filePack</name> <init>= <expr><call><name>manifestFilePackGet</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFile</name></type> <name>file</name> <init>= <expr><call><name>manifestFileUnpack</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>filePack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Only process files that need to be copied</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>file</name><operator>.</operator><name>copy</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If bundling log zero-length files as stored since they will never be copied</comment>
                <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>jobData</name><operator>-&gt;</operator><name>bundle</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(
                        <argument><expr><literal type="string">"store zero-length file %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>storagePrimary</name></name></expr></argument>, <argument><expr><call><name>manifestPathPg</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Is pg_control in the backup?</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal> <name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>pgControlFound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Files that must be copied from the primary are always put in queue 0 when backup from standby</comment>
            <if_stmt><if>if <condition>(<expr><name><name>jobData</name><operator>-&gt;</operator><name>backupStandby</name></name> <operator>&amp;&amp;</operator> <call><name>backupProcessFilePrimary</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>standbyExp</name></name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>filePack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else find the correct queue by matching the file to a target</comment>
            <else>else
            <block>{<block_content>
                <comment type="line">// Find the target that contains this file</comment>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <do>do
                <block>{<block_content>
                    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"backup target not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>strBeginsWith</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name>targetIdx</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block>
                while <condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>

                <comment type="line">// Add file to queue</comment>
                <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name></expr></argument>, <argument><expr><name>targetIdx</name> <operator>+</operator> <name>queueOffset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>filePack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="line">// Add size to total</comment>
            <expr_stmt><expr><name>result</name> <operator>+=</operator> <name><name>file</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

            <comment type="line">// Increment total files</comment>
            <expr_stmt><expr><name>fileTotal</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// pg_control should always be in an online backup</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgControlFound</name> <operator>&amp;&amp;</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptOnline</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW</name><argument_list>(
                <argument><expr><name>FileMissingError</name></expr></argument>,
                <argument><expr><name>PG_FILE_PGCONTROL</name> <literal type="string">" must be present in all online backups\n"</literal>
                <literal type="string">"HINT: is something wrong with the clock or filesystem timestamps?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block></if></if_stmt>

        <comment type="line">// If there are no files to backup then we'll exit with an error.  This could happen if the database is down and backup is</comment>
        <comment type="line">// called with --no-online twice in a row.</comment>
        <if_stmt><if>if <condition>(<expr><name>fileTotal</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>FileMissingError</name></expr></argument>, <argument><expr><literal type="string">"no files have changed since the last backup - this seems unlikely"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Sort the queues</comment>
        <expr_stmt><expr><name>backupProcessQueueComparatorManifest</name> <operator>=</operator> <name>manifest</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>backupProcessQueueComparatorBundle</name> <operator>=</operator> <name><name>jobData</name><operator>-&gt;</operator><name>bundle</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>backupProcessQueueComparatorBundleLimit</name> <operator>=</operator> <name><name>jobData</name><operator>-&gt;</operator><name>bundleLimit</name></name></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>queueIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>queueIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>queueIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>lstSort</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name></expr></argument>, <argument><expr><name>queueIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <comment type="line">// Move process queues to prior context</comment>
        <expr_stmt><expr><call><name>lstMove</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Helper to calculate the next queue to scan based on the client index</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>backupJobQueueNext</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>clientIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queueIdx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>queueTotal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>clientIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>queueIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>queueTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Move (forward or back) to the next queue</comment>
    <expr_stmt><expr><name>queueIdx</name> <operator>+=</operator> <ternary><condition><expr><name>clientIdx</name> <operator>%</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

    <comment type="line">// Deal with wrapping on either end</comment>
    <if_stmt><if>if <condition>(<expr><name>queueIdx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>queueTotal</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>queueIdx</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>queueTotal</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>queueIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Callback to fetch backup jobs for the parallel executor</comment>
<function><type><specifier>static</specifier> <name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>backupJobCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>clientIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>clientIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get a new job if there are any left</comment>
        <decl_stmt><decl><type><name>BackupJobData</name> <modifier>*</modifier></type><name>jobData</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Determine where to begin scanning the queue (we'll stop when we get back here).  When copying from the primary during</comment>
        <comment type="line">// backup from standby only queue 0 will be used.</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>queueOffset</name> <init>= <expr><ternary><condition><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupStandby</name></name> <operator>&amp;&amp;</operator> <name>clientIdx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>queueIdx</name> <init>= <expr><ternary><condition><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupStandby</name></name> <operator>&amp;&amp;</operator> <name>clientIdx</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then>
            <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>clientIdx</name> <operator>%</operator> <operator>(</operator><call><name>lstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>queueOffset</name><operator>)</operator><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>queueEnd</name> <init>= <expr><name>queueIdx</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Create backup job</comment>
        <decl_stmt><decl><type><name>ProtocolCommand</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>protocolCommandNew</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND_BACKUP_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>fileTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>fileSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <do>do
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queue</name> <init>= <expr><operator>*</operator><operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>queueIdx</name> <operator>+</operator> <name>queueOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>fileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>bundle</name> <init>= <expr><name><name>jobData</name><operator>-&gt;</operator><name>bundle</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><name>fileIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFile</name></type> <name>file</name> <init>= <expr><call><name>manifestFileUnpack</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>manifest</name></name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>ManifestFilePack</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Continue if the next file would make the bundle too large. There may be a smaller one that will fit.</comment>
                <if_stmt><if>if <condition>(<expr><name>fileTotal</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fileSize</name> <operator>+</operator> <name><name>file</name><operator>.</operator><name>size</name></name> <operator>&gt;=</operator> <name><name>jobData</name><operator>-&gt;</operator><name>bundleSize</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>fileIdx</name><operator>++</operator></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Add common parameters before first file</comment>
                <if_stmt><if>if <condition>(<expr><name>param</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>protocolCommandParam</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>bundle</name> <operator>&amp;&amp;</operator> <name><name>file</name><operator>.</operator><name>size</name></name> <operator>&lt;=</operator> <name><name>jobData</name><operator>-&gt;</operator><name>bundleLimit</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>backupFileRepoPathP</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>, <argument><expr><operator>.</operator><name>bundleId</name> <operator>=</operator> <name><name>jobData</name><operator>-&gt;</operator><name>bundleId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>fileTotal</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"cannot bundle file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(
                            <argument><expr><name>param</name></expr></argument>,
                            <argument><expr><call><name>backupFileRepoPathP</name><argument_list>(
                                <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>, <argument><expr><operator>.</operator><name>manifestName</name> <operator>=</operator> <name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>.</operator><name>compressType</name> <operator>=</operator> <name><name>jobData</name><operator>-&gt;</operator><name>compressType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>fileName</name> <operator>=</operator> <name><name>file</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>bundle</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>compressType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pckWriteI32P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>compressLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>jobData</name><operator>-&gt;</operator><name>cipherSubPass</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>cipherTypeNone</name></expr> </then><else>: <expr><name>cipherTypeAes256Cbc</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>cipherSubPass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>manifestPathPg</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/"</literal> <name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><operator>!</operator><call><name>backupProcessFilePrimary</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>standbyExp</name></name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>file</name><operator>.</operator><name>checksumSha1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>STR</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>checksumSha1</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>checksumPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>resume</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name><name>file</name><operator>.</operator><name>reference</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>fileTotal</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>fileSize</name> <operator>+=</operator> <name><name>file</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

                <comment type="line">// Remove job from the queue</comment>
                <expr_stmt><expr><call><name>lstRemoveIdx</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Break if not bundling or bundle size has been reached</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bundle</name> <operator>||</operator> <name>fileSize</name> <operator>&gt;=</operator> <name><name>jobData</name><operator>-&gt;</operator><name>bundleSize</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></while>

            <if_stmt><if>if <condition>(<expr><name>fileTotal</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Assign job to result</comment>
                <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>protocolParallelJobNew</name><argument_list>(<argument><expr><ternary><condition><expr><name>bundle</name></expr> ?</condition><then> <expr><call><name>VARUINT64</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>bundleId</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>bundle</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>jobData</name><operator>-&gt;</operator><name>bundleId</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Don't get next queue when copying from primary during backup from standby since the primary only has one queue</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>jobData</name><operator>-&gt;</operator><name>backupStandby</name></name> <operator>||</operator> <name>clientIdx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>queueIdx</name> <operator>=</operator> <call><name>backupJobQueueNext</name><argument_list>(<argument><expr><name>clientIdx</name></expr></argument>, <argument><expr><name>queueIdx</name></expr></argument>, <argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>-&gt;</operator><name>queueList</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>queueOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        while <condition>(<expr><name>queueIdx</name> <operator>!=</operator> <name>queueEnd</name></expr>)</condition>;</do>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>PROTOCOL_PARALLEL_JOB</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>backupProcess</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>BackupData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupData</name></decl></parameter>, <parameter><decl><type><name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>lsnStart</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cipherPassBackup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BACKUP_DATA</name></expr></argument>, <argument><expr><name>backupData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>lsnStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>sizeTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get backup info</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BackupType</name></type> <name>backupType</name> <init>= <expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupType</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupLabel</name> <init>= <expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabel</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupPathExp</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>hardLink</name> <init>= <expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptRepoHardlink</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>storageFeature</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>storageFeatureHardLink</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>backupStandby</name> <init>= <expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptBackupStandby</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>BackupJobData</name></type> <name>jobData</name> <init>=
        <expr><block>{
            <expr><operator>.</operator><name>manifest</name> <operator>=</operator> <name>manifest</name></expr>,
            <expr><operator>.</operator><name>backupLabel</name> <operator>=</operator> <name>backupLabel</name></expr>,
            <expr><operator>.</operator><name>backupStandby</name> <operator>=</operator> <name>backupStandby</name></expr>,
            <expr><operator>.</operator><name>compressType</name> <operator>=</operator> <call><name>compressTypeEnum</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
            <expr><operator>.</operator><name>compressLevel</name> <operator>=</operator> <call><name>cfgOptionInt</name><argument_list>(<argument><expr><name>cfgOptCompressLevel</name></expr></argument>)</argument_list></call></expr>,
            <expr><operator>.</operator><name>cipherType</name> <operator>=</operator> <call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr>,
            <expr><operator>.</operator><name>cipherSubPass</name> <operator>=</operator> <call><name>manifestCipherSubPass</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>,
            <expr><operator>.</operator><name>delta</name> <operator>=</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDelta</name></expr></argument>)</argument_list></call></expr>,
            <expr><operator>.</operator><name>bundle</name> <operator>=</operator> <call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptRepoBundle</name></expr></argument>)</argument_list></call></expr>,
            <expr><operator>.</operator><name>bundleId</name> <operator>=</operator> <literal type="number">1</literal></expr>,

            <comment type="line">// Build expression to identify files that can be copied from the standby when standby backup is supported</comment>
            <expr><operator>.</operator><name>standbyExp</name> <operator>=</operator> <call><name>regExpNew</name><argument_list>(
                <argument><expr><call><name>strNewFmt</name><argument_list>(
                    <argument><expr><literal type="string">"^(("</literal> <name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/("</literal> <name>PG_PATH_BASE</name> <literal type="string">"|"</literal> <name>PG_PATH_GLOBAL</name> <literal type="string">"|%s|"</literal> <name>PG_PATH_PGMULTIXACT</name> <literal type="string">"))|"</literal>
                        <name>MANIFEST_TARGET_PGTBLSPC</name> <literal type="string">")/"</literal></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgXactPath</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
        }</block></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>jobData</name><operator>.</operator><name>bundle</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>bundleSize</name></name> <operator>=</operator> <call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptRepoBundleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>jobData</name><operator>.</operator><name>bundleLimit</name></name> <operator>=</operator> <call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptRepoBundleLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If this is a full backup or hard-linked and paths are supported then create all paths explicitly so that empty paths will</comment>
        <comment type="line">// exist in to repo. Also create tablespace symlinks when symlinks are available. This makes it possible for the user to</comment>
        <comment type="line">// make a copy of the backup path and get a valid cluster.</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>backupType</name> <operator>==</operator> <name>backupTypeFull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>jobData</name><operator>.</operator><name>bundle</name></name><operator>)</operator> <operator>||</operator> <name>hardLink</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Create paths when available</comment>
            <if_stmt><if>if <condition>(<expr><call><name>storageFeature</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>storageFeaturePath</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>pathIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pathIdx</name> <operator>&lt;</operator> <call><name>manifestPathTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pathIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>storagePathCreateP</name><argument_list>(
                        <argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupPathExp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>manifestPath</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>pathIdx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Create tablespace symlinks when available</comment>
            <if_stmt><if>if <condition>(<expr><call><name>storageFeature</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>storageFeatureSymLink</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>targetIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>targetIdx</name> <operator>&lt;</operator> <call><name>manifestTargetTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>targetIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestTarget</name> <modifier>*</modifier><specifier>const</specifier></type> <name>target</name> <init>= <expr><call><name>manifestTarget</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>targetIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>link</name> <init>= <expr><call><name>storagePathP</name><argument_list>(
                            <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>,
                            <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/"</literal> <name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupPathExp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>linkDestination</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(
                            <argument><expr><literal type="string">"../../"</literal> <name>MANIFEST_TARGET_PGTBLSPC</name> <literal type="string">"/%u"</literal></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>tablespaceId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>storageLinkCreateP</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>linkDestination</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Generate processing queues</comment>
        <expr_stmt><expr><name>sizeTotal</name> <operator>=</operator> <call><name>backupProcessQueue</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jobData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Create the parallel executor</comment>
        <decl_stmt><decl><type><name>ProtocolParallel</name> <modifier>*</modifier></type><name>parallelExec</name> <init>= <expr><call><name>protocolParallelNew</name><argument_list>(
            <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptProtocolTimeout</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>backupJobCallback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jobData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// First client is always on the primary</comment>
        <expr_stmt><expr><call><name>protocolParallelClientAdd</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>, <argument><expr><call><name>protocolLocalGet</name><argument_list>(<argument><expr><name>protocolStorageTypePg</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>pgIdxPrimary</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Create the rest of the clients on the primary or standby depending on the value of backup-standby.  Note that standby</comment>
        <comment type="line">// backups don't count the primary client in process-max.</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>processMax</name> <init>= <expr><call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptProcessMax</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>backupStandby</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pgIdx</name> <init>= <expr><ternary><condition><expr><name>backupStandby</name></expr> ?</condition><then> <expr><name><name>backupData</name><operator>-&gt;</operator><name>pgIdxStandby</name></name></expr> </then><else>: <expr><name><name>backupData</name><operator>-&gt;</operator><name>pgIdxPrimary</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>processIdx</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>processIdx</name> <operator>&lt;=</operator> <name>processMax</name></expr>;</condition> <incr><expr><name>processIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>protocolParallelClientAdd</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>, <argument><expr><call><name>protocolLocalGet</name><argument_list>(<argument><expr><name>protocolStorageTypePg</name></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>, <argument><expr><name>processIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <comment type="line">// Maintain a list of files that need to be removed from the manifest when the backup is complete</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>fileRemove</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Determine how often the manifest will be saved (every one percent or threshold size, whichever is greater)</comment>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>manifestSaveLast</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>manifestSaveSize</name> <init>= <expr><name>sizeTotal</name> <operator>/</operator> <literal type="number">100</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>manifestSaveSize</name> <operator>&lt;</operator> <call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptManifestSaveThreshold</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>manifestSaveSize</name> <operator>=</operator> <call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptManifestSaveThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Process jobs</comment>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>sizeProgress</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// Initialize the percent complete to zero</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>currentPercentComplete</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lockWriteDataP</name><argument_list>(<argument><expr><name>lockTypeBackup</name></expr></argument>, <argument><expr><operator>.</operator><name>percentComplete</name> <operator>=</operator> <call><name>VARUINT</name><argument_list>(<argument><expr><name>currentPercentComplete</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_TEMP_RESET_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <do>do
            <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>completed</name> <init>= <expr><call><name>protocolParallelProcess</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>jobIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>jobIdx</name> <operator>&lt;</operator> <name>completed</name></expr>;</condition> <incr><expr><name>jobIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ProtocolParallelJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>protocolParallelResult</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>backupJobResult</name><argument_list>(
                        <argument><expr><name>manifest</name></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>backupStandby</name> <operator>&amp;&amp;</operator> <call><name>protocolParallelJobProcessId</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>backupData</name><operator>-&gt;</operator><name>hostStandby</name></name></expr> </then><else>: <expr><name><name>backupData</name><operator>-&gt;</operator><name>hostPrimary</name></name></expr></else></ternary></expr></argument>,
                        <argument><expr><ternary><condition><expr><call><name>protocolParallelJobProcessId</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><call><name>storagePgIdx</name><argument_list>(<argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>backupData</name><operator>-&gt;</operator><name>storagePrimary</name></name></expr></else></ternary></expr></argument>,
                        <argument><expr><name>fileRemove</name></expr></argument>, <argument><expr><name>job</name></expr></argument>, <argument><expr><name><name>jobData</name><operator>.</operator><name>bundle</name></name></expr></argument>, <argument><expr><name>sizeTotal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sizeProgress</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>currentPercentComplete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <comment type="line">// A keep-alive is required here for the remote holding open the backup connection</comment>
                <expr_stmt><expr><call><name>protocolKeepAlive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Check that the clusters are alive and correctly configured during the backup</comment>
                <expr_stmt><expr><call><name>backupDbPing</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Save the manifest periodically to preserve checksums for resume</comment>
                <if_stmt><if>if <condition>(<expr><name>sizeProgress</name> <operator>-</operator> <name>manifestSaveLast</name> <operator>&gt;=</operator> <name>manifestSaveSize</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>backupManifestSaveCopy</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>manifestSaveLast</name> <operator>=</operator> <name>sizeProgress</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Reset the memory context occasionally so we don't use too much memory or slow down processing</comment>
                <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_RESET</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><operator>!</operator><call><name>protocolParallelDone</name><argument_list>(<argument><expr><name>parallelExec</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <comment type="line">// Ensure that all processing queues are empty</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>queueIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>queueIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>queueList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>queueIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>lstEmpty</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>queueList</name></name></expr></argument>, <argument><expr><name>queueIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="line">// Remove files from the manifest that were removed during the backup.  This must happen after processing to avoid</comment>
        <comment type="line">// invalidating pointers by deleting items from the list.</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileRemoveIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fileRemoveIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>fileRemove</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileRemoveIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>manifestFileRemove</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>fileRemove</name></expr></argument>, <argument><expr><name>fileRemoveIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <comment type="line">// Log references or create hardlinks for all files</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>compressExt</name> <init>= <expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>compressExtStr</name><argument_list>(<argument><expr><name><name>jobData</name><operator>.</operator><name>compressType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fileIdx</name> <operator>&lt;</operator> <call><name>manifestFileTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFile</name></type> <name>file</name> <init>= <expr><call><name>manifestFile</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If the file has a reference, then it was not copied since it can be retrieved from the referenced backup. However,</comment>
            <comment type="line">// if hardlinking is enabled the link will need to be created.</comment>
            <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>.</operator><name>reference</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If hardlinking is enabled then create a hardlink for files that have not changed since the last backup</comment>
                <if_stmt><if>if <condition>(<expr><name>hardLink</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"hardlink %s to %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>reference</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>linkName</name> <init>= <expr><call><name>storagePathP</name><argument_list>(
                        <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupPathExp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>compressExt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>linkDestination</name> <init>= <expr><call><name>storagePathP</name><argument_list>(
                        <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/%s%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>reference</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>compressExt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>storageLinkCreateP</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>linkDestination</name></expr></argument>, <argument><expr><name>linkName</name></expr></argument>, <argument><expr><operator>.</operator><name>linkType</name> <operator>=</operator> <name>storageLinkHard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else log the reference. With delta, it is possible that references may have been removed if a file needed to be</comment>
                <comment type="line">// recopied.</comment>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"reference %s to %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>reference</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Sync backup paths if required</comment>
        <if_stmt><if>if <condition>(<expr><call><name>storageFeature</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>storageFeaturePathSync</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>pathIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pathIdx</name> <operator>&lt;</operator> <call><name>manifestPathTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pathIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>path</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupPathExp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>manifestPath</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>pathIdx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Always sync the path if it exists or if the backup is full (without bundling) or hardlinked. In the latter cases</comment>
                <comment type="line">// the directory should always exist so we want to error if it does not.</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name>backupType</name> <operator>==</operator> <name>backupTypeFull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>jobData</name><operator>.</operator><name>bundle</name></name><operator>)</operator> <operator>||</operator> <name>hardLink</name> <operator>||</operator> <call><name>storagePathExistsP</name><argument_list>(<argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>storagePathSyncP</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Check and copy WAL segments required to make the backup consistent
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>backupArchiveCheckCopy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BackupData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupData</name></decl></parameter>, <parameter><decl><type><name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cipherPassBackup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BACKUP_DATA</name></expr></argument>, <argument><expr><name>backupData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If archive logs are required to complete the backup, then check them.  This is the default, but can be overridden if the</comment>
    <comment type="line">// archive logs are going to a different server.  Be careful of disabling this option because there is no way to verify that the</comment>
    <comment type="line">// backup will be consistent - at least not here.</comment>
    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveCheck</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>lsnStart</name> <init>= <expr><call><name>pgLsnFromStr</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>lsnStart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>lsnStop</name> <init>= <expr><call><name>pgLsnFromStr</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>lsnStop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                <argument><expr><literal type="string">"check archive for segment(s) %s:%s"</literal></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgLsnToWalSegment</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><name>lsnStart</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>walSegmentSize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgLsnToWalSegment</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><name>lsnStop</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>walSegmentSize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Save the backup manifest before getting archive logs in case of failure</comment>
            <expr_stmt><expr><call><name>backupManifestSaveCopy</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Use base path to set ownership and mode</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestPath</name> <modifier>*</modifier></type><name>basePath</name> <init>= <expr><call><name>manifestPathFind</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>MANIFEST_TARGET_PGDATA_STR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Loop through all the segments in the lsn range</comment>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>walSegmentList</name> <init>= <expr><call><name>pgLsnRangeToWalSegmentList</name><argument_list>(
                <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pgVersion</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><name>lsnStart</name></expr></argument>, <argument><expr><name>lsnStop</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>walSegmentSize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>walSegmentIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>walSegmentIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>walSegmentList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>walSegmentIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walSegment</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>walSegmentList</name></expr></argument>, <argument><expr><name>walSegmentIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Find the actual wal segment file in the archive</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>archiveFile</name> <init>= <expr><call><name>walSegmentFind</name><argument_list>(
                        <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>, <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptArchiveTimeout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveCopy</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Copy can be a pretty expensive operation so log it</comment>
                        <expr_stmt><expr><call><name>LOG_DETAIL_FMT</name><argument_list>(<argument><expr><literal type="string">"copy segment %s to backup"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Get compression type of the WAL segment and backup</comment>
                        <decl_stmt><decl><type><name>CompressType</name></type> <name>archiveCompressType</name> <init>= <expr><call><name>compressTypeFromName</name><argument_list>(<argument><expr><name>archiveFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>CompressType</name></type> <name>backupCompressType</name> <init>= <expr><call><name>compressTypeEnum</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Open the archive file</comment>
                        <decl_stmt><decl><type><name>StorageRead</name> <modifier>*</modifier></type><name>read</name> <init>= <expr><call><name>storageNewReadP</name><argument_list>(
                            <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>,
                            <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_ARCHIVE</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>archiveId</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>archiveFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>IoFilterGroup</name> <modifier>*</modifier></type><name>filterGroup</name> <init>= <expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Decrypt with archive key if encrypted</comment>
                        <expr_stmt><expr><call><name>cipherBlockFilterGroupAdd</name><argument_list>(
                            <argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cipherModeDecrypt</name></expr></argument>,
                            <argument><expr><call><name>infoArchiveCipherPass</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>archiveInfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Compress/decompress if archive and backup do not have the same compression settings</comment>
                        <if_stmt><if>if <condition>(<expr><name>archiveCompressType</name> <operator>!=</operator> <name>backupCompressType</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>archiveCompressType</name> <operator>!=</operator> <name>compressTypeNone</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>decompressFilter</name><argument_list>(<argument><expr><name>archiveCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <if_stmt><if>if <condition>(<expr><name>backupCompressType</name> <operator>!=</operator> <name>compressTypeNone</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(
                                    <argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>compressFilter</name><argument_list>(<argument><expr><name>backupCompressType</name></expr></argument>, <argument><expr><call><name>cfgOptionInt</name><argument_list>(<argument><expr><name>cfgOptCompressLevel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// Encrypt with backup key if encrypted</comment>
                        <expr_stmt><expr><call><name>cipherBlockFilterGroupAdd</name><argument_list>(
                            <argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cipherModeEncrypt</name></expr></argument>, <argument><expr><call><name>manifestCipherSubPass</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Add size filter last to calculate repo size</comment>
                        <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>ioSizeNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Copy the file</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>manifestName</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(
                            <argument><expr><name>MANIFEST_TARGET_PGDATA</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgWalPath</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pgVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>storageCopyP</name><argument_list>(
                            <argument><expr><name>read</name></expr></argument>,
                            <argument><expr><call><name>storageNewWriteP</name><argument_list>(
                                <argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name>backupFileRepoPathP</name><argument_list>(
                                    <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabel</name></expr></argument>, <argument><expr><operator>.</operator><name>manifestName</name> <operator>=</operator> <name>manifestName</name></expr></argument>,
                                    <argument><expr><operator>.</operator><name>compressType</name> <operator>=</operator> <call><name>compressTypeEnum</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Add to manifest</comment>
                        <decl_stmt><decl><type><name>ManifestFile</name></type> <name>file</name> <init>=
                        <expr><block>{
                            <expr><operator>.</operator><name>name</name> <operator>=</operator> <name>manifestName</name></expr>,
                            <expr><operator>.</operator><name>mode</name> <operator>=</operator> <name><name>basePath</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name> <operator>|</operator> <name>S_IRGRP</name> <operator>|</operator> <name>S_IROTH</name><operator>)</operator></expr>,
                            <expr><operator>.</operator><name>user</name> <operator>=</operator> <name><name>basePath</name><operator>-&gt;</operator><name>user</name></name></expr>,
                            <expr><operator>.</operator><name>group</name> <operator>=</operator> <name><name>basePath</name><operator>-&gt;</operator><name>group</name></name></expr>,
                            <expr><operator>.</operator><name>size</name> <operator>=</operator> <name><name>backupData</name><operator>-&gt;</operator><name>walSegmentSize</name></name></expr>,
                            <expr><operator>.</operator><name>sizeRepo</name> <operator>=</operator> <call><name>pckReadU64P</name><argument_list>(<argument><expr><call><name>ioFilterGroupResultP</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><name>SIZE_FILTER_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
                            <expr><operator>.</operator><name>timestamp</name> <operator>=</operator> <call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupTimestampStop</name></expr>,
                        }</block></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>checksumSha1</name></name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>archiveFile</name></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>HASH_TYPE_SHA1_SIZE_HEX</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>manifestFileAdd</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// A keep-alive is required here for the remote holding the backup lock</comment>
                <expr_stmt><expr><call><name>protocolKeepAlive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Save and update all files required to complete the backup
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>backupComplete</name><parameter_list>(<parameter><decl><type><name>InfoBackup</name> <modifier>*</modifier><specifier>const</specifier></type> <name>infoBackup</name></decl></parameter>, <parameter><decl><type><name>Manifest</name> <modifier>*</modifier><specifier>const</specifier></type> <name>manifest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupLabel</name> <init>= <expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabel</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Validation and final save of the backup manifest.  Validate in strict mode to catch as many potential issues as possible.</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <expr_stmt><expr><call><name>manifestValidate</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>backupManifestSaveCopy</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>storageCopy</name><argument_list>(
            <argument><expr><call><name>storageNewReadP</name><argument_list>(
                <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><macro><name>strNewFmt</name><argument_list>(<argument>STORAGE_REPO_BACKUP <literal type="string">"/%s/"</literal> BACKUP_MANIFEST_FILE INFO_COPY_EXT</argument>, <argument>strZ(backupLabel)</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>storageNewWriteP</name><argument_list>(
                <argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>BACKUP_MANIFEST_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Copy a compressed version of the manifest to history. If the repo is encrypted then the passphrase to open the manifest</comment>
        <comment type="line">// is required.  We can't just do a straight copy since the destination needs to be compressed and that must happen before</comment>
        <comment type="line">// encryption in order to be efficient. Compression will always be gz for compatibility and since it is always available.</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <decl_stmt><decl><type><name>StorageRead</name> <modifier>*</modifier></type><name>manifestRead</name> <init>= <expr><call><name>storageNewReadP</name><argument_list>(
                <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>BACKUP_MANIFEST_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>cipherBlockFilterGroupAdd</name><argument_list>(
            <argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>manifestRead</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cipherModeDecrypt</name></expr></argument>,
            <argument><expr><call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>StorageWrite</name> <modifier>*</modifier></type><name>manifestWrite</name> <init>= <expr><call><name>storageNewWriteP</name><argument_list>(
                <argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name>strNewFmt</name><argument_list>(
                    <argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/"</literal> <name>BACKUP_PATH_HISTORY</name> <literal type="string">"/%s/%s.manifest%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>compressExtStr</name><argument_list>(<argument><expr><name>compressTypeGz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioWriteFilterGroup</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>manifestWrite</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>compressFilter</name><argument_list>(<argument><expr><name>compressTypeGz</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>cipherBlockFilterGroupAdd</name><argument_list>(
            <argument><expr><call><name>ioWriteFilterGroup</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>manifestWrite</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cipherModeEncrypt</name></expr></argument>,
            <argument><expr><call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>storageCopyP</name><argument_list>(<argument><expr><name>manifestRead</name></expr></argument>, <argument><expr><name>manifestWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Sync history path if required</comment>
        <if_stmt><if>if <condition>(<expr><call><name>storageFeature</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>storageFeaturePathSync</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>storagePathSyncP</name><argument_list>(<argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/"</literal> <name>BACKUP_PATH_HISTORY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Create a symlink to the most recent backup if supported.  This link is purely informational for the user and is never</comment>
        <comment type="line">// used by us since symlinks are not supported on all storage types.</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <expr_stmt><expr><call><name>backupLinkLatest</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>, <argument><expr><call><name>cfgOptionGroupIdxDefault</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Add manifest and save backup.info (infoBackupSaveFile() is responsible for proper syncing)</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <expr_stmt><expr><call><name>infoBackupDataAdd</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>infoBackupSaveFile</name><argument_list>(
            <argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>INFO_BACKUP_PATH_FILE_STR</name></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Save archive.info/copy so the timestamps will be updated to prevent lifecycle settings from removing the files early</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <expr_stmt><expr><call><name>infoArchiveSaveFile</name><argument_list>(
            <argument><expr><call><name>infoArchiveLoadFile</name><argument_list>(
                <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>INFO_ARCHIVE_PATH_FILE_STR</name></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>storageRepoWrite</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>INFO_ARCHIVE_PATH_FILE_STR</name></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>cmdBackup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Verify the repo is local</comment>
    <expr_stmt><expr><call><name>repoIsLocalVerify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Test for stop file</comment>
    <expr_stmt><expr><call><name>lockStopTest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// If the repo option was not provided and more than one repo is configured, then log the default repo chosen</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptRepo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
                <argument><expr><literal type="string">"repo option not specified, defaulting to %s"</literal></expr></argument>,
                <argument><expr><call><name>cfgOptionGroupName</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><call><name>cfgOptionGroupIdxDefault</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Load backup.info</comment>
        <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name> <init>= <expr><call><name>infoBackupLoadFileReconstruct</name><argument_list>(
            <argument><expr><call><name>storageRepo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>INFO_BACKUP_PATH_FILE_STR</name></expr></argument>, <argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>InfoPgData</name></type> <name>infoPg</name> <init>= <expr><call><name>infoPgDataCurrent</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPassBackup</name> <init>= <expr><call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get pg storage and database objects</comment>
        <decl_stmt><decl><type><name>BackupData</name> <modifier>*</modifier></type><name>backupData</name> <init>= <expr><call><name>backupInit</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get the start timestamp which will later be written into the manifest to track total backup time</comment>
        <decl_stmt><decl><type><name>time_t</name></type> <name>timestampStart</name> <init>= <expr><call><name>backupTime</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Check if there is a prior manifest when backup type is diff/incr</comment>
        <decl_stmt><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifestPrior</name> <init>= <expr><call><name>backupBuildIncrPrior</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Start the backup</comment>
        <decl_stmt><decl><type><name>BackupStartResult</name></type> <name>backupStartResult</name> <init>= <expr><call><name>backupStart</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Build the manifest</comment>
        <decl_stmt><decl><type><name>Manifest</name> <modifier>*</modifier></type><name>manifest</name> <init>= <expr><call><name>manifestNewBuild</name><argument_list>(
            <argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>storagePrimary</name></name></expr></argument>, <argument><expr><name><name>infoPg</name><operator>.</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>infoPg</name><operator>.</operator><name>catalogVersion</name></name></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptOnline</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptChecksumPage</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptRepoBundle</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>cfgOptionLst</name><argument_list>(<argument><expr><name>cfgOptExclude</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name><name>backupStartResult</name><operator>.</operator><name>tablespaceList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Validate the manifest using the copy start time</comment>
        <expr_stmt><expr><call><name>manifestBuildValidate</name><argument_list>(
            <argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDelta</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>backupTime</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>compressTypeEnum</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptCompressType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Build an incremental backup if type is not full (manifestPrior will be freed in this call)</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>backupBuildIncr</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>manifestPrior</name></expr></argument>, <argument><expr><name><name>backupStartResult</name><operator>.</operator><name>walSegmentName</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>manifestCipherSubPassSet</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><call><name>cipherPassGen</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Set delta if it is not already set and the manifest requires it</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptDelta</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>varBool</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupOptionDelta</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>cfgOptionSet</name><argument_list>(<argument><expr><name>cfgOptDelta</name></expr></argument>, <argument><expr><name>cfgSourceParam</name></expr></argument>, <argument><expr><name>BOOL_TRUE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Resume a backup when possible</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>backupResume</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>manifestBackupLabelSet</name><argument_list>(
                <argument><expr><name>manifest</name></expr></argument>,
                <argument><expr><call><name>backupLabelCreate</name><argument_list>(
                    <argument><expr><operator>(</operator><name>BackupType</name><operator>)</operator><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabelPrior</name></expr></argument>, <argument><expr><name>timestampStart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Save the manifest before processing starts</comment>
        <expr_stmt><expr><call><name>backupManifestSaveCopy</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Process the backup manifest</comment>
        <expr_stmt><expr><call><name>backupProcess</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>, <argument><expr><name><name>backupStartResult</name><operator>.</operator><name>lsn</name></name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Check that the clusters are alive and correctly configured after the backup</comment>
        <expr_stmt><expr><call><name>backupDbPing</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// The standby db object and protocol won't be used anymore so free them</comment>
        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptBackupStandby</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>dbFree</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>dbStandby</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>protocolRemoteFree</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>pgIdxStandby</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Stop the backup</comment>
        <decl_stmt><decl><type><name>BackupStopResult</name></type> <name>backupStopResult</name> <init>= <expr><call><name>backupStop</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Complete manifest</comment>
        <expr_stmt><expr><call><name>manifestBuildComplete</name><argument_list>(
            <argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>timestampStart</name></expr></argument>, <argument><expr><name><name>backupStartResult</name><operator>.</operator><name>lsn</name></name></expr></argument>, <argument><expr><name><name>backupStartResult</name><operator>.</operator><name>walSegmentName</name></name></expr></argument>, <argument><expr><name><name>backupStopResult</name><operator>.</operator><name>timestamp</name></name></expr></argument>,
            <argument><expr><name><name>backupStopResult</name><operator>.</operator><name>lsn</name></name></expr></argument>, <argument><expr><name><name>backupStopResult</name><operator>.</operator><name>walSegmentName</name></name></expr></argument>, <argument><expr><name><name>infoPg</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>infoPg</name><operator>.</operator><name>systemId</name></name></expr></argument>, <argument><expr><name><name>backupStartResult</name><operator>.</operator><name>dbList</name></name></expr></argument>,
            <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveCheck</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptArchiveCopy</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptBufferSize</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptCompressLevel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptCompressLevelNetwork</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptRepoHardlink</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptProcessMax</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptBackupStandby</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><ternary><condition><expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptAnnotation</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>cfgOptionKv</name><argument_list>(<argument><expr><name>cfgOptAnnotation</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// The primary db object won't be used anymore so free it</comment>
        <expr_stmt><expr><call><name>dbFree</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>dbPrimary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Check and copy WAL segments required to make the backup consistent</comment>
        <expr_stmt><expr><call><name>backupArchiveCheckCopy</name><argument_list>(<argument><expr><name>backupData</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>cipherPassBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// The primary protocol connection won't be used anymore so free it. This needs to happen after backupArchiveCheckCopy() so</comment>
        <comment type="line">// the backup lock is held on the remote which allows conditional archiving based on the backup lock. Any further access to</comment>
        <comment type="line">// the primary storage object may result in an error (likely eof).</comment>
        <expr_stmt><expr><call><name>protocolRemoteFree</name><argument_list>(<argument><expr><name><name>backupData</name><operator>-&gt;</operator><name>pgIdxPrimary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Complete the backup</comment>
        <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(<argument><expr><literal type="string">"new backup label = %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>backupComplete</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Backup info</comment>
        <expr_stmt><expr><call><name>LOG_INFO_FMT</name><argument_list>(
            <argument><expr><literal type="string">"%s backup size = %s, file total = %u"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSizeFormat</name><argument_list>(<argument><expr><call><name>infoBackupDataByLabel</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupLabel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>backupInfoSizeDelta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>manifestFileTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
