<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/common/ini.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Ini Handler
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ini.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/keyValue.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Object type
***********************************************************************************************************************************/</comment>
<struct>struct <name>Ini</name>
<block>{
    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>store</name></decl>;</decl_stmt>                                                <comment type="line">// Key value store that contains the ini data</comment>
}</block>;</struct>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Ini</name> <modifier>*</modifier></type>
<name>iniNew</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Ini</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>Ini</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>Ini</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>store</name> <operator>=</operator> <call><name>kvNew</name><argument_list>()</argument_list></call></expr>,
        }</block></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INI</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Internal function to get an ini value
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type>
<name>iniGetInternal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Ini</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>section</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>required</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INI</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>required</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>section</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Get the section</comment>
    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>sectionKv</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>store</name></name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Section must exist to get the value</comment>
    <if_stmt><if>if <condition>(<expr><name>sectionKv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>kvGet</name><argument_list>(<argument><expr><name>sectionKv</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// If value is null and required then error</comment>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>required</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"section '%s', key '%s' does not exist"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type>
<name>iniGet</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Ini</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>section</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INI</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>iniGetInternal</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type>
<name>iniGetDefault</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Ini</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>section</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>defaultValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INI</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>defaultValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Get the value</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>iniGetInternal</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><ternary><condition><expr><name>result</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>defaultValue</name></expr> </then><else>: <expr><call><name>varStr</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StringList</name> <modifier>*</modifier></type>
<name>iniGetList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Ini</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>section</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INI</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Get the value</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>iniGetInternal</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><ternary><condition><expr><name>result</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>varVarLst</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>iniSectionKeyIsList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Ini</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>section</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INI</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Get the value</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>iniGetInternal</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><call><name>varType</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeVariantList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StringList</name> <modifier>*</modifier></type>
<name>iniSectionKeyList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Ini</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>section</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INI</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>section</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get the section</comment>
        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>sectionKv</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>store</name></name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Return key list if the section exists</comment>
        <if_stmt><if>if <condition>(<expr><name>sectionKv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>kvKeyList</name><argument_list>(<argument><expr><name>sectionKv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <comment type="line">// Otherwise return an empty list</comment>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><call><name>strLstMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StringList</name> <modifier>*</modifier></type>
<name>iniSectionList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Ini</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INI</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get the sections from the keyList</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>kvKeyList</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>store</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>strLstMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>iniParse</name><parameter_list>(<parameter><decl><type><name>Ini</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>content</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INI</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_OBJ_BEGIN</name><argument_list>(<argument>this</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>kvFree</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>store</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>store</name></name> <operator>=</operator> <call><name>kvNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>content</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// Track the current section</comment>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>section</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <comment type="line">// Split the content into lines and loop</comment>
                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>lines</name> <init>= <expr><call><name>strLstNewSplitZ</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>lineIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>lineIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>lines</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>lineIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="line">// Get next line</comment>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>strTrim</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>lines</name></expr></argument>, <argument><expr><name>lineIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>linePtr</name> <init>= <expr><call><name>strZ</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Only interested in lines that are not blank or comments</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>linePtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'#'</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// Looks like this line is a section</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>linePtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition>
                        <block>{<block_content>
                            <comment type="line">// Make sure the section ends with ]</comment>
                            <if_stmt><if>if <condition>(<expr><name><name>linePtr</name><index>[<expr><call><name>strSize</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"ini section should end with ] at line %u: %s"</literal></expr></argument>, <argument><expr><name>lineIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>linePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <comment type="line">// Assign section</comment>
                            <expr_stmt><expr><name>section</name> <operator>=</operator> <call><name>strNewZN</name><argument_list>(<argument><expr><name>linePtr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <comment type="line">// Else it should be a key/value</comment>
                        <else>else
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>section</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"key/value found outside of section at line %u: %s"</literal></expr></argument>, <argument><expr><name>lineIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>linePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <comment type="line">// Find the =</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lineEqual</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>linePtr</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name>lineEqual</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"missing '=' in key/value at line %u: %s"</literal></expr></argument>, <argument><expr><name>lineIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>linePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <comment type="line">// Extract the key</comment>
                            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>strTrim</name><argument_list>(<argument><expr><call><name>strNewZN</name><argument_list>(<argument><expr><name>linePtr</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>lineEqual</name> <operator>-</operator> <name>linePtr</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"key is zero-length at line %u: %s"</literal></expr></argument>, <argument><expr><name>lineIdx</name><operator>++</operator></expr></argument>, <argument><expr><name>linePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <comment type="line">// Store the section/key/value</comment>
                            <expr_stmt><expr><call><name>iniSet</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>strTrim</name><argument_list>(<argument><expr><call><name>strNewZ</name><argument_list>(<argument><expr><name>lineEqual</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_OBJ_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>iniSet</name><parameter_list>(<parameter><decl><type><name>Ini</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>section</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INI</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>section</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>sectionKey</name> <init>= <expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>sectionKv</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>store</name></name></expr></argument>, <argument><expr><name>sectionKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>sectionKv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>sectionKv</name> <operator>=</operator> <call><name>kvPutKv</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>store</name></name></expr></argument>, <argument><expr><name>sectionKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>kvAdd</name><argument_list>(<argument><expr><name>sectionKv</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>iniLoad</name><parameter_list>(
    <parameter><decl><type><name>IoRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>read</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>callbackFunction</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>section</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list></function_decl></parameter>,
    <parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>callbackData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>IO_READ</name></expr></argument>, <argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>FUNCTIONP</name></expr></argument>, <argument><expr><name>callbackFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>callbackData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>read</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Track the current section/key/value</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>section</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>value</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Keep track of the line number for error reporting</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>lineIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <macro><name>MEM_CONTEXT_TEMP_RESET_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ioReadOpen</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <do>do
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>ioReadLineParam</name><argument_list>(<argument><expr><name>read</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>linePtr</name> <init>= <expr><call><name>strZ</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Only interested in lines that are not blank</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// The line is a section. Since the value must be valid JSON this means that the value must never be an array.</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>linePtr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal> <operator>&amp;&amp;</operator> <name><name>linePtr</name><index>[<expr><call><name>strSize</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>strCatZN</name><argument_list>(<argument><expr><call><name>strTrunc</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>linePtr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>strEmpty</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"invalid empty section at line %u: %s"</literal></expr></argument>, <argument><expr><name>lineIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>linePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Else it is a key/value</comment>
                    <else>else
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>strEmpty</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"key/value found outside of section at line %u: %s"</literal></expr></argument>, <argument><expr><name>lineIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>linePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                        <comment type="line">// Find the =</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lineEqual</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>linePtr</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>lineEqual</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"missing '=' in key/value at line %u: %s"</literal></expr></argument>, <argument><expr><name>lineIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>linePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                        <comment type="line">// Extract the key/value. This may require some retries if the key includes an = character since this is</comment>
                        <comment type="line">// also the separator. We know the value must be valid JSON so if it isn't then add the characters up to</comment>
                        <comment type="line">// the next = to the key and try to parse the value as JSON again. If the value never becomes valid JSON</comment>
                        <comment type="line">// then an error is thrown.</comment>
                        <decl_stmt><decl><type><name>bool</name></type> <name>retry</name></decl>;</decl_stmt>

                        <do>do
                        <block>{<block_content>
                            <expr_stmt><expr><name>retry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                            <comment type="line">// Get key/value</comment>
                            <expr_stmt><expr><call><name>strCatZN</name><argument_list>(<argument><expr><call><name>strTrunc</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>linePtr</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>lineEqual</name> <operator>-</operator> <name>linePtr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><call><name>strTrunc</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lineEqual</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// Check that the value is valid JSON</comment>
                            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>jsonValidate</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block>
                            <macro><name>CATCH</name><argument_list>(<argument>JsonFormatError</argument>)</argument_list></macro>
                            <block>{<block_content>
                                <comment type="line">// If value is not valid JSON look for another =. If not found then nothing to retry.</comment>
                                <expr_stmt><expr><name>lineEqual</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>lineEqual</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>lineEqual</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                        <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"invalid JSON value at line %u '%s': %s"</literal></expr></argument>, <argument><expr><name>lineIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>linePtr</name></expr></argument>,
                                        <argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <comment type="line">// Try again with = in new position</comment>
                                <expr_stmt><expr><name>retry</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block>
                            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        while <condition>(<expr><name>retry</name></expr>)</condition>;</do>

                        <comment type="line">// Key may not be zero-length</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"key is zero-length at line %u: %s"</literal></expr></argument>, <argument><expr><name>lineIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>linePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                        <comment type="line">// Callback with the section/key/value</comment>
                        <expr_stmt><expr><call><name>callbackFunction</name><argument_list>(<argument><expr><name>callbackData</name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>lineIdx</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_RESET</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><operator>!</operator><call><name>ioReadEof</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

            <expr_stmt><expr><call><name>ioReadClose</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
