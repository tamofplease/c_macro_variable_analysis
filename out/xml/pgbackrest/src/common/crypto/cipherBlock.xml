<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/common/crypto/cipherBlock.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Block Cipher
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/evp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/err.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/crypto/cipherBlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/crypto/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/filter/filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/object.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Header constants and sizes
***********************************************************************************************************************************/</comment>
<comment type="line">// Magic constant for salted encrypt.  Only salted encrypt is done here, but this constant is required for compatibility with the</comment>
<comment type="line">// openssl command-line tool.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIPHER_BLOCK_MAGIC</name></cpp:macro>                                          <cpp:value>"Salted__"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIPHER_BLOCK_MAGIC_SIZE</name></cpp:macro>                                     <cpp:value>(sizeof(CIPHER_BLOCK_MAGIC) - 1)</cpp:value></cpp:define>

<comment type="line">// Total length of cipher header</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIPHER_BLOCK_HEADER_SIZE</name></cpp:macro>                                    <cpp:value>(CIPHER_BLOCK_MAGIC_SIZE + PKCS5_SALT_LEN)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Object type
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>CipherBlock</name>
<block>{
    <decl_stmt><decl><type><name>CipherMode</name></type> <name>mode</name></decl>;</decl_stmt>                                                <comment type="line">// Mode encrypt/decrypt</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>raw</name></decl>;</decl_stmt>                                                       <comment type="line">// Omit header magic to save space</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>saltDone</name></decl>;</decl_stmt>                                                  <comment type="line">// Has the salt been read/generated?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>processDone</name></decl>;</decl_stmt>                                               <comment type="line">// Has any data been processed?</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>passSize</name></decl>;</decl_stmt>                                                <comment type="line">// Size of passphrase in bytes</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pass</name></decl>;</decl_stmt>                                            <comment type="line">// Passphrase used to generate encryption key</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>headerSize</name></decl>;</decl_stmt>                                              <comment type="line">// Size of header read during decrypt</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>header</name><index>[<expr><name>CIPHER_BLOCK_HEADER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>                 <comment type="line">// Buffer to hold partial header during decrypt</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>EVP_CIPHER</name> <modifier>*</modifier></type><name>cipher</name></decl>;</decl_stmt>                                       <comment type="line">// Cipher object</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>EVP_MD</name> <modifier>*</modifier></type><name>digest</name></decl>;</decl_stmt>                                           <comment type="line">// Message digest object</comment>
    <decl_stmt><decl><type><name>EVP_CIPHER_CTX</name> <modifier>*</modifier></type><name>cipherContext</name></decl>;</decl_stmt>                                  <comment type="line">// Encrypt/decrypt context</comment>

    <decl_stmt><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>                                                 <comment type="line">// Internal buffer in case destination buffer isn't large enough</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>inputSame</name></decl>;</decl_stmt>                                                 <comment type="line">// Is the same input required on next process call?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>done</name></decl>;</decl_stmt>                                                      <comment type="line">// Is processing done?</comment>
}</block></struct></type> <name>CipherBlock</name>;</typedef>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Macros for function logging
***********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>cipherBlockToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CipherBlock</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strNewFmt</name><argument_list>(
        <argument><expr><literal type="string">"{inputSame: %s, done: %s}"</literal></expr></argument>, <argument><expr><call><name>cvtBoolToConstZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>inputSame</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cvtBoolToConstZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>done</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_CIPHER_BLOCK_TYPE</name></cpp:macro>                                                                                             \
    <cpp:value>CipherBlock *</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_LOG_CIPHER_BLOCK_FORMAT</name><parameter_list>(<parameter><type><name>value</name></type></parameter>, <parameter><type><name>buffer</name></type></parameter>, <parameter><type><name>bufferSize</name></type></parameter>)</parameter_list></cpp:macro>                                                                \
    <cpp:value>FUNCTION_LOG_STRING_OBJECT_FORMAT(value, cipherBlockToLog, buffer, bufferSize)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Free cipher context
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cipherBlockFreeResource</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>CipherBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>CIPHER_BLOCK</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EVP_CIPHER_CTX_free</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>cipherContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Determine how large the destination buffer should be
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>cipherBlockProcessSize</name><parameter_list>(<parameter><decl><type><name>CipherBlock</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sourceSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>CIPHER_BLOCK</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>sourceSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Destination size is source size plus one extra block</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>destinationSize</name> <init>= <expr><name>sourceSize</name> <operator>+</operator> <name>EVP_MAX_BLOCK_LENGTH</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// On encrypt the header size must be included before the first block</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>cipherModeEncrypt</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>this</name><operator>-&gt;</operator><name>saltDone</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>destinationSize</name> <operator>+=</operator> <name>CIPHER_BLOCK_MAGIC_SIZE</name> <operator>+</operator> <name>PKCS5_SALT_LEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>destinationSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Encrypt/decrypt data
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>cipherBlockProcessBlock</name><parameter_list>(<parameter><decl><type><name>CipherBlock</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sourceSize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>CIPHER_BLOCK</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>UCHARDATA</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>sourceSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>UCHARDATA</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>source</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>sourceSize</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>destination</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Actual destination size</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>destinationSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the salt has not been generated/read yet</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>this</name><operator>-&gt;</operator><name>saltDone</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>salt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// On encrypt the salt is generated</comment>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>cipherModeEncrypt</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Add magic to the destination buffer so openssl knows the file is salted</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>this</name><operator>-&gt;</operator><name>raw</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><name>CIPHER_BLOCK_MAGIC</name></expr></argument>, <argument><expr><name>CIPHER_BLOCK_MAGIC_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>destination</name> <operator>+=</operator> <name>CIPHER_BLOCK_MAGIC_SIZE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>destinationSize</name> <operator>+=</operator> <name>CIPHER_BLOCK_MAGIC_SIZE</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Add salt to the destination buffer</comment>
            <expr_stmt><expr><call><name>cryptoRandomBytes</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><name>PKCS5_SALT_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>salt</name> <operator>=</operator> <name>destination</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>destination</name> <operator>+=</operator> <name>PKCS5_SALT_LEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>destinationSize</name> <operator>+=</operator> <name>PKCS5_SALT_LEN</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// On decrypt the salt is read from the header</comment>
        <if type="elseif">else if <condition>(<expr><name>sourceSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Check if the entire header has been read</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>headerExpected</name> <init>= <expr><ternary><condition><expr><name><name>this</name><operator>-&gt;</operator><name>raw</name></name></expr> ?</condition><then> <expr><name>PKCS5_SALT_LEN</name></expr> </then><else>: <expr><name>CIPHER_BLOCK_HEADER_SIZE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>headerSize</name></name> <operator>+</operator> <name>sourceSize</name> <operator>&gt;=</operator> <name>headerExpected</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Copy header (or remains of header) from source into the header buffer</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>header</name></name> <operator>+</operator> <name><name>this</name><operator>-&gt;</operator><name>headerSize</name></name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>headerExpected</name> <operator>-</operator> <name><name>this</name><operator>-&gt;</operator><name>headerSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>salt</name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>header</name></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>this</name><operator>-&gt;</operator><name>raw</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>CIPHER_BLOCK_MAGIC_SIZE</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

                <comment type="line">// Advance source and source size by the number of bytes read</comment>
                <expr_stmt><expr><name>source</name> <operator>+=</operator> <name>headerExpected</name> <operator>-</operator> <name><name>this</name><operator>-&gt;</operator><name>headerSize</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>sourceSize</name> <operator>-=</operator> <name>headerExpected</name> <operator>-</operator> <name><name>this</name><operator>-&gt;</operator><name>headerSize</name></name></expr>;</expr_stmt>

                <comment type="line">// The first bytes of the file to decrypt should be equal to the magic.  If not then this is not an</comment>
                <comment type="line">// encrypted file, or at least not in a format we recognize.</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>this</name><operator>-&gt;</operator><name>raw</name></name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><name>CIPHER_BLOCK_MAGIC</name></expr></argument>, <argument><expr><name>CIPHER_BLOCK_MAGIC_SIZE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>CryptoError</name></expr></argument>, <argument><expr><literal type="string">"cipher header invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else copy what was provided into the header buffer and return 0</comment>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>header</name></name> <operator>+</operator> <name><name>this</name><operator>-&gt;</operator><name>headerSize</name></name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>sourceSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>headerSize</name></name> <operator>+=</operator> <name>sourceSize</name></expr>;</expr_stmt>

                <comment type="line">// Indicate that there is nothing left to process</comment>
                <expr_stmt><expr><name>sourceSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If salt generation/read is done</comment>
        <if_stmt><if>if <condition>(<expr><name>salt</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Generate key and initialization vector</comment>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>key</name><index>[<expr><name>EVP_MAX_KEY_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>initVector</name><index>[<expr><name>EVP_MAX_IV_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>EVP_BytesToKey</name><argument_list>(
                <argument><expr><name><name>this</name><operator>-&gt;</operator><name>cipher</name></name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>digest</name></name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>this</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>this</name><operator>-&gt;</operator><name>passSize</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>initVector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Create context to track cipher</comment>
            <expr_stmt><expr><call><name>cryptoError</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>this</name><operator>-&gt;</operator><name>cipherContext</name></name> <operator>=</operator> <call><name>EVP_CIPHER_CTX_new</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"unable to create context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Set free callback to ensure cipher context is freed</comment>
            <expr_stmt><expr><call><name>memContextCallbackSet</name><argument_list>(<argument><expr><call><name>objMemContext</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cipherBlockFreeResource</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Initialize cipher</comment>
            <expr_stmt><expr><call><name>cryptoError</name><argument_list>(
                <argument><expr><operator>!</operator><call><name>EVP_CipherInit_ex</name><argument_list>(
                    <argument><expr><name><name>this</name><operator>-&gt;</operator><name>cipherContext</name></name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>cipher</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>initVector</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>cipherModeEncrypt</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><literal type="string">"unable to initialize cipher"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>saltDone</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Recheck that source size &gt; 0 as the bytes may have been consumed reading the header</comment>
    <if_stmt><if>if <condition>(<expr><name>sourceSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Process the data</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>destinationUpdateSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>cryptoError</name><argument_list>(
            <argument><expr><operator>!</operator><call><name>EVP_CipherUpdate</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>cipherContext</name></name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>destinationUpdateSize</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>sourceSize</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><literal type="string">"unable to process cipher"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>destinationSize</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>destinationUpdateSize</name></expr>;</expr_stmt>

        <comment type="line">// Note that data has been processed so flush is valid</comment>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>processDone</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Return actual destination size</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>destinationSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Flush the remaining data
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>cipherBlockFlush</name><parameter_list>(<parameter><decl><type><name>CipherBlock</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>CIPHER_BLOCK</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BUFFER</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>destination</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Actual destination size</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>destinationSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// If no header was processed then error</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>this</name><operator>-&gt;</operator><name>saltDone</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>CryptoError</name></expr></argument>, <argument><expr><literal type="string">"cipher header missing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Only flush remaining data if some data was processed</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EVP_CipherFinal</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>cipherContext</name></name></expr></argument>, <argument><expr><call><name>bufRemainsPtr</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>destinationSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>CryptoError</name></expr></argument>, <argument><expr><literal type="string">"unable to flush"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Return actual destination size</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>destinationSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Process function used by C filter
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cipherBlockProcess</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Buffer</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>CipherBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>CIPHER_BLOCK</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BUFFER</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BUFFER</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>destination</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>bufRemains</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Copy already buffered bytes</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bufEmpty</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>bufRemains</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>bufUsed</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>bufCat</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>bufUsedZero</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>inputSame</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name></type> <name>catSize</name> <init>= <expr><call><name>bufRemains</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>bufCatSub</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>catSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><call><name>bufPtr</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>bufPtr</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>catSize</name></expr></argument>, <argument><expr><call><name>bufUsed</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>catSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>bufUsedSet</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><call><name>bufUsed</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>catSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>inputSame</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>bufEmpty</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Determine how much space is required in the output buffer</comment>
        <decl_stmt><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>outputActual</name> <init>= <expr><name>destination</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>size_t</name></type> <name>destinationSize</name> <init>= <expr><call><name>cipherBlockProcessSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><ternary><condition><expr><name>source</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>bufUsed</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>destinationSize</name> <operator>&gt;</operator> <call><name>bufRemains</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Allocate the buffer if needed</comment>
            <macro><name>MEM_CONTEXT_OBJ_BEGIN</name><argument_list>(<argument>this</argument>)</argument_list></macro>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>bufNew</name><argument_list>(<argument><expr><name>destinationSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Resize buffer if needed</comment>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>bufResize</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>destinationSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_OBJ_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>outputActual</name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Encrypt/decrypt bytes</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>destinationSizeActual</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// If salt was not generated it means that process() was never called with any data.  It's OK to encrypt a zero byte</comment>
            <comment type="line">// file but we need to call process to generate the header.</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>this</name><operator>-&gt;</operator><name>saltDone</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>destinationSizeActual</name> <operator>=</operator> <call><name>cipherBlockProcessBlock</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>bufRemainsPtr</name><argument_list>(<argument><expr><name>outputActual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>bufUsedInc</name><argument_list>(<argument><expr><name>outputActual</name></expr></argument>, <argument><expr><name>destinationSizeActual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>destinationSizeActual</name> <operator>=</operator> <call><name>cipherBlockFlush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>outputActual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>destinationSizeActual</name> <operator>=</operator> <call><name>cipherBlockProcessBlock</name><argument_list>(
                <argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>bufPtrConst</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>bufUsed</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>bufRemainsPtr</name><argument_list>(<argument><expr><name>outputActual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>bufUsedInc</name><argument_list>(<argument><expr><name>outputActual</name></expr></argument>, <argument><expr><name>destinationSizeActual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Copy from buffer to destination if needed</comment>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bufEmpty</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>cipherBlockProcess</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Is cipher done?
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cipherBlockDone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>THIS_VOID</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CipherBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>CIPHER_BLOCK</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>done</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>this</name><operator>-&gt;</operator><name>inputSame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Should the same input be provided again?
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cipherBlockInputSame</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>THIS_VOID</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CipherBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>CIPHER_BLOCK</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>inputSame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>IoFilter</name> <modifier>*</modifier></type>
<name>cipherBlockNew</name><parameter_list>(<parameter><decl><type><name>CipherMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>CipherType</name></type> <name>cipherType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Buffer</name> <modifier>*</modifier></type><name>pass</name></decl></parameter>, <parameter><decl><type><name>CipherBlockNewParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>cipherType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BUFFER</name></expr></argument>, <argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                          <comment type="line">// Use FUNCTION_TEST so passphrase is not logged</comment>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>digest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>raw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pass</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>bufEmpty</name><argument_list>(<argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Init crypto subsystem</comment>
    <expr_stmt><expr><call><name>cryptoInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Lookup cipher by name.  This means the ciphers passed in must exactly match a name expected by OpenSSL.  This is a good</comment>
    <comment type="line">// thing since the name required by the openssl command-line tool will match what is used by pgBackRest.</comment>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cipherTypeStr</name> <init>= <expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name>cipherType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>EVP_CIPHER</name> <modifier>*</modifier></type><name>cipher</name> <init>= <expr><call><name>EVP_get_cipherbyname</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>cipherTypeStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cipher</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"unable to load cipher '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>cipherTypeStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><name>cipherTypeStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Lookup digest.  If not defined it will be set to sha1.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>EVP_MD</name> <modifier>*</modifier></type><name>digest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>digest</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>digest</name> <operator>=</operator> <call><name>EVP_get_digestbyname</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>param</name><operator>.</operator><name>digest</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>digest</name> <operator>=</operator> <call><name>EVP_sha1</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>digest</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"unable to load digest '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>param</name><operator>.</operator><name>digest</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Allocate memory to hold process state</comment>
    <decl_stmt><decl><type><name>IoFilter</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>CipherBlock</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>, <argument>.allocQty = MEM_CONTEXT_QTY_MAX</argument>, <argument>.callbackQty = <literal type="number">1</literal></argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CipherBlock</name> <modifier>*</modifier></type><name>driver</name> <init>= <expr><call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><operator>*</operator><name>driver</name> <operator>=</operator> <operator>(</operator><name>CipherBlock</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>mode</name> <operator>=</operator> <name>mode</name></expr>,
            <expr><operator>.</operator><name>raw</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>raw</name></name></expr>,
            <expr><operator>.</operator><name>cipher</name> <operator>=</operator> <name>cipher</name></expr>,
            <expr><operator>.</operator><name>digest</name> <operator>=</operator> <name>digest</name></expr>,
            <expr><operator>.</operator><name>passSize</name> <operator>=</operator> <call><name>bufUsed</name><argument_list>(<argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr>,
        }</block></expr>;</expr_stmt>

        <comment type="line">// Store the passphrase</comment>
        <expr_stmt><expr><name><name>driver</name><operator>-&gt;</operator><name>pass</name></name> <operator>=</operator> <call><name>memNew</name><argument_list>(<argument><expr><name><name>driver</name><operator>-&gt;</operator><name>passSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>driver</name><operator>-&gt;</operator><name>pass</name></name></expr></argument>, <argument><expr><call><name>bufPtrConst</name><argument_list>(<argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>driver</name><operator>-&gt;</operator><name>passSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Create param list</comment>
        <decl_stmt><decl><type><name>Pack</name> <modifier>*</modifier></type><name>paramList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>packWrite</name> <init>= <expr><call><name>pckWriteNewP</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>packWrite</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteU64P</name><argument_list>(<argument><expr><name>packWrite</name></expr></argument>, <argument><expr><name>cipherType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteBinP</name><argument_list>(<argument><expr><name>packWrite</name></expr></argument>, <argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>packWrite</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>digest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>packWrite</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>raw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pckWriteEndP</name><argument_list>(<argument><expr><name>packWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>paramList</name> <operator>=</operator> <call><name>pckMove</name><argument_list>(<argument><expr><call><name>pckWriteResult</name><argument_list>(<argument><expr><name>packWrite</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Create filter interface</comment>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>ioFilterNewP</name><argument_list>(
            <argument><expr><name>CIPHER_BLOCK_FILTER_TYPE</name></expr></argument>, <argument><expr><name>driver</name></expr></argument>, <argument><expr><name>paramList</name></expr></argument>, <argument><expr><operator>.</operator><name>done</name> <operator>=</operator> <name>cipherBlockDone</name></expr></argument>, <argument><expr><operator>.</operator><name>inOut</name> <operator>=</operator> <name>cipherBlockProcess</name></expr></argument>,
            <argument><expr><operator>.</operator><name>inputSame</name> <operator>=</operator> <name>cipherBlockInputSame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>IO_FILTER</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>IoFilter</name> <modifier>*</modifier></type>
<name>cipherBlockNewPack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Pack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>paramList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IoFilter</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>paramListPack</name> <init>= <expr><call><name>pckReadNew</name><argument_list>(<argument><expr><name>paramList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CipherMode</name></type> <name>cipherMode</name> <init>= <expr><operator>(</operator><name>CipherMode</name><operator>)</operator><call><name>pckReadU64P</name><argument_list>(<argument><expr><name>paramListPack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CipherType</name></type> <name>cipherType</name> <init>= <expr><operator>(</operator><name>CipherType</name><operator>)</operator><call><name>pckReadU64P</name><argument_list>(<argument><expr><name>paramListPack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>Buffer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pass</name> <init>= <expr><call><name>pckReadBinP</name><argument_list>(<argument><expr><name>paramListPack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>digest</name> <init>= <expr><call><name>pckReadStrP</name><argument_list>(<argument><expr><name>paramListPack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raw</name> <init>= <expr><call><name>pckReadBoolP</name><argument_list>(<argument><expr><name>paramListPack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ioFilterMove</name><argument_list>(<argument><expr><call><name>cipherBlockNewP</name><argument_list>(<argument><expr><name>cipherMode</name></expr></argument>, <argument><expr><name>cipherType</name></expr></argument>, <argument><expr><name>pass</name></expr></argument>, <argument><expr><operator>.</operator><name>digest</name> <operator>=</operator> <name>digest</name></expr></argument>, <argument><expr><operator>.</operator><name>raw</name> <operator>=</operator> <name>raw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>IoFilterGroup</name> <modifier>*</modifier></type>
<name>cipherBlockFilterGroupAdd</name><parameter_list>(<parameter><decl><type><name>IoFilterGroup</name> <modifier>*</modifier></type><name>filterGroup</name></decl></parameter>, <parameter><decl><type><name>CipherType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>CipherMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>IO_FILTER_GROUP</name></expr></argument>, <argument><expr><name>filterGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                          <comment type="line">// Use FUNCTION_TEST so passphrase is not logged</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>filterGroup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>cipherTypeNone</name> <operator>&amp;&amp;</operator> <name>pass</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>type</name> <operator>!=</operator> <name>cipherTypeNone</name> <operator>&amp;&amp;</operator> <name>pass</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>cipherTypeNone</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ioFilterGroupAdd</name><argument_list>(<argument><expr><name>filterGroup</name></expr></argument>, <argument><expr><call><name>cipherBlockNewP</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><call><name>BUFSTR</name><argument_list>(<argument><expr><name>pass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>IO_FILTER_GROUP</name></expr></argument>, <argument><expr><name>filterGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
