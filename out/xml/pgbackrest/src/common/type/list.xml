<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/common/type/list.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
List Handler
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/list.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Object type
***********************************************************************************************************************************/</comment>
<struct>struct <name>List</name>
<block>{
    <decl_stmt><decl><type><name>ListPub</name></type> <name>pub</name></decl>;</decl_stmt>                                                    <comment type="line">// Publicly accessible variables</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>itemSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>listSizeMax</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SortOrder</name></type> <name>sortOrder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>listAlloc</name></decl>;</decl_stmt>                                       <comment type="line">// Pointer to memory allocated for the list</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>                                            <comment type="line">// Pointer to the current start of the list</comment>
    <decl_stmt><decl><type><name>ListComparator</name> <modifier>*</modifier></type><name>comparator</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>lstNew</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>itemSize</name></decl></parameter>, <parameter><decl><type><name>ListParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>itemSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>FUNCTIONP</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>comparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>List</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>, <argument>.allocQty = MEM_CONTEXT_QTY_MAX</argument>)</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Create object</comment>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>List</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>itemSize</name> <operator>=</operator> <name>itemSize</name></expr>,
            <expr><operator>.</operator><name>sortOrder</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>sortOrder</name></name></expr>,
            <expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>comparator</name></name></expr>,
        }</block></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>lstClear</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(this)</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memFree</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>listSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>listSizeMax</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>int</name></type>
<name>lstComparatorStr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item1</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item2</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><call><name>strCmp</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>String</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>item1</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>String</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>item2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>int</name></type>
<name>lstComparatorZ</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item1</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item2</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>item1</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>item2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
General function for a descending comparator that simply switches the parameters on the main comparator (which should be asc)
***********************************************************************************************************************************/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>comparatorDescList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>lstComparatorDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name><name>comparatorDescList</name><operator>-&gt;</operator><name>comparator</name></name><argument_list>(<argument><expr><name>item2</name></expr></argument>, <argument><expr><name>item1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>lstGet</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>listIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>listIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Ensure list index is in range</comment>
    <if_stmt><if>if <condition>(<expr><name>listIdx</name> <operator>&gt;=</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"cannot get index %u from list with %u value(s)"</literal></expr></argument>, <argument><expr><name>listIdx</name></expr></argument>, <argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Return pointer to list item</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>+</operator> <operator>(</operator><name>listIdx</name> <operator>*</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>lstGetLast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Ensure there are items in the list</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"cannot get last from list with no values"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Return pointer to list item</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><call><name>lstGet</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>lstFind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>comparator</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>sortOrder</name></name> <operator>==</operator> <name>sortOrderAsc</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><call><name>bsearch</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>comparator</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>sortOrder</name></name> <operator>==</operator> <name>sortOrderDesc</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Assign the list for the descending comparator to use</comment>
            <expr_stmt><expr><name>comparatorDescList</name> <operator>=</operator> <name>this</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><call><name>bsearch</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name></expr></argument>, <argument><expr><name>lstComparatorDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Fall back on an iterative search</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>listIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>listIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>listIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>this</name><operator>-&gt;</operator><name>comparator</name></name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><call><name>lstGet</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>listIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><call><name>lstGet</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>listIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type>
<name>lstFindIdx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><ternary><condition><expr><name>result</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>LIST_NOT_FOUND</name></expr> </then><else>: <expr><call><name>lstIdx</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>lstFindDefault</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>itemDefault</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>itemDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name><init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><ternary><condition><expr><name>result</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>itemDefault</name></expr> </then><else>: <expr><name>result</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>unsigned</name> <name>int</name></type>
<name>lstIdx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Item pointers should always be aligned with the beginning of an item in the list</comment>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator> <specifier>const</specifier><operator>)</operator><name>item</name> <operator>-</operator> <name><name>this</name><operator>-&gt;</operator><name>list</name></name><operator>)</operator> <operator>%</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>result</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator> <specifier>const</specifier><operator>)</operator><name>item</name> <operator>-</operator> <name><name>this</name><operator>-&gt;</operator><name>list</name></name><operator>)</operator> <operator>/</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Item pointers should always be in range</comment>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>result</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>lstInsert</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>listIdx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>listIdx</name> <operator>&lt;=</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If list size = max then allocate more space</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>this</name><operator>-&gt;</operator><name>listSizeMax</name></name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(this)</argument>)</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// If nothing has been allocated yet</comment>
            <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>listSizeMax</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>listSizeMax</name></name> <operator>=</operator> <name>LIST_INITIAL_SIZE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <call><name>memNew</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>listSizeMax</name></name> <operator>*</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else the list needs to be extended</comment>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>listSizeMax</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <call><name>memResize</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>listSizeMax</name></name> <operator>*</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>listAlloc</name></name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>list</name></name></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else if there is space before the beginning of the list then move the list down</comment>
    <if type="elseif">else if <condition>(
        <expr><operator>(</operator><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>!=</operator> <name><name>this</name><operator>-&gt;</operator><name>listAlloc</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>-</operator> <name><name>this</name><operator>-&gt;</operator><name>listAlloc</name></name><operator>)</operator> <operator>/</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name><operator>)</operator> <operator>==</operator> <name><name>this</name><operator>-&gt;</operator><name>listSizeMax</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>listAlloc</name></name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>listAlloc</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Calculate the position where this item will be copied</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>itemPtr</name> <init>= <expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>+</operator> <operator>(</operator><name>listIdx</name> <operator>*</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="line">// If not inserting at the end then move items down to make space</comment>
    <if_stmt><if>if <condition>(<expr><name>listIdx</name> <operator>!=</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>listIdx</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name><operator>)</operator></expr></argument>, <argument><expr><name>itemPtr</name></expr></argument>, <argument><expr><operator>(</operator><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>listIdx</name><operator>)</operator> <operator>*</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Copy item into the list</comment>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>sortOrder</name></name> <operator>=</operator> <name>sortOrderNone</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>itemPtr</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>listSize</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>itemPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>lstRemoveIdx</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>listIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>listIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>listIdx</name> <operator>&lt;=</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Decrement the list size</comment>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>listSize</name></name><operator>--</operator></expr>;</expr_stmt>

    <comment type="line">// If this is the first item then move the list pointer up to avoid moving all the items</comment>
    <if_stmt><if>if <condition>(<expr><name>listIdx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>+=</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else remove the item by moving the items after it down</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(
            <argument><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>+</operator> <operator>(</operator><name>listIdx</name> <operator>*</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>listIdx</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name><operator>)</operator></expr></argument>,
            <argument><expr><operator>(</operator><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>listIdx</name><operator>)</operator> <operator>*</operator> <name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>lstRemove</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>listIdx</name> <init>= <expr><call><name>lstFindIdx</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>listIdx</name> <operator>!=</operator> <name>LIST_NOT_FOUND</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>lstRemoveIdx</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>listIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>lstRemoveLast</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"cannot remove last from list with no values"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><call><name>lstRemoveIdx</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>lstSort</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>SortOrder</name></type> <name>sortOrder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>sortOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>comparator</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name>sortOrder</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>sortOrderAsc</name></expr>:</case>
                <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>comparator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>sortOrderDesc</name></expr>:</case>
            <block>{<block_content>
                <comment type="line">// Assign the list that will be sorted for the comparator function to use</comment>
                <expr_stmt><expr><name>comparatorDescList</name> <operator>=</operator> <name>this</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>itemSize</name></name></expr></argument>, <argument><expr><name>lstComparatorDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

            <case>case <expr><name>sortOrderNone</name></expr>:</case>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>sortOrder</name></name> <operator>=</operator> <name>sortOrder</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>lstComparatorSet</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>ListComparator</name> <modifier>*</modifier></type><name>comparator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>FUNCTIONP</name></expr></argument>, <argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>comparator</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>sortOrder</name></name> <operator>=</operator> <name>sortOrderNone</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>LIST</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>lstToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"{size: %u}"</literal></expr></argument>, <argument><expr><call><name>lstSize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
