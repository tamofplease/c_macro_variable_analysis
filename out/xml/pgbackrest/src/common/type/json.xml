<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/common/type/json.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Convert JSON to/from KeyValue
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/json.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Object types
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>JsonReadStack</name>
<block>{
    <decl_stmt><decl><type><name>JsonType</name></type> <name>type</name></decl>;</decl_stmt>                                                  <comment type="line">// Container type</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>first</name></decl>;</decl_stmt>                                                     <comment type="line">// First element has been read</comment>
}</block></struct></type> <name>JsonReadStack</name>;</typedef>

<struct>struct <name>JsonRead</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>json</name></decl>;</decl_stmt>                                               <comment type="line">// JSON string</comment>

    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>                                                    <comment type="line">// Stack of object/array tags</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>key</name></decl>;</decl_stmt>                                                       <comment type="line">// Was a key read for an object value?</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>complete</name></decl>;</decl_stmt>                                                  <comment type="line">// JSON read is complete</comment>
}</block>;</struct>

<typedef>typedef <type><struct>struct <name>JsonWriteStack</name>
<block>{
    <decl_stmt><decl><type><name>JsonType</name></type> <name>type</name></decl>;</decl_stmt>                                                  <comment type="line">// Container type</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>first</name></decl>;</decl_stmt>                                                     <comment type="line">// First element has been written</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>keyLast</name><index>[<expr><literal type="number">67</literal></expr>]</index></name></decl>;</decl_stmt>                                               <comment type="line">// Last key (may need to be adjusted for alignment)</comment>
}</block></struct></type> <name>JsonWriteStack</name>;</typedef>

<struct>struct <name>JsonWrite</name>
<block>{
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>json</name></decl>;</decl_stmt>                                                   <comment type="line">// JSON string</comment>

    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>                                                    <comment type="line">// Stack of object/array tags</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>key</name></decl>;</decl_stmt>                                                       <comment type="line">// Is a key set for an object value?</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>complete</name></decl>;</decl_stmt>                                                  <comment type="line">// JSON write is complete</comment>
}</block>;</struct>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Identify container and scalar types
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>jsonTypeScalar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JsonType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>type</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>jsonTypeBool</name></expr>:</case>
        <case>case <expr><name>jsonTypeNull</name></expr>:</case>
        <case>case <expr><name>jsonTypeNumber</name></expr>:</case>
        <case>case <expr><name>jsonTypeString</name></expr>:</case>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <default>default:</default>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>jsonTypeContainer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JsonType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><operator>!</operator><call><name>jsonTypeScalar</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonRead</name> <modifier>*</modifier></type>
<name>jsonReadNew</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>json</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JsonRead</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>JsonRead</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>JsonRead</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>json</name> <operator>=</operator> <call><name>strZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>,
        }</block></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Consume whitespace
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>jsonReadConsumeWhiteSpace</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>whitespace</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <do>do
    <block>{<block_content>
        <switch>switch <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">' '</literal></expr>:</case>
            <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
            <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
            <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
                <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><name>whitespace</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block>
    while <condition>(<expr><name>whitespace</name></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonType</name></type>
<name>jsonReadTypeNext</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadConsumeWhiteSpace</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// There should be some data</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"expected data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Determine data type</comment>
    <decl_stmt><decl><type><name>JsonType</name></type> <name>result</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// String</comment>
        <case>case <expr><literal type="char">'"'</literal></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>jsonTypeString</name></expr>;</expr_stmt>
            <break>break;</break>

        <comment type="line">// Integer</comment>
        <case>case <expr><literal type="char">'-'</literal></expr>:</case>
        <case>case <expr><literal type="char">'0'</literal> <operator>...</operator> <literal type="char">'9'</literal></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>jsonTypeNumber</name></expr>;</expr_stmt>
            <break>break;</break>

        <comment type="line">// Boolean</comment>
        <case>case <expr><literal type="char">'t'</literal></expr>:</case>
        <case>case <expr><literal type="char">'f'</literal></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>jsonTypeBool</name></expr>;</expr_stmt>
            <break>break;</break>

        <comment type="line">// Null</comment>
        <case>case <expr><literal type="char">'n'</literal></expr>:</case>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>jsonTypeNull</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>

        <comment type="line">// Array</comment>
        <case>case <expr><literal type="char">'['</literal></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>jsonTypeArrayBegin</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><literal type="char">']'</literal></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>jsonTypeArrayEnd</name></expr>;</expr_stmt>
            <break>break;</break>

        <comment type="line">// Object</comment>
        <case>case <expr><literal type="char">'{'</literal></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>jsonTypeObjectBegin</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><literal type="char">'}'</literal></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>jsonTypeObjectEnd</name></expr>;</expr_stmt>
            <break>break;</break>

        <comment type="line">// Invalid type</comment>
        <default>default:</default>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"invalid type at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Read the next type ignoring a single comma before the type
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>JsonType</name></type>
<name>jsonReadTypeNextIgnoreComma</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadConsumeWhiteSpace</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><call><name>jsonReadTypeNext</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>jsonBeforeComma</name> <init>= <expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>JsonType</name></type> <name>result</name> <init>= <expr><call><name>jsonReadTypeNext</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>=</operator> <name>jsonBeforeComma</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Push/pop a type on/off the stack
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>jsonReadPush</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>JsonType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Cannot read after complete</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>complete</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"JSON read is complete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Check that the requested type matches the actual type</comment>
    <if_stmt><if>if <condition>(<expr><call><name>jsonReadTypeNextIgnoreComma</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>type</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
            <argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"expected '%s' but found '%s' at: %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><call><name>jsonReadTypeNextIgnoreComma</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If the container stack jas not been created yet</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// If a scalar then no need to create the stack since the read is complete</comment>
        <if_stmt><if>if <condition>(<expr><call><name>jsonTypeScalar</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Create the container stack</comment>
        <else>else
        <block>{<block_content>
            <macro><name>MEM_CONTEXT_OBJ_BEGIN</name><argument_list>(<argument>this</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonReadStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_OBJ_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If there is a container on the stack</comment>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><call><name>jsonTypeContainer</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>key</name><operator>)</operator> <operator>||</operator> <operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>JsonWriteStack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name> <init>= <expr><call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If this is a key check that a key has not been read since the last value</comment>
        <if_stmt><if>if <condition>(<expr><name>key</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jsonTypeObjectBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>key</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"key has already been read at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else make sure a key has been read</comment>
        <if type="elseif">else if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jsonTypeObjectBegin</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>this</name><operator>-&gt;</operator><name>key</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"key has not been read at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Consume comma</comment>
        <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>first</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>jsonTypeObjectBegin</name> <operator>||</operator> <name>key</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"missing comma at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonReadConsumeWhiteSpace</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Add container to the stack</comment>
    <if_stmt><if>if <condition>(<expr><call><name>jsonTypeContainer</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <macro><name>lstAdd</name><argument_list>(<argument>this-&gt;stack</argument>, <argument>&amp;(JsonReadStack){.type = type}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>jsonReadPop</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>JsonType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>jsonTypeContainer</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Cannot read after complete</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>complete</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"JSON read is complete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_DECLARE</name><argument_list>(<argument><expr><specifier>const</specifier> <name>JsonReadStack</name> <operator>*</operator><specifier>const</specifier> <name>container</name> <operator>=</operator> <call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(
        <argument><expr><operator>(</operator><name><name>container</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jsonTypeArrayBegin</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>jsonTypeArrayEnd</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name><name>container</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jsonTypeObjectBegin</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>jsonTypeObjectEnd</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Check that the container has ended</comment>
    <if_stmt><if>if <condition>(<expr><call><name>jsonReadTypeNext</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>type</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
            <argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"expected %c but found %c at: %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>jsonTypeArrayEnd</name></expr> ?</condition><then> <expr><literal type="char">']'</literal></expr> </then><else>: <expr><literal type="char">'}'</literal></expr></else></ternary></expr></argument>, <argument><expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Remove container</comment>
    <expr_stmt><expr><call><name>lstRemoveLast</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Nothing more to read if this is the last container end</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Read JSON number
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>jsonNumberTypeU64</name></decl>,
    <decl><name>jsonNumberTypeI64</name></decl>,
}</block></enum></type> <name>JsonNumberType</name>;</typedef>

<typedef>typedef <type><struct>struct <name>JsonReadNumberResult</name>
<block>{
    <decl_stmt><decl><type><name>JsonNumberType</name></type> <name>type</name></decl>;</decl_stmt>

    <union>union
    <block>{
        <decl_stmt><decl><type><name>int64_t</name></type> <name>i64</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>u64</name></decl>;</decl_stmt>
    }</block> <decl><name>value</name></decl>;</union>
}</block></struct></type> <name>JsonReadNumberResult</name>;</typedef>

<function><type><specifier>static</specifier> <name>JsonReadNumberResult</name></type>
<name>jsonReadNumber</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Consume the - when present</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>intSigned</name> <init>= <expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>==</operator> <literal type="char">'-'</literal></expr></init></decl>;</decl_stmt>

    <comment type="line">// Consume all digits</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>digits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name><index>[<expr><name>digits</name> <operator>+</operator> <name>intSigned</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>digits</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <comment type="line">// Invalid if no digits were found</comment>
    <if_stmt><if>if <condition>(<expr><name>digits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"no digits found at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Copy to buffer</comment>
    <if_stmt><if>if <condition>(<expr><name>digits</name> <operator>&gt;=</operator> <name>CVT_BASE10_BUFFER_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"invalid number at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name> <init>= <expr><name>digits</name> <operator>+</operator> <name>intSigned</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

    <comment type="line">// Return result</comment>
    <if_stmt><if>if <condition>(<expr><name>intSigned</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>FUNCTION_TEST_RETURN_TYPE</name><argument_list>(
            <argument>JsonReadNumberResult</argument>,
            <argument>(JsonReadNumberResult){.type = jsonNumberTypeI64</argument>, <argument>.value = {.i64 = cvtZSubNToInt64(this-&gt;json - size, <literal type="number">0</literal>, size)}}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></if></if_stmt>

    <macro><name>FUNCTION_TEST_RETURN_TYPE</name><argument_list>(
        <argument>JsonReadNumberResult</argument>,
        <argument>(JsonReadNumberResult){.type = jsonNumberTypeU64</argument>, <argument>.value = {.u64 = cvtZSubNToUInt64(this-&gt;json - size, <literal type="number">0</literal>, size)}}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>jsonReadArrayBegin</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeArrayBegin</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>jsonReadArrayEnd</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadPop</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeArrayEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>jsonReadBool</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeBool</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>TRUE_Z</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TRUE_Z</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TRUE_Z</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>FALSE_Z</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FALSE_Z</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FALSE_Z</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"expected boolean at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>int</name></type>
<name>jsonReadInt</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JsonReadNumberResult</name></type> <name>number</name> <init>= <expr><call><name>jsonReadNumber</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>number</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jsonNumberTypeU64</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>u64</name></name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRIu64</name> <literal type="string">" is out of range for int"</literal></expr></argument>, <argument><expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>u64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>u64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>i64</name></name> <operator>&lt;</operator> <name>INT_MIN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRId64</name> <literal type="string">" is out of range for int"</literal></expr></argument>, <argument><expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>i64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>i64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>int64_t</name></type>
<name>jsonReadInt64</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JsonReadNumberResult</name></type> <name>number</name> <init>= <expr><call><name>jsonReadNumber</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>number</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jsonNumberTypeI64</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT64</name></expr></argument>, <argument><expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>i64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>u64</name></name> <operator>&gt;</operator> <name>INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRIu64</name> <literal type="string">" is out of range for int64"</literal></expr></argument>, <argument><expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>u64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT64</name></expr></argument>, <argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>u64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>JsonReadKeyInternalResult</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
}</block></struct></type> <name>JsonReadKeyInternalResult</name>;</typedef>

<function><type><specifier>static</specifier> <name>JsonReadKeyInternalResult</name></type>
<name>jsonReadKeyZN</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Skip the beginning "</comment>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>==</operator> <literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="line">// Read string</comment>
    <decl_stmt><decl><type><name>JsonReadKeyInternalResult</name></type> <name>result</name> <init>= <expr><block>{<expr><operator>.</operator><name>buffer</name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"escape character not allowed in key at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"expected '\"' but found null delimiter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while><empty_stmt>;</empty_stmt>

    <comment type="line">// Set key size</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>size</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>-</operator> <name><name>result</name><operator>.</operator><name>buffer</name></name><operator>)</operator></expr>;</expr_stmt>

    <comment type="line">// Advance the character array pointer to the next element after the string</comment>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="line">// Consume the : after the key</comment>
    <expr_stmt><expr><call><name>jsonReadConsumeWhiteSpace</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"expected : after key '%.*s' at: %s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>result</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_TYPE</name><argument_list>(<argument><expr><name>JsonReadKeyInternalResult</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>String</name> <modifier>*</modifier></type>
<name>jsonReadKey</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeString</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JsonReadKeyInternalResult</name></type> <name>key</name> <init>= <expr><call><name>jsonReadKeyZN</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><call><name>strNewZN</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>jsonReadKeyExpect</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Check that we are currently reading an object</comment>
    <expr_stmt><expr><call><name>jsonReadConsumeWhiteSpace</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JsonWriteStack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name> <init>= <expr><call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jsonTypeObjectBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Read until object end</comment>
    <while>while <condition>(<expr><call><name>jsonReadTypeNextIgnoreComma</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>jsonTypeObjectEnd</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Save state before reading the key</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>jsonBeforeKey</name> <init>= <expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>firstBeforeKey</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeString</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Get and compare next key</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>JsonReadKeyInternalResult</name></type> <name>keyNext</name> <init>= <expr><call><name>jsonReadKeyZN</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>compare</name> <init>= <expr><call><name>strncmp</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>keyNext</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>keyNext</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Return true if key matches</comment>
        <if_stmt><if>if <condition>(<expr><name>compare</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if>
        <comment type="line">// Return false and reset state if requested key is after the actual key</comment>
        <if type="elseif">else if <condition>(<expr><name>compare</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>=</operator> <name>jsonBeforeKey</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>firstBeforeKey</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Skip the value and continue</comment>
        <expr_stmt><expr><call><name>jsonReadSkip</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>jsonReadKeyExpectStrId</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StringId</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>STRID_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><call><name>jsonReadKeyExpect</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STR_SIZE</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>strIdToZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>jsonReadKeyExpectZ</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><call><name>jsonReadKeyExpect</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>JsonRead</name> <modifier>*</modifier></type>
<name>jsonReadKeyRequire</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>jsonReadKeyExpect</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"required key '%s' not found"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>JsonRead</name> <modifier>*</modifier></type>
<name>jsonReadKeyRequireStrId</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StringId</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>STRID_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><call><name>jsonReadKeyRequire</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STR_SIZE</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>strIdToZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>JsonRead</name> <modifier>*</modifier></type>
<name>jsonReadKeyRequireZ</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><call><name>jsonReadKeyRequire</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>jsonReadNull</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeNull</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>NULL_Z</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NULL_Z</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NULL_Z</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"expected null at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>jsonReadObjectBegin</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeObjectBegin</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>jsonReadObjectEnd</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadPop</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeObjectEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<comment type="line">// Quickly skip over a valid JSON string</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>jsonReadSkipStr</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Skip the beginning "</comment>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>==</operator> <literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="line">// Read string</comment>
    <while>while <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

            <switch>switch <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Unicode character</comment>
                <case>case <expr><literal type="char">'u'</literal></expr>:</case>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

                    <comment type="line">// Expect four digits</comment>
                    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>digitIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                    <for>for <control>(<init>;</init> <condition><expr><name>digitIdx</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>digitIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name><index>[<expr><name>digitIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <break>break;</break></block_content></block></if></if_stmt>
                    </block_content>}</block></for>

                    <if_stmt><if>if <condition>(<expr><name>digitIdx</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to decode at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

                    <break>break;</break>
                </block_content>}</block>

                <comment type="line">// Any other escape</comment>
                <default>default:</default>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"expected '\"' but found null delimiter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while><empty_stmt>;</empty_stmt>

    <comment type="line">// Advance the character array pointer to the next element after the string</comment>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>jsonReadSkipRecurse</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><call><name>jsonReadTypeNextIgnoreComma</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>jsonTypeBool</name></expr>:</case>
            <expr_stmt><expr><call><name>jsonReadBool</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>jsonTypeNull</name></expr>:</case>
            <expr_stmt><expr><call><name>jsonReadNull</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>jsonTypeNumber</name></expr>:</case>
            <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonReadNumber</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>jsonTypeString</name></expr>:</case>
            <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonReadSkipStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>jsonTypeArrayBegin</name></expr>:</case>
        <block>{<block_content>
            <expr_stmt><expr><call><name>jsonReadArrayBegin</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <while>while <condition>(<expr><call><name>jsonReadTypeNextIgnoreComma</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>jsonTypeArrayEnd</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>jsonReadSkipRecurse</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

            <expr_stmt><expr><call><name>jsonReadArrayEnd</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <break>break;</break>
        </block_content>}</block>

        <default>default:</default>
        <block>{<block_content>
            <expr_stmt><expr><call><name>jsonReadObjectBegin</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <while>while <condition>(<expr><call><name>jsonReadTypeNextIgnoreComma</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>jsonTypeObjectEnd</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Read key</comment>
                <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeString</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>jsonReadSkipStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Consume the : after the key</comment>
                <expr_stmt><expr><call><name>jsonReadConsumeWhiteSpace</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"expected : after key at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

                <comment type="line">// Skip value</comment>
                <expr_stmt><expr><call><name>jsonReadSkipRecurse</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

            <expr_stmt><expr><call><name>jsonReadObjectEnd</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <break>break;</break>
        </block_content>}</block>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>jsonReadSkip</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadSkipRecurse</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>jsonReadStr</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If NULL</comment>
    <if_stmt><if>if <condition>(<expr><call><name>jsonReadTypeNextIgnoreComma</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>jsonTypeNull</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>jsonReadNull</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Read string</comment>
    <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Skip the beginning "</comment>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>==</operator> <literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="line">// Track portion of string with no escapes</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>noEscape</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>noEscapeSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Copy portion of string without escapes</comment>
            <if_stmt><if>if <condition>(<expr><name>noEscapeSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strCatZN</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>noEscape</name></expr></argument>, <argument><expr><name>noEscapeSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>noEscapeSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

            <switch>switch <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><literal type="char">'"'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><literal type="char">'\\'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><literal type="char">'/'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><literal type="char">'n'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><literal type="char">'r'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><literal type="char">'t'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><literal type="char">'b'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\b'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><literal type="char">'f'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\f'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><literal type="char">'u'</literal></expr>:</case>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

                    <comment type="line">// We don't know how to decode anything except ASCII so fail if it looks like Unicode</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="string">"00"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to decode at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Decode char</comment>
                    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator><call><name>cvtZSubNToUIntBase</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

                    <break>break;</break>
                </block_content>}</block>

                <default>default:</default>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"invalid escape character at: %s"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>json</name></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"expected '\"' but found null delimiter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// If escape string is zero size then start it</comment>
            <if_stmt><if>if <condition>(<expr><name>noEscapeSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>noEscape</name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>noEscapeSize</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="line">// Copy portion of string without escapes</comment>
    <if_stmt><if>if <condition>(<expr><name>noEscapeSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strCatZN</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>noEscape</name></expr></argument>, <argument><expr><name>noEscapeSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Advance the character array pointer to the next element after the string</comment>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StringId</name></type>
<name>jsonReadStrId</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringId</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strIdFromStr</name><argument_list>(<argument><expr><call><name>jsonReadStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StringList</name> <modifier>*</modifier></type>
<name>jsonReadStrLst</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>jsonReadArrayBegin</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><call><name>jsonReadTypeNextIgnoreComma</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>jsonTypeArrayEnd</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>jsonReadStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <expr_stmt><expr><call><name>jsonReadArrayEnd</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>unsigned</name> <name>int</name></type>
<name>jsonReadUInt</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JsonReadNumberResult</name></type> <name>number</name> <init>= <expr><call><name>jsonReadNumber</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>number</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jsonNumberTypeI64</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRId64</name> <literal type="string">" is out of range for uint"</literal></expr></argument>, <argument><expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>i64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>u64</name></name> <operator>&gt;</operator> <name>UINT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRIu64</name> <literal type="string">" is out of range for uint"</literal></expr></argument>, <argument><expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>u64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>u64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>uint64_t</name></type>
<name>jsonReadUInt64</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JsonReadNumberResult</name></type> <name>number</name> <init>= <expr><call><name>jsonReadNumber</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>number</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jsonNumberTypeI64</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>PRId64</name> <literal type="string">" is out of range for uint64"</literal></expr></argument>, <argument><expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>i64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>u64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>Variant</name> <modifier>*</modifier></type>
<name>jsonReadVarRecurse</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><call><name>jsonReadTypeNextIgnoreComma</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>jsonTypeBool</name></expr>:</case>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><call><name>varNewBool</name><argument_list>(<argument><expr><call><name>jsonReadBool</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <case>case <expr><name>jsonTypeNull</name></expr>:</case>
            <expr_stmt><expr><call><name>jsonReadNull</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <case>case <expr><name>jsonTypeNumber</name></expr>:</case>
        <block>{<block_content>
            <expr_stmt><expr><call><name>jsonReadPush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>JsonReadNumberResult</name></type> <name>number</name> <init>= <expr><call><name>jsonReadNumber</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>number</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jsonNumberTypeU64</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><call><name>varNewUInt64</name><argument_list>(<argument><expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>u64</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><call><name>varNewInt64</name><argument_list>(<argument><expr><name><name>number</name><operator>.</operator><name>value</name><operator>.</operator><name>i64</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <case>case <expr><name>jsonTypeString</name></expr>:</case>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><call><name>varNewStr</name><argument_list>(<argument><expr><call><name>jsonReadStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <case>case <expr><name>jsonTypeArrayBegin</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>jsonReadArrayBegin</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext((List *)list)</argument>)</argument_list></macro>
            <block>{<block_content>
                <while>while <condition>(<expr><call><name>jsonReadTypeNextIgnoreComma</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>jsonTypeArrayEnd</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>jsonReadVarRecurse</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>jsonReadArrayEnd</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>varNewVarLst</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>varLstFree</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <default>default:</default>
        <block>{<block_content>
            <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>jsonReadObjectBegin</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <while>while <condition>(<expr><call><name>jsonReadTypeNextIgnoreComma</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>jsonTypeObjectEnd</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name> <init>= <expr><call><name>jsonReadKey</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier><specifier>const</specifier></type> <name>value</name> <init>= <expr><call><name>jsonReadVarRecurse</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>varFree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

            <expr_stmt><expr><call><name>jsonReadObjectEnd</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><call><name>varNewKv</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>Variant</name> <modifier>*</modifier></type>
<name>jsonReadVar</name><parameter_list>(<parameter><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_READ</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>jsonReadVarRecurse</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Variant</name> <modifier>*</modifier></type>
<name>jsonToVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>json</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>read</name> <init>= <expr><call><name>jsonReadNew</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>jsonReadVar</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>jsonValidate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>json</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>read</name> <init>= <expr><call><name>jsonReadNew</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>jsonReadSkip</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonReadConsumeWhiteSpace</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>read</name><operator>-&gt;</operator><name>json</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"characters after JSON at: %s"</literal></expr></argument>, <argument><expr><name><name>read</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>jsonReadToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"{json: %s}"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteNew</name><parameter_list>(<parameter><decl><type><name>JsonWriteNewParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JsonWrite</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>JsonWrite</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>JsonWrite</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>json</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>json</name></name> <operator>==</operator> <name>NULL</name> <operator>?</operator> <call><name>strNew</name><argument_list>()</argument_list></call> <operator>:</operator> <name><name>param</name><operator>.</operator><name>json</name></name></expr>,
        }</block></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Push/pop a type on/off the stack
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>jsonWritePush</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>JsonType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Cannot write after complete</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>complete</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"JSON write is complete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// If the container stack jas not been created yet</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>key</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// If a scalar then no need to create the stack since the write is complete</comment>
        <if_stmt><if>if <condition>(<expr><call><name>jsonTypeScalar</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Create the container stack</comment>
        <else>else
        <block>{<block_content>
            <macro><name>MEM_CONTEXT_OBJ_BEGIN</name><argument_list>(<argument>this</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonWriteStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_OBJ_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// If there is a container on the stack</comment>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><call><name>jsonTypeContainer</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>key</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>JsonWriteStack</name> <modifier>*</modifier><specifier>const</specifier></type> <name>item</name> <init>= <expr><call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If this is a key check that a key has not been written since the last value</comment>
        <if_stmt><if>if <condition>(<expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>key</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"key has already been written"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Also check that the key is after the last key</comment>
            <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>keyLast</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>strCmpZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>keyLast</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"key '%s' is not after prior key '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>keyLast</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Copy key to a buffer to avoid needing to allocate memory</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>SIZE_OF_STRUCT_MEMBER</name><argument_list>(<argument><expr><name>JsonWriteStack</name></expr></argument>, <argument><expr><name>keyLast</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"key '%s' must not be longer than %zu bytes"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>SIZE_OF_STRUCT_MEMBER</name><argument_list>(<argument><expr><name>JsonWriteStack</name></expr></argument>, <argument><expr><name>keyLast</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>keyLast</name></name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SIZE_OF_STRUCT_MEMBER</name><argument_list>(<argument><expr><name>JsonWriteStack</name></expr></argument>, <argument><expr><name>keyLast</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>keyLast</name><index>[<expr><call><name>SIZE_OF_STRUCT_MEMBER</name><argument_list>(<argument><expr><name>JsonWriteStack</name></expr></argument>, <argument><expr><name>keyLast</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else make sure a key has been written</comment>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jsonTypeObjectBegin</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>this</name><operator>-&gt;</operator><name>key</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>JsonFormatError</name></expr></argument>, <argument><expr><literal type="string">"key has not been written"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// Write comma</comment>
        <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>first</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>jsonTypeObjectBegin</name> <operator>||</operator> <name>key</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Add container to the stack</comment>
    <if_stmt><if>if <condition>(<expr><call><name>jsonTypeContainer</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <macro><name>lstAdd</name><argument_list>(<argument>this-&gt;stack</argument>, <argument>&amp;(JsonWriteStack){.type = type}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>jsonWritePop</name><argument_list>(<argument><expr><name>JsonWrite</name> <operator>*</operator><specifier>const</specifier> <name>this</name> <macro><name>ASSERT_PARAM</name><argument_list>(<argument>const JsonType type</argument>)</argument_list></macro></expr></argument>)</argument_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_DECLARE</name><argument_list>(<argument><expr><specifier>const</specifier> <name>JsonWriteStack</name> <operator>*</operator><specifier>const</specifier> <name>container</name> <operator>=</operator> <call><name>lstGetLast</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(
        <argument><expr><operator>(</operator><name><name>container</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jsonTypeArrayBegin</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>jsonTypeArrayEnd</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name><name>container</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jsonTypeObjectBegin</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>jsonTypeObjectEnd</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>container</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>jsonTypeObjectEnd</name> <operator>||</operator> <name><name>this</name><operator>-&gt;</operator><name>key</name></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Remove container</comment>
    <expr_stmt><expr><call><name>lstRemoveLast</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Nothing more to write if this is the last container end</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lstEmpty</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteArrayBegin</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeArrayBegin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteArrayEnd</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>jsonWritePop</name><argument_list>(<argument>this ASSERT_PARAM(jsonTypeArrayEnd)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteBool</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeBool</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>value</name></expr> ?</condition><then> <expr><name>TRUE_STR</name></expr> </then><else>: <expr><name>FALSE_STR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteInt</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeNumber</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>working</name><index>[<expr><name>CVT_BASE10_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>strCatZN</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>working</name></expr></argument>, <argument><expr><call><name>cvtIntToZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>working</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>working</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteInt64</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INT64</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeNumber</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>working</name><index>[<expr><name>CVT_BASE10_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>strCatZN</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>working</name></expr></argument>, <argument><expr><call><name>cvtInt64ToZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>working</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>working</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteJson</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>jsonWriteNull</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteKey</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(
        <argument><expr><call><name>strchr</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\f'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <call><name>strchr</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\t'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\b'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <call><name>strchr</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeString</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="string">"\":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteKeyStrId</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StringId</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>STRID_MAX</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>strIdToZ</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>buffer</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeString</name></expr></argument>, <argument><expr><call><name>STR_SIZE</name><argument_list>(<argument><expr><name>buffer</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buffer</name><index>[<expr><operator>++</operator><name>size</name></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buffer</name><index>[<expr><operator>++</operator><name>size</name></expr>]</index></name> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>strCatZN</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteKeyZ</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><call><name>jsonWriteKey</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteNull</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeNull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>NULL_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteObjectBegin</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeObjectBegin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteObjectEnd</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>jsonWritePop</name><argument_list>(<argument>this ASSERT_PARAM(jsonTypeObjectEnd)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteStr</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>jsonWriteNull</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Track portion of string with no escapes</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>valuePtr</name> <init>= <expr><call><name>strZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>noEscape</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>noEscapeSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>valueIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>valueIdx</name> <operator>&lt;</operator> <call><name>strSize</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>valueIdx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <switch>switch <condition>(<expr><operator>*</operator><name>valuePtr</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'"'</literal></expr>:</case>
            <case>case <expr><literal type="char">'\\'</literal></expr>:</case>
            <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
            <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
            <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
            <case>case <expr><literal type="char">'\b'</literal></expr>:</case>
            <case>case <expr><literal type="char">'\f'</literal></expr>:</case>
            <block>{<block_content>
                <comment type="line">// Copy portion of string without escapes</comment>
                <if_stmt><if>if <condition>(<expr><name>noEscapeSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>strCatZN</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>noEscape</name></expr></argument>, <argument><expr><name>noEscapeSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>noEscapeSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <switch>switch <condition>(<expr><operator>*</operator><name>valuePtr</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><literal type="char">'"'</literal></expr>:</case>
                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="string">"\\\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><literal type="char">'\\'</literal></expr>:</case>
                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="string">"\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="string">"\\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="string">"\\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="string">"\\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><literal type="char">'\b'</literal></expr>:</case>
                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="string">"\\b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>

                    <case>case <expr><literal type="char">'\f'</literal></expr>:</case>
                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="string">"\\f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>

                <break>break;</break>
            </block_content>}</block>

            <default>default:</default>
            <block>{<block_content>
                <comment type="line">// If escape string is zero size then start it</comment>
                <if_stmt><if>if <condition>(<expr><name>noEscapeSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>noEscape</name> <operator>=</operator> <name>valuePtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>noEscapeSize</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        </block_content>}</block></switch>

        <expr_stmt><expr><name>valuePtr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="line">// Copy portion of string without escapes</comment>
    <if_stmt><if>if <condition>(<expr><name>noEscapeSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strCatZN</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>noEscape</name></expr></argument>, <argument><expr><name>noEscapeSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteStrFmt</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Determine how long the allocated string needs to be</comment>
        <decl_stmt><decl><type><name>va_list</name></type> <name>argumentList</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argumentList</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>vsnprintf</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>argumentList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argumentList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Format string</comment>
        <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argumentList</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buffer</name> <init>= <expr><call><name>memNew</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>argumentList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argumentList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>jsonWriteStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>STR_SIZE</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteStrId</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StringId</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>STRID_MAX</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>strIdToZN</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>buffer</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>strCatZN</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteStrLst</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWriteArrayBegin</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>valueIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>valueIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>valueIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>jsonWriteStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>valueIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>jsonWriteArrayEnd</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteUInt</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeNumber</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>working</name><index>[<expr><name>CVT_BASE10_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>strCatZN</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>working</name></expr></argument>, <argument><expr><call><name>cvtUIntToZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>working</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>working</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteUInt64</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWritePush</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jsonTypeNumber</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>working</name><index>[<expr><name>CVT_BASE10_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>strCatZN</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>, <argument><expr><name>working</name></expr></argument>, <argument><expr><call><name>cvtUInt64ToZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>working</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>working</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>jsonWriteVarRecurse</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier><specifier>const</specifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// If VariantList then process each item in the array. Currently the list must be KeyValue types.</comment>
        <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>jsonWriteNull</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <switch>switch <condition>(<expr><call><name>varType</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>varTypeBool</name></expr>:</case>
                    <expr_stmt><expr><call><name>jsonWriteBool</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>varBool</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>varTypeInt</name></expr>:</case>
                    <expr_stmt><expr><call><name>jsonWriteInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>varInt</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>varTypeInt64</name></expr>:</case>
                    <expr_stmt><expr><call><name>jsonWriteInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>varInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>varTypeKeyValue</name></expr>:</case>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>KeyValue</name> <modifier>*</modifier><specifier>const</specifier></type> <name>keyValue</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>keyValue</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>jsonWriteNull</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>keyList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(<argument><expr><call><name>strLstNewVarLst</name><argument_list>(<argument><expr><call><name>kvKeyList</name><argument_list>(<argument><expr><name>keyValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>jsonWriteObjectBegin</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>keyListIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>keyListIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>keyList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>keyListIdx</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <comment type="line">// Write key</comment>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>key</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>keyList</name></expr></argument>, <argument><expr><name>keyListIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <expr_stmt><expr><call><name>jsonWriteKey</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="line">// Write value</comment>
                            <expr_stmt><expr><call><name>jsonWriteVarRecurse</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><name>keyValue</name></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>

                        <expr_stmt><expr><call><name>jsonWriteObjectEnd</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <break>break;</break>
                </block_content>}</block>

                <case>case <expr><name>varTypeString</name></expr>:</case>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>jsonWriteStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block>

                <case>case <expr><name>varTypeUInt</name></expr>:</case>
                    <expr_stmt><expr><call><name>jsonWriteUInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>varUInt</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>varTypeUInt64</name></expr>:</case>
                    <expr_stmt><expr><call><name>jsonWriteUInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>varUInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <default>default:</default>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varType</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeVariantList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><specifier>const</specifier> <name>VariantList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>valueList</name> <init>= <expr><call><name>varVarLst</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>valueList</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>jsonWriteNull</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>jsonWriteArrayBegin</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>valueListIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>valueListIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>valueList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>valueListIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>jsonWriteVarRecurse</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>valueList</name></expr></argument>, <argument><expr><name>valueListIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                        <expr_stmt><expr><call><name>jsonWriteArrayEnd</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block>
            </block_content>}</block></switch>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteVar</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier><specifier>const</specifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWriteVarRecurse</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>JsonWrite</name> <modifier>*</modifier></type>
<name>jsonWriteZ</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>jsonWriteStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><ternary><condition><expr><name>value</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>STR</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type>
<name>jsonWriteResult</name><parameter_list>(<parameter><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>JSON_WRITE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>complete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>jsonFromVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier><specifier>const</specifier></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>jsonWriteVar</name><argument_list>(<argument><expr><call><name>jsonWriteNewP</name><argument_list>(<argument><expr><operator>.</operator><name>json</name> <operator>=</operator> <name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>jsonWriteToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"{size: %zu}"</literal></expr></argument>, <argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>json</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
