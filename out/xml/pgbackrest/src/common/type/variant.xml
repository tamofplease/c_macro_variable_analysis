<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/common/type/variant.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Variant Data Type
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/memContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/convert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/variant.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Constant variants that are generally useful
***********************************************************************************************************************************/</comment>
<comment type="line">// Used to declare Bool Variant constants that will be externed using VARIANT_DECLARE().  Must be used in a .c file.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_BOOL_EXTERN</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>dataParam</name></type></parameter>)</parameter_list></cpp:macro>                                                                                       \
    <cpp:value>const Variant *const name = ((const Variant *)&amp;(const VariantBoolPub){.type = varTypeBool, .data = dataParam})</cpp:value></cpp:define>

<expr_stmt><expr><call><name>VARIANT_BOOL_EXTERN</name><argument_list>(<argument><expr><name>BOOL_FALSE_VAR</name></expr></argument>,                                 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VARIANT_BOOL_EXTERN</name><argument_list>(<argument><expr><name>BOOL_TRUE_VAR</name></expr></argument>,                                  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Information about the variant
***********************************************************************************************************************************/</comment>
<struct>struct <name>Variant</name>
<block>{
    <decl_stmt><decl><type><name>VariantPub</name></type> <name>pub</name></decl>;</decl_stmt>                                                 <comment type="line">// Publicly accessible variables</comment>
}</block>;</struct>

<typedef>typedef <type><struct>struct <name>VariantBool</name>
<block>{
    <decl_stmt><decl><type><name>VariantBoolPub</name></type> <name>pub</name></decl>;</decl_stmt>                                             <comment type="line">// Publicly accessible variables</comment>
}</block></struct></type> <name>VariantBool</name>;</typedef>

<typedef>typedef <type><struct>struct <name>VariantInt</name>
<block>{
    <decl_stmt><decl><type><name>VariantIntPub</name></type> <name>pub</name></decl>;</decl_stmt>                                              <comment type="line">// Publicly accessible variables</comment>
}</block></struct></type> <name>VariantInt</name>;</typedef>

<typedef>typedef <type><struct>struct <name>VariantInt64</name>
<block>{
    <decl_stmt><decl><type><name>VariantInt64Pub</name></type> <name>pub</name></decl>;</decl_stmt>                                            <comment type="line">// Publicly accessible variables</comment>
}</block></struct></type> <name>VariantInt64</name>;</typedef>

<typedef>typedef <type><struct>struct <name>VariantKeyValue</name>
<block>{
    <decl_stmt><decl><type><name>VARIANT_COMMON</name>
    <name>KeyValue</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>                                                 <comment type="line">// KeyValue data</comment>
}</block></struct></type> <name>VariantKeyValue</name>;</typedef>

<typedef>typedef <type><struct>struct <name>VariantString</name>
<block>{
    <decl_stmt><decl><type><name>VariantStringPub</name></type> <name>pub</name></decl>;</decl_stmt>                                           <comment type="line">// Publicly accessible variables</comment>
}</block></struct></type> <name>VariantString</name>;</typedef>

<typedef>typedef <type><struct>struct <name>VariantUInt</name>
<block>{
    <decl_stmt><decl><type><name>VariantUIntPub</name></type> <name>pub</name></decl>;</decl_stmt>                                             <comment type="line">// Publicly accessible variables</comment>
}</block></struct></type> <name>VariantUInt</name>;</typedef>

<typedef>typedef <type><struct>struct <name>VariantUInt64</name>
<block>{
    <decl_stmt><decl><type><name>VariantUInt64Pub</name></type> <name>pub</name></decl>;</decl_stmt>                                           <comment type="line">// Publicly accessible variables</comment>
}</block></struct></type> <name>VariantUInt64</name>;</typedef>

<typedef>typedef <type><struct>struct <name>VariantVariantList</name>
<block>{
    <decl_stmt><decl><type><name>VARIANT_COMMON</name>
    <name>VariantList</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>                                              <comment type="line">// VariantList data</comment>
}</block></struct></type> <name>VariantVariantList</name>;</typedef>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Variant type names
***********************************************************************************************************************************/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>variantTypeName</name><index>[]</index></name> <init>=
<expr><block>{
    <expr><literal type="string">"bool"</literal></expr>,                                                         <comment type="line">// varTypeBool</comment>
    <expr><literal type="string">"int"</literal></expr>,                                                          <comment type="line">// varTypeInt</comment>
    <expr><literal type="string">"int64"</literal></expr>,                                                        <comment type="line">// varTypeInt64</comment>
    <expr><literal type="string">"KeyValue"</literal></expr>,                                                     <comment type="line">// varTypeKeyValue</comment>
    <expr><literal type="string">"String"</literal></expr>,                                                       <comment type="line">// varTypeString</comment>
    <expr><literal type="string">"unsigned int"</literal></expr>,                                                 <comment type="line">// varTypeUInt</comment>
    <expr><literal type="string">"uint64"</literal></expr>,                                                       <comment type="line">// varTypeUInt64</comment>
    <expr><literal type="string">"VariantList"</literal></expr>,                                                  <comment type="line">// varTypeVariantList</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Variant</name> <modifier>*</modifier></type>
<name>varDup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Variant</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>varTypeBool</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varNewBool</name><argument_list>(<argument><expr><call><name>varBool</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>varTypeInt</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varNewInt</name><argument_list>(<argument><expr><call><name>varInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>varTypeInt64</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varNewInt64</name><argument_list>(<argument><expr><call><name>varInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>varTypeKeyValue</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varNewKv</name><argument_list>(<argument><expr><call><name>kvDup</name><argument_list>(<argument><expr><call><name>varKv</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

            <case>case <expr><name>varTypeString</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varNewStr</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>varTypeUInt</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varNewUInt</name><argument_list>(<argument><expr><call><name>varUInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>varTypeUInt64</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varNewUInt64</name><argument_list>(<argument><expr><call><name>varUInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>varTypeVariantList</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varNewVarLst</name><argument_list>(<argument><expr><call><name>varVarLst</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>varEq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Test if both variants are non-null</comment>
    <if_stmt><if>if <condition>(<expr><name>this1</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>this2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Test if both variants are of the same type</comment>
        <if_stmt><if>if <condition>(<expr><call><name>varType</name><argument_list>(<argument><expr><name>this1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>varType</name><argument_list>(<argument><expr><name>this2</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <switch>switch <condition>(<expr><call><name>varType</name><argument_list>(<argument><expr><name>this1</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>varTypeBool</name></expr>:</case>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varBool</name><argument_list>(<argument><expr><name>this1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>varBool</name><argument_list>(<argument><expr><name>this2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>varTypeInt</name></expr>:</case>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varInt</name><argument_list>(<argument><expr><name>this1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>varInt</name><argument_list>(<argument><expr><name>this2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>varTypeInt64</name></expr>:</case>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varInt64</name><argument_list>(<argument><expr><name>this1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>varInt64</name><argument_list>(<argument><expr><name>this2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>varTypeString</name></expr>:</case>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strEq</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>this1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>this2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>varTypeUInt</name></expr>:</case>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varUInt</name><argument_list>(<argument><expr><name>this1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>varUInt</name><argument_list>(<argument><expr><name>this2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>varTypeUInt64</name></expr>:</case>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varUInt64</name><argument_list>(<argument><expr><name>this1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>varUInt64</name><argument_list>(<argument><expr><name>this2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                <default>default:</default>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"unable to test equality for %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this1</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else they are equal if they are both null</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>this1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>this2</name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Variant</name> <modifier>*</modifier></type>
<name>varNewBool</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VariantBool</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>VariantBool</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>VariantBool</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>pub</name> <operator>=</operator>
            <block>{
                <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>varTypeBool</name></expr>,
                <expr><operator>.</operator><name>data</name> <operator>=</operator> <name>data</name></expr>,
            }</block></expr>,
        }</block></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><operator>(</operator><name>Variant</name> <operator>*</operator><operator>)</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>varBool</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeBool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>VariantBool</name> <operator>*</operator><operator>)</operator><name>this</name><operator>)</operator><operator>-&gt;</operator><name><name>pub</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>varBoolForce</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>varTypeBool</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varBool</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeInt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeInt64</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeString</name></expr>:</case>
        <block>{<block_content>
            <comment type="line">// List of false/true boolean string values.  Note that false/true values must be equal.</comment>
            <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>boolString</name><index>[]</index></name> <init>=
            <expr><block>{
                <expr><literal type="string">"n"</literal></expr>, <expr><literal type="string">"f"</literal></expr>, <expr><literal type="string">"0"</literal></expr>,  <expr><literal type="string">"no"</literal></expr>, <expr><name>FALSE_Z</name></expr>, <expr><literal type="string">"off"</literal></expr>,
                <expr><literal type="string">"y"</literal></expr>, <expr><literal type="string">"t"</literal></expr>, <expr><literal type="string">"1"</literal></expr>, <expr><literal type="string">"yes"</literal></expr>,  <expr><name>TRUE_Z</name></expr>,  <expr><literal type="string">"on"</literal></expr>,
            }</block></expr></init></decl>;</decl_stmt>

            <comment type="line">// Search for the string</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>boolIdx</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>boolIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>boolIdx</name> <operator>&lt;</operator> <call><name>LENGTH_OF</name><argument_list>(<argument><expr><name>boolString</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>boolIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name><name>boolString</name><index>[<expr><name>boolIdx</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

            <comment type="line">// If string was not found then not a boolean</comment>
            <if_stmt><if>if <condition>(<expr><name>boolIdx</name> <operator>==</operator> <call><name>LENGTH_OF</name><argument_list>(<argument><expr><name>boolString</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to convert str '%s' to bool"</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// False if in first half of list, true if in second half</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>boolIdx</name> <operator>/</operator> <operator>(</operator><call><name>LENGTH_OF</name><argument_list>(<argument><expr><name>boolString</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>varTypeUInt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varUInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeUInt64</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varUInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"unable to force %s to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeBool</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Variant</name> <modifier>*</modifier></type>
<name>varNewInt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VariantInt</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>VariantInt</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>VariantInt</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>pub</name> <operator>=</operator>
            <block>{
                <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>varTypeInt</name></expr>,
                <expr><operator>.</operator><name>data</name> <operator>=</operator> <name>data</name></expr>,
            }</block></expr>,
        }</block></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><operator>(</operator><name>Variant</name> <operator>*</operator><operator>)</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>int</name></type>
<name>varInt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>VariantInt</name> <operator>*</operator><operator>)</operator><name>this</name><operator>)</operator><operator>-&gt;</operator><name><name>pub</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>varIntForce</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>varTypeBool</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varBool</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeInt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeInt64</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>resultTest</name> <init>= <expr><call><name>varInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Make sure the value fits into a normal 32-bit int range since 32-bit platforms are supported</comment>
            <if_stmt><if>if <condition>(<expr><name>resultTest</name> <operator>&gt;</operator> <name>INT32_MAX</name> <operator>||</operator> <name>resultTest</name> <operator>&lt;</operator> <name>INT32_MIN</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to convert %s %"</literal> <name>PRId64</name> <literal type="string">" to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>resultTest</name></expr></argument>,
                    <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeInt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>resultTest</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>varTypeString</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cvtZToInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeUInt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>resultTest</name> <init>= <expr><call><name>varUInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Make sure the value fits into a normal 32-bit int range</comment>
            <if_stmt><if>if <condition>(<expr><name>resultTest</name> <operator>&gt;</operator> <name>INT32_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to convert %s %u to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>resultTest</name></expr></argument>,
                    <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeInt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>resultTest</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>varTypeUInt64</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>resultTest</name> <init>= <expr><call><name>varUInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Make sure the value fits into a normal 32-bit int range</comment>
            <if_stmt><if>if <condition>(<expr><name>resultTest</name> <operator>&gt;</operator> <name>INT32_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to convert %s %"</literal> <name>PRIu64</name> <literal type="string">" to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>resultTest</name></expr></argument>,
                    <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeInt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>resultTest</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>

        <default>default:</default>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"unable to force %s to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeInt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Variant</name> <modifier>*</modifier></type>
<name>varNewInt64</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INT64</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VariantInt64</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>VariantInt64</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>VariantInt64</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>pub</name> <operator>=</operator>
            <block>{
                <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>varTypeInt64</name></expr>,
                <expr><operator>.</operator><name>data</name> <operator>=</operator> <name>data</name></expr>,
            }</block></expr>,
        }</block></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><operator>(</operator><name>Variant</name> <operator>*</operator><operator>)</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>int64_t</name></type>
<name>varInt64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeInt64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT64</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>VariantInt64</name> <operator>*</operator><operator>)</operator><name>this</name><operator>)</operator><operator>-&gt;</operator><name><name>pub</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int64_t</name></type>
<name>varInt64Force</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>varTypeBool</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varBool</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeInt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>varInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeInt64</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeString</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cvtZToInt64</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeUInt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varUInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <break>break;</break>

        <case>case <expr><name>varTypeUInt64</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>resultTest</name> <init>= <expr><call><name>varUInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If max number of unsigned 64-bit integer is greater than max 64-bit signed integer can hold, then error</comment>
            <if_stmt><if>if <condition>(<expr><name>resultTest</name> <operator>&lt;=</operator> <name>INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>resultTest</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to convert %s %"</literal> <name>PRIu64</name> <literal type="string">" to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>resultTest</name></expr></argument>,
                    <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeInt64</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <break>break;</break>
        </block_content>}</block>

        <default>default:</default>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"unable to force %s to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeInt64</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INT64</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Variant</name> <modifier>*</modifier></type>
<name>varNewUInt</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VariantUInt</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>VariantUInt</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>VariantUInt</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>pub</name> <operator>=</operator>
            <block>{
                <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>varTypeUInt</name></expr>,
                <expr><operator>.</operator><name>data</name> <operator>=</operator> <name>data</name></expr>,
            }</block></expr>,
        }</block></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><operator>(</operator><name>Variant</name> <operator>*</operator><operator>)</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>unsigned</name> <name>int</name></type>
<name>varUInt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeUInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>VariantUInt</name> <operator>*</operator><operator>)</operator><name>this</name><operator>)</operator><operator>-&gt;</operator><name><name>pub</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type>
<name>varUIntForce</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>varTypeBool</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varBool</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeInt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>resultTest</name> <init>= <expr><call><name>varInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If integer is a negative number, throw an error since the resulting conversion would be a different number</comment>
            <if_stmt><if>if <condition>(<expr><name>resultTest</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>resultTest</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to convert %s %d to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>resultTest</name></expr></argument>,
                    <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeUInt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>varTypeInt64</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>resultTest</name> <init>= <expr><call><name>varInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If integer is a negative number or too large, throw an error since the resulting conversion would be out of bounds</comment>
            <if_stmt><if>if <condition>(<expr><name>resultTest</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>resultTest</name> <operator>&lt;=</operator> <name>UINT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>resultTest</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to convert %s %"</literal> <name>PRId64</name> <literal type="string">" to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>resultTest</name></expr></argument>,
                    <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeUInt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>varTypeUInt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varUInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeUInt64</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint64_t</name></type> <name>resultTest</name> <init>= <expr><call><name>varUInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If integer is too large, throw an error since the resulting conversion would be out of bounds</comment>
            <if_stmt><if>if <condition>(<expr><name>resultTest</name> <operator>&lt;=</operator> <name>UINT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>resultTest</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to convert %s %"</literal> <name>PRIu64</name> <literal type="string">" to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>resultTest</name></expr></argument>,
                    <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeUInt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>varTypeString</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cvtZToUInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"unable to force %s to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeUInt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Variant</name> <modifier>*</modifier></type>
<name>varNewUInt64</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VariantUInt64</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>VariantUInt64</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>VariantUInt64</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>pub</name> <operator>=</operator>
            <block>{
                <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>varTypeUInt64</name></expr>,
                <expr><operator>.</operator><name>data</name> <operator>=</operator> <name>data</name></expr>,
            }</block></expr>,
        }</block></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><operator>(</operator><name>Variant</name> <operator>*</operator><operator>)</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>uint64_t</name></type>
<name>varUInt64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeUInt64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>VariantUInt64</name> <operator>*</operator><operator>)</operator><name>this</name><operator>)</operator><operator>-&gt;</operator><name><name>pub</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type>
<name>varUInt64Force</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>varTypeBool</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varBool</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeInt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>resultTest</name> <init>= <expr><call><name>varInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If integer is a negative number, throw an error since the resulting conversion would be a different number</comment>
            <if_stmt><if>if <condition>(<expr><name>resultTest</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>resultTest</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to convert %s %d to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>resultTest</name></expr></argument>,
                    <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeUInt64</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>varTypeInt64</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>resultTest</name> <init>= <expr><call><name>varInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If integer is a negative number, throw an error since the resulting conversion would be out of bounds</comment>
            <if_stmt><if>if <condition>(<expr><name>resultTest</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>resultTest</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                    <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to convert %s %"</literal> <name>PRId64</name> <literal type="string">" to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>resultTest</name></expr></argument>,
                    <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeUInt64</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>varTypeString</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cvtZToUInt64</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeUInt</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varUInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeUInt64</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varUInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"unable to force %s to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeUInt64</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Variant</name> <modifier>*</modifier></type>
<name>varNewKv</name><parameter_list>(<parameter><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>KEY_VALUE</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VariantKeyValue</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>VariantKeyValue</argument>, <argument>.childQty = <literal type="number">1</literal></argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>VariantKeyValue</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>varTypeKeyValue</name></expr>,
        }</block></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>kvMove</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>memContextCurrent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><operator>(</operator><name>Variant</name> <operator>*</operator><operator>)</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>KeyValue</name> <modifier>*</modifier></type>
<name>varKv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeKeyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>VariantKeyValue</name> <operator>*</operator><operator>)</operator><name>this</name><operator>)</operator><operator>-&gt;</operator><name>data</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>KEY_VALUE</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Variant</name> <modifier>*</modifier></type>
<name>varNewStr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VariantString</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the variant is larger than the extra allowed with a mem context then allocate the buffer separately</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>allocExtra</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>VariantString</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>StringPub</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <call><name>strSize</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>allocExtra</name> <operator>&gt;</operator> <name>MEM_CONTEXT_ALLOC_EXTRA_MAX</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>VariantString</argument>, <argument>.childQty = <literal type="number">1</literal></argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>VariantString</name><operator>)</operator>
            <block>{
                <expr><operator>.</operator><name>pub</name> <operator>=</operator>
                <block>{
                    <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>varTypeString</name></expr>,
                    <expr><operator>.</operator><name>data</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>,
                }</block></expr>,
            }</block></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><operator>(</operator><name>Variant</name> <operator>*</operator><operator>)</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <macro><name>OBJ_NEW_EXTRA_BEGIN</name><argument_list>(<argument>VariantString</argument>, <argument>(uint16_t)(allocExtra)</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>VariantString</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>pub</name> <operator>=</operator>
            <block>{
                <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>varTypeString</name></expr>,
            }</block></expr>,
        }</block></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Point the String after the VariantString struct</comment>
            <decl_stmt><decl><type><name>StringPub</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pubData</name> <init>= <expr><operator>(</operator><name>StringPub</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>this</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>String</name> <operator>*</operator><operator>)</operator><name>pubData</name></expr>;</expr_stmt>

            <comment type="line">// Assign the string size and buffer (after StringPub struct)</comment>
            <expr_stmt><expr><operator>*</operator><name>pubData</name> <operator>=</operator> <operator>(</operator><name>StringPub</name><operator>)</operator>
            <block>{
                <expr><operator>.</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>strSize</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>pubData</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>,
            }</block></expr>;</expr_stmt>

            <comment type="line">// Assign the string</comment>
            <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>pubData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pubData</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><call><name>strSize</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><operator>(</operator><name>Variant</name> <operator>*</operator><operator>)</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Variant</name> <modifier>*</modifier></type>
<name>varNewStrZ</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><call><name>varNewStr</name><argument_list>(<argument><expr><ternary><condition><expr><name>data</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>STR</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type>
<name>varStr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>VariantString</name> <operator>*</operator><operator>)</operator><name>this</name><operator>)</operator><operator>-&gt;</operator><name><name>pub</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>String</name> <modifier>*</modifier></type>
<name>varStrForce</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>varTypeBool</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><call><name>cvtBoolToConstZ</name><argument_list>(<argument><expr><call><name>varBool</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeInt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name><name>working</name><index>[<expr><name>CVT_BASE10_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>cvtIntToZ</name><argument_list>(<argument><expr><call><name>varInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>working</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>working</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><name>working</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>varTypeInt64</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name><name>working</name><index>[<expr><name>CVT_BASE10_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>cvtInt64ToZ</name><argument_list>(<argument><expr><call><name>varInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>working</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>working</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><name>working</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>varTypeString</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>varTypeUInt</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name><name>working</name><index>[<expr><name>CVT_BASE10_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>cvtUIntToZ</name><argument_list>(<argument><expr><call><name>varUInt</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>working</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>working</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><name>working</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>

        <case>case <expr><name>varTypeUInt64</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name><name>working</name><index>[<expr><name>CVT_BASE10_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>cvtUInt64ToZ</name><argument_list>(<argument><expr><call><name>varUInt64</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>working</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>working</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><name>working</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>

        <default>default:</default>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to force %s to %s"</literal></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name><name>variantTypeName</name><index>[<expr><name>varTypeString</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Variant</name> <modifier>*</modifier></type>
<name>varNewVarLst</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VariantList</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT_LIST</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VariantVariantList</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>VariantVariantList</argument>, <argument>.childQty = <literal type="number">1</literal></argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>VariantVariantList</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>varTypeVariantList</name></expr>,
        }</block></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>varLstDup</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><operator>(</operator><name>Variant</name> <operator>*</operator><operator>)</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>VariantList</name> <modifier>*</modifier></type>
<name>varVarLst</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeVariantList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>VariantVariantList</name> <operator>*</operator><operator>)</operator><name>this</name><operator>)</operator><operator>-&gt;</operator><name>data</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>VARIANT_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>varToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>this</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>NULL_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <switch>switch <condition>(<expr><call><name>varType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>varTypeString</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strToLog</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>varTypeKeyValue</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><literal type="string">"{KeyValue}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>varTypeVariantList</name></expr>:</case>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><literal type="string">"{VariantList}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>varTypeBool</name></expr>:</case>
            <case>case <expr><name>varTypeInt</name></expr>:</case>
            <case>case <expr><name>varTypeInt64</name></expr>:</case>
            <case>case <expr><name>varTypeUInt</name></expr>:</case>
            <case>case <expr><name>varTypeUInt64</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"{%s}"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>varStrForce</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
