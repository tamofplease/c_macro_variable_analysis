<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/common/memContext.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Memory Context Manager
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/macro.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/memContext.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Contains information about a memory allocation. This header is placed at the beginning of every memory allocation returned to the
user by memNew(), etc. The advantage is that when an allocation is passed back by the user we know the location of the allocation
header by doing some pointer arithmetic. This is much faster than searching through a list.
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>MemContextAlloc</name>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>allocIdx</name><range>:<expr><literal type="number">32</literal></expr></range></decl>;</decl_stmt>                                       <comment type="line">// Index in the allocation list</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name><range>:<expr><literal type="number">32</literal></expr></range></decl>;</decl_stmt>                                           <comment type="line">// Allocation size (4GB max)</comment>
}</block></struct></type> <name>MemContextAlloc</name>;</typedef>

<comment type="line">// Get the allocation buffer pointer given the allocation header pointer</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEM_CONTEXT_ALLOC_BUFFER</name><parameter_list>(<parameter><type><name>header</name></type></parameter>)</parameter_list></cpp:macro>                            <cpp:value>((MemContextAlloc *)header + 1)</cpp:value></cpp:define>

<comment type="line">// Get the allocation header pointer given the allocation buffer pointer</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEM_CONTEXT_ALLOC_HEADER</name><parameter_list>(<parameter><type><name>buffer</name></type></parameter>)</parameter_list></cpp:macro>                            <cpp:value>((MemContextAlloc *)buffer - 1)</cpp:value></cpp:define>

<comment type="line">// Make sure the allocation is valid for the current memory context. This check only works correctly if the allocation is valid and</comment>
<comment type="line">// allocated as one of many but belongs to another context. Otherwise, there is likely to be a segfault.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_ALLOC_MANY_VALID</name><parameter_list>(<parameter><type><name>alloc</name></type></parameter>)</parameter_list></cpp:macro>                                                                                             \
    <cpp:value>ASSERT(                                                                                                                        \
        alloc != NULL &amp;&amp; (uintptr_t)alloc != (uintptr_t)-sizeof(MemContextAlloc) &amp;&amp;                                                \
        alloc-&gt;allocIdx &lt; memContextAllocMany(memContextStack[memContextCurrentStackIdx].memContext)-&gt;listSize &amp;&amp;                  \
        memContextAllocMany(memContextStack[memContextCurrentStackIdx].memContext)-&gt;list[alloc-&gt;allocIdx]);</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Contains information about the memory context
***********************************************************************************************************************************/</comment>
<comment type="line">// Quantity of child contexts, allocations, or callbacks</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>memQtyNone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,                                                 <comment type="line">// None for this type</comment>
    <decl><name>memQtyOne</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,                                                  <comment type="line">// One for this type</comment>
    <decl><name>memQtyMany</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,                                                 <comment type="line">// Many for this type</comment>
}</block></enum></type> <name>MemQty</name>;</typedef>

<comment type="line">// Main structure required by every mem context</comment>
<struct>struct <name>MemContext</name>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>                                               <comment type="line">// Indicates what the context is being used for</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>active</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                                  <comment type="line">// Is the context currently active?</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>MemQty</name></type> <name>childQty</name><range>:<expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>                                              <comment type="line">// How many child contexts can this context have?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>childInitialized</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                        <comment type="line">// Has the child context list been initialized?</comment>
    <decl_stmt><decl><type><name>MemQty</name></type> <name>allocQty</name><range>:<expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>                                              <comment type="line">// How many allocations can this context have?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>allocInitialized</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                        <comment type="line">// Has the allocation list been initialized?</comment>
    <decl_stmt><decl><type><name>MemQty</name></type> <name>callbackQty</name><range>:<expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>                                           <comment type="line">// How many callbacks can this context have?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>callbackInitialized</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>                                     <comment type="line">// Has the callback been initialized?</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>allocExtra</name><range>:<expr><literal type="number">16</literal></expr></range></decl>;</decl_stmt>                                           <comment type="line">// Size of extra allocation (1kB max)</comment>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>contextParentIdx</name></decl>;</decl_stmt>                                  <comment type="line">// Index in the parent context list</comment>
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>contextParent</name></decl>;</decl_stmt>                                      <comment type="line">// All contexts have a parent except top</comment>
}</block>;</struct>

<comment type="line">// Mem context with one allocation</comment>
<typedef>typedef <type><struct>struct <name>MemContextAllocOne</name>
<block>{
    <decl_stmt><decl><type><name>MemContextAlloc</name> <modifier>*</modifier></type><name>alloc</name></decl>;</decl_stmt>                                         <comment type="line">// Memory allocation created in this context</comment>
}</block></struct></type> <name>MemContextAllocOne</name>;</typedef>

<comment type="line">// Mem context with many allocations</comment>
<typedef>typedef <type><struct>struct <name>MemContextAllocMany</name>
<block>{
    <decl_stmt><decl><type><name>MemContextAlloc</name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>                                         <comment type="line">// List of memory allocations created in this context</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>listSize</name></decl>;</decl_stmt>                                          <comment type="line">// Size of alloc list (not the actual count of allocations)</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>freeIdx</name></decl>;</decl_stmt>                                           <comment type="line">// Index of first free space in the alloc list</comment>
}</block></struct></type> <name>MemContextAllocMany</name>;</typedef>

<comment type="line">// Mem context with one child context</comment>
<typedef>typedef <type><struct>struct <name>MemContextChildOne</name>
<block>{
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>                                            <comment type="line">// Context created in this context</comment>
}</block></struct></type> <name>MemContextChildOne</name>;</typedef>

<comment type="line">// Mem context with many child contexts</comment>
<typedef>typedef <type><struct>struct <name>MemContextChildMany</name>
<block>{
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>                                              <comment type="line">// List of contexts created in this context</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>listSize</name></decl>;</decl_stmt>                                          <comment type="line">// Size of child context list (not the actual count of contexts)</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>freeIdx</name></decl>;</decl_stmt>                                           <comment type="line">// Index of first free space in the context list</comment>
}</block></struct></type> <name>MemContextChildMany</name>;</typedef>

<comment type="line">// Mem context with one callback</comment>
<typedef>typedef <type><struct>struct <name>MemContextCallbackOne</name>
<block>{
    <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>function</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>                                       <comment type="line">// Function to call before the context is freed</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>argument</name></decl>;</decl_stmt>                                                 <comment type="line">// Argument to pass to callback function</comment>
}</block></struct></type> <name>MemContextCallbackOne</name>;</typedef>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Possible sizes for the manifest based on options. Formatting has been compressed to save space.
***********************************************************************************************************************************/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>memContextSizePossible</name><index>[<expr><name>memQtyMany</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>memQtyMany</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>memQtyOne</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>=
<expr><block>{
    <comment type="line">// child none</comment>
    <expr><block>{<comment type="line">// alloc none</comment>
     <expr><block>{<comment type="block">/* callback none */</comment> <expr><literal type="number">0</literal></expr>, <comment type="block">/* callback one */</comment> <expr>sizeof<operator>(</operator><name>MemContextCallbackOne</name><operator>)</operator></expr>}</block></expr>,
     <comment type="line">// alloc one</comment>
     <expr><block>{<comment type="block">/* callback none */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocOne</name></expr></argument>)</argument_list></sizeof></expr>,
      <comment type="block">/* callback one */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocOne</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> sizeof<operator>(</operator><name>MemContextCallbackOne</name><operator>)</operator></expr>}</block></expr>,
     <comment type="line">// alloc many</comment>
     <expr><block>{<comment type="block">/* callback none */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocMany</name></expr></argument>)</argument_list></sizeof></expr>,
      <comment type="block">/* callback one */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocMany</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> sizeof<operator>(</operator><name>MemContextCallbackOne</name><operator>)</operator></expr>}</block></expr>}</block></expr>,
    <comment type="line">// child one</comment>
    <expr><block>{<comment type="line">// alloc none</comment>
     <expr><block>{<comment type="block">/* callback none */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildOne</name></expr></argument>)</argument_list></sizeof></expr>,
      <comment type="block">/* callback one */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildOne</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> sizeof<operator>(</operator><name>MemContextCallbackOne</name><operator>)</operator></expr>}</block></expr>,
     <comment type="line">// alloc one</comment>
     <expr><block>{<comment type="block">/* callback none */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildOne</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocOne</name></expr></argument>)</argument_list></sizeof></expr>,
      <comment type="block">/* callback one */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildOne</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocOne</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> sizeof<operator>(</operator><name>MemContextCallbackOne</name><operator>)</operator></expr>}</block></expr>,
     <comment type="line">// alloc many</comment>
     <expr><block>{<comment type="block">/* callback none */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildOne</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocMany</name></expr></argument>)</argument_list></sizeof></expr>,
      <comment type="block">/* callback one */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildOne</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocMany</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> sizeof<operator>(</operator><name>MemContextCallbackOne</name><operator>)</operator></expr>}</block></expr>}</block></expr>,
    <comment type="line">// child many</comment>
    <expr><block>{<comment type="line">// alloc none</comment>
     <expr><block>{<comment type="block">/* callback none */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildMany</name></expr></argument>)</argument_list></sizeof></expr>,
      <comment type="block">/* callback one */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildMany</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> sizeof<operator>(</operator><name>MemContextCallbackOne</name><operator>)</operator></expr>}</block></expr>,
     <comment type="line">// alloc one</comment>
     <expr><block>{<comment type="block">/* callback none */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildMany</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocOne</name></expr></argument>)</argument_list></sizeof></expr>,
      <comment type="block">/* callback one */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildMany</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocOne</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> sizeof<operator>(</operator><name>MemContextCallbackOne</name><operator>)</operator></expr>}</block></expr>,
     <comment type="line">// alloc many</comment>
     <expr><block>{<comment type="block">/* callback none */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildMany</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocMany</name></expr></argument>)</argument_list></sizeof></expr>,
      <comment type="block">/* callback one */</comment> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildMany</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocMany</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> sizeof<operator>(</operator><name>MemContextCallbackOne</name><operator>)</operator></expr>}</block></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get pointers to optional parts of the manifest
***********************************************************************************************************************************/</comment>
<comment type="line">// Get pointer to child part</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEM_CONTEXT_CHILD_OFFSET</name><parameter_list>(<parameter><type><name>memContext</name></type></parameter>)</parameter_list></cpp:macro>                        <cpp:value>((unsigned char *)(memContext + 1) + memContext-&gt;allocExtra)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>MemContextChildOne</name> <modifier>*</modifier></type>
<name>memContextChildOne</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>MemContextChildOne</name> <operator>*</operator><operator>)</operator><call><name>MEM_CONTEXT_CHILD_OFFSET</name><argument_list>(<argument><expr><name>memContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MemContextChildMany</name> <modifier>*</modifier></type>
<name>memContextChildMany</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>MemContextChildMany</name> <operator>*</operator><operator>)</operator><call><name>MEM_CONTEXT_CHILD_OFFSET</name><argument_list>(<argument><expr><name>memContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Get pointer to allocation part</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEM_CONTEXT_ALLOC_OFFSET</name><parameter_list>(<parameter><type><name>memContext</name></type></parameter>)</parameter_list></cpp:macro>                                                                                       \
    <cpp:value>((unsigned char *)(memContext + 1) + memContextSizePossible[memContext-&gt;childQty][0][0] + memContext-&gt;allocExtra)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>MemContextAllocOne</name> <modifier>*</modifier></type>
<name>memContextAllocOne</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>MemContextAllocOne</name> <operator>*</operator><operator>)</operator><call><name>MEM_CONTEXT_ALLOC_OFFSET</name><argument_list>(<argument><expr><name>memContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MemContextAllocMany</name> <modifier>*</modifier></type>
<name>memContextAllocMany</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>MemContextAllocMany</name> <operator>*</operator><operator>)</operator><call><name>MEM_CONTEXT_ALLOC_OFFSET</name><argument_list>(<argument><expr><name>memContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Get pointer to callback part</comment>
<function><type><specifier>static</specifier> <name>MemContextCallbackOne</name> <modifier>*</modifier></type>
<name>memContextCallbackOne</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return
        <expr><operator>(</operator><name>MemContextCallbackOne</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>memContext</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator>
            <name><name>memContextSizePossible</name><index>[<expr><name><name>memContext</name><operator>-&gt;</operator><name>childQty</name></name></expr>]</index><index>[<expr><name><name>memContext</name><operator>-&gt;</operator><name>allocQty</name></name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>memContext</name><operator>-&gt;</operator><name>allocExtra</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Top context

The top context always exists and can never be freed.  All other contexts are children of the top context. The top context is
generally used to allocate memory that exists for the life of the program.
***********************************************************************************************************************************/</comment>
<struct><specifier>static</specifier> struct <name>MemContextTop</name>
<block>{
    <decl_stmt><decl><type><name>MemContext</name></type> <name>memContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemContextChildMany</name></type> <name>memContextChildMany</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemContextAllocMany</name></type> <name>memContextAllocMany</name></decl>;</decl_stmt>
}</block> <decl><name>contextTop</name> <init>=
<expr><block>{
    <expr><operator>.</operator><name>memContext</name> <operator>=</operator>
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"TOP"</literal></expr>,
        <expr><operator>.</operator><name>active</name> <operator>=</operator> <name>true</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr><operator>.</operator><name>childQty</name> <operator>=</operator> <name>memQtyMany</name></expr>,
        <expr><operator>.</operator><name>allocQty</name> <operator>=</operator> <name>memQtyMany</name></expr>,
    }</block></expr>,
}</block></expr></init></decl>;</struct>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Memory context stack types
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>memContextStackTypeSwitch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,                                  <comment type="line">// Context can be switched to allocate mem for new variables</comment>
    <decl><name>memContextStackTypeNew</name></decl>,                                         <comment type="line">// Context to be tracked for error handling - cannot switch to</comment>
}</block></enum></type> <name>MemContextStackType</name>;</typedef>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Mem context stack used to pop mem contexts and cleanup after an error
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEM_CONTEXT_STACK_MAX</name></cpp:macro>                                       <cpp:value>128</cpp:value></cpp:define>

<struct><specifier>static</specifier> struct <name>MemContextStack</name>
<block>{
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>memContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemContextStackType</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tryDepth</name></decl>;</decl_stmt>
}</block> <decl><name><name>memContextStack</name><index>[<expr><name>MEM_CONTEXT_STACK_MAX</name></expr>]</index></name> <init>= <expr><block>{<expr><block>{<expr><operator>.</operator><name>memContext</name> <operator>=</operator> <operator>(</operator><name>MemContext</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>contextTop</name></expr>}</block></expr>}</block></expr></init></decl>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>memContextCurrentStackIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>memContextMaxStackIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Wrapper around malloc() with error handling
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>memAllocInternal</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Allocate memory</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Error when malloc fails</comment>
    <if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>MemoryError</name></expr></argument>, <argument><expr><literal type="string">"unable to allocate %zu bytes"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Return the buffer</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Allocate an array of pointers and set all entries to NULL
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>memAllocPtrArrayInternal</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Allocate memory</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>buffer</name> <init>= <expr><call><name>memAllocInternal</name><argument_list>(<argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Set all pointers to NULL</comment>
    <for>for <control>(<init><decl><type><name>size_t</name></type> <name>ptrIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ptrIdx</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>ptrIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>ptrIdx</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>

    <comment type="line">// Return the buffer</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Wrapper around realloc() with error handling
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>memReAllocInternal</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>bufferOld</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sizeNew</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>bufferOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>sizeNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>bufferOld</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Allocate memory</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>bufferNew</name> <init>= <expr><call><name>realloc</name><argument_list>(<argument><expr><name>bufferOld</name></expr></argument>, <argument><expr><name>sizeNew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Error when realloc fails</comment>
    <if_stmt><if>if <condition>(<expr><name>bufferNew</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>MemoryError</name></expr></argument>, <argument><expr><literal type="string">"unable to reallocate %zu bytes"</literal></expr></argument>, <argument><expr><name>sizeNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Return the buffer</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>bufferNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Wrapper around realloc() with error handling
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>memReAllocPtrArrayInternal</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>bufferOld</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sizeOld</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sizeNew</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>bufferOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>sizeOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>sizeNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Allocate memory</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>bufferNew</name> <init>= <expr><call><name>memReAllocInternal</name><argument_list>(<argument><expr><name>bufferOld</name></expr></argument>, <argument><expr><name>sizeNew</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Set all new pointers to NULL</comment>
    <for>for <control>(<init><decl><type><name>size_t</name></type> <name>ptrIdx</name> <init>= <expr><name>sizeOld</name></expr></init></decl>;</init> <condition><expr><name>ptrIdx</name> <operator>&lt;</operator> <name>sizeNew</name></expr>;</condition> <incr><expr><name>ptrIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>bufferNew</name><index>[<expr><name>ptrIdx</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>

    <comment type="line">// Return the buffer</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>bufferNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Wrapper around free()
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>memFreeInternal</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Find space for a new mem context
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>memContextNewIndex</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContext</name></decl></parameter>, <parameter><decl><type><name>MemContextChildMany</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContextChild</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name>memContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>memContextChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>memContext</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>memContextChild</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Initialize (free space will always be index 0)</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>memContext</name><operator>-&gt;</operator><name>childInitialized</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>memContextChild</name> <operator>=</operator> <operator>(</operator><name>MemContextChildMany</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>list</name> <operator>=</operator> <call><name>memAllocPtrArrayInternal</name><argument_list>(<argument><expr><name>MEM_CONTEXT_INITIAL_SIZE</name></expr></argument>)</argument_list></call></expr>,
            <expr><operator>.</operator><name>listSize</name> <operator>=</operator> <name>MEM_CONTEXT_INITIAL_SIZE</name></expr>,
        }</block></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>memContext</name><operator>-&gt;</operator><name>childInitialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// Try to find space for the new context</comment>
        <for>for <control>(<init>;</init> <condition><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>freeIdx</name></name> <operator>&lt;</operator> <name><name>memContextChild</name><operator>-&gt;</operator><name>listSize</name></name></expr>;</condition> <incr><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>freeIdx</name></name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>memContextChild</name><operator>-&gt;</operator><name>list</name><index>[<expr><name><name>memContextChild</name><operator>-&gt;</operator><name>freeIdx</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// If no space was found then allocate more</comment>
        <if_stmt><if>if <condition>(<expr><name><name>memContextChild</name><operator>-&gt;</operator><name>freeIdx</name></name> <operator>==</operator> <name><name>memContextChild</name><operator>-&gt;</operator><name>listSize</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Calculate new list size</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>listSizeNew</name> <init>= <expr><name><name>memContextChild</name><operator>-&gt;</operator><name>listSize</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

            <comment type="line">// ReAllocate memory before modifying anything else in case there is an error</comment>
            <expr_stmt><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <call><name>memReAllocPtrArrayInternal</name><argument_list>(<argument><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>listSize</name></name></expr></argument>, <argument><expr><name>listSizeNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Set new list size</comment>
            <expr_stmt><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>listSize</name></name> <operator>=</operator> <name>listSizeNew</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>freeIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>MemContext</name> <modifier>*</modifier></type>
<name>memContextNew</name><parameter_list>(
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>name</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <parameter><decl><type><specifier>const</specifier> <name>MemContextNewParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>childQty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>allocQty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>callbackQty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>allocExtra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>param</name><operator>.</operator><name>childQty</name></name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>param</name><operator>.</operator><name>childQty</name></name> <operator>==</operator> <name>UINT8_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>param</name><operator>.</operator><name>allocQty</name></name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>param</name><operator>.</operator><name>allocQty</name></name> <operator>==</operator> <name>UINT8_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>param</name><operator>.</operator><name>callbackQty</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Check context name length</comment>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Pad allocExtra so that optional structures will be aligned. There may not be any optional structures but it doesn't seem</comment>
    <comment type="line">// worth the cost of checking since memory allocations are aligned so the extra bytes would be wasted anyway.</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>allocExtra</name> <init>= <expr><name><name>param</name><operator>.</operator><name>allocExtra</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>allocExtra</name> <operator>%</operator> <call><name>ALIGN_OF</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>allocExtra</name> <operator>+=</operator> <call><name>ALIGN_OFFSET</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>allocExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Create the new context</comment>
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>contextCurrent</name> <init>= <expr><name><name>memContextStack</name><index>[<expr><name>memContextCurrentStackIdx</name></expr>]</index></name><operator>.</operator><name>memContext</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>childQty</name></name> <operator>!=</operator> <name>memQtyNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>MemQty</name></type> <name>childQty</name> <init>= <expr><ternary><condition><expr><name><name>param</name><operator>.</operator><name>childQty</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>memQtyMany</name></expr> </then><else>: <expr><operator>(</operator><name>MemQty</name><operator>)</operator><name><name>param</name><operator>.</operator><name>childQty</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>MemQty</name></type> <name>allocQty</name> <init>= <expr><ternary><condition><expr><name><name>param</name><operator>.</operator><name>allocQty</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>memQtyMany</name></expr> </then><else>: <expr><operator>(</operator><name>MemQty</name><operator>)</operator><name><name>param</name><operator>.</operator><name>allocQty</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>MemQty</name></type> <name>callbackQty</name> <init>= <expr><operator>(</operator><name>MemQty</name><operator>)</operator><name><name>param</name><operator>.</operator><name>callbackQty</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name> <init>= <expr><call><name>memAllocInternal</name><argument_list>(
        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContext</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>allocExtra</name> <operator>+</operator> <name><name>memContextSizePossible</name><index>[<expr><name>childQty</name></expr>]</index><index>[<expr><name>allocQty</name></expr>]</index><index>[<expr><name>callbackQty</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>MemContext</name><operator>)</operator>
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <comment type="line">// Set the context name</comment>
        <expr><operator>.</operator><name>name</name> <operator>=</operator> <name>name</name></expr>,

        <comment type="line">// Set new context active</comment>
        <expr><operator>.</operator><name>active</name> <operator>=</operator> <name>true</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="line">// Set flags</comment>
        <expr><operator>.</operator><name>childQty</name> <operator>=</operator> <name>childQty</name></expr>,
        <expr><operator>.</operator><name>allocQty</name> <operator>=</operator> <name>allocQty</name></expr>,
        <expr><operator>.</operator><name>callbackQty</name> <operator>=</operator> <name>callbackQty</name></expr>,

        <comment type="line">// Set extra allocation</comment>
        <expr><operator>.</operator><name>allocExtra</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>allocExtra</name></expr>,

        <comment type="line">// Set current context as the parent</comment>
        <expr><operator>.</operator><name>contextParent</name> <operator>=</operator> <name>contextCurrent</name></expr>,
    }</block></expr>;</expr_stmt>

    <comment type="line">// Find space for the new context</comment>
    <if_stmt><if>if <condition>(<expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyOne</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>contextCurrent</name><operator>-&gt;</operator><name>childInitialized</name></name> <operator>||</operator> <call><name>memContextChildOne</name><argument_list>(<argument><expr><name>contextCurrent</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>context</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memContextChildOne</name><argument_list>(<argument><expr><name>contextCurrent</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>context</name> <operator>=</operator> <name>this</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>childInitialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>MemContextChildMany</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContextChild</name> <init>= <expr><call><name>memContextChildMany</name><argument_list>(<argument><expr><name>contextCurrent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>contextParentIdx</name></name> <operator>=</operator> <call><name>memContextNewIndex</name><argument_list>(<argument><expr><name>contextCurrent</name></expr></argument>, <argument><expr><name>memContextChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>list</name><index>[<expr><name><name>this</name><operator>-&gt;</operator><name>contextParentIdx</name></name></expr>]</index></name> <operator>=</operator> <name>this</name></expr>;</expr_stmt>

        <comment type="line">// Possible free context must be in the next position</comment>
        <expr_stmt><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>freeIdx</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// Add to the mem context stack so it will be automatically freed on error if memContextKeep() has not been called</comment>
    <expr_stmt><expr><name>memContextMaxStackIdx</name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>memContextStack</name><index>[<expr><name>memContextMaxStackIdx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator>struct <name>MemContextStack</name><operator>)</operator>
    <block>{
        <expr><operator>.</operator><name>memContext</name> <operator>=</operator> <name>this</name></expr>,
        <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>memContextStackTypeNew</name></expr>,
        <expr><operator>.</operator><name>tryDepth</name> <operator>=</operator> <call><name>errorTryDepth</name><argument_list>()</argument_list></call></expr>,
    }</block></expr>;</expr_stmt>

    <comment type="line">// Return context</comment>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>memContextAllocExtra</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>allocExtra</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>this</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>MemContext</name> <modifier>*</modifier></type>
<name>memContextFromAllocExtra</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>allocExtra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>allocExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>allocExtra</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MemContext</name> <operator>*</operator><operator>)</operator><name>allocExtra</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>allocExtra</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><operator>(</operator><name>MemContext</name> <operator>*</operator><operator>)</operator><name>allocExtra</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>MemContext</name> <modifier>*</modifier></type>
<name>memContextConstFromAllocExtra</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>allocExtra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>allocExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>allocExtra</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>MemContext</name> <operator>*</operator><operator>)</operator><name>allocExtra</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>allocExtra</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><operator>(</operator><name>MemContext</name> <operator>*</operator><operator>)</operator><name>allocExtra</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>memContextCallbackSet</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>callbackFunction</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callbackArgument</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>FUNCTIONP</name></expr></argument>, <argument><expr><name>callbackFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>callbackArgument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>callbackFunction</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>callbackQty</name></name> <operator>!=</operator> <name>memQtyNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="line">// Error if callback has already been set - there may be valid use cases for this in the future but error until one is found</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>callbackInitialized</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"callback is already set for context '%s'"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Set callback function and argument</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>memContextCallbackOne</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <operator>(</operator><name>MemContextCallbackOne</name><operator>)</operator><block>{<expr><operator>.</operator><name>function</name> <operator>=</operator> <name>callbackFunction</name></expr>, <expr><operator>.</operator><name>argument</name> <operator>=</operator> <name>callbackArgument</name></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>callbackInitialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>memContextCallbackClear</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>callbackQty</name></name> <operator>!=</operator> <name>memQtyNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Clear callback function and argument</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>memContextCallbackOne</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <operator>(</operator><name>MemContextCallbackOne</name><operator>)</operator><block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>callbackInitialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Find an available slot in the memory context's allocation list and allocate memory
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>MemContextAlloc</name> <modifier>*</modifier></type>
<name>memContextAllocNew</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Allocate memory</comment>
    <decl_stmt><decl><type><name>MemContextAlloc</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>memAllocInternal</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAlloc</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Find space for the new allocation</comment>
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>contextCurrent</name> <init>= <expr><name><name>memContextStack</name><index>[<expr><name>memContextCurrentStackIdx</name></expr>]</index></name><operator>.</operator><name>memContext</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>!=</operator> <name>memQtyNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>==</operator> <name>memQtyOne</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemContextAllocOne</name> <modifier>*</modifier><specifier>const</specifier></type> <name>contextAlloc</name> <init>= <expr><call><name>memContextAllocOne</name><argument_list>(<argument><expr><name>contextCurrent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>contextCurrent</name><operator>-&gt;</operator><name>allocInitialized</name></name> <operator>||</operator> <name><name>contextAlloc</name><operator>-&gt;</operator><name>alloc</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Initialize allocation header</comment>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>MemContextAlloc</name><operator>)</operator><block>{<expr><operator>.</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAlloc</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>size</name><operator>)</operator></expr>}</block></expr>;</expr_stmt>

        <comment type="line">// Set pointer in allocation</comment>
        <expr_stmt><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>allocInitialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>==</operator> <name>memQtyMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>MemContextAllocMany</name> <modifier>*</modifier><specifier>const</specifier></type> <name>contextAlloc</name> <init>= <expr><call><name>memContextAllocMany</name><argument_list>(<argument><expr><name>contextCurrent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Initialize (free space will always be index 0)</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>contextCurrent</name><operator>-&gt;</operator><name>allocInitialized</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>contextAlloc</name> <operator>=</operator> <operator>(</operator><name>MemContextAllocMany</name><operator>)</operator>
            <block>{
                <expr><operator>.</operator><name>list</name> <operator>=</operator> <call><name>memAllocPtrArrayInternal</name><argument_list>(<argument><expr><name>MEM_CONTEXT_ALLOC_INITIAL_SIZE</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>listSize</name> <operator>=</operator> <name><name>contextAlloc</name><operator>-&gt;</operator><name>listSize</name></name> <operator>=</operator> <name>MEM_CONTEXT_ALLOC_INITIAL_SIZE</name></expr>,
            }</block></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>allocInitialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <for>for <control>(<init>;</init> <condition><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>freeIdx</name></name> <operator>&lt;</operator> <name><name>contextAlloc</name><operator>-&gt;</operator><name>listSize</name></name></expr>;</condition> <incr><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>freeIdx</name></name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>list</name><index>[<expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>freeIdx</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

            <comment type="line">// If no space was found then allocate more</comment>
            <if_stmt><if>if <condition>(<expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>freeIdx</name></name> <operator>==</operator> <name><name>contextAlloc</name><operator>-&gt;</operator><name>listSize</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Calculate new list size</comment>
                <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>listSizeNew</name> <init>= <expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>listSize</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

                <comment type="line">// Reallocate memory before modifying anything else in case there is an error</comment>
                <expr_stmt><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <call><name>memReAllocPtrArrayInternal</name><argument_list>(<argument><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>listSize</name></name></expr></argument>, <argument><expr><name>listSizeNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Set new size</comment>
                <expr_stmt><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>listSize</name></name> <operator>=</operator> <name>listSizeNew</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// Initialize allocation header</comment>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>MemContextAlloc</name><operator>)</operator><block>{<expr><operator>.</operator><name>allocIdx</name> <operator>=</operator> <name><name>contextAlloc</name><operator>-&gt;</operator><name>freeIdx</name></name></expr>, <expr><operator>.</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAlloc</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>size</name><operator>)</operator></expr>}</block></expr>;</expr_stmt>

        <comment type="line">// Set pointer in allocation list</comment>
        <expr_stmt><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>list</name><index>[<expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>freeIdx</name></name></expr>]</index></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

        <comment type="line">// Update free index to next location. This location may not be free but it is where the search should start next time.</comment>
        <expr_stmt><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>freeIdx</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_TYPE_P</name><argument_list>(<argument><expr><name>MemContextAlloc</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Resize memory that has already been allocated
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>MemContextAlloc</name> <modifier>*</modifier></type>
<name>memContextAllocResize</name><parameter_list>(<parameter><decl><type><name>MemContextAlloc</name> <modifier>*</modifier></type><name>alloc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Resize the allocation</comment>
    <expr_stmt><expr><name>alloc</name> <operator>=</operator> <call><name>memReAllocInternal</name><argument_list>(<argument><expr><name>alloc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAlloc</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>alloc</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAlloc</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>size</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="line">// Update pointer in allocation list in case the realloc moved the allocation</comment>
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>currentContext</name> <init>= <expr><name><name>memContextStack</name><index>[<expr><name>memContextCurrentStackIdx</name></expr>]</index></name><operator>.</operator><name>memContext</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>currentContext</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>!=</operator> <name>memQtyNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>currentContext</name><operator>-&gt;</operator><name>allocInitialized</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>currentContext</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>==</operator> <name>memQtyOne</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>memContextAllocOne</name><argument_list>(<argument><expr><name>currentContext</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alloc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memContextAllocOne</name><argument_list>(<argument><expr><name>currentContext</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alloc</name> <operator>=</operator> <name>alloc</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>currentContext</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>==</operator> <name>memQtyMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_ALLOC_MANY_VALID</name><argument_list>(<argument><expr><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memContextAllocMany</name><argument_list>(<argument><expr><name>currentContext</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>list</name><index>[<expr><name><name>alloc</name><operator>-&gt;</operator><name>allocIdx</name></name></expr>]</index></name> <operator>=</operator> <name>alloc</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_TYPE_P</name><argument_list>(<argument><expr><name>MemContextAlloc</name></expr></argument>, <argument><expr><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>memNew</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>MEM_CONTEXT_ALLOC_BUFFER</name><argument_list>(<argument><expr><call><name>memContextAllocNew</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>memNewPtrArray</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Allocate pointer array</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>buffer</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>MEM_CONTEXT_ALLOC_BUFFER</name><argument_list>(<argument><expr><call><name>memContextAllocNew</name><argument_list>(<argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Set pointers to NULL</comment>
    <for>for <control>(<init><decl><type><name>size_t</name></type> <name>ptrIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ptrIdx</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>ptrIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>ptrIdx</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>memResize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><call><name>MEM_CONTEXT_ALLOC_BUFFER</name><argument_list>(<argument><expr><call><name>memContextAllocResize</name><argument_list>(<argument><expr><call><name>MEM_CONTEXT_ALLOC_HEADER</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>memFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Get the allocation</comment>
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>contextCurrent</name> <init>= <expr><name><name>memContextStack</name><index>[<expr><name>memContextCurrentStackIdx</name></expr>]</index></name><operator>.</operator><name>memContext</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>!=</operator> <name>memQtyNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>allocInitialized</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>MemContextAlloc</name> <modifier>*</modifier><specifier>const</specifier></type> <name>alloc</name> <init>= <expr><call><name>MEM_CONTEXT_ALLOC_HEADER</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Remove allocation from the context</comment>
    <if_stmt><if>if <condition>(<expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>==</operator> <name>memQtyOne</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>memContextAllocOne</name><argument_list>(<argument><expr><name>contextCurrent</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alloc</name> <operator>==</operator> <name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memContextAllocOne</name><argument_list>(<argument><expr><name>contextCurrent</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alloc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>contextCurrent</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>==</operator> <name>memQtyMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT_ALLOC_MANY_VALID</name><argument_list>(<argument><expr><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// If this allocation is before the current free allocation then make it the current free allocation</comment>
        <decl_stmt><decl><type><name>MemContextAllocMany</name> <modifier>*</modifier><specifier>const</specifier></type> <name>contextAlloc</name> <init>= <expr><call><name>memContextAllocMany</name><argument_list>(<argument><expr><name>contextCurrent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>alloc</name><operator>-&gt;</operator><name>allocIdx</name></name> <operator>&lt;</operator> <name><name>contextAlloc</name><operator>-&gt;</operator><name>freeIdx</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>freeIdx</name></name> <operator>=</operator> <name><name>alloc</name><operator>-&gt;</operator><name>allocIdx</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Null the allocation</comment>
        <expr_stmt><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>list</name><index>[<expr><name><name>alloc</name><operator>-&gt;</operator><name>allocIdx</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// Free the allocation</comment>
    <expr_stmt><expr><call><name>memFreeInternal</name><argument_list>(<argument><expr><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>memContextMove</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>parentNew</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name>parentNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>parentNew</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Only move if a valid mem context is provided and the old and new parents are not the same</comment>
    <if_stmt><if>if <condition>(<expr><name>this</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>this</name><operator>-&gt;</operator><name>contextParent</name></name> <operator>!=</operator> <name>parentNew</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name><operator>-&gt;</operator><name>childQty</name></name> <operator>!=</operator> <name>memQtyNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name><operator>-&gt;</operator><name>childInitialized</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Null out the context in the old parent</comment>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyOne</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>memContextChildOne</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>context</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memContextChildOne</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>memContextChildMany</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>list</name><index>[<expr><name><name>this</name><operator>-&gt;</operator><name>contextParentIdx</name></name></expr>]</index></name> <operator>==</operator> <name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memContextChildMany</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>list</name><index>[<expr><name><name>this</name><operator>-&gt;</operator><name>contextParentIdx</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// Find a place in the new parent context and assign it</comment>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>parentNew</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>parentNew</name><operator>-&gt;</operator><name>childQty</name></name> <operator>!=</operator> <name>memQtyNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>parentNew</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyOne</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>parentNew</name><operator>-&gt;</operator><name>childInitialized</name></name> <operator>||</operator> <call><name>memContextChildOne</name><argument_list>(<argument><expr><name>parentNew</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>context</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memContextChildOne</name><argument_list>(<argument><expr><name>parentNew</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>context</name> <operator>=</operator> <name>this</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>parentNew</name><operator>-&gt;</operator><name>childInitialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>parentNew</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>MemContextChildMany</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContextChild</name> <init>= <expr><call><name>memContextChildMany</name><argument_list>(<argument><expr><name>parentNew</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// The child list may move while finding a new index so store the index and use it with (what might be) the new pointer</comment>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>contextParentIdx</name></name> <operator>=</operator> <call><name>memContextNewIndex</name><argument_list>(<argument><expr><name>parentNew</name></expr></argument>, <argument><expr><name>memContextChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>list</name><index>[<expr><name><name>this</name><operator>-&gt;</operator><name>contextParentIdx</name></name></expr>]</index></name> <operator>=</operator> <name>this</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// Set new parent</comment>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name></name> <operator>=</operator> <name>parentNew</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>memContextSwitch</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>memContextCurrentStackIdx</name> <operator>&lt;</operator> <name>MEM_CONTEXT_STACK_MAX</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>memContextMaxStackIdx</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>memContextCurrentStackIdx</name> <operator>=</operator> <name>memContextMaxStackIdx</name></expr>;</expr_stmt>

    <comment type="line">// Add memContext to the stack as a context that can be used for memory allocation</comment>
    <expr_stmt><expr><name><name>memContextStack</name><index>[<expr><name>memContextCurrentStackIdx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator>struct <name>MemContextStack</name><operator>)</operator>
    <block>{
        <expr><operator>.</operator><name>memContext</name> <operator>=</operator> <name>this</name></expr>,
        <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>memContextStackTypeSwitch</name></expr>,
        <expr><operator>.</operator><name>tryDepth</name> <operator>=</operator> <call><name>errorTryDepth</name><argument_list>()</argument_list></call></expr>,
    }</block></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>memContextSwitchBack</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>memContextCurrentStackIdx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Generate a detailed error to help with debugging</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>memContextStack</name><index>[<expr><name>memContextMaxStackIdx</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>memContextStackTypeNew</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
            <argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"current context expected but new context '%s' found"</literal></expr></argument>,
            <argument><expr><name><name>memContextStack</name><index>[<expr><name>memContextMaxStackIdx</name></expr>]</index></name><operator>.</operator><name><name>memContext</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>memContextCurrentStackIdx</name> <operator>==</operator> <name>memContextMaxStackIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>memContextMaxStackIdx</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>memContextCurrentStackIdx</name><operator>--</operator></expr>;</expr_stmt>

    <comment type="line">// memContext of type New cannot be the current context so keep going until we find a memContext we can switch to as the current</comment>
    <comment type="line">// context</comment>
    <while>while <condition>(<expr><name><name>memContextStack</name><index>[<expr><name>memContextCurrentStackIdx</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>memContextStackTypeNew</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>memContextCurrentStackIdx</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>memContextKeep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Generate a detailed error to help with debugging</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>memContextStack</name><index>[<expr><name>memContextMaxStackIdx</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>!=</operator> <name>memContextStackTypeNew</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
            <argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"new context expected but current context '%s' found"</literal></expr></argument>,
            <argument><expr><name><name>memContextStack</name><index>[<expr><name>memContextMaxStackIdx</name></expr>]</index></name><operator>.</operator><name><name>memContext</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>memContextMaxStackIdx</name><operator>--</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>memContextDiscard</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Generate a detailed error to help with debugging</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>memContextStack</name><index>[<expr><name>memContextMaxStackIdx</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>!=</operator> <name>memContextStackTypeNew</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
            <argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"new context expected but current context '%s' found"</literal></expr></argument>,
            <argument><expr><name><name>memContextStack</name><index>[<expr><name>memContextMaxStackIdx</name></expr>]</index></name><operator>.</operator><name><name>memContext</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>memContextFree</name><argument_list>(<argument><expr><name><name>memContextStack</name><index>[<expr><name>memContextMaxStackIdx</name></expr>]</index></name><operator>.</operator><name>memContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>memContextMaxStackIdx</name><operator>--</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>MemContext</name> <modifier>*</modifier></type>
<name>memContextTop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><operator>(</operator><name>MemContext</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>contextTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>MemContext</name> <modifier>*</modifier></type>
<name>memContextCurrent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name><name>memContextStack</name><index>[<expr><name>memContextCurrentStackIdx</name></expr>]</index></name><operator>.</operator><name>memContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>MemContext</name> <modifier>*</modifier></type>
<name>memContextPrior</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>memContextCurrentStackIdx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>priorIdx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name><name>memContextStack</name><index>[<expr><name>memContextCurrentStackIdx</name> <operator>-</operator> <name>priorIdx</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>memContextStackTypeNew</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>priorIdx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name><name>memContextStack</name><index>[<expr><name>memContextCurrentStackIdx</name> <operator>-</operator> <name>priorIdx</name></expr>]</index></name><operator>.</operator><name>memContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>size_t</name></type>
<name>memContextSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Size of struct and extra</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>offset</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>this</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name><name>this</name><operator>-&gt;</operator><name>allocExtra</name></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Size of child contexts</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyOne</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>childInitialized</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>MemContextChildOne</name> <modifier>*</modifier><specifier>const</specifier></type> <name>contextChild</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>MemContextChildOne</name> <operator>*</operator><specifier>const</specifier><operator>)</operator><name>offset</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>contextChild</name><operator>-&gt;</operator><name>context</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>total</name> <operator>+=</operator> <call><name>memContextSize</name><argument_list>(<argument><expr><name><name>contextChild</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildOne</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyMany</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>childInitialized</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>MemContextChildMany</name> <modifier>*</modifier><specifier>const</specifier></type> <name>contextChild</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>MemContextChildMany</name> <operator>*</operator><specifier>const</specifier><operator>)</operator><name>offset</name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>contextIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>contextIdx</name> <operator>&lt;</operator> <name><name>contextChild</name><operator>-&gt;</operator><name>listSize</name></name></expr>;</condition> <incr><expr><name>contextIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>contextChild</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>contextIdx</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>total</name> <operator>+=</operator> <call><name>memContextSize</name><argument_list>(<argument><expr><name><name>contextChild</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>contextIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>contextChild</name><operator>-&gt;</operator><name>listSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildMany</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextChildMany</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Size of allocations</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>==</operator> <name>memQtyOne</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>allocInitialized</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>MemContextAllocOne</name> <modifier>*</modifier><specifier>const</specifier></type> <name>contextAlloc</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>MemContextAllocOne</name> <operator>*</operator><specifier>const</specifier><operator>)</operator><name>offset</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>alloc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>contextAlloc</name><operator>-&gt;</operator><name>alloc</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocOne</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>==</operator> <name>memQtyMany</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>allocInitialized</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>MemContextAllocMany</name> <modifier>*</modifier><specifier>const</specifier></type> <name>contextAlloc</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>MemContextAllocMany</name> <operator>*</operator><specifier>const</specifier><operator>)</operator><name>offset</name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>allocIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>allocIdx</name> <operator>&lt;</operator> <name><name>contextAlloc</name><operator>-&gt;</operator><name>listSize</name></name></expr>;</condition> <incr><expr><name>allocIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>allocIdx</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>contextAlloc</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>allocIdx</name></expr>]</index></name><operator>-&gt;</operator><name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>contextAlloc</name><operator>-&gt;</operator><name>listSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocMany</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextAllocMany</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Size of callback</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>callbackQty</name></name> <operator>!=</operator> <name>memQtyNone</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MemContextCallbackOne</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>offset</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>this</name><operator>)</operator> <operator>+</operator> <name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>memContextClean</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>tryDepth</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>fatal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>tryDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>tryDepth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Iterate through everything pushed to the stack since the last try</comment>
    <while>while <condition>(<expr><name><name>memContextStack</name><index>[<expr><name>memContextMaxStackIdx</name></expr>]</index></name><operator>.</operator><name>tryDepth</name> <operator>&gt;=</operator> <name>tryDepth</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Free memory contexts that were not kept. Skip this for fatal errors to avoid calling destructors that could error and</comment>
        <comment type="line">// mask the original error.</comment>
        <if_stmt><if>if <condition>(<expr><name><name>memContextStack</name><index>[<expr><name>memContextMaxStackIdx</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>memContextStackTypeNew</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fatal</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>memContextFree</name><argument_list>(<argument><expr><name><name>memContextStack</name><index>[<expr><name>memContextMaxStackIdx</name></expr>]</index></name><operator>.</operator><name>memContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else find the prior context and make it the current context</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>memContextCurrentStackIdx</name><operator>--</operator></expr>;</expr_stmt>

            <while>while <condition>(<expr><name><name>memContextStack</name><index>[<expr><name>memContextCurrentStackIdx</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>memContextStackTypeNew</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>memContextCurrentStackIdx</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>memContextMaxStackIdx</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<comment type="line">// Helper to execute callbacks for the context and all its children</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>memContextCallbackRecurse</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="line">// Certain actions against the context are no longer allowed</comment>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Callback</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>callbackInitialized</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemContextCallbackOne</name> <modifier>*</modifier><specifier>const</specifier></type> <name>callback</name> <init>= <expr><call><name>memContextCallbackOne</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>callback</name><operator>-&gt;</operator><name>function</name></name><argument_list>(<argument><expr><name><name>callback</name><operator>-&gt;</operator><name>argument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>callbackInitialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Child callbacks</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>childInitialized</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyOne</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MemContextChildOne</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContextChild</name> <init>= <expr><call><name>memContextChildOne</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>memContextChild</name><operator>-&gt;</operator><name>context</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>memContextCallbackRecurse</name><argument_list>(<argument><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>MemContextChildMany</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContextChild</name> <init>= <expr><call><name>memContextChildMany</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>contextIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>contextIdx</name> <operator>&lt;</operator> <name><name>memContextChild</name><operator>-&gt;</operator><name>listSize</name></name></expr>;</condition> <incr><expr><name>contextIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>memContextChild</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>contextIdx</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>memContextCallbackRecurse</name><argument_list>(<argument><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>contextIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>memContextFreeRecurse</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="line">// Current context cannot be freed unless it is top (top is never really freed, just the stuff under it)</comment>
    <if_stmt><if>if <condition>(<expr><name>this</name> <operator>==</operator> <name><name>memContextStack</name><index>[<expr><name>memContextCurrentStackIdx</name></expr>]</index></name><operator>.</operator><name>memContext</name> <operator>&amp;&amp;</operator> <name>this</name> <operator>!=</operator> <call><name>memContextTop</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"cannot free current context '%s'"</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Free child contexts</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>childInitialized</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyOne</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MemContextChildOne</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContextChild</name> <init>= <expr><call><name>memContextChildOne</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>memContextChild</name><operator>-&gt;</operator><name>context</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>memContextFreeRecurse</name><argument_list>(<argument><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>MemContextChildMany</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContextChild</name> <init>= <expr><call><name>memContextChildMany</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>contextIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>contextIdx</name> <operator>&lt;</operator> <name><name>memContextChild</name><operator>-&gt;</operator><name>listSize</name></name></expr>;</condition> <incr><expr><name>contextIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>memContextChild</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>contextIdx</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>memContextFreeRecurse</name><argument_list>(<argument><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>contextIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="line">// Free child context allocation list</comment>
            <expr_stmt><expr><call><name>memFreeInternal</name><argument_list>(<argument><expr><call><name>memContextChildMany</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Free memory allocations and list</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>allocInitialized</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>!=</operator> <name>memQtyNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>==</operator> <name>memQtyOne</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MemContextAllocOne</name> <modifier>*</modifier><specifier>const</specifier></type> <name>contextAlloc</name> <init>= <expr><call><name>memContextAllocOne</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>alloc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>memFreeInternal</name><argument_list>(<argument><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>allocQty</name></name> <operator>==</operator> <name>memQtyMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>MemContextAllocMany</name> <modifier>*</modifier><specifier>const</specifier></type> <name>contextAlloc</name> <init>= <expr><call><name>memContextAllocMany</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>allocIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>allocIdx</name> <operator>&lt;</operator> <name><name>contextAlloc</name><operator>-&gt;</operator><name>listSize</name></name></expr>;</condition> <incr><expr><name>allocIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>allocIdx</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>memFreeInternal</name><argument_list>(<argument><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>list</name><index>[<expr><name>allocIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

            <expr_stmt><expr><call><name>memFreeInternal</name><argument_list>(<argument><expr><name><name>contextAlloc</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Free the memory context so the slot can be reused (if not the top mem context)</comment>
    <if_stmt><if>if <condition>(<expr><name>this</name> <operator>!=</operator> <call><name>memContextTop</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyOne</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>memContextChildOne</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name><operator>-&gt;</operator><name>childQty</name></name> <operator>==</operator> <name>memQtyMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>MemContextChildMany</name> <modifier>*</modifier><specifier>const</specifier></type> <name>memContextChild</name> <init>= <expr><call><name>memContextChildMany</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If the context index is lower than the current free index in the parent then replace it</comment>
            <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>contextParentIdx</name></name> <operator>&lt;</operator> <name><name>memContextChild</name><operator>-&gt;</operator><name>freeIdx</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>memContextChild</name><operator>-&gt;</operator><name>freeIdx</name></name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>contextParentIdx</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>memContextChildMany</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>contextParent</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>list</name><index>[<expr><name><name>this</name><operator>-&gt;</operator><name>contextParentIdx</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>memFreeInternal</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else reset top context. In practice it is uncommon for the top mem context to be freed and then used again.</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>childInitialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>allocInitialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <comment type="line">// Make the top mem context active again</comment>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>memContextFree</name><parameter_list>(<parameter><decl><type><name>MemContext</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>MEM_CONTEXT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Execute callbacks</comment>
    <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memContextCallbackRecurse</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <comment type="line">// Free context even if a callback fails</comment>
    <macro><name>FINALLY</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memContextFreeRecurse</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
