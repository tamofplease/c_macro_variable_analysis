<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/info/infoBackup.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Backup Info Handler
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/backup/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/crypto/cipherBlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ini.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/bufferWrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/regExp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/infoBackup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"info/manifest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Constants
***********************************************************************************************************************************/</comment>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>INFO_BACKUP_PATH_FILE_STR</name></expr></argument>,                            <argument><expr><name>INFO_BACKUP_PATH_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>INFO_BACKUP_PATH_FILE_COPY_STR</name></expr></argument>,                       <argument><expr><name>INFO_BACKUP_PATH_FILE_COPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Object type
***********************************************************************************************************************************/</comment>
<struct>struct <name>InfoBackup</name>
<block>{
    <decl_stmt><decl><type><name>InfoBackupPub</name></type> <name>pub</name></decl>;</decl_stmt>                                              <comment type="line">// Publicly accessible variables</comment>
}</block>;</struct>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Internal constructor
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>InfoBackup</name> <modifier>*</modifier></type>
<name>infoBackupNewInternal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>InfoBackup</name><operator>)</operator>
    <block>{
        <expr><operator>.</operator><name>pub</name> <operator>=</operator>
        <block>{
            <expr><operator>.</operator><name>memContext</name> <operator>=</operator> <call><name>memContextCurrent</name><argument_list>()</argument_list></call></expr>,
            <expr><operator>.</operator><name>backup</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>InfoBackupData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr>,
        }</block></expr>,
    }</block></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>InfoBackup</name> <modifier>*</modifier></type>
<name>infoBackupNew</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>pgSystemId</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgCatalogVersion</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPassSub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>pgSystemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgCatalogVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPassSub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pgVersion</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pgSystemId</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pgCatalogVersion</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>InfoBackup</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>infoBackupNewInternal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Initialize the pg data</comment>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>infoPg</name></name> <operator>=</operator> <call><name>infoPgNew</name><argument_list>(<argument><expr><name>infoPgBackup</name></expr></argument>, <argument><expr><name>cipherPassSub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>infoBackupPgSet</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>, <argument><expr><name>pgSystemId</name></expr></argument>, <argument><expr><name>pgCatalogVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Create new object and load contents from a file
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_SECTION</name></cpp:macro>                                         <cpp:value>"backup"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_SECTION_BACKUP_CURRENT</name></cpp:macro>                          <cpp:value>INFO_BACKUP_SECTION ":current"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_ANNOTATION</name></cpp:macro>                           <cpp:value>"backup-annotation"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_ARCHIVE_START</name></cpp:macro>                        <cpp:value>"backup-archive-start"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_ARCHIVE_STOP</name></cpp:macro>                         <cpp:value>"backup-archive-stop"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_INFO_REPO_SIZE</name></cpp:macro>                       <cpp:value>"backup-info-repo-size"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_INFO_REPO_SIZE_DELTA</name></cpp:macro>                 <cpp:value>"backup-info-repo-size-delta"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_INFO_SIZE</name></cpp:macro>                            <cpp:value>"backup-info-size"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_INFO_SIZE_DELTA</name></cpp:macro>                      <cpp:value>"backup-info-size-delta"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_LSN_START</name></cpp:macro>                            <cpp:value>"backup-lsn-start"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_LSN_STOP</name></cpp:macro>                             <cpp:value>"backup-lsn-stop"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_PRIOR</name></cpp:macro>                                <cpp:value>STRID5("backup-prior", 0x93d3286e1558c220)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_REFERENCE</name></cpp:macro>                            <cpp:value>"backup-reference"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_TIMESTAMP_START</name></cpp:macro>                      <cpp:value>"backup-timestamp-start"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_TIMESTAMP_STOP</name></cpp:macro>                       <cpp:value>"backup-timestamp-stop"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_TYPE</name></cpp:macro>                                 <cpp:value>STRID5("backup-type", 0x1619a6e1558c220)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_BACKUP_ERROR</name></cpp:macro>                                <cpp:value>STRID5("backup-error", 0x93e522ee1558c220)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_OPT_ARCHIVE_CHECK</name></cpp:macro>                           <cpp:value>"option-archive-check"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_OPT_ARCHIVE_COPY</name></cpp:macro>                            <cpp:value>"option-archive-copy"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_OPT_BACKUP_STANDBY</name></cpp:macro>                          <cpp:value>"option-backup-standby"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_OPT_CHECKSUM_PAGE</name></cpp:macro>                           <cpp:value>"option-checksum-page"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_OPT_COMPRESS</name></cpp:macro>                                <cpp:value>"option-compress"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_OPT_HARDLINK</name></cpp:macro>                                <cpp:value>"option-hardlink"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFO_BACKUP_KEY_OPT_ONLINE</name></cpp:macro>                                  <cpp:value>"option-online"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>infoBackupLoadCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>section</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>section</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier><specifier>const</specifier></type> <name>infoBackup</name> <init>= <expr><operator>(</operator><name>InfoBackup</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Process current backup list</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>section</name></expr></argument>, <argument><expr><name>INFO_BACKUP_SECTION_BACKUP_CURRENT</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(infoBackup-&gt;pub.backup)</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>json</name> <init>= <expr><call><name>jsonReadNew</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>jsonReadObjectBegin</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>info</name> <init>=
            <expr><block>{
                <expr><operator>.</operator><name>backupLabel</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>,

            }</block></expr></init></decl>;</decl_stmt>

            <comment type="line">// Format and version</comment>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backrestFormat</name></name> <operator>=</operator> <call><name>jsonReadUInt</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_KEY_FORMAT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backrestVersion</name></name> <operator>=</operator> <call><name>jsonReadStr</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_KEY_VERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Annotation</comment>
            <if_stmt><if>if <condition>(<expr><call><name>jsonReadKeyExpectZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_ANNOTATION</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupAnnotation</name></name> <operator>=</operator> <call><name>jsonReadVar</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Archive start/stop</comment>
            <if_stmt><if>if <condition>(<expr><call><name>jsonReadKeyExpectZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_ARCHIVE_START</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupArchiveStart</name></name> <operator>=</operator> <call><name>jsonReadStr</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>jsonReadKeyExpectZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_ARCHIVE_STOP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupArchiveStop</name></name> <operator>=</operator> <call><name>jsonReadStr</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Report errors detected during the backup. The key may not exist in older versions.</comment>
            <if_stmt><if>if <condition>(<expr><call><name>jsonReadKeyExpectStrId</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_ERROR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupError</name></name> <operator>=</operator> <call><name>varNewBool</name><argument_list>(<argument><expr><call><name>jsonReadBool</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Size info</comment>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupInfoRepoSize</name></name> <operator>=</operator> <call><name>jsonReadUInt64</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_INFO_REPO_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupInfoRepoSizeDelta</name></name> <operator>=</operator> <call><name>jsonReadUInt64</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_INFO_REPO_SIZE_DELTA</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupInfoSize</name></name> <operator>=</operator> <call><name>jsonReadUInt64</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_INFO_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupInfoSizeDelta</name></name> <operator>=</operator> <call><name>jsonReadUInt64</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_INFO_SIZE_DELTA</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Lsn start/stop</comment>
            <if_stmt><if>if <condition>(<expr><call><name>jsonReadKeyExpectZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_LSN_START</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupLsnStart</name></name> <operator>=</operator> <call><name>jsonReadStr</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>jsonReadKeyExpectZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_LSN_STOP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupLsnStop</name></name> <operator>=</operator> <call><name>jsonReadStr</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Prior backup</comment>
            <if_stmt><if>if <condition>(<expr><call><name>jsonReadKeyExpectStrId</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_PRIOR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupPrior</name></name> <operator>=</operator> <call><name>jsonReadStr</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Reference</comment>
            <if_stmt><if>if <condition>(<expr><call><name>jsonReadKeyExpectZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_REFERENCE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupReference</name></name> <operator>=</operator> <call><name>jsonReadStrLst</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Read timestamps as uint64 to ensure a positive value (guarantee no backups before 1970)</comment>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupTimestampStart</name></name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>jsonReadUInt64</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_TIMESTAMP_START</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupTimestampStop</name></name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>jsonReadUInt64</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_TIMESTAMP_STOP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// backup type</comment>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupType</name></name> <operator>=</operator> <operator>(</operator><name>BackupType</name><operator>)</operator><call><name>jsonReadStrId</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireStrId</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>backupType</name></name> <operator>==</operator> <name>backupTypeFull</name> <operator>||</operator> <name><name>info</name><operator>.</operator><name>backupType</name></name> <operator>==</operator> <name>backupTypeDiff</name> <operator>||</operator> <name><name>info</name><operator>.</operator><name>backupType</name></name> <operator>==</operator> <name>backupTypeIncr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Database id</comment>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>backupPgId</name></name> <operator>=</operator> <call><name>jsonReadUInt</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_KEY_DB_ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Options</comment>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>optionArchiveCheck</name></name> <operator>=</operator> <call><name>jsonReadBool</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_ARCHIVE_CHECK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>optionArchiveCopy</name></name> <operator>=</operator> <call><name>jsonReadBool</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_ARCHIVE_COPY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>optionBackupStandby</name></name> <operator>=</operator> <call><name>jsonReadBool</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_BACKUP_STANDBY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>optionChecksumPage</name></name> <operator>=</operator> <call><name>jsonReadBool</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_CHECKSUM_PAGE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>optionCompress</name></name> <operator>=</operator> <call><name>jsonReadBool</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_COMPRESS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>optionHardlink</name></name> <operator>=</operator> <call><name>jsonReadBool</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_HARDLINK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>info</name><operator>.</operator><name>optionOnline</name></name> <operator>=</operator> <call><name>jsonReadBool</name><argument_list>(<argument><expr><call><name>jsonReadKeyRequireZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_ONLINE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Add the backup data to the list</comment>
            <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name><name>infoBackup</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>backup</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>InfoBackup</name> <modifier>*</modifier></type>
<name>infoBackupNewLoad</name><parameter_list>(<parameter><decl><type><name>IoRead</name> <modifier>*</modifier></type><name>read</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>IO_READ</name></expr></argument>, <argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>read</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>InfoBackup</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>infoBackupNewInternal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>infoPg</name></name> <operator>=</operator> <call><name>infoPgNewLoad</name><argument_list>(<argument><expr><name>read</name></expr></argument>, <argument><expr><name>infoPgBackup</name></expr></argument>, <argument><expr><name>infoBackupLoadCallback</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Save to file
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>infoBackupSaveCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sectionNext</name></decl></parameter>, <parameter><decl><type><name>InfoSave</name> <modifier>*</modifier><specifier>const</specifier></type> <name>infoSaveData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>sectionNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO_SAVE</name></expr></argument>, <argument><expr><name>infoSaveData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoSaveData</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier><specifier>const</specifier></type> <name>infoBackup</name> <init>= <expr><operator>(</operator><name>InfoBackup</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>infoSaveSection</name><argument_list>(<argument><expr><name>infoSaveData</name></expr></argument>, <argument><expr><name>INFO_BACKUP_SECTION_BACKUP_CURRENT</name></expr></argument>, <argument><expr><name>sectionNext</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Set the backup current section</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupIdx</name> <operator>&lt;</operator> <call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>InfoBackupData</name></type> <name>backupData</name> <init>= <expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>json</name> <init>= <expr><call><name>jsonWriteObjectBegin</name><argument_list>(<argument><expr><call><name>jsonWriteNewP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>jsonWriteUInt</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_KEY_FORMAT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backrestFormat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteStr</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_KEY_VERSION</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backrestVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>backupData</name><operator>.</operator><name>backupAnnotation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>jsonWriteVar</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_ANNOTATION</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupAnnotation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>jsonWriteStr</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_ARCHIVE_START</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupArchiveStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteStr</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_ARCHIVE_STOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupArchiveStop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Do not save backup-error if it was not loaded. This prevents backups that were added before the backup-error flag</comment>
            <comment type="line">// was introduced from being saved with an incorrect value.</comment>
            <if_stmt><if>if <condition>(<expr><name><name>backupData</name><operator>.</operator><name>backupError</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>jsonWriteBool</name><argument_list>(<argument><expr><call><name>jsonWriteKeyStrId</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_ERROR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varBool</name><argument_list>(<argument><expr><name><name>backupData</name><operator>.</operator><name>backupError</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>jsonWriteUInt64</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_INFO_REPO_SIZE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupInfoRepoSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteUInt64</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_INFO_REPO_SIZE_DELTA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupInfoRepoSizeDelta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteUInt64</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_INFO_SIZE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupInfoSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteUInt64</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_INFO_SIZE_DELTA</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupInfoSizeDelta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>backupData</name><operator>.</operator><name>backupLsnStart</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>jsonWriteStr</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_LSN_START</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupLsnStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>backupData</name><operator>.</operator><name>backupLsnStop</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>jsonWriteStr</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_LSN_STOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupLsnStop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>backupData</name><operator>.</operator><name>backupPrior</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>jsonWriteStr</name><argument_list>(<argument><expr><call><name>jsonWriteKeyStrId</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_PRIOR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupPrior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>backupData</name><operator>.</operator><name>backupReference</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>jsonWriteStrLst</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_REFERENCE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupReference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// When storing time_t treat as signed int to avoid casting</comment>
            <expr_stmt><expr><call><name>jsonWriteInt64</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_TIMESTAMP_START</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupTimestampStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteInt64</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_TIMESTAMP_STOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupTimestampStop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>jsonWriteStrId</name><argument_list>(<argument><expr><call><name>jsonWriteKeyStrId</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_BACKUP_TYPE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteUInt</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_KEY_DB_ID</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupPgId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>jsonWriteBool</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_ARCHIVE_CHECK</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>optionArchiveCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteBool</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_ARCHIVE_COPY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>optionArchiveCopy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteBool</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_BACKUP_STANDBY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>optionBackupStandby</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteBool</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_CHECKSUM_PAGE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>optionChecksumPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteBool</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_COMPRESS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>optionCompress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteBool</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_HARDLINK</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>optionHardlink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteBool</name><argument_list>(<argument><expr><call><name>jsonWriteKeyZ</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>INFO_BACKUP_KEY_OPT_ONLINE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>optionOnline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>infoSaveValue</name><argument_list>(
                <argument><expr><name>infoSaveData</name></expr></argument>, <argument><expr><name>INFO_BACKUP_SECTION_BACKUP_CURRENT</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>backupData</name><operator>.</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>jsonWriteResult</name><argument_list>(<argument><expr><call><name>jsonWriteObjectEnd</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>infoBackupSave</name><parameter_list>(<parameter><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>IoWrite</name> <modifier>*</modifier></type><name>write</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>IO_WRITE</name></expr></argument>, <argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>write</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>infoPgSave</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>write</name></expr></argument>, <argument><expr><name>infoBackupSaveCallback</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>InfoBackup</name> <modifier>*</modifier></type>
<name>infoBackupPgSet</name><parameter_list>(<parameter><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>pgSystemId</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgCatalogVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>pgSystemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgCatalogVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>infoPg</name></name> <operator>=</operator> <call><name>infoPgSet</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>infoPgBackup</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>, <argument><expr><name>pgSystemId</name></expr></argument>, <argument><expr><name>pgCatalogVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>InfoBackupData</name></type>
<name>infoBackupData</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InfoBackup</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>backupDataIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>backupDataIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>INFO_BACKUP_DATA</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>InfoBackupData</name> <operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>backup</name></name></expr></argument>, <argument><expr><name>backupDataIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>infoBackupDataAdd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InfoBackup</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier></type><name>manifest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MANIFEST</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>manifest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestData</name> <modifier>*</modifier></type><name>manData</name> <init>= <expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Calculate backup sizes, references and report errors</comment>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>backupSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>backupSizeDelta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>backupRepoSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>backupRepoSizeDelta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>backupError</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>fileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fileIdx</name> <operator>&lt;</operator> <call><name>manifestFileTotal</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>fileIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestFile</name></type> <name>file</name> <init>= <expr><call><name>manifestFile</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>, <argument><expr><name>fileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>backupSize</name> <operator>+=</operator> <name><name>file</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>backupRepoSize</name> <operator>+=</operator> <ternary><condition><expr><name><name>file</name><operator>.</operator><name>sizeRepo</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>file</name><operator>.</operator><name>sizeRepo</name></name></expr> </then><else>: <expr><name><name>file</name><operator>.</operator><name>size</name></name></expr></else></ternary></expr>;</expr_stmt>

            <comment type="line">// If a reference to a file exists, then it is in a previous backup and the delta calculation was already done</comment>
            <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>.</operator><name>reference</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>backupSizeDelta</name> <operator>+=</operator> <name><name>file</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>backupRepoSizeDelta</name> <operator>+=</operator> <ternary><condition><expr><name><name>file</name><operator>.</operator><name>sizeRepo</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>file</name><operator>.</operator><name>sizeRepo</name></name></expr> </then><else>: <expr><name><name>file</name><operator>.</operator><name>size</name></name></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Is there an error in the file?</comment>
            <if_stmt><if>if <condition>(<expr><name><name>file</name><operator>.</operator><name>checksumPageError</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>backupError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(this-&gt;pub.backup)</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>infoBackupData</name> <init>=
            <expr><block>{
                <expr><operator>.</operator><name>backupLabel</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>backrestFormat</name> <operator>=</operator> <name>REPOSITORY_FORMAT</name></expr>,
                <expr><operator>.</operator><name>backrestVersion</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>backrestVersion</name></name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>backupInfoRepoSize</name> <operator>=</operator> <name>backupRepoSize</name></expr>,
                <expr><operator>.</operator><name>backupInfoRepoSizeDelta</name> <operator>=</operator> <name>backupRepoSizeDelta</name></expr>,
                <expr><operator>.</operator><name>backupInfoSize</name> <operator>=</operator> <name>backupSize</name></expr>,
                <expr><operator>.</operator><name>backupInfoSizeDelta</name> <operator>=</operator> <name>backupSizeDelta</name></expr>,
                <expr><operator>.</operator><name>backupPgId</name> <operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>pgId</name></name></expr>,
                <expr><operator>.</operator><name>backupTimestampStart</name> <operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>backupTimestampStart</name></name></expr>,
                <expr><operator>.</operator><name>backupTimestampStop</name><operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>backupTimestampStop</name></name></expr>,
                <expr><operator>.</operator><name>backupType</name> <operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>backupType</name></name></expr>,
                <expr><operator>.</operator><name>backupError</name> <operator>=</operator> <call><name>varNewBool</name><argument_list>(<argument><expr><name>backupError</name></expr></argument>)</argument_list></call></expr>,

                <expr><operator>.</operator><name>backupAnnotation</name> <operator>=</operator> <call><name>varDup</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>annotation</name></name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>backupArchiveStart</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>archiveStart</name></name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>backupArchiveStop</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>archiveStop</name></name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>backupLsnStart</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>lsnStart</name></name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>backupLsnStop</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>lsnStop</name></name></expr></argument>)</argument_list></call></expr>,

                <expr><operator>.</operator><name>optionArchiveCheck</name> <operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>backupOptionArchiveCheck</name></name></expr>,
                <expr><operator>.</operator><name>optionArchiveCopy</name> <operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>backupOptionArchiveCopy</name></name></expr>,
                <expr><operator>.</operator><name>optionBackupStandby</name> <operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>backupOptionStandby</name></name> <operator>!=</operator> <name>NULL</name> <operator>?</operator> <call><name>varBool</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>backupOptionStandby</name></name></expr></argument>)</argument_list></call> <operator>:</operator> <name>false</name></expr>,
                <expr><operator>.</operator><name>optionChecksumPage</name> <operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>backupOptionChecksumPage</name></name> <operator>!=</operator> <name>NULL</name> <operator>?</operator>
                    <call><name>varBool</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>backupOptionChecksumPage</name></name></expr></argument>)</argument_list></call> <operator>:</operator> <name>false</name></expr>,
                <expr><operator>.</operator><name>optionCompress</name> <operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>backupOptionCompressType</name></name> <operator>!=</operator> <name>compressTypeNone</name></expr>,
                <expr><operator>.</operator><name>optionHardlink</name> <operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>backupOptionHardLink</name></name></expr>,
                <expr><operator>.</operator><name>optionOnline</name> <operator>=</operator> <name><name>manData</name><operator>-&gt;</operator><name>backupOptionOnline</name></name></expr>,
            }</block></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>manData</name><operator>-&gt;</operator><name>backupType</name></name> <operator>!=</operator> <name>backupTypeFull</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// This list may not be sorted for manifests created before the reference list was added. Remove the last reference</comment>
                <comment type="line">// since it will always be the current backup. Technically the current backup is always referenced but this is not</comment>
                <comment type="line">// useful information for the user.</comment>
                <expr_stmt><expr><name><name>infoBackupData</name><operator>.</operator><name>backupReference</name></name> <operator>=</operator> <call><name>strLstSort</name><argument_list>(<argument><expr><call><name>strLstDup</name><argument_list>(<argument><expr><call><name>manifestReferenceList</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(
                    <argument><expr><call><name>strEq</name><argument_list>(
                        <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>infoBackupData</name><operator>.</operator><name>backupReference</name></name></expr></argument>, <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name><name>infoBackupData</name><operator>.</operator><name>backupReference</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name><name>infoBackupData</name><operator>.</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strLstRemoveIdx</name><argument_list>(<argument><expr><name><name>infoBackupData</name><operator>.</operator><name>backupReference</name></name></expr></argument>, <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name><name>infoBackupData</name><operator>.</operator><name>backupReference</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>infoBackupData</name><operator>.</operator><name>backupPrior</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>backupLabelPrior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Add the backup data to the current backup list</comment>
            <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>backup</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>infoBackupData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Ensure the list is sorted ascending by the backupLabel</comment>
            <expr_stmt><expr><call><name>lstSort</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>backup</name></name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>infoBackupDataAnnotationSet</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InfoBackup</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>backupLabel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>KeyValue</name> <modifier>*</modifier><specifier>const</specifier></type> <name>newAnnotationKv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>KEY_VALUE</name></expr></argument>, <argument><expr><name>newAnnotationKv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>infoBackupLabelExists</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>newAnnotationKv</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(this-&gt;pub.backup)</argument>)</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get data for specified backup</comment>
        <decl_stmt><decl><type><name>InfoBackupData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>infoBackupData</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>backup</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>backupLabel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Create annotation if it does not exist</comment>
        <if_stmt><if>if <condition>(<expr><name><name>infoBackupData</name><operator>-&gt;</operator><name>backupAnnotation</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>infoBackupData</name><operator>-&gt;</operator><name>backupAnnotation</name></name> <operator>=</operator> <call><name>varNewKv</name><argument_list>(<argument><expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Update annotations</comment>
        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier><specifier>const</specifier></type> <name>annotationKv</name> <init>= <expr><call><name>varKv</name><argument_list>(<argument><expr><name><name>infoBackupData</name><operator>-&gt;</operator><name>backupAnnotation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>VariantList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>newAnnotationKeyList</name> <init>= <expr><call><name>kvKeyList</name><argument_list>(<argument><expr><name>newAnnotationKv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>keyIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>keyIdx</name> <operator>&lt;</operator> <call><name>varLstSize</name><argument_list>(<argument><expr><name>newAnnotationKeyList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>keyIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier><specifier>const</specifier></type> <name>newKey</name> <init>= <expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>newAnnotationKeyList</name></expr></argument>, <argument><expr><name>keyIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier><specifier>const</specifier></type> <name>newValue</name> <init>= <expr><call><name>kvGet</name><argument_list>(<argument><expr><name>newAnnotationKv</name></expr></argument>, <argument><expr><name>newKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If value is empty remove the key</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strEmpty</name><argument_list>(<argument><expr><call><name>varStr</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>kvRemove</name><argument_list>(<argument><expr><name>annotationKv</name></expr></argument>, <argument><expr><name>newKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else put new key/value (this will overwrite an existing value)</comment>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>annotationKv</name></expr></argument>, <argument><expr><name>newKey</name></expr></argument>, <argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Clean field if there are no annotations left</comment>
        <if_stmt><if>if <condition>(<expr><call><name>varLstSize</name><argument_list>(<argument><expr><call><name>kvKeyList</name><argument_list>(<argument><expr><name>annotationKv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>infoBackupData</name><operator>-&gt;</operator><name>backupAnnotation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>infoBackupDataDelete</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InfoBackup</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupDeleteLabel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupDeleteLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>backupData</name> <init>= <expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strCmp</name><argument_list>(<argument><expr><name><name>backupData</name><operator>.</operator><name>backupLabel</name></name></expr></argument>, <argument><expr><name>backupDeleteLabel</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>lstRemoveIdx</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>backup</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StringList</name> <modifier>*</modifier></type>
<name>infoBackupDataLabelList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InfoBackup</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Return a 0 sized list if no current backups or none matching the filter</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Prepare regexp if an expression was passed</comment>
        <decl_stmt><decl><type><name>RegExp</name> <modifier>*</modifier></type><name>regExp</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>expression</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>regExpNew</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <comment type="line">// For each backup label, compare it to the filter (if any) and sort it for return</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupLabelIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupLabelIdx</name> <operator>&lt;</operator> <call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupLabelIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>backupData</name> <init>= <expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>backupLabelIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>regExp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>regExpMatch</name><argument_list>(<argument><expr><name>regExp</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StringList</name> <modifier>*</modifier></type>
<name>infoBackupDataDependentList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InfoBackup</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>backupLabel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>backupLabel</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Return the given label as the only dependency or the given label and a list of labels that depend on it</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// For each backup label from oldest to newest in the current section, add each dependency to the list</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupLabelIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupLabelIdx</name> <operator>&lt;</operator> <call><name>infoBackupDataTotal</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupLabelIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>InfoBackupData</name></type> <name>backupData</name> <init>= <expr><call><name>infoBackupData</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>backupLabelIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If the backupPrior is in the dependency chain add the label to the list</comment>
            <if_stmt><if>if <condition>(<expr><name><name>backupData</name><operator>.</operator><name>backupPrior</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strLstExists</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupPrior</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>backupData</name><operator>.</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>InfoBackupLoadFileData</name>
<block>{
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>memContext</name></decl>;</decl_stmt>                                         <comment type="line">// Mem context</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storage</name></decl>;</decl_stmt>                                         <comment type="line">// Storage to load from</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileName</name></decl>;</decl_stmt>                                         <comment type="line">// Base filename</comment>
    <decl_stmt><decl><type><name>CipherType</name></type> <name>cipherType</name></decl>;</decl_stmt>                                          <comment type="line">// Cipher type</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPass</name></decl>;</decl_stmt>                                       <comment type="line">// Cipher passphrase</comment>
    <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl>;</decl_stmt>                                         <comment type="line">// Loaded infoBackup object</comment>
}</block></struct></type> <name>InfoBackupLoadFileData</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>infoBackupLoadFileCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>try</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>try</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>InfoBackupLoadFileData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>loadData</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>try</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// Construct filename based on try</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileName</name> <init>= <expr><ternary><condition><expr><name>try</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>loadData</name><operator>-&gt;</operator><name>fileName</name></name></expr> </then><else>: <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s"</literal> <name>INFO_COPY_EXT</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>loadData</name><operator>-&gt;</operator><name>fileName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <comment type="line">// Attempt to load the file</comment>
            <decl_stmt><decl><type><name>IoRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>read</name> <init>= <expr><call><name>storageReadIo</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><name><name>loadData</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>cipherBlockFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioReadFilterGroup</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>loadData</name><operator>-&gt;</operator><name>cipherType</name></name></expr></argument>, <argument><expr><name>cipherModeDecrypt</name></expr></argument>, <argument><expr><name><name>loadData</name><operator>-&gt;</operator><name>cipherPass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>loadData-&gt;memContext</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>loadData</name><operator>-&gt;</operator><name>infoBackup</name></name> <operator>=</operator> <call><name>infoBackupNewLoad</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>InfoBackup</name> <modifier>*</modifier></type>
<name>infoBackupLoadFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storage</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>, <parameter><decl><type><name>CipherType</name></type> <name>cipherType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>cipherType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>storage</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>fileName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>cipherType</name> <operator>==</operator> <name>cipherTypeNone</name> <operator>&amp;&amp;</operator> <name>cipherPass</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>cipherType</name> <operator>!=</operator> <name>cipherTypeNone</name> <operator>&amp;&amp;</operator> <name>cipherPass</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>InfoBackupLoadFileData</name></type> <name>data</name> <init>=
    <expr><block>{
        <expr><operator>.</operator><name>memContext</name> <operator>=</operator> <call><name>memContextCurrent</name><argument_list>()</argument_list></call></expr>,
        <expr><operator>.</operator><name>storage</name> <operator>=</operator> <name>storage</name></expr>,
        <expr><operator>.</operator><name>fileName</name> <operator>=</operator> <name>fileName</name></expr>,
        <expr><operator>.</operator><name>cipherType</name> <operator>=</operator> <name>cipherType</name></expr>,
        <expr><operator>.</operator><name>cipherPass</name> <operator>=</operator> <name>cipherPass</name></expr>,
    }</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fileNamePath</name> <init>= <expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>infoLoad</name><argument_list>(
                <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"unable to load info file '%s' or '%s"</literal> <name>INFO_COPY_EXT</name> <literal type="string">"'"</literal></expr></argument>, <argument><expr><name>fileNamePath</name></expr></argument>, <argument><expr><name>fileNamePath</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>infoBackupLoadFileCallback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROWP_FMT</name><argument_list>(
                <argument><expr><call><name>errorType</name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><literal type="string">"%s\n"</literal>
                <literal type="string">"HINT: backup.info cannot be opened and is required to perform a backup.\n"</literal>
                <literal type="string">"HINT: has a stanza-create been performed?"</literal></expr></argument>,
                <argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>infoBackup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>InfoBackup</name> <modifier>*</modifier></type>
<name>infoBackupLoadFileReconstruct</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storage</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>, <parameter><decl><type><name>CipherType</name></type> <name>cipherType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>cipherType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>storage</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>fileName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>cipherType</name> <operator>==</operator> <name>cipherTypeNone</name> <operator>&amp;&amp;</operator> <name>cipherPass</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>cipherType</name> <operator>!=</operator> <name>cipherTypeNone</name> <operator>&amp;&amp;</operator> <name>cipherPass</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name> <init>= <expr><call><name>infoBackupLoadFile</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>cipherType</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get a list of backups in the repo</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>backupList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(
            <argument><expr><call><name>storageListP</name><argument_list>(
                <argument><expr><name>storage</name></expr></argument>, <argument><expr><name>STORAGE_REPO_BACKUP_STR</name></expr></argument>,
                <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>backupRegExpP</name><argument_list>(<argument><expr><operator>.</operator><name>full</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>differential</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>incremental</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get the list of current backups and remove backups from current that are no longer in the repository</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>backupCurrentList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(<argument><expr><call><name>infoBackupDataLabelList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupCurrIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupCurrIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>backupCurrentList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupCurrIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>backupLabel</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>backupCurrentList</name></expr></argument>, <argument><expr><name>backupCurrIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>manifestFileName</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>BACKUP_MANIFEST_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If the manifest does not exist on disk and this backup has not already been deleted from the current list in the</comment>
            <comment type="line">// infoBackup object, then remove it and its dependencies</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>storageExistsP</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>manifestFileName</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>infoBackupLabelExists</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>backupList</name> <init>= <expr><call><name>strLstSort</name><argument_list>(<argument><expr><call><name>infoBackupDataDependentList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>removeBackup</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"backup '%s' missing manifest removed from "</literal> <name>INFO_BACKUP_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>removeBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>infoBackupDataDelete</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>removeBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Get the updated current list of backups from backup.info</comment>
        <expr_stmt><expr><name>backupCurrentList</name> <operator>=</operator> <call><name>strLstSort</name><argument_list>(<argument><expr><call><name>infoBackupDataLabelList</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// For each backup in the repo, check if it exists in backup.info</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>backupIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>backupIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>backupIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>backupLabel</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>backupList</name></expr></argument>, <argument><expr><name>backupIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If it does not exist in the list of current backups, then if it is valid, add it</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>backupCurrentList</name></expr></argument>, <argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>manifestFileName</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP</name> <literal type="string">"/%s/"</literal> <name>BACKUP_MANIFEST_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Check if a completed backup exists (backup.manifest only - ignore .copy)</comment>
                <if_stmt><if>if <condition>(<expr><call><name>storageExistsP</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>manifestFileName</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>Manifest</name> <modifier>*</modifier></type><name>manifest</name> <init>= <expr><call><name>manifestLoadFile</name><argument_list>(
                        <argument><expr><name>storage</name></expr></argument>, <argument><expr><name>manifestFileName</name></expr></argument>, <argument><expr><name>cipherType</name></expr></argument>, <argument><expr><call><name>infoPgCipherPass</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>ManifestData</name> <modifier>*</modifier></type><name>manData</name> <init>= <expr><call><name>manifestData</name><argument_list>(<argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// If the pg data for the manifest exists in the history, then add it to current, but if something doesn't match</comment>
                    <comment type="line">// then warn that the backup is not valid</comment>
                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>pgIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>pgIdx</name> <operator>&lt;</operator> <call><name>infoPgDataTotal</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pgIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>InfoPgData</name></type> <name>pgHistory</name> <init>= <expr><call><name>infoPgData</name><argument_list>(<argument><expr><call><name>infoBackupPg</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// If there is an exact match with the history, system and version and there is no backup-prior dependency</comment>
                        <comment type="line">// or there is a backup-prior and it is in the list, then add this backup to the current backup list</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>manData</name><operator>-&gt;</operator><name>pgId</name></name> <operator>==</operator> <name><name>pgHistory</name><operator>.</operator><name>id</name></name> <operator>&amp;&amp;</operator> <name><name>manData</name><operator>-&gt;</operator><name>pgSystemId</name></name> <operator>==</operator> <name><name>pgHistory</name><operator>.</operator><name>systemId</name></name> <operator>&amp;&amp;</operator>
                            <name><name>manData</name><operator>-&gt;</operator><name>pgVersion</name></name> <operator>==</operator> <name><name>pgHistory</name><operator>.</operator><name>version</name></name> <operator>&amp;&amp;</operator>
                            <operator>(</operator><name><name>manData</name><operator>-&gt;</operator><name>backupLabelPrior</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>infoBackupLabelExists</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name><name>manData</name><operator>-&gt;</operator><name>backupLabelPrior</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"backup '%s' found in repository added to "</literal> <name>INFO_BACKUP_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>backupLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>infoBackupDataAdd</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>manifest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>LOG_WARN_FMT</name><argument_list>(<argument><expr><literal type="string">"invalid backup '%s' cannot be added to current backups"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>manData</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>infoBackupSaveFile</name><parameter_list>(
    <parameter><decl><type><name>InfoBackup</name> <modifier>*</modifier></type><name>infoBackup</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storage</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileName</name></decl></parameter>, <parameter><decl><type><name>CipherType</name></type> <name>cipherType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>cipherPass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INFO_BACKUP</name></expr></argument>, <argument><expr><name>infoBackup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>cipherType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>infoBackup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>storage</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>fileName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>cipherType</name> <operator>==</operator> <name>cipherTypeNone</name> <operator>&amp;&amp;</operator> <name>cipherPass</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>cipherType</name> <operator>!=</operator> <name>cipherTypeNone</name> <operator>&amp;&amp;</operator> <name>cipherPass</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Write output into a buffer since it needs to be saved to storage twice</comment>
        <decl_stmt><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><call><name>bufNew</name><argument_list>(<argument><expr><call><name>ioBufferSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IoWrite</name> <modifier>*</modifier></type><name>write</name> <init>= <expr><call><name>ioBufferWriteNew</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>cipherBlockFilterGroupAdd</name><argument_list>(<argument><expr><call><name>ioWriteFilterGroup</name><argument_list>(<argument><expr><name>write</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cipherType</name></expr></argument>, <argument><expr><name>cipherModeEncrypt</name></expr></argument>, <argument><expr><name>cipherPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>infoBackupSave</name><argument_list>(<argument><expr><name>infoBackup</name></expr></argument>, <argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Save the file and make a copy</comment>
        <expr_stmt><expr><call><name>storagePutP</name><argument_list>(<argument><expr><call><name>storageNewWriteP</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>storagePutP</name><argument_list>(<argument><expr><call><name>storageNewWriteP</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s"</literal> <name>INFO_COPY_EXT</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>infoBackupDataToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InfoBackupData</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"{label: %s, pgId: %u}"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>backupLabel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>backupPgId</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
