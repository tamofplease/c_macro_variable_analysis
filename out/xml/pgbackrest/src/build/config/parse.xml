<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/build/config/parse.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Parse Configuration Yaml
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;yaml.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/convert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/posix/storage.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build/common/yaml.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build/config/parse.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Command role constants
***********************************************************************************************************************************/</comment>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>CMD_ROLE_ASYNC_STR</name></expr></argument>,                                   <argument><expr><name>CMD_ROLE_ASYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>CMD_ROLE_LOCAL_STR</name></expr></argument>,                                   <argument><expr><name>CMD_ROLE_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>CMD_ROLE_MAIN_STR</name></expr></argument>,                                    <argument><expr><name>CMD_ROLE_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>CMD_ROLE_REMOTE_STR</name></expr></argument>,                                  <argument><expr><name>CMD_ROLE_REMOTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Command constants
***********************************************************************************************************************************/</comment>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>CMD_HELP_STR</name></expr></argument>,                                         <argument><expr><name>CMD_HELP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>CMD_VERSION_STR</name></expr></argument>,                                      <argument><expr><name>CMD_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Option type constants
***********************************************************************************************************************************/</comment>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>OPT_TYPE_BOOLEAN_STR</name></expr></argument>,                                 <argument><expr><name>OPT_TYPE_BOOLEAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>OPT_TYPE_HASH_STR</name></expr></argument>,                                    <argument><expr><name>OPT_TYPE_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>OPT_TYPE_INTEGER_STR</name></expr></argument>,                                 <argument><expr><name>OPT_TYPE_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>OPT_TYPE_LIST_STR</name></expr></argument>,                                    <argument><expr><name>OPT_TYPE_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>OPT_TYPE_PATH_STR</name></expr></argument>,                                    <argument><expr><name>OPT_TYPE_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>OPT_TYPE_SIZE_STR</name></expr></argument>,                                    <argument><expr><name>OPT_TYPE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>OPT_TYPE_STRING_STR</name></expr></argument>,                                  <argument><expr><name>OPT_TYPE_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>OPT_TYPE_STRING_ID_STR</name></expr></argument>,                               <argument><expr><name>OPT_TYPE_STRING_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>OPT_TYPE_TIME_STR</name></expr></argument>,                                    <argument><expr><name>OPT_TYPE_TIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Option constants
***********************************************************************************************************************************/</comment>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>OPT_STANZA_STR</name></expr></argument>,                                       <argument><expr><name>OPT_STANZA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Section constants
***********************************************************************************************************************************/</comment>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>SECTION_COMMAND_LINE_STR</name></expr></argument>,                             <argument><expr><name>SECTION_COMMAND_LINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>SECTION_GLOBAL_STR</name></expr></argument>,                                   <argument><expr><name>SECTION_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>SECTION_STANZA_STR</name></expr></argument>,                                   <argument><expr><name>SECTION_STANZA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Parse command list
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>BldCfgCommandRaw</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>name</name></decl>;</decl_stmt>                                       <comment type="line">// See BldCfgCommand for comments</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>internal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>logFile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>logLevelDefault</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>lockRequired</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>lockRemoteRequired</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>lockType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>parameterAllowed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>roleList</name></decl>;</decl_stmt>
}</block></struct></type> <name>BldCfgCommandRaw</name>;</typedef>

<comment type="line">// Helper to parse command roles</comment>
<function><type><specifier>static</specifier> <name>StringList</name> <modifier>*</modifier></type>
<name>bldCfgParseCommandRole</name><parameter_list>(<parameter><decl><type><name>Yaml</name> <modifier>*</modifier><specifier>const</specifier></type> <name>yaml</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>YamlEvent</name></type> <name>commandRoleVal</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>commandRoleVal</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeMapEnd</name></expr>)</condition>
        <block>{<block_content>
            <do>do
            <block>{<block_content>
                <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>commandRoleVal</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>commandRoleVal</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>commandRoleVal</name> <operator>=</operator> <call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><name><name>commandRoleVal</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeMapEnd</name></expr>)</condition>;</do>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>bldCfgParseCommandList</name><parameter_list>(<parameter><decl><type><name>Yaml</name> <modifier>*</modifier><specifier>const</specifier></type> <name>yaml</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BldCfgCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>YamlEvent</name></type> <name>cmd</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <do>do
        <block>{<block_content>
            <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>BldCfgCommandRaw</name></type> <name>cmdRaw</name> <init>=
            <expr><block>{
                <expr><operator>.</operator><name>name</name> <operator>=</operator> <name><name>cmd</name><operator>.</operator><name>value</name></name></expr>,
                <expr><operator>.</operator><name>logFile</name> <operator>=</operator> <name>true</name></expr>,
                <expr><operator>.</operator><name>logLevelDefault</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><literal type="string">"info"</literal></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>lockType</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr>,
            }</block></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>YamlEvent</name></type> <name>cmdDef</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>cmdDef</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>yamlEventTypeScalar</name></expr>)</condition>
            <block>{<block_content>
                <do>do
                <block>{<block_content>
                    <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>cmdDef</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>cmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"command-role"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>cmdRaw</name><operator>.</operator><name>roleList</name></name> <operator>=</operator> <call><name>bldCfgParseCommandRole</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>YamlEvent</name></type> <name>cmdDefVal</name> <init>= <expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>cmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>cmdRaw</name><operator>.</operator><name>internal</name></name> <operator>=</operator> <call><name>yamlBoolParse</name><argument_list>(<argument><expr><name>cmdDefVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>cmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"lock-type"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>cmdRaw</name><operator>.</operator><name>lockType</name></name> <operator>=</operator> <name><name>cmdDefVal</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>cmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"lock-remote-required"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>cmdRaw</name><operator>.</operator><name>lockRemoteRequired</name></name> <operator>=</operator> <call><name>yamlBoolParse</name><argument_list>(<argument><expr><name>cmdDefVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>cmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"lock-required"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>cmdRaw</name><operator>.</operator><name>lockRequired</name></name> <operator>=</operator> <call><name>yamlBoolParse</name><argument_list>(<argument><expr><name>cmdDefVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>cmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"log-file"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>cmdRaw</name><operator>.</operator><name>logFile</name></name> <operator>=</operator> <call><name>yamlBoolParse</name><argument_list>(<argument><expr><name>cmdDefVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>cmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"log-level-default"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>cmdRaw</name><operator>.</operator><name>logLevelDefault</name></name> <operator>=</operator> <call><name>strLower</name><argument_list>(<argument><expr><call><name>strDup</name><argument_list>(<argument><expr><name><name>cmdDefVal</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>cmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"parameter-allowed"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>cmdRaw</name><operator>.</operator><name>parameterAllowed</name></name> <operator>=</operator> <call><name>strLower</name><argument_list>(<argument><expr><call><name>strDup</name><argument_list>(<argument><expr><name><name>cmdDefVal</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unknown command definition '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>cmdDef</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></else></if_stmt>

                    <expr_stmt><expr><name>cmdDef</name> <operator>=</operator> <call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                while <condition>(<expr><name><name>cmdDef</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeMapEnd</name></expr>)</condition>;</do>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>cmdDef</name></expr></argument>, <argument><expr><name>yamlEventTypeMapEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="line">// Create role list if not defined</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cmdRaw</name><operator>.</operator><name>roleList</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cmdRaw</name><operator>.</operator><name>roleList</name></name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Add main to the role list and resort</comment>
            <expr_stmt><expr><call><name>strLstAddIfMissing</name><argument_list>(<argument><expr><name><name>cmdRaw</name><operator>.</operator><name>roleList</name></name></expr></argument>, <argument><expr><name>CMD_ROLE_MAIN_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>strLstSort</name><argument_list>(<argument><expr><name><name>cmdRaw</name><operator>.</operator><name>roleList</name></name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(result)</argument>)</argument_list></macro>
            <block>{<block_content>
                <macro><name>lstAdd</name><argument_list>(
                    <argument>result</argument>,
                    <argument>&amp;(BldCfgCommand)
                    {
                        .name = strDup(cmdRaw.name)</argument>,
                        <argument>.internal = cmdRaw.internal</argument>,
                        <argument>.logFile = cmdRaw.logFile</argument>,
                        <argument>.logLevelDefault = strDup(cmdRaw.logLevelDefault)</argument>,
                        <argument>.lockRequired = cmdRaw.lockRequired</argument>,
                        <argument>.lockRemoteRequired = cmdRaw.lockRemoteRequired</argument>,
                        <argument>.lockType = strDup(cmdRaw.lockType)</argument>,
                        <argument>.parameterAllowed = cmdRaw.parameterAllowed</argument>,
                        <argument>.roleList = strLstDup(cmdRaw.roleList)</argument>,
                    <argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        while <condition>(<expr><name><name>cmd</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeMapEnd</name></expr>)</condition>;</do>

        <expr_stmt><expr><call><name>lstSort</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Parse option group list
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>BldCfgOptionGroupRaw</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>name</name></decl>;</decl_stmt>                                       <comment type="line">// See BldCfgOptionGroup for comments</comment>
}</block></struct></type> <name>BldCfgOptionGroupRaw</name>;</typedef>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>bldCfgParseOptionGroupList</name><parameter_list>(<parameter><decl><type><name>Yaml</name> <modifier>*</modifier><specifier>const</specifier></type> <name>yaml</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BldCfgOptionGroup</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>YamlEvent</name></type> <name>optGrp</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <do>do
        <block>{<block_content>
            <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>optGrp</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>BldCfgOptionGroupRaw</name></type> <name>optGrpRaw</name> <init>= <expr><block>{<expr><operator>.</operator><name>name</name> <operator>=</operator> <name><name>optGrp</name><operator>.</operator><name>value</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(result)</argument>)</argument_list></macro>
            <block>{<block_content>
                <macro><name>lstAdd</name><argument_list>(<argument>result</argument>, <argument>&amp;(BldCfgOptionGroup){.name = strDup(optGrpRaw.name)}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>optGrp</name> <operator>=</operator> <call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        while <condition>(<expr><name><name>optGrp</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeMapEnd</name></expr>)</condition>;</do>

        <expr_stmt><expr><call><name>lstSort</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Parse option list
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>BldCfgOptionDependRaw</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>                                           <comment type="line">// See BldCfgOptionDepend for comments</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>defaultValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>valueList</name></decl>;</decl_stmt>
}</block></struct></type> <name>BldCfgOptionDependRaw</name>;</typedef>

<typedef>typedef <type><struct>struct <name>BldCfgOptionDeprecateRaw</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>                                             <comment type="line">// See BldCfgOptionDeprecate for comments</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>indexed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>unindexed</name></decl>;</decl_stmt>
}</block></struct></type> <name>BldCfgOptionDeprecateRaw</name>;</typedef>

<typedef>typedef <type><struct>struct <name>BldCfgOptionCommandRaw</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>                                             <comment type="line">// See BldCfgOptionCommand for comments</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>internal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>required</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>defaultValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOptionDependRaw</name> <modifier>*</modifier></type><name>depend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>allowList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>roleList</name></decl>;</decl_stmt>
}</block></struct></type> <name>BldCfgOptionCommandRaw</name>;</typedef>

<typedef>typedef <type><struct>struct <name>BldCfgOptionRaw</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>                                             <comment type="line">// See BldCfgOption for comments</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>section</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>internal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>required</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Variant</name> <modifier>*</modifier></type><name>negate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>reset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>defaultValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>defaultLiteral</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>secure</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOptionDependRaw</name> <modifier>*</modifier></type><name>depend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>allowList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>allowRangeMin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>allowRangeMax</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>cmdList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type><name>cmdRoleList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>deprecateList</name></decl>;</decl_stmt>
}</block></struct></type> <name>BldCfgOptionRaw</name>;</typedef>

<comment type="line">// Helper to parse allow list</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>StringList</name> <modifier>*</modifier></type>
<name>bldCfgParseAllowList</name><parameter_list>(<parameter><decl><type><name>Yaml</name> <modifier>*</modifier><specifier>const</specifier></type> <name>yaml</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>YamlEvent</name></type> <name>allowListVal</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If allow list is defined</comment>
        <if_stmt><if>if <condition>(<expr><name><name>allowListVal</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>yamlEventTypeSeqBegin</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>YamlEvent</name></type> <name>allowListVal</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <do>do
            <block>{<block_content>
                <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>allowListVal</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>allowListVal</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>allowListVal</name> <operator>=</operator> <call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><name><name>allowListVal</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeSeqEnd</name></expr>)</condition>;</do>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>

            <comment type="line">// Else allow list is inherited</comment>
            <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>optList</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"option list is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>allowListVal</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOptionRaw</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optInherit</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>optList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>allowListVal</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>optInherit</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"inherited option is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strLstDup</name><argument_list>(<argument><expr><name><name>optInherit</name><operator>-&gt;</operator><name>allowList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"result is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Helper to parse allow range</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bldCfgParseAllowRange</name><parameter_list>(<parameter><decl><type><name>Yaml</name> <modifier>*</modifier><specifier>const</specifier></type> <name>yaml</name></decl></parameter>, <parameter><decl><type><name>BldCfgOptionRaw</name> <modifier>*</modifier><specifier>const</specifier></type> <name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeSeqBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>YamlEvent</name></type> <name>allowRangeMinVal</name> <init>= <expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>YamlEvent</name></type> <name>allowRangeMaxVal</name> <init>= <expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>allowRangeMin</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>allowRangeMinVal</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>allowRangeMax</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>allowRangeMaxVal</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeSeqEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Helper to parse depend</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>BldCfgOptionDependRaw</name> <modifier>*</modifier></type>
<name>bldCfgParseDepend</name><parameter_list>(<parameter><decl><type><name>Yaml</name> <modifier>*</modifier><specifier>const</specifier></type> <name>yaml</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOptionDependRaw</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>YamlEvent</name></type> <name>dependVal</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>dependVal</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>yamlEventTypeMapBegin</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>YamlEvent</name></type> <name>dependDef</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>BldCfgOptionDependRaw</name></type> <name>optDependRaw</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

            <do>do
            <block>{<block_content>
                <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>dependDef</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>dependDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeSeqBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>YamlEvent</name></type> <name>dependDefVal</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>valueList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <do>do
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>dependDefVal</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>valueList</name></expr></argument>, <argument><expr><name><name>dependDefVal</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>dependDefVal</name> <operator>=</operator> <call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>
                    while <condition>(<expr><name><name>dependDefVal</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeSeqEnd</name></expr>)</condition>;</do>

                    <expr_stmt><expr><name><name>optDependRaw</name><operator>.</operator><name>valueList</name></name> <operator>=</operator> <name>valueList</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>YamlEvent</name></type> <name>dependDefVal</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>dependDefVal</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>dependDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>optDependRaw</name><operator>.</operator><name>defaultValue</name></name> <operator>=</operator> <name><name>dependDefVal</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>dependDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"option"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>optDependRaw</name><operator>.</operator><name>option</name></name> <operator>=</operator> <name><name>dependDefVal</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unknown depend definition '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>dependDef</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><name>dependDef</name> <operator>=</operator> <call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><name><name>dependDef</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeMapEnd</name></expr>)</condition>;</do>

            <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>BldCfgOptionDependRaw</name> <modifier>*</modifier></type><name>optDepend</name> <init>= <expr><call><name>memNew</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BldCfgOptionDependRaw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><operator>*</operator><name>optDepend</name> <operator>=</operator> <operator>(</operator><name>BldCfgOptionDependRaw</name><operator>)</operator>
                <block>{
                    <expr><operator>.</operator><name>option</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>optDependRaw</name><operator>.</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>,
                    <expr><operator>.</operator><name>defaultValue</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>optDependRaw</name><operator>.</operator><name>defaultValue</name></name></expr></argument>)</argument_list></call></expr>,
                    <expr><operator>.</operator><name>valueList</name> <operator>=</operator> <macro><name>strLstDup</name><argument_list>(<argument>optDependRaw.valueList</argument>)</argument_list></macro></expr>
                }</block></expr>;</expr_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>optDepend</name></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// Else depend is inherited</comment>
            <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>optList</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"option list is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>dependVal</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOptionRaw</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optInherit</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>optList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dependVal</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>optInherit</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"dependency inherited from option '%s' before it is defined"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>dependVal</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optInherit</name><operator>-&gt;</operator><name>depend</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Helper to reconcile depend</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>BldCfgOptionDepend</name> <modifier>*</modifier></type>
<name>bldCfgParseDependReconcile</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>BldCfgOptionRaw</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optRaw</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BldCfgOptionDependRaw</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optDependRaw</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BldCfgOptionDepend</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>optDependRaw</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>optDependRaw</name><operator>-&gt;</operator><name>defaultValue</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>OPT_TYPE_BOOLEAN_STR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"dependency default invalid for non-boolean option '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOption</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optDepend</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>optList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>optDependRaw</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>optDepend</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"dependency on undefined option '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>optDependRaw</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>memNew</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BldCfgOptionDepend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>memcpy</name><argument_list>(
            <argument>result</argument>,
            <argument>&amp;(BldCfgOptionDepend){
                .option = optDepend</argument>, <argument>.defaultValue = strDup(optDependRaw-&gt;defaultValue)</argument>,
                <argument>.valueList = strLstDup(optDependRaw-&gt;valueList)}</argument>,
            <argument>sizeof(BldCfgOptionDepend)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Helper to parse deprecate</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>bldCfgParseOptionDeprecate</name><parameter_list>(<parameter><decl><type><name>Yaml</name> <modifier>*</modifier><specifier>const</specifier></type> <name>yaml</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BldCfgOptionDeprecateRaw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>YamlEvent</name></type> <name>optDeprecate</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <do>do
        <block>{<block_content>
            <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>optDeprecate</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>optDeprecate</name><operator>.</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>indexed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Determine if this deprecation is indexed</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>questionPos</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>strChr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>questionPos</name> <operator>!=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSubN</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>questionPos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSub</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>questionPos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>indexed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Create final deprecation if it does not already exist</comment>
            <decl_stmt><decl><type><name>BldCfgOptionDeprecateRaw</name> <modifier>*</modifier></type><name>deprecate</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>deprecate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <macro><name>lstAdd</name><argument_list>(<argument>result</argument>, <argument>&amp;(BldCfgOptionDeprecateRaw){.name = strDup(name)}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>deprecate</name> <operator>=</operator> <call><name>lstFind</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>deprecate</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"deprecate is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Set indexed/unindexed flags</comment>
            <if_stmt><if>if <condition>(<expr><name>indexed</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>deprecate</name><operator>-&gt;</operator><name>indexed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>deprecate</name><operator>-&gt;</operator><name>unindexed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name>optDeprecate</name> <operator>=</operator> <call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        while <condition>(<expr><name><name>optDeprecate</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeMapEnd</name></expr>)</condition>;</do>

        <expr_stmt><expr><call><name>lstSort</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Helper to reconcile deprecate</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>bldCfgParseOptionDeprecateReconcile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optDeprecateRawList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>optDeprecateRawList</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BldCfgOptionDeprecate</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optDeprecateRawIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optDeprecateRawIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>optDeprecateRawList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>optDeprecateRawIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOptionDeprecateRaw</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optDeprecateRaw</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>optDeprecateRawList</name></expr></argument>, <argument><expr><name>optDeprecateRawIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <macro><name>lstAdd</name><argument_list>(
                <argument>result</argument>,
                <argument>&amp;(BldCfgOptionDeprecate)
                {
                    .name = strDup(optDeprecateRaw-&gt;name)</argument>,
                    <argument>.indexed = optDeprecateRaw-&gt;indexed</argument>,
                    <argument>.unindexed = optDeprecateRaw-&gt;unindexed</argument>,
                <argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Helper to parse the option command list</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>List</name> <modifier>*</modifier></type>
<name>bldCfgParseOptionCommandList</name><parameter_list>(<parameter><decl><type><name>Yaml</name> <modifier>*</modifier><specifier>const</specifier></type> <name>yaml</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>YamlEvent</name></type> <name>optCmdVal</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// If command list is defined</comment>
        <if_stmt><if>if <condition>(<expr><name><name>optCmdVal</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>yamlEventTypeMapBegin</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optCmdRawList</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BldCfgOptionCommandRaw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>YamlEvent</name></type> <name>optCmd</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <do>do
            <block>{<block_content>
                <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>optCmd</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>BldCfgOptionCommandRaw</name></type> <name>optCmdRaw</name> <init>= <expr><block>{<expr><operator>.</operator><name>name</name> <operator>=</operator> <name><name>optCmd</name><operator>.</operator><name>value</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>YamlEvent</name></type> <name>optCmdDef</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>optCmdDef</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>yamlEventTypeScalar</name></expr>)</condition>
                <block>{<block_content>
                    <do>do
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>optCmdDef</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optCmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"allow-list"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>optCmdRaw</name><operator>.</operator><name>allowList</name></name> <operator>=</operator> <call><name>bldCfgParseAllowList</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optCmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"command-role"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>optCmdRaw</name><operator>.</operator><name>roleList</name></name> <operator>=</operator> <call><name>bldCfgParseCommandRole</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optCmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"depend"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(optCmdRawList)</argument>)</argument_list></macro>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>optCmdRaw</name><operator>.</operator><name>depend</name></name> <operator>=</operator> <call><name>bldCfgParseDepend</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>optList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block>
                            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>YamlEvent</name></type> <name>optCmdDefVal</name> <init>= <expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optCmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <comment type="line">// If an override to inheritance</comment>
                                <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optCmdDefVal</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"~"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name><name>optCmdRaw</name><operator>.</operator><name>defaultValue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <comment type="line">// Else set the value</comment>
                                <else>else<block type="pseudo"><block_content>
                                    <expr_stmt><expr><name><name>optCmdRaw</name><operator>.</operator><name>defaultValue</name></name> <operator>=</operator> <name><name>optCmdDefVal</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optCmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>optCmdRaw</name><operator>.</operator><name>internal</name></name> <operator>=</operator> <call><name>varNewBool</name><argument_list>(<argument><expr><call><name>yamlBoolParse</name><argument_list>(<argument><expr><name>optCmdDefVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optCmdDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"required"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>optCmdRaw</name><operator>.</operator><name>required</name></name> <operator>=</operator> <call><name>varNewBool</name><argument_list>(<argument><expr><call><name>yamlBoolParse</name><argument_list>(<argument><expr><name>optCmdDefVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else<block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unknown option command definition '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>optCmdDef</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        </block_content>}</block></else></if_stmt>

                        <expr_stmt><expr><name>optCmdDef</name> <operator>=</operator> <call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>
                    while <condition>(<expr><name><name>optCmdDef</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeMapEnd</name></expr>)</condition>;</do>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>optCmdDef</name></expr></argument>, <argument><expr><name>yamlEventTypeMapEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(optCmdRawList)</argument>)</argument_list></macro>
                <block>{<block_content>
                    <macro><name>lstAdd</name><argument_list>(
                        <argument>optCmdRawList</argument>,
                        <argument>&amp;(BldCfgOptionCommandRaw)
                        {
                            .name = strDup(optCmdRaw.name)</argument>,
                            <argument>.internal = varDup(optCmdRaw.internal)</argument>,
                            <argument>.required = varDup(optCmdRaw.required)</argument>,
                            <argument>.defaultValue = strDup(optCmdRaw.defaultValue)</argument>,
                            <argument>.depend = optCmdRaw.depend</argument>,
                            <argument>.allowList = strLstDup(optCmdRaw.allowList)</argument>,
                            <argument>.roleList = strLstDup(optCmdRaw.roleList)</argument>,
                        <argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>optCmd</name> <operator>=</operator> <call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><name><name>optCmd</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeMapEnd</name></expr>)</condition>;</do>

            <expr_stmt><expr><call><name>lstSort</name><argument_list>(<argument><expr><name>optCmdRawList</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lstMove</name><argument_list>(<argument><expr><name>optCmdRawList</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else command list is inherited</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>optList</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"option list is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>optCmdVal</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOptionRaw</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optInherit</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>optList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>optCmdVal</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>optInherit</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"inherited option is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optInherit</name><operator>-&gt;</operator><name>cmdList</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>bldCfgParseOptionList</name><parameter_list>(<parameter><decl><type><name>Yaml</name> <modifier>*</modifier><specifier>const</specifier></type> <name>yaml</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cmdList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optGrpList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BldCfgOption</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optListRaw</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BldCfgOptionRaw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Parse raw</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>YamlEvent</name></type> <name>opt</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <do>do
        <block>{<block_content>
            <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>BldCfgOptionRaw</name></type> <name>optRaw</name> <init>= <expr><block>{<expr><operator>.</operator><name>name</name> <operator>=</operator> <name><name>opt</name><operator>.</operator><name>value</name></name></expr>, <expr><operator>.</operator><name>required</name> <operator>=</operator> <name>BOOL_TRUE_VAR</name></expr>}</block></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>inheritFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>YamlEvent</name></type> <name>optDef</name> <init>= <expr><call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <do>do
            <block>{<block_content>
                <expr_stmt><expr><call><name>yamlEventCheck</name><argument_list>(<argument><expr><name>optDef</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"allow-list"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>allowList</name></name> <operator>=</operator> <call><name>bldCfgParseAllowList</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>optListRaw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"allow-range"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>bldCfgParseAllowRange</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optRaw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>cmdList</name></name> <operator>=</operator> <call><name>bldCfgParseOptionCommandList</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>optListRaw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"command-role"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>cmdRoleList</name></name> <operator>=</operator> <call><name>bldCfgParseCommandRole</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"depend"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>depend</name></name> <operator>=</operator> <call><name>bldCfgParseDepend</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>optListRaw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"deprecate"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>deprecateList</name></name> <operator>=</operator> <call><name>bldCfgParseOptionDeprecate</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>YamlEvent</name></type> <name>optDefVal</name> <init>= <expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeScalar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// If an override to inheritance</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDefVal</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"~"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>defaultValue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <comment type="line">// Else set the value</comment>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>defaultValue</name></name> <operator>=</operator> <name><name>optDefVal</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"default-literal"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>defaultLiteral</name></name> <operator>=</operator> <call><name>yamlBoolParse</name><argument_list>(<argument><expr><name>optDefVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"group"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name><name>optDefVal</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lstExists</name><argument_list>(<argument><expr><name>optGrpList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>optRaw</name><operator>.</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' has invalid group '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>.</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"inherit"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOptionRaw</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optInherit</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>optListRaw</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>optDefVal</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>optInherit</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"inherited option is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>optRaw</name> <operator>=</operator> <operator>*</operator><name>optInherit</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>opt</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt>

                        <comment type="line">// Deprecations cannot be inherited</comment>
                        <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>deprecateList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                        <expr_stmt><expr><name>inheritFound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>internal</name></name> <operator>=</operator> <call><name>yamlBoolParse</name><argument_list>(<argument><expr><name>optDefVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"negate"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>negate</name></name> <operator>=</operator> <call><name>varNewBool</name><argument_list>(<argument><expr><call><name>yamlBoolParse</name><argument_list>(<argument><expr><name>optDefVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"required"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>required</name></name> <operator>=</operator> <call><name>varNewBool</name><argument_list>(<argument><expr><call><name>yamlBoolParse</name><argument_list>(<argument><expr><name>optDefVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"section"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>section</name></name> <operator>=</operator> <name><name>optDefVal</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"secure"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>secure</name></name> <operator>=</operator> <call><name>yamlBoolParse</name><argument_list>(<argument><expr><name>optDefVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>optDefVal</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unknown option definition '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>optDef</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><name>optDef</name> <operator>=</operator> <call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            while <condition>(<expr><name><name>optDef</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeMapEnd</name></expr>)</condition>;</do>

            <comment type="line">// Type is required</comment>
            <if_stmt><if>if <condition>(<expr><name><name>optRaw</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"option '%s' requires 'type'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// Set defaults if not inherited</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>inheritFound</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Section defaults to command line</comment>
                <if_stmt><if>if <condition>(<expr><name><name>optRaw</name><operator>.</operator><name>section</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>section</name></name> <operator>=</operator> <name>SECTION_COMMAND_LINE_STR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Set negate default if not defined</comment>
                <if_stmt><if>if <condition>(<expr><name><name>optRaw</name><operator>.</operator><name>negate</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>negate</name></name> <operator>=</operator> <call><name>varNewBool</name><argument_list>(
                        <argument><expr><call><name>strEq</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name>OPT_TYPE_BOOLEAN_STR</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>.</operator><name>section</name></name></expr></argument>, <argument><expr><name>SECTION_COMMAND_LINE_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Build default command list if not defined</comment>
                <if_stmt><if>if <condition>(<expr><name><name>optRaw</name><operator>.</operator><name>cmdList</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>optCmdList</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BldCfgOptionCommandRaw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>cmdIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>cmdIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>cmdList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>cmdIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgCommand</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cmd</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>cmdList</name></expr></argument>, <argument><expr><name>cmdIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>CMD_HELP_STR</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>CMD_VERSION_STR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <macro><name>lstAdd</name><argument_list>(<argument>optCmdList</argument>, <argument>&amp;(BldCfgOptionCommandRaw){.name = cmd-&gt;name}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></for>

                    <expr_stmt><expr><call><name>lstSort</name><argument_list>(<argument><expr><name>optCmdList</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>cmdList</name></name> <operator>=</operator> <name>optCmdList</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// Set reset</comment>
            <expr_stmt><expr><name><name>optRaw</name><operator>.</operator><name>reset</name></name> <operator>=</operator> <operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>.</operator><name>section</name></name></expr></argument>, <argument><expr><name>SECTION_COMMAND_LINE_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name>optListRaw</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optRaw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>opt</name> <operator>=</operator> <call><name>yamlEventNext</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        while <condition>(<expr><name><name>opt</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>yamlEventTypeMapEnd</name></expr>)</condition>;</do>

        <expr_stmt><expr><call><name>lstSort</name><argument_list>(<argument><expr><name>optListRaw</name></expr></argument>, <argument><expr><name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Copy option list to result</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optRawIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optRawIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>optListRaw</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>optRawIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOptionRaw</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optRaw</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>optListRaw</name></expr></argument>, <argument><expr><name>optRawIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(result)</argument>)</argument_list></macro>
            <block>{<block_content>
                <macro><name>lstAdd</name><argument_list>(
                    <argument>result</argument>,
                    <argument>&amp;(BldCfgOption)
                    {
                        .name = strDup(optRaw-&gt;name)</argument>,
                        <argument>.type = strDup(optRaw-&gt;type)</argument>,
                        <argument>.section = strDup(optRaw-&gt;section)</argument>,
                        <argument>.internal = optRaw-&gt;internal</argument>,
                        <argument>.required = varBool(optRaw-&gt;required)</argument>,
                        <argument>.negate = varBool(optRaw-&gt;negate)</argument>,
                        <argument>.reset = optRaw-&gt;reset</argument>,
                        <argument>.defaultValue = strDup(optRaw-&gt;defaultValue)</argument>,
                        <argument>.defaultLiteral = optRaw-&gt;defaultLiteral</argument>,
                        <argument>.group = strDup(optRaw-&gt;group)</argument>,
                        <argument>.secure = optRaw-&gt;secure</argument>,
                        <argument>.allowList = strLstDup(optRaw-&gt;allowList)</argument>,
                        <argument>.allowRangeMin = strDup(optRaw-&gt;allowRangeMin)</argument>,
                        <argument>.allowRangeMax = strDup(optRaw-&gt;allowRangeMax)</argument>,
                        <argument>.deprecateList = bldCfgParseOptionDeprecateReconcile(optRaw-&gt;deprecateList)</argument>,
                <argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Reconcile option list</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optRawIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optRawIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>optListRaw</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>optRawIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOptionRaw</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optRaw</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>optListRaw</name></expr></argument>, <argument><expr><name>optRawIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Reconcile option command list roles</comment>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cmdOptList</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BldCfgOptionCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optCmdRawIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optCmdRawIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>-&gt;</operator><name>cmdList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>optCmdRawIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>BldCfgOptionCommandRaw</name></type> <name>optCmd</name> <init>= <expr><operator>*</operator><operator>(</operator><name>BldCfgOptionCommandRaw</name> <operator>*</operator><operator>)</operator><call><name>lstGet</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>-&gt;</operator><name>cmdList</name></name></expr></argument>, <argument><expr><name>optCmdRawIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Lookup command</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgCommand</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cmd</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>cmdList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>optCmd</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                        <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"invalid command '%s' in option '%s' command list"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>optCmd</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Default required to option required if not defined</comment>
                <if_stmt><if>if <condition>(<expr><name><name>optCmd</name><operator>.</operator><name>required</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>optCmd</name><operator>.</operator><name>required</name></name> <operator>=</operator> <name><name>optRaw</name><operator>-&gt;</operator><name>required</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Default internal to option internal if not defined</comment>
                <if_stmt><if>if <condition>(<expr><name><name>optCmd</name><operator>.</operator><name>internal</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>optCmd</name><operator>.</operator><name>internal</name></name> <operator>=</operator> <call><name>varNewBool</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>-&gt;</operator><name>internal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Default command role list if not defined</comment>
                <if_stmt><if>if <condition>(<expr><name><name>optCmd</name><operator>.</operator><name>roleList</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Use option list as default if defined. It will need to be filtered against roles valid for each command</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>optRaw</name><operator>-&gt;</operator><name>cmdRoleList</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>roleList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>cmdRoleIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>cmdRoleIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>-&gt;</operator><name>cmdRoleList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>cmdRoleIdx</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>role</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>optRaw</name><operator>-&gt;</operator><name>cmdRoleList</name></name></expr></argument>, <argument><expr><name>cmdRoleIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>strLstExists</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>roleList</name></name></expr></argument>, <argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>roleList</name></expr></argument>, <argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></for>

                        <expr_stmt><expr><name><name>optCmd</name><operator>.</operator><name>roleList</name></name> <operator>=</operator> <name>roleList</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <comment type="line">// Else use option command list</comment>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>optCmd</name><operator>.</operator><name>roleList</name></name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>roleList</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name><name>optCmd</name><operator>.</operator><name>roleList</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"role list is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(cmdOptList)</argument>)</argument_list></macro>
                <block>{<block_content>
                    <macro><name>lstAdd</name><argument_list>(
                        <argument>cmdOptList</argument>,
                        <argument>&amp;(BldCfgOptionCommand)
                        {
                            .name = strDup(optCmd.name)</argument>,
                            <argument>.internal = varBool(optCmd.internal)</argument>,
                            <argument>.required = varBool(optCmd.required)</argument>,
                            <argument>.defaultValue = strDup(optCmd.defaultValue)</argument>,
                            <argument>.depend = bldCfgParseDependReconcile(optRaw, optCmd.depend, result)</argument>,
                            <argument>.allowList = strLstDup(optCmd.allowList)</argument>,
                            <argument>.roleList = strLstDup(optCmd.roleList)</argument>,
                        <argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <decl_stmt><decl><type><name>BldCfgOption</name> <modifier>*</modifier><specifier>const</specifier></type> <name>opt</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>optRawIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><call><name>strEq</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>optRaw</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"option name does not equal raw option name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>lstMemContext(result)</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>cmdList</name></name> <operator>=</operator> <call><name>lstMove</name><argument_list>(<argument><expr><name>cmdOptList</name></expr></argument>, <argument><expr><call><name>memContextCurrent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>depend</name></name> <operator>=</operator> <call><name>bldCfgParseDependReconcile</name><argument_list>(<argument><expr><name>optRaw</name></expr></argument>, <argument><expr><name><name>optRaw</name><operator>-&gt;</operator><name>depend</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Build option resolve order list
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>bldCfgParseOptionResolveList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>lstNewP</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BldCfgOption</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>.</operator><name>comparator</name> <operator>=</operator> <name>lstComparatorStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// The stanza option will always be resolved first since errors can be confusing when it is missing. That means it must exist</comment>
    <comment type="line">// and cannot have any dependencies.</comment>
    <comment type="line">// -----------------------------------------------------------------------------------------------------------------------------</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOption</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optStanza</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>optList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>OPT_STANZA_STR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>optStanza</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"option '"</literal> <name>OPT_STANZA</name> <literal type="string">"' must exist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>optStanza</name><operator>-&gt;</operator><name>depend</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"option '"</literal> <name>OPT_STANZA</name> <literal type="string">"' may not depend on other option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optCmdIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optCmdIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>optStanza</name><operator>-&gt;</operator><name>cmdList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>optCmdIdx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOptionCommand</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optStanzaCmd</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>optStanza</name><operator>-&gt;</operator><name>cmdList</name></name></expr></argument>, <argument><expr><name>optCmdIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>optStanzaCmd</name><operator>-&gt;</operator><name>depend</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"option '"</literal> <name>OPT_STANZA</name> <literal type="string">"' command '%s' may not depend on other option"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>optStanzaCmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// Determine resolve order</comment>
    <comment type="line">// -----------------------------------------------------------------------------------------------------------------------------</comment>
    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optResolveList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>optResolveList</name></expr></argument>, <argument><expr><name>OPT_STANZA_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <do>do
    <block>{<block_content>
        <comment type="line">// Was at least one option resolved in the loop?</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>resolved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>optList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>optIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOption</name> <modifier>*</modifier><specifier>const</specifier></type> <name>opt</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>optList</name></expr></argument>, <argument><expr><name>optIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If the option has already been resolved then continue</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strLstExists</name><argument_list>(<argument><expr><name>optResolveList</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="line">// If the option dependency has not been resolved then continue</comment>
            <if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>depend</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>optResolveList</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>depend</name><operator>-&gt;</operator><name>option</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="line">// If the option command dependency has not been resolved then continue</comment>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>optCmdIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init>;</init> <condition><expr><name>optCmdIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>cmdList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>optCmdIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOptionCommand</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optCmd</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>cmdList</name></name></expr></argument>, <argument><expr><name>optCmdIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>optCmd</name><operator>-&gt;</operator><name>depend</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>optResolveList</name></expr></argument>, <argument><expr><name><name>optCmd</name><operator>-&gt;</operator><name>depend</name><operator>-&gt;</operator><name>option</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><name>optCmdIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>cmdList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="line">// Option dependencies have been resolved</comment>
            <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>optResolveList</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>resolved</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// If nothing was resolved in the loop then there may be a circular reference</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>resolved</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Find the options that were not resolved</comment>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>unresolvedList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>optList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>optIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOption</name> <modifier>*</modifier><specifier>const</specifier></type> <name>opt</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name>optList</name></expr></argument>, <argument><expr><name>optIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>optResolveList</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>unresolvedList</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                <argument><expr><name>FormatError</name></expr></argument>,
                <argument><expr><literal type="string">"unable to resolve dependencies for option(s) '%s'\n"</literal>
                <literal type="string">"HINT: are there circular dependencies?"</literal></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>unresolvedList</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    while <condition>(<expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>optResolveList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name>optList</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

    <comment type="line">// Copy resolved list</comment>
    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optResolveIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optResolveIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>optResolveList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>optResolveIdx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optName</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>optResolveList</name></expr></argument>, <argument><expr><name>optResolveIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BldCfgOption</name> <modifier>*</modifier><specifier>const</specifier></type> <name>opt</name> <init>= <expr><call><name>lstFind</name><argument_list>(<argument><expr><name>optList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>BldCfg</name></type>
<name>bldCfgParse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storageRepo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// Initialize yaml</comment>
    <decl_stmt><decl><type><name>Yaml</name> <modifier>*</modifier><specifier>const</specifier></type> <name>yaml</name> <init>= <expr><call><name>yamlNew</name><argument_list>(<argument><expr><call><name>storageGetP</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><name>storageRepo</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"src/build/config/config.yaml"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>yamlEventNextCheck</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>yamlEventTypeMapBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Parse configuration</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cmdList</name> <init>= <expr><call><name>bldCfgParseCommandList</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optGrpList</name> <init>= <expr><call><name>bldCfgParseOptionGroupList</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optList</name> <init>= <expr><call><name>bldCfgParseOptionList</name><argument_list>(<argument><expr><name>yaml</name></expr></argument>, <argument><expr><name>cmdList</name></expr></argument>, <argument><expr><name>optGrpList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier><specifier>const</specifier></type> <name>optResolveList</name> <init>= <expr><call><name>bldCfgParseOptionResolveList</name><argument_list>(<argument><expr><name>optList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>(</operator><name>BldCfg</name><operator>)</operator><block>{<expr><operator>.</operator><name>cmdList</name> <operator>=</operator> <name>cmdList</name></expr>, <expr><operator>.</operator><name>optGrpList</name> <operator>=</operator> <name>optGrpList</name></expr>, <expr><operator>.</operator><name>optList</name> <operator>=</operator> <name>optList</name></expr>, <expr><operator>.</operator><name>optResolveList</name> <operator>=</operator> <name>optResolveList</name></expr>}</block></expr>;</return>
</block_content>}</block></function>
</unit>
