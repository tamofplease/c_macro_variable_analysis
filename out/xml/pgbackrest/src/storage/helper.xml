<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/storage/helper.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Storage Helper
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/memContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/regExp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/posix/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/remote/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Storage path constants
***********************************************************************************************************************************/</comment>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_STR</name></expr></argument>,                            <argument><expr><name>STORAGE_SPOOL_ARCHIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_IN_STR</name></expr></argument>,                         <argument><expr><name>STORAGE_SPOOL_ARCHIVE_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>STORAGE_SPOOL_ARCHIVE_OUT_STR</name></expr></argument>,                        <argument><expr><name>STORAGE_SPOOL_ARCHIVE_OUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>STORAGE_REPO_ARCHIVE_STR</name></expr></argument>,                             <argument><expr><name>STORAGE_REPO_ARCHIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>STORAGE_REPO_BACKUP_STR</name></expr></argument>,                              <argument><expr><name>STORAGE_REPO_BACKUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>STORAGE_PATH_ARCHIVE_STR</name></expr></argument>,                             <argument><expr><name>STORAGE_PATH_ARCHIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>STORAGE_PATH_BACKUP_STR</name></expr></argument>,                              <argument><expr><name>STORAGE_PATH_BACKUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Error message when writable storage is requested in dry-run mode
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITABLE_WHILE_DRYRUN</name></cpp:macro>                                                                                                      \
    <cpp:value>"unable to get writable storage in dry-run mode or before dry-run is initialized"</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Local variables
***********************************************************************************************************************************/</comment>
<struct><specifier>static</specifier> struct <name>StorageHelperLocal</name>
<block>{
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>memContext</name></decl>;</decl_stmt>                                         <comment type="line">// Mem context for storage helper</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>StorageHelper</name> <modifier>*</modifier></type><name>helperList</name></decl>;</decl_stmt>                                <comment type="line">// List of helpers to create storage</comment>

    <decl_stmt><decl><type><name>Storage</name> <modifier>*</modifier></type><name>storageLocal</name></decl>;</decl_stmt>                                          <comment type="line">// Local read-only storage</comment>
    <decl_stmt><decl><type><name>Storage</name> <modifier>*</modifier></type><name>storageLocalWrite</name></decl>;</decl_stmt>                                     <comment type="line">// Local write storage</comment>
    <decl_stmt><decl><type><name>Storage</name> <modifier>*</modifier><modifier>*</modifier></type><name>storagePg</name></decl>;</decl_stmt>                                            <comment type="line">// PostgreSQL read-only storage</comment>
    <decl_stmt><decl><type><name>Storage</name> <modifier>*</modifier><modifier>*</modifier></type><name>storagePgWrite</name></decl>;</decl_stmt>                                       <comment type="line">// PostgreSQL write storage</comment>
    <decl_stmt><decl><type><name>Storage</name> <modifier>*</modifier><modifier>*</modifier></type><name>storageRepo</name></decl>;</decl_stmt>                                          <comment type="line">// Repository read-only storage</comment>
    <decl_stmt><decl><type><name>Storage</name> <modifier>*</modifier><modifier>*</modifier></type><name>storageRepoWrite</name></decl>;</decl_stmt>                                     <comment type="line">// Repository write storage</comment>
    <decl_stmt><decl><type><name>Storage</name> <modifier>*</modifier></type><name>storageSpool</name></decl>;</decl_stmt>                                          <comment type="line">// Spool read-only storage</comment>
    <decl_stmt><decl><type><name>Storage</name> <modifier>*</modifier></type><name>storageSpoolWrite</name></decl>;</decl_stmt>                                     <comment type="line">// Spool write storage</comment>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>stanza</name></decl>;</decl_stmt>                                                 <comment type="line">// Stanza for storage</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>stanzaInit</name></decl>;</decl_stmt>                                                <comment type="line">// Has the stanza been initialized?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>dryRunInit</name></decl>;</decl_stmt>                                                <comment type="line">// Has dryRun been initialized?  If not disallow writes.</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>dryRun</name></decl>;</decl_stmt>                                                    <comment type="line">// Disallow writes in dry-run mode.</comment>
    <decl_stmt><decl><type><name>RegExp</name> <modifier>*</modifier></type><name>walRegExp</name></decl>;</decl_stmt>                                              <comment type="line">// Regular expression for identifying wal files</comment>
}</block> <decl><name>storageHelper</name></decl>;</struct>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Create the storage helper memory context
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>storageHelperContextInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>memContext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>memContextTop()</argument>)</argument_list></macro>
        <block>{<block_content>
            <macro><name>MEM_CONTEXT_NEW_BEGIN</name><argument_list>(<argument>StorageHelper</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>, <argument>.allocQty = MEM_CONTEXT_QTY_MAX</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>memContext</name></name> <operator>=</operator> <call><name>MEM_CONTEXT_NEW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type> <name>storageHelperInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>StorageHelper</name> <modifier>*</modifier><specifier>const</specifier></type> <name>helperList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>helperList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>helperList</name></name> <operator>=</operator> <name>helperList</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>storageHelperDryRunInit</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>dryRun</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>dryRunInit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>dryRun</name></name> <operator>=</operator> <name>dryRun</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Initialize the stanza and error if it changes
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>storageHelperStanzaInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>stanzaRequired</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If the stanza is NULL and the storage has not already been initialized then initialize the stanza</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>storageHelper</name><operator>.</operator><name>stanzaInit</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>stanzaRequired</name> <operator>&amp;&amp;</operator> <call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptStanza</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"stanza cannot be NULL for this storage object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>storageHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>stanza</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptStanza</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>stanzaInit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storageLocal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>storageLocal</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>storageHelperContextInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>storageHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>storageLocal</name></name> <operator>=</operator> <call><name>storagePosixNewP</name><argument_list>(<argument><expr><name>FSLASH_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name><name>storageHelper</name><operator>.</operator><name>storageLocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storageLocalWrite</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>storageLocalWrite</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>storageHelperContextInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>storageHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>storageLocalWrite</name></name> <operator>=</operator> <call><name>storagePosixNewP</name><argument_list>(<argument><expr><name>FSLASH_STR</name></expr></argument>, <argument><expr><operator>.</operator><name>write</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name><name>storageHelper</name><operator>.</operator><name>storageLocalWrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get pg storage for the specified host id
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storagePgGet</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgIdx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>write</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Storage</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Use remote storage</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgIsLocal</name><argument_list>(<argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storageRemoteNew</name><argument_list>(
            <argument><expr><name>STORAGE_MODE_FILE_DEFAULT</name></expr></argument>, <argument><expr><name>STORAGE_MODE_PATH_DEFAULT</name></expr></argument>, <argument><expr><name>write</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
            <argument><expr><call><name>protocolRemoteGet</name><argument_list>(<argument><expr><name>protocolStorageTypePg</name></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptCompressLevelNetwork</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Use Posix storage</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storagePosixNewP</name><argument_list>(<argument><expr><call><name>cfgOptionIdxStr</name><argument_list>(<argument><expr><name>cfgOptPgPath</name></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>write</name> <operator>=</operator> <name>write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storagePgIdx</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>storagePg</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>storageHelper</name><operator>.</operator><name>storagePg</name><index>[<expr><name>pgIdx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>storageHelperContextInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>storageHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>storagePg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>storagePg</name></name> <operator>=</operator> <call><name>memNewPtrArray</name><argument_list>(<argument><expr><call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><name>cfgOptGrpPg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>storagePg</name><index>[<expr><name>pgIdx</name></expr>]</index></name> <operator>=</operator> <call><name>storagePgGet</name><argument_list>(<argument><expr><name>pgIdx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name><name>storageHelper</name><operator>.</operator><name>storagePg</name><index>[<expr><name>pgIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storagePg</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><call><name>storagePgIdx</name><argument_list>(<argument><expr><call><name>cfgOptionGroupIdxDefault</name><argument_list>(<argument><expr><name>cfgOptGrpPg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storagePgIdxWrite</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Writes not allowed in dry-run mode</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>storageHelper</name><operator>.</operator><name>dryRunInit</name></name> <operator>||</operator> <name><name>storageHelper</name><operator>.</operator><name>dryRun</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>WRITABLE_WHILE_DRYRUN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>storagePgWrite</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>storageHelper</name><operator>.</operator><name>storagePgWrite</name><index>[<expr><name>pgIdx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>storageHelperContextInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>storageHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>storagePgWrite</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>storagePgWrite</name></name> <operator>=</operator> <call><name>memNewPtrArray</name><argument_list>(<argument><expr><call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><name>cfgOptGrpPg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>storagePgWrite</name><index>[<expr><name>pgIdx</name></expr>]</index></name> <operator>=</operator> <call><name>storagePgGet</name><argument_list>(<argument><expr><name>pgIdx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name><name>storageHelper</name><operator>.</operator><name>storagePgWrite</name><index>[<expr><name>pgIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storagePgWrite</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><call><name>storagePgIdxWrite</name><argument_list>(<argument><expr><call><name>cfgOptionGroupIdxDefault</name><argument_list>(<argument><expr><name>cfgOptGrpPg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Create the WAL regular expression
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>storageHelperRepoInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>walRegExp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>memContextTop()</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>walRegExp</name></name> <operator>=</operator> <call><name>regExpNew</name><argument_list>(<argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"^[0-F]{24}"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Construct a repo path from an expression and path
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>storageRepoPathExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>expression</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>expression</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>STORAGE_REPO_ARCHIVE_STR</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Construct the base path</comment>
        <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>stanza</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>STORAGE_PATH_ARCHIVE</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>storageHelper</name><operator>.</operator><name>stanza</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>STORAGE_PATH_ARCHIVE_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="line">// If a subpath should be appended, determine if it is WAL path, else just append the subpath</comment>
        <if_stmt><if>if <condition>(<expr><name>path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pathSplit</name> <init>= <expr><call><name>strLstNewSplitZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>file</name> <init>= <expr><ternary><condition><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>pathSplit</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>pathSplit</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>file</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>regExpMatch</name><argument_list>(<argument><expr><name><name>storageHelper</name><operator>.</operator><name>walRegExp</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"/%s/%.16s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>pathSplit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><call><name>strLstFree</name><argument_list>(<argument><expr><name>pathSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>STORAGE_REPO_BACKUP_STR</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Construct the base path</comment>
        <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>stanza</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>STORAGE_PATH_BACKUP</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>storageHelper</name><operator>.</operator><name>stanza</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>STORAGE_PATH_BACKUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="line">// Append subpath if provided</comment>
        <if_stmt><if>if <condition>(<expr><name>path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"invalid expression '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the repo storage
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storageRepoGet</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>write</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Storage</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Use remote storage</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>repoIsLocal</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storageRemoteNew</name><argument_list>(
            <argument><expr><name>STORAGE_MODE_FILE_DEFAULT</name></expr></argument>, <argument><expr><name>STORAGE_MODE_PATH_DEFAULT</name></expr></argument>, <argument><expr><name>write</name></expr></argument>, <argument><expr><name>storageRepoPathExpression</name></expr></argument>,
            <argument><expr><call><name>protocolRemoteGet</name><argument_list>(<argument><expr><name>protocolStorageTypeRepo</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptCompressLevelNetwork</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Use local storage</comment>
    <else>else
    <block>{<block_content>
        <comment type="line">// Search for the helper</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringId</name></type> <name>type</name> <init>= <expr><call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoType</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>helperList</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><specifier>const</specifier> <name>StorageHelper</name> <modifier>*</modifier></type><name>helper</name> <init>= <expr><name><name>storageHelper</name><operator>.</operator><name>helperList</name></name></expr></init></decl>;</init> <condition><expr><name><name>helper</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>helper</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>helper</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>type</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>helper</name><operator>-&gt;</operator><name>helper</name></name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>, <argument><expr><name>write</name></expr></argument>, <argument><expr><name>storageRepoPathExpression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// If no helper was found it try Posix</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>STORAGE_POSIX_TYPE</name></expr></argument>, <argument><expr><literal type="string">"invalid storage type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storagePosixNewP</name><argument_list>(
                <argument><expr><call><name>cfgOptionIdxStr</name><argument_list>(<argument><expr><name>cfgOptRepoPath</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>write</name> <operator>=</operator> <name>write</name></expr></argument>, <argument><expr><operator>.</operator><name>pathExpressionFunction</name> <operator>=</operator> <name>storageRepoPathExpression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storageRepoIdx</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>storageRepo</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>storageHelperContextInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>storageHelperStanzaInit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>storageHelperRepoInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>storageHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>storageRepo</name></name> <operator>=</operator> <call><name>memNewPtrArray</name><argument_list>(<argument><expr><call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>storageRepo</name><index>[<expr><name>repoIdx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>storageHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>storageRepo</name><index>[<expr><name>repoIdx</name></expr>]</index></name> <operator>=</operator> <call><name>storageRepoGet</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name><name>storageHelper</name><operator>.</operator><name>storageRepo</name><index>[<expr><name>repoIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storageRepo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><call><name>storageRepoIdx</name><argument_list>(<argument><expr><call><name>cfgOptionGroupIdxDefault</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storageRepoIdxWrite</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Writes not allowed in dry-run mode</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>storageHelper</name><operator>.</operator><name>dryRunInit</name></name> <operator>||</operator> <name><name>storageHelper</name><operator>.</operator><name>dryRun</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>WRITABLE_WHILE_DRYRUN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>storageRepoWrite</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>storageHelperContextInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>storageHelperStanzaInit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>storageHelperRepoInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>storageHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>storageRepoWrite</name></name> <operator>=</operator> <call><name>memNewPtrArray</name><argument_list>(<argument><expr><call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>storageRepoWrite</name><index>[<expr><name>repoIdx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>storageHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>storageRepoWrite</name><index>[<expr><name>repoIdx</name></expr>]</index></name> <operator>=</operator> <call><name>storageRepoGet</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name><name>storageHelper</name><operator>.</operator><name>storageRepoWrite</name><index>[<expr><name>repoIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storageRepoWrite</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><call><name>storageRepoIdxWrite</name><argument_list>(<argument><expr><call><name>cfgOptionGroupIdxDefault</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Spool storage path expression
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>storageSpoolPathExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>expression</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>storageHelper</name><operator>.</operator><name>stanza</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>STORAGE_SPOOL_ARCHIVE</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_PATH_ARCHIVE</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>storageHelper</name><operator>.</operator><name>stanza</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_PATH_ARCHIVE</name> <literal type="string">"/%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>storageHelper</name><operator>.</operator><name>stanza</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>STORAGE_SPOOL_ARCHIVE_IN</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_PATH_ARCHIVE</name> <literal type="string">"/%s/in"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>storageHelper</name><operator>.</operator><name>stanza</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_PATH_ARCHIVE</name> <literal type="string">"/%s/in/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>storageHelper</name><operator>.</operator><name>stanza</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>STORAGE_SPOOL_ARCHIVE_OUT</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_PATH_ARCHIVE</name> <literal type="string">"/%s/out"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>storageHelper</name><operator>.</operator><name>stanza</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><name>STORAGE_PATH_ARCHIVE</name> <literal type="string">"/%s/out/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>storageHelper</name><operator>.</operator><name>stanza</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"invalid expression '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storageSpool</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>storageSpool</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>storageHelperContextInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>storageHelperStanzaInit</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>storageHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>storageSpool</name></name> <operator>=</operator> <call><name>storagePosixNewP</name><argument_list>(
                <argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptSpoolPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>pathExpressionFunction</name> <operator>=</operator> <name>storageSpoolPathExpression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name><name>storageHelper</name><operator>.</operator><name>storageSpool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type>
<name>storageSpoolWrite</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Writes not allowed in dry-run mode</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>storageHelper</name><operator>.</operator><name>dryRunInit</name></name> <operator>||</operator> <name><name>storageHelper</name><operator>.</operator><name>dryRun</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>WRITABLE_WHILE_DRYRUN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>storageSpoolWrite</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>storageHelperContextInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>storageHelperStanzaInit</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>storageHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>storageHelper</name><operator>.</operator><name>storageSpoolWrite</name></name> <operator>=</operator> <call><name>storagePosixNewP</name><argument_list>(
                <argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptSpoolPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>write</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>pathExpressionFunction</name> <operator>=</operator> <name>storageSpoolPathExpression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name><name>storageHelper</name><operator>.</operator><name>storageSpoolWrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>storageHelperFree</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>storageHelper</name><operator>.</operator><name>memContext</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memContextFree</name><argument_list>(<argument><expr><name><name>storageHelper</name><operator>.</operator><name>memContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>storageHelper</name> <operator>=</operator> <operator>(</operator>struct <name>StorageHelperLocal</name><operator>)</operator><block>{<expr><operator>.</operator><name>memContext</name> <operator>=</operator> <name>NULL</name></expr>, <expr><operator>.</operator><name>helperList</name> <operator>=</operator> <name><name>storageHelper</name><operator>.</operator><name>helperList</name></name></expr>}</block></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
