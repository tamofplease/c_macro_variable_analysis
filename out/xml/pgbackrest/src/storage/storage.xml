<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/storage/storage.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Storage Interface
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/memContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/regExp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/wait.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/storage.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Object type
***********************************************************************************************************************************/</comment>
<struct>struct <name>Storage</name>
<block>{
    <decl_stmt><decl><type><name>StoragePub</name></type> <name>pub</name></decl>;</decl_stmt>                                                 <comment type="line">// Publicly accessible variables</comment>
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>memContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mode_t</name></type> <name>modeFile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mode_t</name></type> <name>modePath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>write</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StoragePathExpressionCallback</name> <modifier>*</modifier></type><name>pathExpressionFunction</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Storage</name> <modifier>*</modifier></type>
<name>storageNew</name><parameter_list>(
    <parameter><decl><type><name>StringId</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>modeFile</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>modePath</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>write</name></decl></parameter>,
    <parameter><decl><type><name>StoragePathExpressionCallback</name></type> <name>pathExpressionFunction</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>driver</name></decl></parameter>, <parameter><decl><type><name>StorageInterface</name></type> <name>interface</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name>modeFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name>modePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>FUNCTIONP</name></expr></argument>, <argument><expr><name>pathExpressionFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>driver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_INTERFACE</name></expr></argument>, <argument><expr><name>interface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>type</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>driver</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>interface</name><operator>.</operator><name>info</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>interface</name><operator>.</operator><name>list</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>interface</name><operator>.</operator><name>newRead</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>interface</name><operator>.</operator><name>newWrite</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>interface</name><operator>.</operator><name>pathRemove</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>interface</name><operator>.</operator><name>remove</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Storage</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><operator>(</operator><name>Storage</name> <operator>*</operator><operator>)</operator><call><name>memNew</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Storage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>Storage</name><operator>)</operator>
    <block>{
        <expr><operator>.</operator><name>pub</name> <operator>=</operator>
        <block>{
            <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>type</name></expr>,
            <expr><operator>.</operator><name>driver</name> <operator>=</operator> <name>driver</name></expr>,
            <expr><operator>.</operator><name>interface</name> <operator>=</operator> <name>interface</name></expr>,
        }</block></expr>,
        <expr><operator>.</operator><name>memContext</name> <operator>=</operator> <call><name>memContextCurrent</name><argument_list>()</argument_list></call></expr>,
        <expr><operator>.</operator><name>path</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>,
        <expr><operator>.</operator><name>modeFile</name> <operator>=</operator> <name>modeFile</name></expr>,
        <expr><operator>.</operator><name>modePath</name> <operator>=</operator> <name>modePath</name></expr>,
        <expr><operator>.</operator><name>write</name> <operator>=</operator> <name>write</name></expr>,
        <expr><operator>.</operator><name>pathExpressionFunction</name> <operator>=</operator> <name>pathExpressionFunction</name></expr>,
    }</block></expr>;</expr_stmt>

    <comment type="line">// If path sync feature is enabled then path feature must be enabled</comment>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(
        <argument><expr><name>AssertError</name></expr></argument>, <argument><expr><operator>!</operator><call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeaturePathSync</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeaturePath</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"path feature required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If hardlink feature is enabled then path feature must be enabled</comment>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(
        <argument><expr><name>AssertError</name></expr></argument>, <argument><expr><operator>!</operator><call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeatureHardLink</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeaturePath</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"path feature required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If symlink feature is enabled then path feature must be enabled</comment>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(
        <argument><expr><name>AssertError</name></expr></argument>, <argument><expr><operator>!</operator><call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeatureSymLink</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeaturePath</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><literal type="string">"path feature required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If link features are enabled then linkCreate must be implemented</comment>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(
        <argument><expr><name>AssertError</name></expr></argument>,
        <argument><expr><operator>(</operator><operator>!</operator><call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeatureSymLink</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeatureHardLink</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
            <name><name>interface</name><operator>.</operator><name>linkCreate</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>,
        <argument><expr><literal type="string">"linkCreate required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>storageCopy</name><parameter_list>(<parameter><decl><type><name>StorageRead</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>StorageWrite</name> <modifier>*</modifier></type><name>destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_READ</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_WRITE</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>source</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>destination</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Open source file</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ioReadOpen</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Open the destination file now that we know the source file exists and is readable</comment>
            <expr_stmt><expr><call><name>ioWriteOpen</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Copy data from source to destination</comment>
            <expr_stmt><expr><call><name>ioCopyP</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Close the source and destination files</comment>
            <expr_stmt><expr><call><name>ioReadClose</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ioWriteClose</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Set result to indicate that the file was copied</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>storageExists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pathExp</name></decl></parameter>, <parameter><decl><type><name>StorageExistsParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>TIMEMSEC</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Wait</name> <modifier>*</modifier></type><name>wait</name> <init>= <expr><call><name>waitNew</name><argument_list>(<argument><expr><name><name>param</name><operator>.</operator><name>timeout</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Loop until file exists or timeout</comment>
        <do>do
        <block>{<block_content>
            <comment type="line">// storageInfoLevelBasic is required here because storageInfoLevelExists will not return the type and this function</comment>
            <comment type="line">// specifically wants to test existence of a *file*, not just the existence of anything with the specified name.</comment>
            <decl_stmt><decl><type><name>StorageInfo</name></type> <name>info</name> <init>= <expr><call><name>storageInfoP</name><argument_list>(
                <argument><expr><name>this</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>, <argument><expr><operator>.</operator><name>level</name> <operator>=</operator> <name>storageInfoLevelBasic</name></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>followLink</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Only exists if it is a file</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>exists</name></name> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>storageTypeFile</name></expr>;</expr_stmt>
        </block_content>}</block>
        while <condition>(<expr><operator>!</operator><name>result</name> <operator>&amp;&amp;</operator> <call><name>waitMore</name><argument_list>(<argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Buffer</name> <modifier>*</modifier></type>
<name>storageGet</name><parameter_list>(<parameter><decl><type><name>StorageRead</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>StorageGetParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_READ</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>SIZE</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>exactSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the file exists</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ioReadOpen</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// If exact read</comment>
            <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>exactSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bufNew</name><argument_list>(<argument><expr><name><name>param</name><operator>.</operator><name>exactSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ioRead</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// If an exact read make sure the size is as expected</comment>
                <if_stmt><if>if <condition>(<expr><call><name>bufUsed</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>param</name><operator>.</operator><name>exactSize</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FileReadError</name></expr></argument>, <argument><expr><literal type="string">"unable to read %zu byte(s) from '%s'"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>exactSize</name></name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storageReadName</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else read entire file</comment>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bufNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>read</name> <init>= <expr><call><name>bufNew</name><argument_list>(<argument><expr><call><name>ioBufferSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <do>do
                <block>{<block_content>
                    <comment type="line">// Read data</comment>
                    <expr_stmt><expr><call><name>ioRead</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Add to result and free read buffer</comment>
                    <expr_stmt><expr><call><name>bufCat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>bufUsedZero</name><argument_list>(<argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                while <condition>(<expr><operator>!</operator><call><name>ioReadEof</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
            </block_content>}</block></else></if_stmt>

            <comment type="line">// Move buffer to parent context on success</comment>
            <expr_stmt><expr><call><name>bufMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ioReadClose</name><argument_list>(<argument><expr><call><name>storageReadIo</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BUFFER</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StorageInfo</name></type>
<name>storageInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileExp</name></decl></parameter>, <parameter><decl><type><name>StorageInfoParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>fileExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>ignoreMissing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>followLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>noPathEnforce</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>interface</name><operator>.</operator><name>info</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StorageInfo</name></type> <name>result</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Build the path</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>storagePathP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>fileExp</name></expr></argument>, <argument><expr><operator>.</operator><name>noEnforce</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>noPathEnforce</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Call driver function</comment>
        <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>level</name></name> <operator>==</operator> <name>storageInfoLevelDefault</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>param</name><operator>.</operator><name>level</name></name> <operator>=</operator> <ternary><condition><expr><call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeatureInfoDetail</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>storageInfoLevelDetail</name></expr> </then><else>: <expr><name>storageInfoLevelBasic</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// If file is / then this is definitely a path so skip the call for drivers that do not support paths and do not provide</comment>
        <comment type="line">// additional info to return. Also, some object stores (e.g. S3) behave strangely when getting info for /.</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>FSLASH_STR</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeaturePath</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>StorageInfo</name><operator>)</operator><block>{<expr><operator>.</operator><name>level</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>level</name></name></expr>}</block></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else call the driver</comment>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storageInterfaceInfoP</name><argument_list>(<argument><expr><call><name>storageDriver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>level</name></name></expr></argument>, <argument><expr><operator>.</operator><name>followLink</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>followLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="line">// Error if the file missing and not ignoring</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>.</operator><name>exists</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>param</name><operator>.</operator><name>ignoreMissing</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_SYS_ERROR_FMT</name><argument_list>(<argument><expr><name>FileOpenError</name></expr></argument>, <argument><expr><name>STORAGE_ERROR_INFO_MISSING</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Dup the strings into the prior context</comment>
        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>linkDestination</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>linkDestination</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>user</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>user</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>group</name></name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STORAGE_INFO</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StorageIterator</name> <modifier>*</modifier></type>
<name>storageNewItr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pathExp</name></decl></parameter>, <parameter><decl><type><name>StorageNewItrParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>errorOnMissing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>recurse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>nullOnMissing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>sortOrder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>expression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>recurse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>interface</name><operator>.</operator><name>list</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>param</name><operator>.</operator><name>errorOnMissing</name></name> <operator>||</operator> <call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeaturePath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StorageIterator</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Info level</comment>
        <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>level</name></name> <operator>==</operator> <name>storageInfoLevelDefault</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>param</name><operator>.</operator><name>level</name></name> <operator>=</operator> <ternary><condition><expr><call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeatureInfoDetail</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>storageInfoLevelDetail</name></expr> </then><else>: <expr><name>storageInfoLevelBasic</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storageItrMove</name><argument_list>(
            <argument><expr><call><name>storageItrNew</name><argument_list>(
                <argument><expr><call><name>storageDriver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>level</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>errorOnMissing</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>nullOnMissing</name></name></expr></argument>,
                <argument><expr><name><name>param</name><operator>.</operator><name>recurse</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>sortOrder</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>expression</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STORAGE_ITERATOR</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type> <name>storageLinkCreate</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>target</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>linkPath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StorageLinkCreateParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>linkPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>linkType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>target</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>linkPath</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>interface</name><operator>.</operator><name>linkCreate</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(
        <argument><expr><operator>(</operator><name><name>param</name><operator>.</operator><name>linkType</name></name> <operator>==</operator> <name>storageLinkSym</name> <operator>&amp;&amp;</operator> <call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeatureSymLink</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name><name>param</name><operator>.</operator><name>linkType</name></name> <operator>==</operator> <name>storageLinkHard</name> <operator>&amp;&amp;</operator> <call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeatureHardLink</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>storageInterfaceLinkCreateP</name><argument_list>(<argument><expr><call><name>storageDriver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>linkPath</name></expr></argument>, <argument><expr><operator>.</operator><name>linkType</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>linkType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StringList</name> <modifier>*</modifier></type>
<name>storageList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pathExp</name></decl></parameter>, <parameter><decl><type><name>StorageListParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>errorOnMissing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>nullOnMissing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>expression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>param</name><operator>.</operator><name>errorOnMissing</name></name> <operator>||</operator> <operator>!</operator><name><name>param</name><operator>.</operator><name>nullOnMissing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>StorageIterator</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storageItr</name> <init>= <expr><call><name>storageNewItrP</name><argument_list>(
            <argument><expr><name>this</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>errorOnMissing</name></name></expr></argument>, <argument><expr><operator>.</operator><name>nullOnMissing</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>nullOnMissing</name></name></expr></argument>,
            <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>expression</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>storageItr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strLstNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <while>while <condition>(<expr><call><name>storageItrMore</name><argument_list>(<argument><expr><name>storageItr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>storageItrNext</name><argument_list>(<argument><expr><name>storageItr</name></expr></argument>)</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

            <expr_stmt><expr><call><name>strLstMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>storageMove</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>StorageRead</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>StorageWrite</name> <modifier>*</modifier></type><name>destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_READ</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_WRITE</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>interface</name><operator>.</operator><name>move</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>source</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>destination</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>storageReadIgnoreMissing</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>storageType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>storageReadType</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>storageReadType</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>storageWriteType</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// If the file can't be moved it will need to be copied</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>storageInterfaceMoveP</name><argument_list>(<argument><expr><call><name>storageDriver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Perform the copy</comment>
            <expr_stmt><expr><call><name>storageCopyP</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Remove the source file</comment>
            <expr_stmt><expr><call><name>storageInterfaceRemoveP</name><argument_list>(<argument><expr><call><name>storageDriver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>storageReadName</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Sync source path if the destination path was synced.  We know the source and destination paths are different because</comment>
            <comment type="line">// the move did not succeed.  This will need updating when drivers other than Posix/CIFS are implemented because there's</comment>
            <comment type="line">// no way to get coverage on it now.</comment>
            <if_stmt><if>if <condition>(<expr><call><name>storageWriteSyncPath</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>storageInterfacePathSyncP</name><argument_list>(<argument><expr><call><name>storageDriver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strPath</name><argument_list>(<argument><expr><call><name>storageReadName</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StorageRead</name> <modifier>*</modifier></type>
<name>storageNewRead</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileExp</name></decl></parameter>, <parameter><decl><type><name>StorageNewReadParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>fileExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>ignoreMissing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>compressible</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>param</name><operator>.</operator><name>limit</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>varType</name><argument_list>(<argument><expr><name><name>param</name><operator>.</operator><name>limit</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>varTypeUInt64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StorageRead</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storageReadMove</name><argument_list>(
            <argument><expr><call><name>storageInterfaceNewReadP</name><argument_list>(
                <argument><expr><call><name>storageDriver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>fileExp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>ignoreMissing</name></name></expr></argument>, <argument><expr><operator>.</operator><name>compressible</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>compressible</name></name></expr></argument>,
                <argument><expr><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>.</operator><name>limit</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>limit</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STORAGE_READ</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StorageWrite</name> <modifier>*</modifier></type>
<name>storageNewWrite</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileExp</name></decl></parameter>, <parameter><decl><type><name>StorageNewWriteParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>fileExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>modeFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>modePath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>user</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INT64</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>timeModified</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>noCreatePath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>noSyncFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>noSyncPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>noAtomic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>noTruncate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>compressible</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// noTruncate does not work with atomic writes because a new file is always created for atomic writes</comment>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>param</name><operator>.</operator><name>noTruncate</name></name> <operator>||</operator> <name><name>param</name><operator>.</operator><name>noAtomic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StorageWrite</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storageWriteMove</name><argument_list>(
            <argument><expr><call><name>storageInterfaceNewWriteP</name><argument_list>(
                <argument><expr><call><name>storageDriver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>fileExp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>modeFile</name> <operator>=</operator> <ternary><condition><expr><name><name>param</name><operator>.</operator><name>modeFile</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>param</name><operator>.</operator><name>modeFile</name></name></expr> </then><else>: <expr><name><name>this</name><operator>-&gt;</operator><name>modeFile</name></name></expr></else></ternary></expr></argument>,
                <argument><expr><operator>.</operator><name>modePath</name> <operator>=</operator> <ternary><condition><expr><name><name>param</name><operator>.</operator><name>modePath</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>param</name><operator>.</operator><name>modePath</name></name></expr> </then><else>: <expr><name><name>this</name><operator>-&gt;</operator><name>modePath</name></name></expr></else></ternary></expr></argument>, <argument><expr><operator>.</operator><name>user</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><operator>.</operator><name>group</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>group</name></name></expr></argument>,
                <argument><expr><operator>.</operator><name>timeModified</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>timeModified</name></name></expr></argument>, <argument><expr><operator>.</operator><name>createPath</name> <operator>=</operator> <operator>!</operator><name><name>param</name><operator>.</operator><name>noCreatePath</name></name></expr></argument>, <argument><expr><operator>.</operator><name>syncFile</name> <operator>=</operator> <operator>!</operator><name><name>param</name><operator>.</operator><name>noSyncFile</name></name></expr></argument>,
                <argument><expr><operator>.</operator><name>syncPath</name> <operator>=</operator> <operator>!</operator><name><name>param</name><operator>.</operator><name>noSyncPath</name></name></expr></argument>, <argument><expr><operator>.</operator><name>atomic</name> <operator>=</operator> <operator>!</operator><name><name>param</name><operator>.</operator><name>noAtomic</name></name></expr></argument>, <argument><expr><operator>.</operator><name>truncate</name> <operator>=</operator> <operator>!</operator><name><name>param</name><operator>.</operator><name>noTruncate</name></name></expr></argument>,
                <argument><expr><operator>.</operator><name>compressible</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>compressible</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STORAGE_WRITE</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>storagePath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pathExp</name></decl></parameter>, <parameter><decl><type><name>StoragePathParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>noEnforce</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// If there is no path expression then return the base storage path</comment>
    <if_stmt><if>if <condition>(<expr><name>pathExp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// If the path expression is absolute then use it as is</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Make sure the base storage path is contained within the path expression</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>param</name><operator>.</operator><name>noEnforce</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>strBeginsWith</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <operator>!</operator><operator>(</operator><call><name>strSize</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strSize</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><operator>(</operator><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strSize</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"absolute path '%s' is not in base path '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else path expression is relative so combine it with the base storage path</comment>
        <else>else
        <block>{<block_content>
            <comment type="line">// There may or may not be a path expression that needs to be evaluated</comment>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>pathEvaluated</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Check if there is a path expression that needs to be evaluated</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>pathExpressionFunction</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"expression '%s' not valid without callback function"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Get position of the expression end</comment>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Error if end is not found</comment>
                <if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"end &gt; not found in path expression '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Create a string from the expression</comment>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><call><name>strNewZN</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>end</name> <operator>-</operator> <call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Create a string from the path if there is anything left after the expression</comment>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>strSize</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>strSize</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Error if path separator is not found</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>end</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"'/' should separate expression and path '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="line">// Only create path if there is something after the path separator</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>end</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"path '%s' should not end in '/'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><name>end</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Evaluate the path</comment>
                <expr_stmt><expr><name>pathEvaluated</name> <operator>=</operator> <call><name><name>this</name><operator>-&gt;</operator><name>pathExpressionFunction</name></name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Evaluated path cannot be NULL</comment>
                <if_stmt><if>if <condition>(<expr><name>pathEvaluated</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"evaluated path '%s' cannot be null"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Assign evaluated path to path</comment>
                <expr_stmt><expr><name>pathExp</name> <operator>=</operator> <name>pathEvaluated</name></expr>;</expr_stmt>

                <comment type="line">// Free temp vars</comment>
                <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><name>pathEvaluated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>storagePathCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pathExp</name></decl></parameter>, <parameter><decl><type><name>StoragePathCreateParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>errorOnExists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>noParentCreate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>interface</name><operator>.</operator><name>pathCreate</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeaturePath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Build the path</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>storagePathP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Call driver function</comment>
        <expr_stmt><expr><call><name>storageInterfacePathCreateP</name><argument_list>(
            <argument><expr><call><name>storageDriver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>errorOnExists</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>noParentCreate</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>param</name><operator>.</operator><name>mode</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>param</name><operator>.</operator><name>mode</name></name></expr> </then><else>: <expr><name><name>this</name><operator>-&gt;</operator><name>modePath</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>storagePathExists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pathExp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeaturePath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// storageInfoLevelBasic is required here because storageInfoLevelExists will not return the type and this function specifically</comment>
    <comment type="line">// wants to test existence of a *path*, not just the existence of anything with the specified name.</comment>
    <decl_stmt><decl><type><name>StorageInfo</name></type> <name>info</name> <init>= <expr><call><name>storageInfoP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>, <argument><expr><operator>.</operator><name>level</name> <operator>=</operator> <name>storageInfoLevelBasic</name></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><operator>.</operator><name>followLink</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>exists</name></name> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>storageTypePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>storagePathRemove</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pathExp</name></decl></parameter>, <parameter><decl><type><name>StoragePathRemoveParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>errorOnMissing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>recurse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>param</name><operator>.</operator><name>errorOnMissing</name></name> <operator>||</operator> <call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeaturePath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>param</name><operator>.</operator><name>recurse</name></name> <operator>||</operator> <call><name>storageFeature</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>storageFeaturePath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Build the path</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>storagePathP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Call driver function</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>storageInterfacePathRemoveP</name><argument_list>(<argument><expr><call><name>storageDriver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>recurse</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>param</name><operator>.</operator><name>errorOnMissing</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>PathRemoveError</name></expr></argument>, <argument><expr><name>STORAGE_ERROR_PATH_REMOVE_MISSING</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type> <name>storagePathSync</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>pathExp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Not all storage requires path sync so just do nothing if the function is not implemented</comment>
    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>interface</name><operator>.</operator><name>pathSync</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>storageInterfacePathSyncP</name><argument_list>(<argument><expr><call><name>storageDriver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pathExp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>storagePut</name><parameter_list>(<parameter><decl><type><name>StorageWrite</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_WRITE</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BUFFER</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ioWriteOpen</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ioWrite</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ioWriteClose</name><argument_list>(<argument><expr><call><name>storageWriteIo</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>storageRemove</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>fileExp</name></decl></parameter>, <parameter><decl><type><name>StorageRemoveParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>fileExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>errorOnMissing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Build the path</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>storagePathP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>fileExp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Call driver function</comment>
        <expr_stmt><expr><call><name>storageInterfaceRemoveP</name><argument_list>(<argument><expr><call><name>storageDriver</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name><name>param</name><operator>.</operator><name>errorOnMissing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>storageToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strNewFmt</name><argument_list>(
        <argument><expr><literal type="string">"{type: %s, path: %s, write: %s}"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><call><name>storageType</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strToLog</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>cvtBoolToConstZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
