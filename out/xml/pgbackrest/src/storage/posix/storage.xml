<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/storage/posix/storage.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Posix Storage
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/regExp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/posix/read.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/posix/storage.intern.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/posix/write.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Define PATH_MAX if it is not defined
***********************************************************************************************************************************/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PATH_MAX</name></cpp:ifndef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_MAX</name></cpp:macro>                                                <cpp:value>(4 * 1024)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Object type
***********************************************************************************************************************************/</comment>
<struct>struct <name>StoragePosix</name>
<block>{
    <expr_stmt><expr><name>STORAGE_COMMON_MEMBER</name></expr>;</expr_stmt>
}</block>;</struct>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>StorageInfo</name></type>
<name>storagePosixInfo</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>StorageInfoLevel</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>StorageInterfaceInfoParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>StoragePosix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_POSIX</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>followLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StorageInfo</name></type> <name>result</name> <init>= <expr><block>{<expr><operator>.</operator><name>level</name> <operator>=</operator> <name>level</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <comment type="line">// Stat the file to check if it exists</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statFile</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name><name>param</name><operator>.</operator><name>followLink</name></name></expr> ?</condition><then> <expr><call><name>stat</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>statFile</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>lstat</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>statFile</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>                                                                                        <comment type="line">// {vm_covered}</comment>
            <expr_stmt><expr><call><name>THROW_SYS_ERROR_FMT</name><argument_list>(<argument><expr><name>FileOpenError</name></expr></argument>, <argument><expr><name>STORAGE_ERROR_INFO</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>                                     <comment type="line">// {vm_covered}</comment>
    </block_content>}</block></if>
    <comment type="line">// On success the file exists</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>exists</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="line">// Add type info (no need set file type since it is the default)</comment>
        <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>level</name></name> <operator>&gt;=</operator> <name>storageInfoLevelType</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statFile</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statFile</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>storageTypePath</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>statFile</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>storageTypeLink</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>storageTypeSpecial</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Add basic level info</comment>
        <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>level</name></name> <operator>&gt;=</operator> <name>storageInfoLevelBasic</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>timeModified</name></name> <operator>=</operator> <name><name>statFile</name><operator>.</operator><name>st_mtime</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>storageTypeFile</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>size</name></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>statFile</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Add detail level info</comment>
        <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>level</name></name> <operator>&gt;=</operator> <name>storageInfoLevelDetail</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <name><name>statFile</name><operator>.</operator><name>st_gid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>group</name></name> <operator>=</operator> <call><name>groupNameFromId</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>userId</name></name> <operator>=</operator> <name><name>statFile</name><operator>.</operator><name>st_uid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>user</name></name> <operator>=</operator> <call><name>userNameFromId</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>userId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name><name>statFile</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IRWXU</name> <operator>|</operator> <name>S_IRWXG</name> <operator>|</operator> <name>S_IRWXO</name><operator>)</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>storageTypeLink</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name></type> <name><name>linkDestination</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ssize_t</name></type> <name>linkDestinationSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR_FMT</name><argument_list>(
                    <argument><expr><operator>(</operator><name>linkDestinationSize</name> <operator>=</operator> <call><name>readlink</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>linkDestination</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>linkDestination</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>,
                    <argument><expr><name>FileReadError</name></expr></argument>, <argument><expr><literal type="string">"unable to get destination for link '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>linkDestination</name></name> <operator>=</operator> <call><name>strNewZN</name><argument_list>(<argument><expr><name>linkDestination</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>linkDestinationSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STORAGE_INFO</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>storagePosixLinkCreate</name><parameter_list>(
    <parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>target</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>linkPath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StorageInterfaceLinkCreateParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>StoragePosix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_POSIX</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>linkPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>linkType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>target</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>linkPath</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Create symlink</comment>
    <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>linkType</name></name> <operator>==</operator> <name>storageLinkSym</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR_FMT</name><argument_list>(
            <argument><expr><call><name>symlink</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>linkPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>FileOpenError</name></expr></argument>, <argument><expr><literal type="string">"unable to create symlink '%s' to '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>linkPath</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="line">// Else create hardlink</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>param</name><operator>.</operator><name>linkType</name></name> <operator>==</operator> <name>storageLinkHard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR_FMT</name><argument_list>(
            <argument><expr><call><name>link</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>linkPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>FileOpenError</name></expr></argument>, <argument><expr><literal type="string">"unable to create hardlink '%s' to '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>linkPath</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<comment type="line">// Helper function to get info for a file if it exists. This logic can't live directly in storagePosixList() because there is a race</comment>
<comment type="line">// condition where a file might exist while listing the directory but it is gone before stat() can be called. In order to get</comment>
<comment type="line">// complete test coverage this function must be split out.</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>storagePosixListEntry</name><parameter_list>(
    <parameter><decl><type><name>StoragePosix</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><name>StorageList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>name</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>StorageInfoLevel</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STORAGE_POSIX</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STORAGE_LIST</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>list</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>path</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StorageInfo</name></type> <name>info</name> <init>= <expr><call><name>storageInterfaceInfoP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>exists</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>info</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>STR</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>storageLstAdd</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>StorageList</name> <modifier>*</modifier></type>
<name>storagePosixList</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StorageInfoLevel</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StorageInterfaceListParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>StoragePosix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_POSIX</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>param</name></expr>;</expr_stmt>                                                <comment type="line">// No parameters are used</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>path</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StorageList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Open the directory for read</comment>
    <decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dir</name> <init>= <expr><call><name>opendir</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the directory could not be opened process errors and report missing directories</comment>
    <if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>                                                                                        <comment type="line">// {vm_covered}</comment>
            <expr_stmt><expr><call><name>THROW_SYS_ERROR_FMT</name><argument_list>(<argument><expr><name>PathOpenError</name></expr></argument>, <argument><expr><name>STORAGE_ERROR_LIST_INFO</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>                                <comment type="line">// {vm_covered}</comment>
    </block_content>}</block></if>
    <comment type="line">// Directory was found</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storageLstNew</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <macro><name>MEM_CONTEXT_TEMP_RESET_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// Read the directory entries</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dirEntry</name> <init>= <expr><call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <while>while <condition>(<expr><name>dirEntry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Always skip . and ..</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEqZ</name><argument_list>(<argument><expr><name>DOT_STR</name></expr></argument>, <argument><expr><name><name>dirEntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strEqZ</name><argument_list>(<argument><expr><name>DOTDOT_STR</name></expr></argument>, <argument><expr><name><name>dirEntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="line">// If only making a list of files that exist then no need to go get detailed info which requires calling</comment>
                        <comment type="line">// stat() and is therefore relatively slow</comment>
                        <if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <name>storageInfoLevelExists</name></expr>)</condition>
                        <block>{<block_content>
                            <macro><name>storageLstAdd</name><argument_list>(
                                <argument>result</argument>,
                                <argument>&amp;(StorageInfo)
                                {
                                    .name = STR(dirEntry-&gt;d_name)</argument>,
                                    <argument>.level = storageInfoLevelExists</argument>,
                                    <argument>.exists = true</argument>,
                                <argument>}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                        </block_content>}</block></if>
                        <comment type="line">// Else more info is required which requires a call to stat()</comment>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>storagePosixListEntry</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>dirEntry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Get next entry</comment>
                    <expr_stmt><expr><name>dirEntry</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="line">// Reset the memory context occasionally so we don't use too much memory or slow down processing</comment>
                    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_RESET</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></while>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <macro><name>FINALLY</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STORAGE_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>storagePosixMove</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>, <parameter><decl><type><name>StorageRead</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>StorageWrite</name> <modifier>*</modifier></type><name>destination</name></decl></parameter>, <parameter><decl><type><name>StorageInterfaceMoveParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>StoragePosix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_POSIX</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_READ</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_WRITE</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>param</name></expr>;</expr_stmt>                                                <comment type="line">// No parameters are used</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>source</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>destination</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>sourceFile</name> <init>= <expr><call><name>storageReadName</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>destinationFile</name> <init>= <expr><call><name>storageWriteName</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>destinationPath</name> <init>= <expr><call><name>strPath</name><argument_list>(<argument><expr><name>destinationFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Attempt to move the file</comment>
        <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>sourceFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>destinationFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// Determine which file/path is missing</comment>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Check if the source is missing. Rename does not follow links so there is no need to set followLink.</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>storageInterfaceInfoP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>sourceFile</name></expr></argument>, <argument><expr><name>storageInfoLevelExists</name></expr></argument>)</argument_list></call><operator>.</operator><name>exists</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_SYS_ERROR_FMT</name><argument_list>(<argument><expr><name>FileMissingError</name></expr></argument>, <argument><expr><literal type="string">"unable to move missing source '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>sourceFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>storageWriteCreatePath</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_SYS_ERROR_FMT</name><argument_list>(
                        <argument><expr><name>PathMissingError</name></expr></argument>, <argument><expr><literal type="string">"unable to move '%s' to missing path '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>sourceFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>destinationPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>storageInterfacePathCreateP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>destinationPath</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><call><name>storageWriteModePath</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storageInterfaceMoveP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else the destination is on a different device so a copy will be needed</comment>
            <if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EXDEV</name></expr>)</condition>                                                                                <comment type="line">// {vm_covered}</comment>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>THROW_SYS_ERROR_FMT</name><argument_list>(                                                                                <comment type="line">// {vm_covered}</comment>
                    <argument><expr><name>FileMoveError</name></expr></argument>, <argument><expr><literal type="string">"unable to move '%s' to '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>sourceFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>destinationFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <comment type="line">// {vm_covered}</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <comment type="line">// Sync paths on success</comment>
        <else>else
        <block>{<block_content>
            <comment type="line">// Sync source path if the destination path was synced and the paths are not equal</comment>
            <if_stmt><if>if <condition>(<expr><call><name>storageWriteSyncPath</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>sourcePath</name> <init>= <expr><call><name>strPath</name><argument_list>(<argument><expr><name>sourceFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEq</name><argument_list>(<argument><expr><name>destinationPath</name></expr></argument>, <argument><expr><name>sourcePath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>storageInterfacePathSyncP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>sourcePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>StorageRead</name> <modifier>*</modifier></type>
<name>storagePosixNewRead</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignoreMissing</name></decl></parameter>, <parameter><decl><type><name>StorageInterfaceNewReadParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>StoragePosix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_POSIX</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>ignoreMissing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>VARIANT</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STORAGE_READ</name></expr></argument>, <argument><expr><call><name>storageReadPosixNew</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>ignoreMissing</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>limit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>StorageWrite</name> <modifier>*</modifier></type>
<name>storagePosixNewWrite</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>StorageInterfaceNewWriteParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>StoragePosix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_POSIX</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>modeFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>modePath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>user</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>TIME</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>timeModified</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>createPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>syncFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>syncPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>atomic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>truncate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(
        <argument><expr><name>STORAGE_WRITE</name></expr></argument>,
        <argument><expr><call><name>storageWritePosixNew</name><argument_list>(
            <argument><expr><name>this</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>modeFile</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>modePath</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>group</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>timeModified</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>createPath</name></name></expr></argument>,
            <argument><expr><name><name>param</name><operator>.</operator><name>syncFile</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>this</name><operator>-&gt;</operator><name>interface</name><operator>.</operator><name>pathSync</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>param</name><operator>.</operator><name>syncPath</name></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>atomic</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>truncate</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>storagePosixPathCreate</name><parameter_list>(
    <parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>errorOnExists</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>noParentCreate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>mode_t</name></type> <name>mode</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>StorageInterfacePathCreateParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>StoragePosix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_POSIX</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>errorOnExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>noParentCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>param</name></expr>;</expr_stmt>                                                <comment type="line">// No parameters are used</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>path</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Attempt to create the directory</comment>
    <if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// If the parent path does not exist then create it if allowed</comment>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>noParentCreate</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pathParent</name> <init>= <expr><call><name>strPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>storageInterfacePathCreateP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>pathParent</name></expr></argument>, <argument><expr><name>errorOnExists</name></expr></argument>, <argument><expr><name>noParentCreate</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>storageInterfacePathCreateP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>errorOnExists</name></expr></argument>, <argument><expr><name>noParentCreate</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>strFree</name><argument_list>(<argument><expr><name>pathParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Ignore path exists if allowed</comment>
        <if type="elseif">else if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EEXIST</name> <operator>||</operator> <name>errorOnExists</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_SYS_ERROR_FMT</name><argument_list>(<argument><expr><name>PathCreateError</name></expr></argument>, <argument><expr><literal type="string">"unable to create path '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>storagePosixPathRemove</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>StorageInterfacePathRemoveParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>StoragePosix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_POSIX</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>param</name></expr>;</expr_stmt>                                                <comment type="line">// No parameters are used</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>path</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Recurse if requested</comment>
        <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StorageList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>list</name> <init>= <expr><call><name>storageInterfaceListP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>storageInfoLevelExists</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>list</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <macro><name>MEM_CONTEXT_TEMP_RESET_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>listIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>listIdx</name> <operator>&lt;</operator> <call><name>storageLstSize</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>listIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>file</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storageLstGet</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>listIdx</name></expr></argument>)</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Rather than stat the file to discover what type it is, just try to unlink it and see what happens</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>                                                               <comment type="line">// {vm_covered}</comment>
                        <block>{<block_content>
                            <comment type="line">// These errors indicate that the entry is actually a path so we'll try to delete it that way</comment>
                            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EPERM</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EISDIR</name></expr>)</condition>               <comment type="line">// {uncovered_branch - no EPERM on tested systems}</comment>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>storageInterfacePathRemoveP</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <comment type="line">// Else error</comment>
                            <else>else<block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>THROW_SYS_ERROR_FMT</name><argument_list>(<argument><expr><name>PathRemoveError</name></expr></argument>, <argument><expr><name>STORAGE_ERROR_PATH_REMOVE_FILE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>   <comment type="line">// {vm_covered}</comment>
                        </block_content>}</block></if></if_stmt>

                        <comment type="line">// Reset the memory context occasionally so we don't use too much memory or slow down processing</comment>
                        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_RESET</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Delete the path</comment>
        <if_stmt><if>if <condition>(<expr><call><name>rmdir</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>                                                                                    <comment type="line">// {vm_covered}</comment>
                <expr_stmt><expr><call><name>THROW_SYS_ERROR_FMT</name><argument_list>(<argument><expr><name>PathRemoveError</name></expr></argument>, <argument><expr><name>STORAGE_ERROR_PATH_REMOVE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>                        <comment type="line">// {vm_covered}</comment>

            <comment type="line">// Path does not exist</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>storagePosixPathSync</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>StorageInterfacePathSyncParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>StoragePosix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_POSIX</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>param</name></expr>;</expr_stmt>                                                <comment type="line">// No parameters are used</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>path</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Open directory and handle errors</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Handle errors</comment>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>                                                                                        <comment type="line">// {vm_covered}</comment>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>PathMissingError</name></expr></argument>, <argument><expr><name>STORAGE_ERROR_PATH_SYNC_MISSING</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW_SYS_ERROR_FMT</name><argument_list>(<argument><expr><name>PathOpenError</name></expr></argument>, <argument><expr><name>STORAGE_ERROR_PATH_SYNC_OPEN</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>                           <comment type="line">// {vm_covered}</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// Attempt to sync the directory</comment>
        <if_stmt><if>if <condition>(<expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>errNo</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Close the file descriptor to free resources but don't check for failure</comment>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>THROW_SYS_ERROR_CODE_FMT</name><argument_list>(<argument><expr><name>errNo</name></expr></argument>, <argument><expr><name>PathSyncError</name></expr></argument>, <argument><expr><name>STORAGE_ERROR_PATH_SYNC</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>THROW_ON_SYS_ERROR_FMT</name><argument_list>(<argument><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>PathCloseError</name></expr></argument>, <argument><expr><name>STORAGE_ERROR_PATH_SYNC_CLOSE</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>storagePosixRemove</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>StorageInterfaceRemoveParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>StoragePosix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE_POSIX</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>errorOnMissing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Attempt to unlink the file</comment>
    <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>errorOnMissing</name></name> <operator>||</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>                                                                <comment type="line">// {vm_covered}</comment>
            <expr_stmt><expr><call><name>THROW_SYS_ERROR_FMT</name><argument_list>(<argument><expr><name>FileRemoveError</name></expr></argument>, <argument><expr><literal type="string">"unable to remove '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>                              <comment type="line">// {vm_covered}</comment>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>StorageInterface</name></type> <name>storageInterfacePosix</name> <init>=
<expr><block>{
    <expr><operator>.</operator><name>feature</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>storageFeaturePath</name></expr>,

    <expr><operator>.</operator><name>info</name> <operator>=</operator> <name>storagePosixInfo</name></expr>,
    <expr><operator>.</operator><name>linkCreate</name> <operator>=</operator> <name>storagePosixLinkCreate</name></expr>,
    <expr><operator>.</operator><name>list</name> <operator>=</operator> <name>storagePosixList</name></expr>,
    <expr><operator>.</operator><name>move</name> <operator>=</operator> <name>storagePosixMove</name></expr>,
    <expr><operator>.</operator><name>newRead</name> <operator>=</operator> <name>storagePosixNewRead</name></expr>,
    <expr><operator>.</operator><name>newWrite</name> <operator>=</operator> <name>storagePosixNewWrite</name></expr>,
    <expr><operator>.</operator><name>pathCreate</name> <operator>=</operator> <name>storagePosixPathCreate</name></expr>,
    <expr><operator>.</operator><name>pathRemove</name> <operator>=</operator> <name>storagePosixPathRemove</name></expr>,
    <expr><operator>.</operator><name>pathSync</name> <operator>=</operator> <name>storagePosixPathSync</name></expr>,
    <expr><operator>.</operator><name>remove</name> <operator>=</operator> <name>storagePosixRemove</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>Storage</name> <modifier>*</modifier></type>
<name>storagePosixNewInternal</name><parameter_list>(
    <parameter><decl><type><name>StringId</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>modeFile</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>modePath</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>write</name></decl></parameter>,
    <parameter><decl><type><name>StoragePathExpressionCallback</name></type> <name>pathExpressionFunction</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pathSync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name>modeFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name>modePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>FUNCTIONP</name></expr></argument>, <argument><expr><name>pathExpressionFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>pathSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>type</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>path</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>modeFile</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>modePath</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Initialize user module</comment>
    <expr_stmt><expr><call><name>userInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Create the object</comment>
    <decl_stmt><decl><type><name>Storage</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>StoragePosix</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>, <argument>.allocQty = MEM_CONTEXT_QTY_MAX</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>StoragePosix</name> <modifier>*</modifier></type><name>driver</name> <init>= <expr><call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><operator>*</operator><name>driver</name> <operator>=</operator> <operator>(</operator><name>StoragePosix</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>interface</name> <operator>=</operator> <name>storageInterfacePosix</name></expr>,
        }</block></expr>;</expr_stmt>

        <comment type="line">// Disable path sync when not supported</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pathSync</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>driver</name><operator>-&gt;</operator><name>interface</name><operator>.</operator><name>pathSync</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// If this is a posix driver then add link features</comment>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>STORAGE_POSIX_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>driver</name><operator>-&gt;</operator><name>interface</name><operator>.</operator><name>feature</name></name> <operator>|=</operator>
                <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>storageFeatureHardLink</name> <operator>|</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>storageFeatureSymLink</name> <operator>|</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>storageFeaturePathSync</name> <operator>|</operator>
                <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>storageFeatureInfoDetail</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>storageNew</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>modeFile</name></expr></argument>, <argument><expr><name>modePath</name></expr></argument>, <argument><expr><name>write</name></expr></argument>, <argument><expr><name>pathExpressionFunction</name></expr></argument>, <argument><expr><name>driver</name></expr></argument>, <argument><expr><name><name>driver</name><operator>-&gt;</operator><name>interface</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Storage</name> <modifier>*</modifier></type>
<name>storagePosixNew</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>StoragePosixNewParam</name></type> <name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>modeFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>MODE</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>modePath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>FUNCTIONP</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>pathExpressionFunction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(
        <argument><expr><name>STORAGE</name></expr></argument>,
        <argument><expr><call><name>storagePosixNewInternal</name><argument_list>(
            <argument><expr><name>STORAGE_POSIX_TYPE</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>param</name><operator>.</operator><name>modeFile</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>STORAGE_MODE_FILE_DEFAULT</name></expr> </then><else>: <expr><name><name>param</name><operator>.</operator><name>modeFile</name></name></expr></else></ternary></expr></argument>,
            <argument><expr><ternary><condition><expr><name><name>param</name><operator>.</operator><name>modePath</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>STORAGE_MODE_PATH_DEFAULT</name></expr> </then><else>: <expr><name><name>param</name><operator>.</operator><name>modePath</name></name></expr></else></ternary></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>write</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>pathExpressionFunction</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
