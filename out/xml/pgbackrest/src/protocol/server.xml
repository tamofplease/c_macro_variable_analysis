<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/protocol/server.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Protocol Server
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/keyValue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Object type
***********************************************************************************************************************************/</comment>
<struct>struct <name>ProtocolServer</name>
<block>{
    <decl_stmt><decl><type><name>IoRead</name> <modifier>*</modifier></type><name>read</name></decl>;</decl_stmt>                                                   <comment type="line">// Read interface</comment>
    <decl_stmt><decl><type><name>IoWrite</name> <modifier>*</modifier></type><name>write</name></decl>;</decl_stmt>                                                 <comment type="line">// Write interface</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>                                             <comment type="line">// Name displayed in logging</comment>
}</block>;</struct>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>ProtocolServer</name> <modifier>*</modifier></type>
<name>protocolServerNew</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>service</name></decl></parameter>, <parameter><decl><type><name>IoRead</name> <modifier>*</modifier></type><name>read</name></decl></parameter>, <parameter><decl><type><name>IoWrite</name> <modifier>*</modifier></type><name>write</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>service</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>IO_READ</name></expr></argument>, <argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>IO_WRITE</name></expr></argument>, <argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>read</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>write</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ProtocolServer</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>ProtocolServer</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>ProtocolServer</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>read</name> <operator>=</operator> <name>read</name></expr>,
            <expr><operator>.</operator><name>write</name> <operator>=</operator> <name>write</name></expr>,
            <expr><operator>.</operator><name>name</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>,
        }</block></expr>;</expr_stmt>

        <comment type="line">// Send the protocol greeting</comment>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>JsonWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>json</name> <init>= <expr><call><name>jsonWriteObjectBegin</name><argument_list>(<argument><expr><call><name>jsonWriteNewP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>jsonWriteZ</name><argument_list>(<argument><expr><call><name>jsonWriteKeyStrId</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>PROTOCOL_GREETING_NAME</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PROJECT_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteStr</name><argument_list>(<argument><expr><call><name>jsonWriteKeyStrId</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>PROTOCOL_GREETING_SERVICE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>service</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonWriteZ</name><argument_list>(<argument><expr><call><name>jsonWriteKeyStrId</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>PROTOCOL_GREETING_VERSION</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PROJECT_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ioWriteStrLine</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>, <argument><expr><call><name>jsonWriteResult</name><argument_list>(<argument><expr><call><name>jsonWriteObjectEnd</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ioWriteFlush</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PROTOCOL_SERVER</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>protocolServerError</name><parameter_list>(<parameter><decl><type><name>ProtocolServer</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>message</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_SERVER</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>INT</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>code</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>message</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>stack</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Write the error and flush to be sure it gets sent immediately</comment>
        <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>pckWriteNewIo</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>protocolMessageTypeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pckWriteI32P</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pckWriteEndP</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ioWriteFlush</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>ProtocolServerCommandGetResult</name></type>
<name>protocolServerCommandGet</name><parameter_list>(<parameter><decl><type><name>ProtocolServer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_SERVER</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ProtocolServerCommandGetResult</name></type> <name>result</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>command</name> <init>= <expr><call><name>pckReadNewIo</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>read</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ProtocolMessageType</name></type> <name>type</name> <init>= <expr><operator>(</operator><name>ProtocolMessageType</name><operator>)</operator><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>protocolMessageTypeCommand</name></expr></argument>, <argument><expr><literal type="string">"expected command message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>id</name></name> <operator>=</operator> <call><name>pckReadStrIdP</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>.</operator><name>param</name></name> <operator>=</operator> <call><name>pckReadPackP</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pckReadEndP</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_STRUCT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>protocolServerProcess</name><parameter_list>(
    <parameter><decl><type><name>ProtocolServer</name> <modifier>*</modifier></type><name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VariantList</name> <modifier>*</modifier></type><name>retryInterval</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProtocolServerHandler</name> <modifier>*</modifier><specifier>const</specifier></type> <name>handlerList</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>handlerListSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_SERVER</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>VARIANT_LIST</name></expr></argument>, <argument><expr><name>retryInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>handlerList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>handlerListSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>handlerList</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>handlerListSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Loop until exit command is received</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>exit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <do>do
    <block>{<block_content>
        <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// Get command</comment>
                <decl_stmt><decl><type><name>ProtocolServerCommandGetResult</name></type> <name>command</name> <init>= <expr><call><name>protocolServerCommandGet</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Find the handler</comment>
                <decl_stmt><decl><type><name>ProtocolServerCommandHandler</name></type> <name>handler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>handlerIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>handlerIdx</name> <operator>&lt;</operator> <name>handlerListSize</name></expr>;</condition> <incr><expr><name>handlerIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>command</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name><name>handlerList</name><index>[<expr><name>handlerIdx</name></expr>]</index></name><operator>.</operator><name>command</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>handler</name> <operator>=</operator> <name><name>handlerList</name><index>[<expr><name>handlerIdx</name></expr>]</index></name><operator>.</operator><name>handler</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="line">// If handler was found then process</comment>
                <if_stmt><if>if <condition>(<expr><name>handler</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="line">// Send the command to the handler</comment>
                    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
                    <block>{<block_content>
                        <comment type="line">// Variables to store first error message and retry messages</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>ErrorType</name> <modifier>*</modifier></type><name>errType</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>errMessage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>errMessageFirst</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>errStackTrace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Initialize retries in case of command failure</comment>
                        <decl_stmt><decl><type><name>bool</name></type> <name>retry</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>retryRemaining</name> <init>= <expr><ternary><condition><expr><name>retryInterval</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>varLstSize</name><argument_list>(<argument><expr><name>retryInterval</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>TimeMSec</name></type> <name>retrySleepMs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Handler retry loop</comment>
                        <do>do
                        <block>{<block_content>
                            <expr_stmt><expr><name>retry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>handler</name><argument_list>(<argument><expr><call><name>pckReadNew</name><argument_list>(<argument><expr><name><name>command</name><operator>.</operator><name>param</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block>
                            <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
                            <block>{<block_content>
                                <comment type="line">// On first error record the error details. Only the first error will contain a stack trace since</comment>
                                <comment type="line">// the first error is most likely to contain valuable information.</comment>
                                <if_stmt><if>if <condition>(<expr><name>errType</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>errType</name> <operator>=</operator> <call><name>errorType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>errMessage</name> <operator>=</operator> <call><name>strCatZ</name><argument_list>(<argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>errMessageFirst</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>errStackTrace</name> <operator>=</operator> <call><name>strNewZ</name><argument_list>(<argument><expr><call><name>errorStackTrace</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <comment type="line">// Else on a retry error only record the error type and message. Retry errors are less likely to</comment>
                                <comment type="line">// contain valuable information but may be helpful for debugging.</comment>
                                <else>else
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                                        <argument><expr><name>errMessage</name></expr></argument>, <argument><expr><literal type="string">"\n[%s] on retry after %"</literal> <name>PRIu64</name> <literal type="string">"ms"</literal></expr></argument>, <argument><expr><call><name>errorTypeName</name><argument_list>(<argument><expr><call><name>errorType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>retrySleepMs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <comment type="line">// Only append the message if it differs from the first message</comment>
                                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEqZ</name><argument_list>(<argument><expr><name>errMessageFirst</name></expr></argument>, <argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>errMessage</name></expr></argument>, <argument><expr><literal type="string">": %s"</literal></expr></argument>, <argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                                </block_content>}</block></else></if_stmt>

                                <comment type="line">// Are there retries remaining?</comment>
                                <if_stmt><if>if <condition>(<expr><name>retryRemaining</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="line">// Get the sleep interval for this retry</comment>
                                    <expr_stmt><expr><name>retrySleepMs</name> <operator>=</operator> <call><name>varUInt64</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>retryInterval</name></expr></argument>, <argument><expr><call><name>varLstSize</name><argument_list>(<argument><expr><name>retryInterval</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>retryRemaining</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <comment type="line">// Log the retry</comment>
                                    <expr_stmt><expr><call><name>LOG_DEBUG_FMT</name><argument_list>(
                                        <argument><expr><literal type="string">"retry %s after %"</literal> <name>PRIu64</name> <literal type="string">"ms: %s"</literal></expr></argument>, <argument><expr><call><name>errorTypeName</name><argument_list>(<argument><expr><call><name>errorType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>retrySleepMs</name></expr></argument>,
                                        <argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <comment type="line">// Sleep for interval</comment>
                                    <expr_stmt><expr><call><name>sleepMSec</name><argument_list>(<argument><expr><name>retrySleepMs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <comment type="line">// Decrement retries remaining and retry</comment>
                                    <expr_stmt><expr><name>retryRemaining</name><operator>--</operator></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>retry</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                                    <comment type="line">// Send keep-alive to remotes. A retry means the command is taking longer than usual so make</comment>
                                    <comment type="line">// sure the remote does not timeout.</comment>
                                    <expr_stmt><expr><call><name>protocolKeepAlive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <comment type="line">// Else report error to the client</comment>
                                <else>else<block type="pseudo"><block_content>
                                    <expr_stmt><expr><call><name>protocolServerError</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>errorTypeCode</name><argument_list>(<argument><expr><name>errType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>errMessage</name></expr></argument>, <argument><expr><name>errStackTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                            </block_content>}</block>
                            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        while <condition>(<expr><name>retry</name></expr>)</condition>;</do>
                    </block_content>}</block>
                    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else check built-in commands</comment>
                <else>else
                <block>{<block_content>
                    <switch>switch <condition>(<expr><name><name>command</name><operator>.</operator><name>id</name></name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>PROTOCOL_COMMAND_EXIT</name></expr>:</case>
                            <expr_stmt><expr><name>exit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <break>break;</break>

                        <case>case <expr><name>PROTOCOL_COMMAND_NOOP</name></expr>:</case>
                            <expr_stmt><expr><call><name>protocolServerDataEndPut</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>

                        <default>default:</default>
                            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                <argument><expr><name>ProtocolError</name></expr></argument>, <argument><expr><literal type="string">"invalid command '%s' (0x%"</literal> <name>PRIx64</name> <literal type="string">")"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name><name>command</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>command</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></switch>
                </block_content>}</block></else></if_stmt>

                <comment type="line">// Send keep-alive to remotes. When a local process is doing work that does not involve the remote it is important</comment>
                <comment type="line">// that the remote does not timeout.  This will send a keep alive once per unit of work that is performed by the</comment>
                <comment type="line">// local process.</comment>
                <expr_stmt><expr><call><name>protocolKeepAlive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <macro><name>CATCH_FATAL</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// Report error to the client</comment>
            <expr_stmt><expr><call><name>protocolServerError</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>errorCode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>errorStackTrace</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Rethrow so the process exits with an error</comment>
            <expr_stmt><expr><call><name>RETHROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    while <condition>(<expr><operator>!</operator><name>exit</name></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>PackRead</name> <modifier>*</modifier></type>
<name>protocolServerDataGet</name><parameter_list>(<parameter><decl><type><name>ProtocolServer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_SERVER</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>pckReadNewIo</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>read</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ProtocolMessageType</name></type> <name>type</name> <init>= <expr><operator>(</operator><name>ProtocolMessageType</name><operator>)</operator><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>protocolMessageTypeData</name></expr></argument>, <argument><expr><literal type="string">"expected data message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pckReadPackReadP</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pckReadEndP</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PACK_READ</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>protocolServerDataPut</name><parameter_list>(<parameter><decl><type><name>ProtocolServer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><name>PackWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_SERVER</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PACK_WRITE</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// End the pack</comment>
        <if_stmt><if>if <condition>(<expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pckWriteEndP</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Write the result</comment>
        <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier></type><name>resultMessage</name> <init>= <expr><call><name>pckWriteNewIo</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>resultMessage</name></expr></argument>, <argument><expr><name>protocolMessageTypeData</name></expr></argument>, <argument><expr><operator>.</operator><name>defaultWrite</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pckWritePackP</name><argument_list>(<argument><expr><name>resultMessage</name></expr></argument>, <argument><expr><call><name>pckWriteResult</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pckWriteEndP</name><argument_list>(<argument><expr><name>resultMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Flush on NULL result since it might be used to synchronize</comment>
        <if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ioWriteFlush</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>protocolServerDataEndPut</name><parameter_list>(<parameter><decl><type><name>ProtocolServer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_SERVER</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Write the response and flush to be sure it gets sent immediately</comment>
        <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier></type><name>response</name> <init>= <expr><call><name>pckWriteNewIo</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>response</name></expr></argument>, <argument><expr><name>protocolMessageTypeDataEnd</name></expr></argument>, <argument><expr><operator>.</operator><name>defaultWrite</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pckWriteEndP</name><argument_list>(<argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ioWriteFlush</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>protocolServerToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProtocolServer</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"{name: %s}"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
