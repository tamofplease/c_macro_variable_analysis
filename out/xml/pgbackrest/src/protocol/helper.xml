<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/protocol/helper.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Protocol Helper
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/crypto/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/exec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/client.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/socket/client.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/socket/server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/tls/client.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/io/tls/server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/memContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/config.intern.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/exec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/load.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/parse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config/protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Constants
***********************************************************************************************************************************/</comment>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>PROTOCOL_SERVICE_LOCAL_STR</name></expr></argument>,                           <argument><expr><name>PROTOCOL_SERVICE_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>PROTOCOL_SERVICE_REMOTE_STR</name></expr></argument>,                          <argument><expr><name>PROTOCOL_SERVICE_REMOTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Local variables
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>ProtocolHelperClient</name>
<block>{
    <decl_stmt><decl><type><name>Exec</name> <modifier>*</modifier></type><name>exec</name></decl>;</decl_stmt>                                                     <comment type="line">// Executed client</comment>
    <decl_stmt><decl><type><name>IoClient</name> <modifier>*</modifier></type><name>ioClient</name></decl>;</decl_stmt>                                             <comment type="line">// Io client, e.g. TlsClient</comment>
    <decl_stmt><decl><type><name>IoSession</name> <modifier>*</modifier></type><name>ioSession</name></decl>;</decl_stmt>                                           <comment type="line">// Io session, e.g. TlsSession</comment>
    <decl_stmt><decl><type><name>ProtocolClient</name> <modifier>*</modifier></type><name>client</name></decl>;</decl_stmt>                                         <comment type="line">// Protocol client</comment>
}</block></struct></type> <name>ProtocolHelperClient</name>;</typedef>

<struct><specifier>static</specifier> struct
<block>{
    <decl_stmt><decl><type><name>MemContext</name> <modifier>*</modifier></type><name>memContext</name></decl>;</decl_stmt>                                         <comment type="line">// Mem context for protocol helper</comment>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>clientRemoteSize</name></decl>;</decl_stmt>                                  <comment type="line">// Remote clients</comment>
    <decl_stmt><decl><type><name>ProtocolHelperClient</name> <modifier>*</modifier></type><name>clientRemote</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>clientLocalSize</name></decl>;</decl_stmt>                                   <comment type="line">// Local clients</comment>
    <decl_stmt><decl><type><name>ProtocolHelperClient</name> <modifier>*</modifier></type><name>clientLocal</name></decl>;</decl_stmt>
}</block> <decl><name>protocolHelper</name></decl>;</struct>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Init local mem context and data structure
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>protocolHelperInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="line">// In the protocol helper has not been initialized</comment>
    <if_stmt><if>if <condition>(<expr><name><name>protocolHelper</name><operator>.</operator><name>memContext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Create a mem context to store protocol objects</comment>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>memContextTop()</argument>)</argument_list></macro>
        <block>{<block_content>
            <macro><name>MEM_CONTEXT_NEW_BEGIN</name><argument_list>(<argument><literal type="string">"ProtocolHelper"</literal></argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>, <argument>.allocQty = MEM_CONTEXT_QTY_MAX</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name><name>protocolHelper</name><operator>.</operator><name>memContext</name></name> <operator>=</operator> <call><name>MEM_CONTEXT_NEW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>MEM_CONTEXT_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>repoIsLocal</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><operator>!</operator><call><name>cfgOptionIdxTest</name><argument_list>(<argument><expr><name>cfgOptRepoHost</name></expr></argument>, <argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>repoIsLocalVerify</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>repoIsLocalVerifyIdx</name><argument_list>(<argument><expr><call><name>cfgOptionGroupIdxDefault</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>repoIsLocalVerifyIdx</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>repoIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>repoIsLocal</name><argument_list>(<argument><expr><name>repoIdx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>HostInvalidError</name></expr></argument>, <argument><expr><literal type="string">"%s command must be run on the repository host"</literal></expr></argument>, <argument><expr><call><name>cfgCommandName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>pgIsLocal</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><operator>!</operator><call><name>cfgOptionIdxTest</name><argument_list>(<argument><expr><name>cfgOptPgHost</name></expr></argument>, <argument><expr><name>pgIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>pgIsLocalVerify</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgIsLocal</name><argument_list>(<argument><expr><call><name>cfgOptionGroupIdxDefault</name><argument_list>(<argument><expr><name>cfgOptGrpPg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>HostInvalidError</name></expr></argument>, <argument><expr><literal type="string">"%s command must be run on the "</literal> <name>PG_NAME</name> <literal type="string">" host"</literal></expr></argument>, <argument><expr><call><name>cfgCommandName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the command line required for local protocol execution
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>StringList</name> <modifier>*</modifier></type>
<name>protocolLocalParam</name><parameter_list>(<parameter><decl><type><name>ProtocolStorageType</name></type> <name>protocolStorageType</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hostIdx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>processId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>protocolStorageType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>processId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Option replacements</comment>
        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>optionReplace</name> <init>= <expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Add the process id -- used when more than one process will be called</comment>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_PROCESS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><name>processId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Add the pg default. Don't do this for repos because the repo default should come from the user or the local should</comment>
        <comment type="line">// handle all the repos equally. Repos don't get special handling like pg primaries or standbys.</comment>
        <if_stmt><if>if <condition>(<expr><name>protocolStorageType</name> <operator>==</operator> <name>protocolStorageTypePg</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_PG</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><call><name>cfgOptionGroupIdxToKey</name><argument_list>(<argument><expr><name>cfgOptGrpPg</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Add the remote type</comment>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_REMOTE_TYPE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name>protocolStorageType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Only enable file logging on the local when requested</comment>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(
            <argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_FILE</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><ternary><condition><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptLogSubprocess</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>VARUINT64</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptLogLevelFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Always output errors on stderr for debugging purposes</comment>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_STDERR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Disable output to stdout since it is used by the protocol</comment>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_CONSOLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cfgExecParam</name><argument_list>(<argument><expr><call><name>cfgCommand</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>cfgCmdRoleLocal</name></expr></argument>, <argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<comment type="line">// Helper to execute the local process. This is a separate function solely so that it can be shimmed during testing.</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>protocolLocalExec</name><parameter_list>(
    <parameter><decl><type><name>ProtocolHelperClient</name> <modifier>*</modifier></type><name>helper</name></decl></parameter>, <parameter><decl><type><name>ProtocolStorageType</name></type> <name>protocolStorageType</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hostIdx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>processId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>helper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>protocolStorageType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>processId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>helper</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Execute the protocol command</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>PROTOCOL_SERVICE_LOCAL</name> <literal type="string">"-%u process"</literal></expr></argument>, <argument><expr><name>processId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>param</name> <init>= <expr><call><name>protocolLocalParam</name><argument_list>(<argument><expr><name>protocolStorageType</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>, <argument><expr><name>processId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>helper</name><operator>-&gt;</operator><name>exec</name></name> <operator>=</operator> <call><name>execNew</name><argument_list>(<argument><expr><call><name>cfgExe</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptProtocolTimeout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>execOpen</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>exec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Create protocol object</comment>
        <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><name>PROTOCOL_SERVICE_LOCAL</name> <literal type="string">"-%u protocol"</literal></expr></argument>, <argument><expr><name>processId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>helper</name><operator>-&gt;</operator><name>client</name></name> <operator>=</operator> <call><name>protocolClientNew</name><argument_list>(
                <argument><expr><name>name</name></expr></argument>, <argument><expr><name>PROTOCOL_SERVICE_LOCAL_STR</name></expr></argument>, <argument><expr><call><name>execIoRead</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>exec</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>execIoWrite</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>exec</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Move client to exec context so they are freed together</comment>
        <expr_stmt><expr><call><name>protocolClientMove</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><call><name>execMemContext</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>exec</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ProtocolClient</name> <modifier>*</modifier></type>
<name>protocolLocalGet</name><parameter_list>(<parameter><decl><type><name>ProtocolStorageType</name></type> <name>protocolStorageType</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hostIdx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>processId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>protocolStorageType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>processId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>protocolHelperInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Allocate the client cache</comment>
    <if_stmt><if>if <condition>(<expr><name><name>protocolHelper</name><operator>.</operator><name>clientLocalSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>protocolHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>protocolHelper</name><operator>.</operator><name>clientLocalSize</name></name> <operator>=</operator> <call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptProcessMax</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>protocolHelper</name><operator>.</operator><name>clientLocal</name></name> <operator>=</operator> <call><name>memNew</name><argument_list>(<argument><expr><name><name>protocolHelper</name><operator>.</operator><name>clientLocalSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ProtocolHelperClient</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>clientIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>clientIdx</name> <operator>&lt;</operator> <name><name>protocolHelper</name><operator>.</operator><name>clientLocalSize</name></name></expr>;</condition> <incr><expr><name>clientIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>protocolHelper</name><operator>.</operator><name>clientLocal</name><index>[<expr><name>clientIdx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ProtocolHelperClient</name><operator>)</operator><block>{<expr><operator>.</operator><name>exec</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>processId</name> <operator>&lt;=</operator> <name><name>protocolHelper</name><operator>.</operator><name>clientLocalSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Create protocol object</comment>
    <decl_stmt><decl><type><name>ProtocolHelperClient</name> <modifier>*</modifier></type><name>protocolHelperClient</name> <init>= <expr><operator>&amp;</operator><name><name>protocolHelper</name><operator>.</operator><name>clientLocal</name><index>[<expr><name>processId</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>client</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>protocolHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>protocolLocalExec</name><argument_list>(<argument><expr><name>protocolHelperClient</name></expr></argument>, <argument><expr><name>protocolStorageType</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>, <argument><expr><name>processId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Send noop to catch initialization errors</comment>
        <expr_stmt><expr><call><name>protocolClientNoOp</name><argument_list>(<argument><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Free the protocol client and underlying exec'd process. Log any errors as warnings since it is not worth terminating the process
while closing a local/remote that has already completed its work. The warning will be an indication that something is not right.
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>protocolHelperClientFree</name><parameter_list>(<parameter><decl><type><name>ProtocolHelperClient</name> <modifier>*</modifier></type><name>protocolHelperClient</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>protocolHelperClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>client</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Try to shutdown the protocol but only warn on error</comment>
        <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>protocolClientFree</name><argument_list>(<argument><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Try to end the child process but only warn on error</comment>
        <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>execFree</name><argument_list>(<argument><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>exec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_WARN</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Free the io client/session (there should be no errors)</comment>
        <expr_stmt><expr><call><name>ioSessionFree</name><argument_list>(<argument><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>ioSession</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ioClientFree</name><argument_list>(<argument><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>ioClient</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>ioSession</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>ioClient</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>client</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>exec</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>protocolLocalFree</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>processId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>processId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>protocolHelper</name><operator>.</operator><name>clientLocal</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>processId</name> <operator>&lt;=</operator> <name><name>protocolHelper</name><operator>.</operator><name>clientLocalSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>protocolHelperClientFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>protocolHelper</name><operator>.</operator><name>clientLocal</name><index>[<expr><name>processId</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<comment type="line">// Helper to check if client is authorized for a stanza</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>protocolServerAuthorize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>authListStr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>stanza</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>authListStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>stanza</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>authListStr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Empty list is not valid. ??? It would be better if this were done during config parsing.</comment>
        <expr_stmt><expr><name>authListStr</name> <operator>=</operator> <call><name>strTrim</name><argument_list>(<argument><expr><call><name>strDup</name><argument_list>(<argument><expr><name>authListStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strEmpty</name><argument_list>(<argument><expr><name>authListStr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>OptionInvalidValueError</name></expr></argument>, <argument><expr><literal type="string">"'"</literal> <name>CFGOPT_TLS_SERVER_AUTH</name> <literal type="string">"' option must have a value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// If * then all stanzas are authorized</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>authListStr</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else check the stanza list for a match with the specified stanza. Each entry will need to be trimmed before comparing.</comment>
        <if type="elseif">else if <condition>(<expr><name>stanza</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>authList</name> <init>= <expr><call><name>strLstNewSplitZ</name><argument_list>(<argument><expr><name>authListStr</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>authListIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>authListIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>authList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>authListIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>strEq</name><argument_list>(<argument><expr><call><name>strTrim</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>authList</name></expr></argument>, <argument><expr><name>authListIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stanza</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ProtocolServer</name> <modifier>*</modifier></type>
<name>protocolServer</name><parameter_list>(<parameter><decl><type><name>IoServer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tlsServer</name></decl></parameter>, <parameter><decl><type><name>IoSession</name> <modifier>*</modifier><specifier>const</specifier></type> <name>socketSession</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>IO_SERVER</name></expr></argument>, <argument><expr><name>tlsServer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>IO_SESSION</name></expr></argument>, <argument><expr><name>socketSession</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ProtocolServer</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Start TLS</comment>
        <decl_stmt><decl><type><name>IoSession</name> <modifier>*</modifier><specifier>const</specifier></type> <name>tlsSession</name> <init>= <expr><call><name>ioServerAccept</name><argument_list>(<argument><expr><name>tlsServer</name></expr></argument>, <argument><expr><name>socketSession</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>protocolServerNew</name><argument_list>(
            <argument><expr><name>PROTOCOL_SERVICE_REMOTE_STR</name></expr></argument>, <argument><expr><name>PROTOCOL_SERVICE_REMOTE_STR</name></expr></argument>, <argument><expr><call><name>ioSessionIoReadP</name><argument_list>(<argument><expr><name>tlsSession</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>ioSessionIoWrite</name><argument_list>(<argument><expr><name>tlsSession</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// If session is authenticated</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ioSessionAuthenticated</name><argument_list>(<argument><expr><name>tlsSession</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <comment type="line">// Get list of authorized stanzas for this client</comment>
                <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptTlsServerAuth</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"missing auth data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>clientAuthList</name> <init>= <expr><call><name>strDup</name><argument_list>(
                    <argument><expr><call><name>varStr</name><argument_list>(<argument><expr><call><name>kvGet</name><argument_list>(<argument><expr><call><name>cfgOptionKv</name><argument_list>(<argument><expr><name>cfgOptTlsServerAuth</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>ioSessionPeerName</name><argument_list>(<argument><expr><name>tlsSession</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Error if the client is not authorized for anything</comment>
                <if_stmt><if>if <condition>(<expr><name>clientAuthList</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>AccessError</name></expr></argument>, <argument><expr><literal type="string">"access denied"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Get parameter list from the client and load it</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>ProtocolServerCommandGetResult</name></type> <name>command</name> <init>= <expr><call><name>protocolServerCommandGet</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><name><name>command</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name>PROTOCOL_COMMAND_CONFIG</name></expr></argument>, <argument><expr><literal type="string">"expected config command"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>paramList</name> <init>= <expr><call><name>pckReadStrLstP</name><argument_list>(<argument><expr><call><name>pckReadNew</name><argument_list>(<argument><expr><name><name>command</name><operator>.</operator><name>param</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>strLstInsert</name><argument_list>(<argument><expr><name>paramList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>cfgExe</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>cfgLoad</name><argument_list>(<argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>paramList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strLstPtr</name><argument_list>(<argument><expr><name>paramList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Error if the client is not authorized for the requested stanza</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>protocolServerAuthorize</name><argument_list>(<argument><expr><name>clientAuthList</name></expr></argument>, <argument><expr><call><name>cfgOptionStrNull</name><argument_list>(<argument><expr><name>cfgOptStanza</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW</name><argument_list>(<argument><expr><name>AccessError</name></expr></argument>, <argument><expr><literal type="string">"access denied"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>
            <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><call><name>protocolServerError</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>errorCode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>errorMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>errorStackTrace</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RETHROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Ack the config command</comment>
            <expr_stmt><expr><call><name>protocolServerDataEndPut</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ioSessionMove</name><argument_list>(<argument><expr><name>tlsSession</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>protocolServerMove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="line">// Else the client can only detect that the server is alive</comment>
        <else>else
        <block>{<block_content>
            <comment type="line">// Send a data end message and return a NULL server. Do not waste time looking at what the client wrote.</comment>
            <expr_stmt><expr><call><name>protocolServerDataEndPut</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Set result to NULL so there is no server for the caller to use. The TLS session will be freed when the temp mem</comment>
            <comment type="line">// context ends.</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PROTOCOL_SERVER</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the command line required for remote protocol execution
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>StringList</name> <modifier>*</modifier></type>
<name>protocolRemoteParam</name><parameter_list>(<parameter><decl><type><name>ProtocolStorageType</name></type> <name>protocolStorageType</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hostIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>protocolStorageType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Is this a repo remote?</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>isRepo</name> <init>= <expr><name>protocolStorageType</name> <operator>==</operator> <name>protocolStorageTypeRepo</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Option replacements</comment>
        <decl_stmt><decl><type><name>KeyValue</name> <modifier>*</modifier></type><name>optionReplace</name> <init>= <expr><call><name>kvNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Replace config options with the host versions</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>optConfig</name> <init>= <expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHostConfig</name></expr> </then><else>: <expr><name>cfgOptPgHostConfig</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>kvPut</name><argument_list>(
            <argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_CONFIG</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><ternary><condition><expr><call><name>cfgOptionIdxSource</name><argument_list>(<argument><expr><name>optConfig</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>cfgSourceDefault</name></expr> ?</condition><then> <expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>cfgOptionIdxStr</name><argument_list>(<argument><expr><name>optConfig</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>optConfigIncludePath</name> <init>= <expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHostConfigIncludePath</name></expr> </then><else>: <expr><name>cfgOptPgHostConfigIncludePath</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>kvPut</name><argument_list>(
            <argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_CONFIG_INCLUDE_PATH</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><ternary><condition><expr><call><name>cfgOptionIdxSource</name><argument_list>(<argument><expr><name>optConfigIncludePath</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>cfgSourceDefault</name></expr> ?</condition><then>
                <expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>cfgOptionIdxStr</name><argument_list>(<argument><expr><name>optConfigIncludePath</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>optConfigPath</name> <init>= <expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHostConfigPath</name></expr> </then><else>: <expr><name>cfgOptPgHostConfigPath</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>kvPut</name><argument_list>(
            <argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_CONFIG_PATH</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><ternary><condition><expr><call><name>cfgOptionIdxSource</name><argument_list>(<argument><expr><name>optConfigPath</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>cfgSourceDefault</name></expr> ?</condition><then> <expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>cfgOptionIdxStr</name><argument_list>(<argument><expr><name>optConfigPath</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Update/remove repo/pg options that are sent to the remote</comment>
        <for>for <control>(<init><decl><type><name>ConfigOption</name></type> <name>optionId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optionId</name> <operator>&lt;</operator> <name>CFG_OPTION_TOTAL</name></expr>;</condition> <incr><expr><name>optionId</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">// Skip options that are not part of a group</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionGroup</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <decl_stmt><decl><type><name>bool</name></type> <name>remove</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>skipHostZero</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Remove repo options that are not needed on the remote</comment>
            <if_stmt><if>if <condition>(<expr><call><name>cfgOptionGroupId</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cfgOptGrpRepo</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// If remote type is pg then remove all repo options since they will not be used</comment>
                <if_stmt><if>if <condition>(<expr><name>protocolStorageType</name> <operator>==</operator> <name>protocolStorageTypePg</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>remove</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Else remove repo options for indexes that are not being passed to the repo. This prevents the remote from getting</comment>
                <comment type="line">// partial info about a repo, which could cause an error during validation.</comment>
                <else>else
                <block>{<block_content>
                    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optionIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optionIdx</name> <operator>&lt;</operator> <call><name>cfgOptionIdxTotal</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>optionIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionIdxTest</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionIdx</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>optionIdx</name> <operator>!=</operator> <name>hostIdx</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRZ</name><argument_list>(<argument><expr><call><name>cfgOptionIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <comment type="line">// Remove pg options that are not needed on the remote</comment>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>cfgOptionGroupId</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cfgOptGrpPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Remove unrequired/defaulted pg options when the remote type is repo since they won't be used</comment>
                <if_stmt><if>if <condition>(<expr><name>protocolStorageType</name> <operator>==</operator> <name>protocolStorageTypeRepo</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>remove</name> <operator>=</operator> <operator>!</operator><call><name>cfgParseOptionRequired</name><argument_list>(<argument><expr><call><name>cfgCommand</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>cfgParseOptionDefault</name><argument_list>(<argument><expr><call><name>cfgCommand</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>optionId</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="line">// Move pg options to host index 0 (key 1) so they will be in the default index on the remote host</comment>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>hostIdx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>kvPut</name><argument_list>(
                            <argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRZ</name><argument_list>(<argument><expr><call><name>cfgOptionIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><ternary><condition><expr><call><name>cfgOptionIdxSource</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>cfgSourceDefault</name></expr> ?</condition><then> <expr><call><name>cfgOptionIdxVar</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name>remove</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>skipHostZero</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="line">// Remove options that have been marked for removal if they are not already null or invalid. This is more efficient because</comment>
            <comment type="line">// cfgExecParam() won't have to search through as large a list looking for overrides.</comment>
            <if_stmt><if>if <condition>(<expr><name>remove</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Loop through option indexes</comment>
                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>optionIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>optionIdx</name> <operator>&lt;</operator> <call><name>cfgOptionIdxTotal</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>optionIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionIdxTest</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionIdx</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>skipHostZero</name> <operator>&amp;&amp;</operator> <name>optionIdx</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRZ</name><argument_list>(<argument><expr><call><name>cfgOptionIdxName</name><argument_list>(<argument><expr><name>optionId</name></expr></argument>, <argument><expr><name>optionIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Set repo default so the remote only operates on a single repo</comment>
        <if_stmt><if>if <condition>(<expr><name>protocolStorageType</name> <operator>==</operator> <name>protocolStorageTypeRepo</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_REPO</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARUINT</name><argument_list>(<argument><expr><call><name>cfgOptionGroupIdxToKey</name><argument_list>(<argument><expr><name>cfgOptGrpRepo</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Add the process id if not set. This means that the remote is being started from the main process and should always get a</comment>
        <comment type="line">// process id of 0.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptProcess</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_PROCESS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARINT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Don't pass log-path or lock-path since these are host specific</comment>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_PATH</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOCK_PATH</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Only enable file logging on the remote when requested</comment>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(
            <argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_FILE</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><ternary><condition><expr><call><name>cfgOptionBool</name><argument_list>(<argument><expr><name>cfgOptLogSubprocess</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>VARUINT64</name><argument_list>(<argument><expr><call><name>cfgOptionStrId</name><argument_list>(<argument><expr><name>cfgOptLogLevelFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Always output errors on stderr for debugging purposes</comment>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_STDERR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Disable output to stdout since it is used by the protocol</comment>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_LOG_LEVEL_CONSOLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Add the remote type</comment>
        <expr_stmt><expr><call><name>kvPut</name><argument_list>(<argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><call><name>VARSTRDEF</name><argument_list>(<argument><expr><name>CFGOPT_REMOTE_TYPE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSTR</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name>protocolStorageType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cfgExecParam</name><argument_list>(<argument><expr><call><name>cfgCommand</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>cfgCmdRoleRemote</name></expr></argument>, <argument><expr><name>optionReplace</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Helper to add SSH parameters when executing the remote via SSH</comment>
<function><type><specifier>static</specifier> <name>StringList</name> <modifier>*</modifier></type>
<name>protocolRemoteParamSsh</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProtocolStorageType</name></type> <name>protocolStorageType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>hostIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>protocolStorageType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Is this a repo remote?</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>isRepo</name> <init>= <expr><name>protocolStorageType</name> <operator>==</operator> <name>protocolStorageTypeRepo</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Fixed parameters for ssh command</comment>
        <expr_stmt><expr><call><name>strLstAddZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"-o"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strLstAddZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"LogLevel=error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strLstAddZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"-o"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strLstAddZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"Compression=no"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strLstAddZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"-o"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strLstAddZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"PasswordAuthentication=no"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Append port if specified</comment>
        <decl_stmt><decl><type><name>ConfigOption</name></type> <name>optHostPort</name> <init>= <expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHostPort</name></expr> </then><else>: <expr><name>cfgOptPgHostPort</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>cfgOptionIdxTest</name><argument_list>(<argument><expr><name>optHostPort</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strLstAddZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"-p"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>strLstAddFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><call><name>cfgOptionIdxUInt</name><argument_list>(<argument><expr><name>optHostPort</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Append user/host</comment>
        <expr_stmt><expr><call><name>strLstAddFmt</name><argument_list>(
            <argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%s@%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionIdxStr</name><argument_list>(<argument><expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHostUser</name></expr> </then><else>: <expr><name>cfgOptPgHostUser</name></expr></else></ternary></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>cfgOptionIdxStr</name><argument_list>(<argument><expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHost</name></expr> </then><else>: <expr><name>cfgOptPgHost</name></expr></else></ternary></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Add remote command and parameters</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>paramList</name> <init>= <expr><call><name>protocolRemoteParam</name><argument_list>(<argument><expr><name>protocolStorageType</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>strLstInsert</name><argument_list>(<argument><expr><name>paramList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>cfgOptionIdxStr</name><argument_list>(<argument><expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHostCmd</name></expr> </then><else>: <expr><name>cfgOptPgHostCmd</name></expr></else></ternary></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>strLstJoin</name><argument_list>(<argument><expr><name>paramList</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<comment type="line">// Helper to execute the local process. This is a separate function solely so that it can be shimmed during testing.</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>protocolRemoteExec</name><parameter_list>(
    <parameter><decl><type><name>ProtocolHelperClient</name> <modifier>*</modifier><specifier>const</specifier></type> <name>helper</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProtocolStorageType</name></type> <name>protocolStorageType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>hostIdx</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>processId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>helper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>protocolStorageType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>processId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>helper</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Get remote info</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isRepo</name> <init>= <expr><name>protocolStorageType</name> <operator>==</operator> <name>protocolStorageTypeRepo</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringId</name></type> <name>remoteType</name> <init>= <expr><call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHostType</name></expr> </then><else>: <expr><name>cfgOptPgHostType</name></expr></else></ternary></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>host</name> <init>= <expr><call><name>cfgOptionIdxStr</name><argument_list>(<argument><expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHost</name></expr> </then><else>: <expr><name>cfgOptPgHost</name></expr></else></ternary></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Handle remote types</comment>
        <decl_stmt><decl><type><name>IoRead</name> <modifier>*</modifier></type><name>read</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IoWrite</name> <modifier>*</modifier></type><name>write</name></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name>remoteType</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// SSH remote</comment>
            <case>case <expr><name>CFGOPTVAL_REPO_HOST_TYPE_SSH</name></expr>:</case>
            <block>{<block_content>
                <comment type="line">// Exec SSH</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>name</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><name>PROTOCOL_SERVICE_REMOTE</name> <literal type="string">"-%u process on '%s'"</literal></expr></argument>, <argument><expr><name>processId</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>param</name> <init>= <expr><call><name>protocolRemoteParamSsh</name><argument_list>(<argument><expr><name>protocolStorageType</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>helper</name><operator>-&gt;</operator><name>exec</name></name> <operator>=</operator> <call><name>execNew</name><argument_list>(<argument><expr><call><name>cfgOptionStr</name><argument_list>(<argument><expr><name>cfgOptCmdSsh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptProtocolTimeout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>execOpen</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>exec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>read</name> <operator>=</operator> <call><name>execIoRead</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>exec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>write</name> <operator>=</operator> <call><name>execIoWrite</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>exec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <break>break;</break>
            </block_content>}</block>

            <comment type="line">// TLS remote</comment>
            <default>default:</default>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>remoteType</name> <operator>==</operator> <name>CFGOPTVAL_REPO_HOST_TYPE_TLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Negotiate TLS</comment>
                <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>helper</name><operator>-&gt;</operator><name>ioClient</name></name> <operator>=</operator> <call><name>tlsClientNewP</name><argument_list>(
                        <argument><expr><call><name>sckClientNew</name><argument_list>(
                            <argument><expr><name>host</name></expr></argument>, <argument><expr><call><name>cfgOptionIdxUInt</name><argument_list>(<argument><expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHostPort</name></expr> </then><else>: <expr><name>cfgOptPgHostPort</name></expr></else></ternary></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptIoTimeout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptProtocolTimeout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>host</name></expr></argument>, <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptIoTimeout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cfgOptionUInt64</name><argument_list>(<argument><expr><name>cfgOptProtocolTimeout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                        <argument><expr><operator>.</operator><name>caFile</name> <operator>=</operator> <call><name>cfgOptionIdxStrNull</name><argument_list>(<argument><expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHostCaFile</name></expr> </then><else>: <expr><name>cfgOptPgHostCaFile</name></expr></else></ternary></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><operator>.</operator><name>caPath</name> <operator>=</operator> <call><name>cfgOptionIdxStrNull</name><argument_list>(<argument><expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHostCaPath</name></expr> </then><else>: <expr><name>cfgOptPgHostCaPath</name></expr></else></ternary></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><operator>.</operator><name>certFile</name> <operator>=</operator> <call><name>cfgOptionIdxStr</name><argument_list>(<argument><expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHostCertFile</name></expr> </then><else>: <expr><name>cfgOptPgHostCertFile</name></expr></else></ternary></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><operator>.</operator><name>keyFile</name> <operator>=</operator> <call><name>cfgOptionIdxStr</name><argument_list>(<argument><expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptRepoHostKeyFile</name></expr> </then><else>: <expr><name>cfgOptPgHostKeyFile</name></expr></else></ternary></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>helper</name><operator>-&gt;</operator><name>ioSession</name></name> <operator>=</operator> <call><name>ioClientOpen</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>ioClient</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>read</name> <operator>=</operator> <call><name>ioSessionIoReadP</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>ioSession</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>write</name> <operator>=</operator> <call><name>ioSessionIoWrite</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>ioSession</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <break>break;</break>
            </block_content>}</block>
        </block_content>}</block></switch>

        <comment type="line">// Create protocol object</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>name</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(
            <argument><expr><name>PROTOCOL_SERVICE_REMOTE</name> <literal type="string">"-%u %s protocol on '%s'"</literal></expr></argument>, <argument><expr><name>processId</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name>remoteType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>helper</name><operator>-&gt;</operator><name>client</name></name> <operator>=</operator> <call><name>protocolClientNew</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>PROTOCOL_SERVICE_REMOTE_STR</name></expr></argument>, <argument><expr><name>read</name></expr></argument>, <argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Remote initialization</comment>
        <switch>switch <condition>(<expr><name>remoteType</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// SSH remote</comment>
            <case>case <expr><name>CFGOPTVAL_REPO_HOST_TYPE_SSH</name></expr>:</case>
                <comment type="line">// Move client to exec context so they are freed together</comment>
                <expr_stmt><expr><call><name>protocolClientMove</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><call><name>execMemContext</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>exec</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <comment type="line">// TLS remote</comment>
            <default>default:</default>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>remoteType</name> <operator>==</operator> <name>CFGOPTVAL_REPO_HOST_TYPE_TLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <comment type="line">// Pass parameters to server</comment>
                    <decl_stmt><decl><type><name>ProtocolCommand</name> <modifier>*</modifier><specifier>const</specifier></type> <name>command</name> <init>= <expr><call><name>protocolCommandNew</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND_CONFIG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>pckWriteStrLstP</name><argument_list>(<argument><expr><call><name>protocolCommandParam</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>protocolRemoteParam</name><argument_list>(<argument><expr><name>protocolStorageType</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>protocolClientExecute</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>protocolCommandFree</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <macro><name>CATCH_ANY</name><argument_list>()</argument_list></macro>
                <block>{<block_content>
                    <comment type="line">// Clear the callback so the client does not try to shut down the connection. Attempting to shut down the</comment>
                    <comment type="line">// connection will fail since the server has already disconnected and a new error will be thrown, masking the</comment>
                    <comment type="line">// original error.</comment>
                    <expr_stmt><expr><call><name>memContextCallbackClear</name><argument_list>(<argument><expr><call><name>objMemContext</name><argument_list>(<argument><expr><name><name>helper</name><operator>-&gt;</operator><name>client</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>RETHROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <break>break;</break>
            </block_content>}</block>
        </block_content>}</block></switch>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ProtocolClient</name> <modifier>*</modifier></type>
<name>protocolRemoteGet</name><parameter_list>(<parameter><decl><type><name>ProtocolStorageType</name></type> <name>protocolStorageType</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hostIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>protocolStorageType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Is this a repo remote?</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>isRepo</name> <init>= <expr><name>protocolStorageType</name> <operator>==</operator> <name>protocolStorageTypeRepo</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>protocolHelperInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Allocate the client cache</comment>
    <if_stmt><if>if <condition>(<expr><name><name>protocolHelper</name><operator>.</operator><name>clientRemoteSize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>protocolHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>protocolHelper</name><operator>.</operator><name>clientRemoteSize</name></name> <operator>=</operator> <call><name>cfgOptionGroupIdxTotal</name><argument_list>(<argument><expr><ternary><condition><expr><name>isRepo</name></expr> ?</condition><then> <expr><name>cfgOptGrpRepo</name></expr> </then><else>: <expr><name>cfgOptGrpPg</name></expr></else></ternary></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>protocolHelper</name><operator>.</operator><name>clientRemote</name></name> <operator>=</operator> <call><name>memNew</name><argument_list>(<argument><expr><name><name>protocolHelper</name><operator>.</operator><name>clientRemoteSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ProtocolHelperClient</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>clientIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>clientIdx</name> <operator>&lt;</operator> <name><name>protocolHelper</name><operator>.</operator><name>clientRemoteSize</name></name></expr>;</condition> <incr><expr><name>clientIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>protocolHelper</name><operator>.</operator><name>clientRemote</name><index>[<expr><name>clientIdx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ProtocolHelperClient</name><operator>)</operator><block>{<expr><operator>.</operator><name>exec</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Determine protocol id for the remote.  If the process option is set then use that since we want the remote protocol id to</comment>
    <comment type="line">// match the local protocol id. Otherwise set to 0 since the remote is being started from a main process and there should only</comment>
    <comment type="line">// be one remote per host.</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>processId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>cfgOptionTest</name><argument_list>(<argument><expr><name>cfgOptProcess</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>processId</name> <operator>=</operator> <call><name>cfgOptionUInt</name><argument_list>(<argument><expr><name>cfgOptProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name>hostIdx</name> <operator>&lt;</operator> <name><name>protocolHelper</name><operator>.</operator><name>clientRemoteSize</name></name></expr></argument>, <argument><expr><literal type="string">"invalid host"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Create protocol object</comment>
    <decl_stmt><decl><type><name>ProtocolHelperClient</name> <modifier>*</modifier></type><name>protocolHelperClient</name> <init>= <expr><operator>&amp;</operator><name><name>protocolHelper</name><operator>.</operator><name>clientRemote</name><index>[<expr><name>hostIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>client</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_BEGIN</name><argument_list>(<argument>protocolHelper.memContext</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>protocolRemoteExec</name><argument_list>(<argument><expr><name>protocolHelperClient</name></expr></argument>, <argument><expr><name>protocolStorageType</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>, <argument><expr><name>processId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Send noop to catch initialization errors</comment>
            <expr_stmt><expr><call><name>protocolClientNoOp</name><argument_list>(<argument><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Get cipher options from the remote if none are locally configured</comment>
            <if_stmt><if>if <condition>(<expr><name>isRepo</name> <operator>&amp;&amp;</operator> <call><name>cfgOptionIdxStrId</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cipherTypeNone</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// Options to query</comment>
                <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><call><name>varLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>varNewStrZ</name><argument_list>(<argument><expr><call><name>cfgOptionIdxName</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>varLstAdd</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><call><name>varNewStrZ</name><argument_list>(<argument><expr><call><name>cfgOptionIdxName</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>VariantList</name> <modifier>*</modifier></type><name>optionList</name> <init>= <expr><call><name>configOptionRemote</name><argument_list>(<argument><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>varUInt64</name><argument_list>(<argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>optionList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>cipherTypeNone</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>cfgOptionIdxSet</name><argument_list>(<argument><expr><name>cfgOptRepoCipherType</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>, <argument><expr><name>cfgSourceConfig</name></expr></argument>, <argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>optionList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>cfgOptionIdxSet</name><argument_list>(<argument><expr><name>cfgOptRepoCipherPass</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>, <argument><expr><name>cfgSourceConfig</name></expr></argument>, <argument><expr><call><name>varLstGet</name><argument_list>(<argument><expr><name>optionList</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name><name>protocolHelperClient</name><operator>-&gt;</operator><name>client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>protocolRemoteFree</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hostIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>hostIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>protocolHelper</name><operator>.</operator><name>clientRemote</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>protocolHelperClientFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>protocolHelper</name><operator>.</operator><name>clientRemote</name><index>[<expr><name>hostIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>protocolKeepAlive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>protocolHelper</name><operator>.</operator><name>memContext</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>clientIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>clientIdx</name> <operator>&lt;</operator> <name><name>protocolHelper</name><operator>.</operator><name>clientRemoteSize</name></name></expr>;</condition> <incr><expr><name>clientIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>protocolHelper</name><operator>.</operator><name>clientRemote</name><index>[<expr><name>clientIdx</name></expr>]</index></name><operator>.</operator><name>client</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>protocolClientNoOp</name><argument_list>(<argument><expr><name><name>protocolHelper</name><operator>.</operator><name>clientRemote</name><index>[<expr><name>clientIdx</name></expr>]</index></name><operator>.</operator><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>protocolFree</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_VOID</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>protocolHelper</name><operator>.</operator><name>memContext</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// Free remotes</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>clientIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>clientIdx</name> <operator>&lt;</operator> <name><name>protocolHelper</name><operator>.</operator><name>clientRemoteSize</name></name></expr>;</condition> <incr><expr><name>clientIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>protocolRemoteFree</name><argument_list>(<argument><expr><name>clientIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <comment type="line">// Free locals</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>clientIdx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>clientIdx</name> <operator>&lt;=</operator> <name><name>protocolHelper</name><operator>.</operator><name>clientLocalSize</name></name></expr>;</condition> <incr><expr><name>clientIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>protocolLocalFree</name><argument_list>(<argument><expr><name>clientIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
