<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/protocol/client.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Protocol Client
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/type/keyValue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/client.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"protocol/server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Client state enum
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><enum>enum
<block>{
    <comment type="line">// Client is waiting for a command</comment>
    <decl><name>protocolClientStateIdle</name> <init>= <expr><call><name>STRID5</name><argument_list>(<argument><expr><literal type="string">"idle"</literal></expr></argument>, <argument><expr><literal type="number">0x2b0890</literal></expr></argument>)</argument_list></call></expr></init></decl>,

    <comment type="line">// Command put is in progress</comment>
    <decl><name>protocolClientStateCommandPut</name> <init>= <expr><call><name>STRID5</name><argument_list>(<argument><expr><literal type="string">"cmd-put"</literal></expr></argument>, <argument><expr><literal type="number">0x52b0d91a30</literal></expr></argument>)</argument_list></call></expr></init></decl>,

    <comment type="line">// Waiting for command data from server. Only used when dataPut is true in protocolClientCommandPut().</comment>
    <decl><name>protocolClientStateCommandDataGet</name> <init>= <expr><call><name>STRID5</name><argument_list>(<argument><expr><literal type="string">"cmd-data-get"</literal></expr></argument>, <argument><expr><literal type="number">0xa14fb0d024d91a30</literal></expr></argument>)</argument_list></call></expr></init></decl>,

    <comment type="line">// Putting data to server. Only used when dataPut is true in protocolClientCommandPut().</comment>
    <decl><name>protocolClientStateDataPut</name> <init>= <expr><call><name>STRID5</name><argument_list>(<argument><expr><literal type="string">"data-put"</literal></expr></argument>, <argument><expr><literal type="number">0xa561b0d0240</literal></expr></argument>)</argument_list></call></expr></init></decl>,

    <comment type="line">// Getting data from server</comment>
    <decl><name>protocolClientStateDataGet</name> <init>= <expr><call><name>STRID5</name><argument_list>(<argument><expr><literal type="string">"data-get"</literal></expr></argument>, <argument><expr><literal type="number">0xa14fb0d0240</literal></expr></argument>)</argument_list></call></expr></init></decl>,
}</block></enum></type> <name>ProtocolClientState</name>;</typedef>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Object type
***********************************************************************************************************************************/</comment>
<struct>struct <name>ProtocolClient</name>
<block>{
    <decl_stmt><decl><type><name>ProtocolClientPub</name></type> <name>pub</name></decl>;</decl_stmt>                                          <comment type="line">// Publicly accessible variables</comment>
    <decl_stmt><decl><type><name>ProtocolClientState</name></type> <name>state</name></decl>;</decl_stmt>                                      <comment type="line">// Current client state</comment>
    <decl_stmt><decl><type><name>IoWrite</name> <modifier>*</modifier></type><name>write</name></decl>;</decl_stmt>                                                 <comment type="line">// Write interface</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>                                             <comment type="line">// Name displayed in logging</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>errorPrefix</name></decl>;</decl_stmt>                                      <comment type="line">// Prefix used when throwing error</comment>
    <decl_stmt><decl><type><name>TimeMSec</name></type> <name>keepAliveTime</name></decl>;</decl_stmt>                                         <comment type="line">// Last time data was put to the server</comment>
}</block>;</struct>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Close protocol connection
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>protocolClientFreeResource</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>ProtocolClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Switch state to idle so the command is sent no matter the current state</comment>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>protocolClientStateIdle</name></expr>;</expr_stmt>

    <comment type="line">// Send an exit command but don't wait to see if it succeeds</comment>
    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>protocolClientCommandPut</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>protocolCommandNew</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND_EXIT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>ProtocolClient</name> <modifier>*</modifier></type>
<name>protocolClientNew</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>service</name></decl></parameter>, <parameter><decl><type><name>IoRead</name> <modifier>*</modifier></type><name>read</name></decl></parameter>, <parameter><decl><type><name>IoWrite</name> <modifier>*</modifier></type><name>write</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>service</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>IO_READ</name></expr></argument>, <argument><expr><name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>IO_WRITE</name></expr></argument>, <argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>read</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>write</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>ProtocolClient</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>ProtocolClient</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>, <argument>.callbackQty = <literal type="number">1</literal></argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>ProtocolClient</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>pub</name> <operator>=</operator>
            <block>{
                <expr><operator>.</operator><name>read</name> <operator>=</operator> <name>read</name></expr>,
            }</block></expr>,
            <expr><operator>.</operator><name>state</name> <operator>=</operator> <name>protocolClientStateIdle</name></expr>,
            <expr><operator>.</operator><name>write</name> <operator>=</operator> <name>write</name></expr>,
            <expr><operator>.</operator><name>name</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>,
            <expr><operator>.</operator><name>errorPrefix</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"raised from %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
            <expr><operator>.</operator><name>keepAliveTime</name> <operator>=</operator> <call><name>timeMSec</name><argument_list>()</argument_list></call></expr>,
        }</block></expr>;</expr_stmt>

        <comment type="line">// Read, parse, and check the protocol greeting</comment>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>JsonRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>greeting</name> <init>= <expr><call><name>jsonReadNew</name><argument_list>(<argument><expr><call><name>ioReadLine</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>read</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>jsonReadObjectBegin</name><argument_list>(<argument><expr><name>greeting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <struct><specifier>const</specifier> struct
            <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>StringId</name></type> <name>key</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>value</name></decl>;</decl_stmt>
            }</block> <decl><name><name>expected</name><index>[]</index></name> <init>=
            <expr><block>{
                <expr><block>{<expr><operator>.</operator><name>key</name> <operator>=</operator> <name>PROTOCOL_GREETING_NAME</name></expr>, <expr><operator>.</operator><name>value</name> <operator>=</operator> <name>PROJECT_NAME</name></expr>}</block></expr>,
                <expr><block>{<expr><operator>.</operator><name>key</name> <operator>=</operator> <name>PROTOCOL_GREETING_SERVICE</name></expr>, <expr><operator>.</operator><name>value</name> <operator>=</operator> <macro><name>strZ</name><argument_list>(<argument>service</argument>)</argument_list></macro></expr>}</block></expr>,
                <expr><block>{<expr><operator>.</operator><name>key</name> <operator>=</operator> <name>PROTOCOL_GREETING_VERSION</name></expr>, <expr><operator>.</operator><name>value</name> <operator>=</operator> <name>PROJECT_VERSION</name></expr>}</block></expr>,
            }</block></expr></init></decl>;</struct>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>expectedIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>expectedIdx</name> <operator>&lt;</operator> <call><name>LENGTH_OF</name><argument_list>(<argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>expectedIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>jsonReadKeyExpectStrId</name><argument_list>(<argument><expr><name>greeting</name></expr></argument>, <argument><expr><name><name>expected</name><index>[<expr><name>expectedIdx</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>ProtocolError</name></expr></argument>, <argument><expr><literal type="string">"unable to find greeting key '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name><name>expected</name><index>[<expr><name>expectedIdx</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>jsonReadTypeNext</name><argument_list>(<argument><expr><name>greeting</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>jsonTypeString</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>ProtocolError</name></expr></argument>, <argument><expr><literal type="string">"greeting key '%s' must be string type"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name><name>expected</name><index>[<expr><name>expectedIdx</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>actualValue</name> <init>= <expr><call><name>jsonReadStr</name><argument_list>(<argument><expr><name>greeting</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEqZ</name><argument_list>(<argument><expr><name>actualValue</name></expr></argument>, <argument><expr><name><name>expected</name><index>[<expr><name>expectedIdx</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                        <argument><expr><name>ProtocolError</name></expr></argument>,
                        <argument><expr><literal type="string">"expected value '%s' for greeting key '%s' but got '%s'\n"</literal>
                            <literal type="string">"HINT: is the same version of "</literal> <name>PROJECT_NAME</name> <literal type="string">" installed on the local and remote host?"</literal></expr></argument>,
                        <argument><expr><name><name>expected</name><index>[<expr><name>expectedIdx</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name><name>expected</name><index>[<expr><name>expectedIdx</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>actualValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>jsonReadObjectEnd</name><argument_list>(<argument><expr><name>greeting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Set a callback to shutdown the protocol</comment>
        <expr_stmt><expr><call><name>memContextCallbackSet</name><argument_list>(<argument><expr><call><name>objMemContext</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>protocolClientFreeResource</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Check protocol state
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>protocolClientStateExpect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProtocolClient</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProtocolClientState</name></type> <name>expect</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>expect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>expect</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>ProtocolError</name></expr></argument>, <argument><expr><literal type="string">"client state is '%s' but expected '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name>expect</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>protocolClientDataPut</name><parameter_list>(<parameter><decl><type><name>ProtocolClient</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><name>PackWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PACK_WRITE</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Expect data-put state before data put</comment>
    <expr_stmt><expr><call><name>protocolClientStateExpect</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>protocolClientStateDataPut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// End the pack</comment>
        <if_stmt><if>if <condition>(<expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pckWriteEndP</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Write the data</comment>
        <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier></type><name>dataMessage</name> <init>= <expr><call><name>pckWriteNewIo</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>dataMessage</name></expr></argument>, <argument><expr><name>protocolMessageTypeData</name></expr></argument>, <argument><expr><operator>.</operator><name>defaultWrite</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pckWritePackP</name><argument_list>(<argument><expr><name>dataMessage</name></expr></argument>, <argument><expr><call><name>pckWriteResult</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pckWriteEndP</name><argument_list>(<argument><expr><name>dataMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Flush when there is no more data to put</comment>
        <if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ioWriteFlush</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Switch state to data-get after successful data end put</comment>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>protocolClientStateDataGet</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<comment type="line">// Helper to process errors</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>protocolClientError</name><parameter_list>(<parameter><decl><type><name>ProtocolClient</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProtocolMessageType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>PackRead</name> <modifier>*</modifier><specifier>const</specifier></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PACK_READ</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>error</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>protocolMessageTypeError</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>ErrorType</name> <modifier>*</modifier><specifier>const</specifier></type> <name>type</name> <init>= <expr><call><name>errorTypeFromCode</name><argument_list>(<argument><expr><call><name>pckReadI32P</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>message</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>errorPrefix</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pckReadStrP</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>stack</name> <init>= <expr><call><name>pckReadStrP</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>pckReadEndP</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Switch state to idle after error (server will do the same)</comment>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>protocolClientStateIdle</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><name>message</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>stack</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"invalid error data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>errorInternalThrow</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>PackRead</name> <modifier>*</modifier></type>
<name>protocolClientDataGet</name><parameter_list>(<parameter><decl><type><name>ProtocolClient</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Expect data-get state before data get</comment>
    <expr_stmt><expr><call><name>protocolClientStateExpect</name><argument_list>(
        <argument><expr><name>this</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>this</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>protocolClientStateCommandDataGet</name></expr> ?</condition><then> <expr><name>protocolClientStateCommandDataGet</name></expr> </then><else>: <expr><name>protocolClientStateDataGet</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier></type><name>response</name> <init>= <expr><call><name>pckReadNewIo</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>read</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ProtocolMessageType</name></type> <name>type</name> <init>= <expr><operator>(</operator><name>ProtocolMessageType</name><operator>)</operator><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>response</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>protocolClientError</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>protocolMessageTypeData</name></expr></argument>, <argument><expr><literal type="string">"expected data message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pckReadPackReadP</name><argument_list>(<argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pckReadEndP</name><argument_list>(<argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Switch state to data-put after successful command data get</comment>
        <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>protocolClientStateCommandDataGet</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>protocolClientStateDataPut</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PACK_READ</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>protocolClientDataEndGet</name><parameter_list>(<parameter><decl><type><name>ProtocolClient</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Expect data-get state before data end get</comment>
    <expr_stmt><expr><call><name>protocolClientStateExpect</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>protocolClientStateDataGet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier></type><name>response</name> <init>= <expr><call><name>pckReadNewIo</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>read</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ProtocolMessageType</name></type> <name>type</name> <init>= <expr><operator>(</operator><name>ProtocolMessageType</name><operator>)</operator><call><name>pckReadU32P</name><argument_list>(<argument><expr><name>response</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>protocolClientError</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>protocolMessageTypeDataEnd</name></expr></argument>, <argument><expr><literal type="string">"expected data end message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pckReadEndP</name><argument_list>(<argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Switch state to idle after successful data end get</comment>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>protocolClientStateIdle</name></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>protocolClientCommandPut</name><parameter_list>(<parameter><decl><type><name>ProtocolClient</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><name>ProtocolCommand</name> <modifier>*</modifier><specifier>const</specifier></type> <name>command</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dataPut</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>dataPut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>command</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Expect idle state before command put</comment>
    <expr_stmt><expr><call><name>protocolClientStateExpect</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>protocolClientStateIdle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Switch state to cmd-put</comment>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>protocolClientStateDataPut</name></expr>;</expr_stmt>

    <comment type="line">// Put command</comment>
    <expr_stmt><expr><call><name>protocolCommandPut</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Switch state to data-get/data-put after successful command put</comment>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <ternary><condition><expr><name>dataPut</name></expr> ?</condition><then> <expr><name>protocolClientStateCommandDataGet</name></expr> </then><else>: <expr><name>protocolClientStateDataGet</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="line">// Reset the keep alive time</comment>
    <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>keepAliveTime</name></name> <operator>=</operator> <call><name>timeMSec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>PackRead</name> <modifier>*</modifier></type>
<name>protocolClientExecute</name><parameter_list>(<parameter><decl><type><name>ProtocolClient</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><name>ProtocolCommand</name> <modifier>*</modifier><specifier>const</specifier></type> <name>command</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>resultRequired</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>resultRequired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>command</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Put command</comment>
    <expr_stmt><expr><call><name>protocolClientCommandPut</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Read result if required</comment>
    <decl_stmt><decl><type><name>PackRead</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>resultRequired</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>protocolClientDataGet</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Read response</comment>
    <expr_stmt><expr><call><name>protocolClientDataEndGet</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PACK_READ</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>protocolClientNoOp</name><parameter_list>(<parameter><decl><type><name>ProtocolClient</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PROTOCOL_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><call><name>protocolClientExecute</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>protocolCommandNew</name><argument_list>(<argument><expr><name>PROTOCOL_COMMAND_NOOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>protocolClientToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProtocolClient</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"{name: %s, state: %s}"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strIdToStr</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
