<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/postgres/interface.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
PostgreSQL Interface
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/memContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/regExp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface/static.vendor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/helper.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Defines for various Postgres paths and files
***********************************************************************************************************************************/</comment>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>PG_FILE_PGVERSION_STR</name></expr></argument>,                                <argument><expr><name>PG_FILE_PGVERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>PG_FILE_POSTGRESQLAUTOCONF_STR</name></expr></argument>,                       <argument><expr><name>PG_FILE_POSTGRESQLAUTOCONF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>PG_FILE_POSTMTRPID_STR</name></expr></argument>,                               <argument><expr><name>PG_FILE_POSTMTRPID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>PG_FILE_RECOVERYCONF_STR</name></expr></argument>,                             <argument><expr><name>PG_FILE_RECOVERYCONF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>PG_FILE_RECOVERYDONE_STR</name></expr></argument>,                             <argument><expr><name>PG_FILE_RECOVERYDONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>PG_FILE_RECOVERYSIGNAL_STR</name></expr></argument>,                           <argument><expr><name>PG_FILE_RECOVERYSIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>PG_FILE_STANDBYSIGNAL_STR</name></expr></argument>,                            <argument><expr><name>PG_FILE_STANDBYSIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>PG_PATH_GLOBAL_STR</name></expr></argument>,                                   <argument><expr><name>PG_PATH_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>PG_NAME_WAL_STR</name></expr></argument>,                                      <argument><expr><name>PG_NAME_WAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_EXTERN</name><argument_list>(<argument><expr><name>PG_NAME_XLOG_STR</name></expr></argument>,                                     <argument><expr><name>PG_NAME_XLOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="line">// Wal path names depending on version</comment>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>PG_PATH_PGWAL_STR</name></expr></argument>,                                    <argument><expr><literal type="string">"pg_wal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>PG_PATH_PGXLOG_STR</name></expr></argument>,                                   <argument><expr><literal type="string">"pg_xlog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="line">// Transaction commit log path names depending on version</comment>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>PG_PATH_PGCLOG_STR</name></expr></argument>,                                   <argument><expr><literal type="string">"pg_clog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>PG_PATH_PGXACT_STR</name></expr></argument>,                                   <argument><expr><literal type="string">"pg_xact"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="line">// Lsn name used in functions depnding on version</comment>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>PG_NAME_LSN_STR</name></expr></argument>,                                      <argument><expr><literal type="string">"lsn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRING_STATIC</name><argument_list>(<argument><expr><name>PG_NAME_LOCATION_STR</name></expr></argument>,                                 <argument><expr><literal type="string">"location"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
The control file is 8192 bytes but only the first 512 bytes are used to prevent torn pages even on really old storage with 512-byte
sectors. This is true across all versions of PostgreSQL.
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_CONTROL_DATA_SIZE</name></cpp:macro>                                        <cpp:value>512</cpp:value></cpp:define>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
PostgreSQL interface definitions

The interface functions are documented here rather than the auto-generated file.
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>PgInterface</name>
<block>{
    <comment type="line">// Version of PostgreSQL supported by this interface</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>version</name></decl>;</decl_stmt>

    <comment type="line">// Does pg_control match this version of PostgreSQL?</comment>
    <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>controlIs</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line">// Convert pg_control to a common data structure</comment>
    <function_decl><type><name>PgControl</name></type> (<modifier>*</modifier><name>control</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line">// Get the control version for this version of PostgreSQL</comment>
    <function_decl><type><name>uint32_t</name></type> (<modifier>*</modifier><name>controlVersion</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line">// Does the WAL header match this version of PostgreSQL?</comment>
    <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>walIs</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

    <comment type="line">// Convert WAL header to a common data structure</comment>
    <function_decl><type><name>PgWal</name></type> (<modifier>*</modifier><name>wal</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
}</block></struct></type> <name>PgInterface</name>;</typedef>

<comment type="line">// Include auto-generated interfaces</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/interface.auto.c.inc"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
These pg_control fields are common to all versions of PostgreSQL, so we can use them to generate error messages when the pg_control
version cannot be found.
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>PgControlCommon</name>
<block>{
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>systemId</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>controlVersion</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>catalogVersion</name></decl>;</decl_stmt>
}</block></struct></type> <name>PgControlCommon</name>;</typedef>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get the interface for a PostgreSQL version
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>PgInterface</name> <modifier>*</modifier></type>
<name>pgInterfaceVersion</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>PgInterface</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>interfaceIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>interfaceIdx</name> <operator>&lt;</operator> <call><name>LENGTH_OF</name><argument_list>(<argument><expr><name>pgInterface</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>interfaceIdx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pgInterface</name><index>[<expr><name>interfaceIdx</name></expr>]</index></name><operator>.</operator><name>version</name> <operator>==</operator> <name>pgVersion</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><name>pgInterface</name><index>[<expr><name>interfaceIdx</name></expr>]</index></name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// If the version was not found then error</comment>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"invalid "</literal> <name>PG_NAME</name> <literal type="string">" version %u"</literal></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_TYPE_CONST_P</name><argument_list>(<argument><expr><name>PgInterface</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>pgDbIsTemplate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"template0"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strEqZ</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"template1"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>pgDbIsSystem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>pgDbIsTemplate</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>bool</name></type>
<name>pgDbIsSystemId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>id</name> <operator>&lt;</operator> <name>FirstNormalObjectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Check expected WAL segment size for older PostgreSQL versions
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgWalSegmentSizeCheck</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>walSegmentSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>walSegmentSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pgVersion</name> <operator>&lt;</operator> <name>PG_VERSION_11</name> <operator>&amp;&amp;</operator> <name>walSegmentSize</name> <operator>!=</operator> <name>PG_WAL_SEGMENT_SIZE_DEFAULT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
            <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"wal segment size is %u but must be %u for "</literal> <name>PG_NAME</name> <literal type="string">" &lt;= "</literal> <name>PG_VERSION_10_STR</name></expr></argument>, <argument><expr><name>walSegmentSize</name></expr></argument>,
            <argument><expr><name>PG_WAL_SEGMENT_SIZE_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>PgControl</name></type>
<name>pgControlFromBuffer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Buffer</name> <modifier>*</modifier></type><name>controlFile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BUFFER</name></expr></argument>, <argument><expr><name>controlFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>controlFile</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Search for the version of PostgreSQL that uses this control file</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PgInterface</name> <modifier>*</modifier></type><name>interface</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>interfaceIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>interfaceIdx</name> <operator>&lt;</operator> <call><name>LENGTH_OF</name><argument_list>(<argument><expr><name>pgInterface</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>interfaceIdx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pgInterface</name><index>[<expr><name>interfaceIdx</name></expr>]</index></name><operator>.</operator><call><name>controlIs</name><argument_list>(<argument><expr><call><name>bufPtrConst</name><argument_list>(<argument><expr><name>controlFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>interface</name> <operator>=</operator> <operator>&amp;</operator><name><name>pgInterface</name><index>[<expr><name>interfaceIdx</name></expr>]</index></name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// If the version was not found then error with the control and catalog version that were found</comment>
    <if_stmt><if>if <condition>(<expr><name>interface</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>PgControlCommon</name> <modifier>*</modifier></type><name>controlCommon</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>PgControlCommon</name> <operator>*</operator><operator>)</operator><call><name>bufPtrConst</name><argument_list>(<argument><expr><name>controlFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
            <argument><expr><name>VersionNotSupportedError</name></expr></argument>,
            <argument><expr><literal type="string">"unexpected control version = %u and catalog version = %u\n"</literal>
                <literal type="string">"HINT: is this version of PostgreSQL supported?"</literal></expr></argument>,
            <argument><expr><name><name>controlCommon</name><operator>-&gt;</operator><name>controlVersion</name></name></expr></argument>, <argument><expr><name><name>controlCommon</name><operator>-&gt;</operator><name>catalogVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Get info from the control file</comment>
    <decl_stmt><decl><type><name>PgControl</name></type> <name>result</name> <init>= <expr><call><name><name>interface</name><operator>-&gt;</operator><name>control</name></name><argument_list>(<argument><expr><call><name>bufPtrConst</name><argument_list>(<argument><expr><name>controlFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name><name>interface</name><operator>-&gt;</operator><name>version</name></name></expr>;</expr_stmt>

    <comment type="line">// Check the segment size</comment>
    <expr_stmt><expr><call><name>pgWalSegmentSizeCheck</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>walSegmentSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Check the page size</comment>
    <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>pageSize</name></name> <operator>!=</operator> <name>PG_PAGE_SIZE_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"page size is %u but must be %u"</literal></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>pageSize</name></name></expr></argument>, <argument><expr><name>PG_PAGE_SIZE_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PG_CONTROL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>PgControl</name></type>
<name>pgControlFromFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>storage</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PgControl</name></type> <name>result</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Read control file</comment>
        <decl_stmt><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>controlFile</name> <init>= <expr><call><name>storageGetP</name><argument_list>(
            <argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><name>PG_PATH_GLOBAL</name> <literal type="string">"/"</literal> <name>PG_FILE_PGCONTROL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>exactSize</name> <operator>=</operator> <name>PG_CONTROL_DATA_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgControlFromBuffer</name><argument_list>(<argument><expr><name>controlFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PG_CONTROL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>uint32_t</name></type>
<name>pgControlVersion</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT32</name></expr></argument>, <argument><expr><call><name>pgInterfaceVersion</name><argument_list>(<argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>controlVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
These WAL header fields are common to all versions of PostgreSQL, so we can use them to generate error messages when the WAL magic
cannot be found.
***********************************************************************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>PgWalCommon</name>
<block>{
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>magic</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>flag</name></decl>;</decl_stmt>
}</block></struct></type> <name>PgWalCommon</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_WAL_LONG_HEADER</name></cpp:macro>                                          <cpp:value>0x0002</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>PgWal</name></type>
<name>pgWalFromBuffer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Buffer</name> <modifier>*</modifier></type><name>walBuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BUFFER</name></expr></argument>, <argument><expr><name>walBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walBuffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Check that this is a long format WAL header</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>PgWalCommon</name> <operator>*</operator><operator>)</operator><call><name>bufPtrConst</name><argument_list>(<argument><expr><name>walBuffer</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>flag</name> <operator>&amp;</operator> <name>PG_WAL_LONG_HEADER</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"first page header in WAL file is expected to be in long format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Search for the version of PostgreSQL that uses this WAL magic</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PgInterface</name> <modifier>*</modifier></type><name>interface</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>interfaceIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>interfaceIdx</name> <operator>&lt;</operator> <call><name>LENGTH_OF</name><argument_list>(<argument><expr><name>pgInterface</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>interfaceIdx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pgInterface</name><index>[<expr><name>interfaceIdx</name></expr>]</index></name><operator>.</operator><call><name>walIs</name><argument_list>(<argument><expr><call><name>bufPtrConst</name><argument_list>(<argument><expr><name>walBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>interface</name> <operator>=</operator> <operator>&amp;</operator><name><name>pgInterface</name><index>[<expr><name>interfaceIdx</name></expr>]</index></name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// If the version was not found then error with the magic that was found</comment>
    <if_stmt><if>if <condition>(<expr><name>interface</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
            <argument><expr><name>VersionNotSupportedError</name></expr></argument>,
            <argument><expr><literal type="string">"unexpected WAL magic %u\n"</literal>
                <literal type="string">"HINT: is this version of PostgreSQL supported?"</literal></expr></argument>,
            <argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>PgWalCommon</name> <operator>*</operator><operator>)</operator><call><name>bufPtrConst</name><argument_list>(<argument><expr><name>walBuffer</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// Get info from the control file</comment>
    <decl_stmt><decl><type><name>PgWal</name></type> <name>result</name> <init>= <expr><call><name><name>interface</name><operator>-&gt;</operator><name>wal</name></name><argument_list>(<argument><expr><call><name>bufPtrConst</name><argument_list>(<argument><expr><name>walBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name><name>interface</name><operator>-&gt;</operator><name>version</name></name></expr>;</expr_stmt>

    <comment type="line">// Check the segment size</comment>
    <expr_stmt><expr><call><name>pgWalSegmentSizeCheck</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PG_WAL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>PgWal</name></type>
<name>pgWalFromFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>walFile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier></type><name>storage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walFile</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PgWal</name></type> <name>result</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Read WAL segment header</comment>
        <decl_stmt><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>walBuffer</name> <init>= <expr><call><name>storageGetP</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>walFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>exactSize</name> <operator>=</operator> <name>PG_WAL_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgWalFromBuffer</name><argument_list>(<argument><expr><name>walBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PG_WAL</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>pgTablespaceId</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgCatalogVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgCatalogVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>pgVersionStr</name> <init>= <expr><call><name>pgVersionToStr</name><argument_list>(<argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <macro><name>MEM_CONTEXT_PRIOR_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"PG_%s_%u"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pgVersionStr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pgCatalogVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>MEM_CONTEXT_PRIOR_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>uint64_t</name></type>
<name>pgLsnFromStr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier></type><name>lsnPart</name> <init>= <expr><call><name>strLstNewSplit</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>FSLASH_STR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>FormatError</name></expr></argument>, <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>lsnPart</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"lsn requires two parts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>cvtZToUInt64Base</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>lsnPart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>+</operator> <call><name>cvtZToUInt64Base</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>lsnPart</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>String</name> <modifier>*</modifier></type>
<name>pgLsnToStr</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%x/%x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>pgLsnToWalSegment</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>timeline</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>walSegmentSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>walSegmentSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(
        <argument><expr><name>STRING</name></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%08X%08X%08X"</literal></expr></argument>, <argument><expr><name>timeline</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal><operator>)</operator> <operator>/</operator> <name>walSegmentSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type>
<name>pgLsnFromWalSegment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>walSegment</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>walSegmentSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>walSegmentSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walSegment</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walSegmentSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(
        <argument><expr><name>UINT64</name></expr></argument>,
        <argument><expr><operator>(</operator><call><name>cvtZSubNToUInt64Base</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>+</operator>
        <operator>(</operator><call><name>cvtZSubNToUInt64Base</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>walSegmentSize</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>uint32_t</name></type>
<name>pgTimelineFromWalSegment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>walSegment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walSegment</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>UINT32</name></expr></argument>, <argument><expr><call><name>cvtZSubNToUIntBase</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>walSegment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>StringList</name> <modifier>*</modifier></type>
<name>pgLsnRangeToWalSegmentList</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>timeline</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>lsnStart</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>lsnStop</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>walSegmentSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>lsnStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>lsnStop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>walSegmentSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pgVersion</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>timeline</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>lsnStart</name> <operator>&lt;=</operator> <name>lsnStop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>walSegmentSize</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pgVersion</name> <operator>&gt;</operator> <name>PG_VERSION_92</name> <operator>||</operator> <name>walSegmentSize</name> <operator>==</operator> <name>PG_WAL_SEGMENT_SIZE_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Skip the FF segment when PostgreSQL &lt;= 9.2 (in this case segment size should always be 16MB)</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>skipFF</name> <init>= <expr><name>pgVersion</name> <operator>&lt;=</operator> <name>PG_VERSION_92</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Calculate the start and stop segments</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>startMajor</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>lsnStart</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>startMinor</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>lsnStart</name> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal><operator>)</operator> <operator>/</operator> <name>walSegmentSize</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>stopMajor</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>lsnStop</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>stopMinor</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>lsnStop</name> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal><operator>)</operator> <operator>/</operator> <name>walSegmentSize</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>minorPerMajor</name> <init>= <expr><literal type="number">0xFFFFFFFF</literal> <operator>/</operator> <name>walSegmentSize</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Create list</comment>
        <expr_stmt><expr><call><name>strLstAddFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%08X%08X%08X"</literal></expr></argument>, <argument><expr><name>timeline</name></expr></argument>, <argument><expr><name>startMajor</name></expr></argument>, <argument><expr><name>startMinor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><operator>!</operator><operator>(</operator><name>startMajor</name> <operator>==</operator> <name>stopMajor</name> <operator>&amp;&amp;</operator> <name>startMinor</name> <operator>==</operator> <name>stopMinor</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>startMinor</name><operator>++</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>skipFF</name> <operator>&amp;&amp;</operator> <name>startMinor</name> <operator>==</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>skipFF</name> <operator>&amp;&amp;</operator> <name>startMinor</name> <operator>&gt;</operator> <name>minorPerMajor</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>startMajor</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>startMinor</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>strLstAddFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"%08X%08X%08X"</literal></expr></argument>, <argument><expr><name>timeline</name></expr></argument>, <argument><expr><name>startMajor</name></expr></argument>, <argument><expr><name>startMinor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type>
<name>pgLsnName</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><ternary><condition><expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_WAL_RENAME</name></expr> ?</condition><then> <expr><name>PG_NAME_LSN_STR</name></expr> </then><else>: <expr><name>PG_NAME_LOCATION_STR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Get WAL name (wal/xlog) for a PostgreSQL version
***********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type>
<name>pgWalName</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><ternary><condition><expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_WAL_RENAME</name></expr> ?</condition><then> <expr><name>PG_NAME_WAL_STR</name></expr> </then><else>: <expr><name>PG_NAME_XLOG_STR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type>
<name>pgWalPath</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><ternary><condition><expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_WAL_RENAME</name></expr> ?</condition><then> <expr><name>PG_PATH_PGWAL_STR</name></expr> </then><else>: <expr><name>PG_PATH_PGXLOG_STR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type>
<name>pgXactPath</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pgVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>pgVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN_CONST</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><ternary><condition><expr><name>pgVersion</name> <operator>&gt;=</operator> <name>PG_VERSION_WAL_RENAME</name></expr> ?</condition><then> <expr><name>PG_PATH_PGXACT_STR</name></expr> </then><else>: <expr><name>PG_PATH_PGCLOG_STR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>unsigned</name> <name>int</name></type>
<name>pgVersionFromStr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>version</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If format not number.number (9.4) or number only (10) then error. No check for valid/supported PG version is on purpose.</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>regExpMatchOne</name><argument_list>(<argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"^[0-9]+[.]*[0-9]+$"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><literal type="string">"version %s format is invalid"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// If there is no dot then only the major version is needed</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>idxStart</name> <init>= <expr><call><name>strChr</name><argument_list>(<argument><expr><name>version</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>idxStart</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><call><name>cvtZToUInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="line">// Major and minor version are needed</comment>
    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(
        <argument><expr><name>UINT</name></expr></argument>, <argument><expr><call><name>cvtZSubNToUInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>idxStart</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">10000</literal> <operator>+</operator> <call><name>cvtZToUInt</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>idxStart</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>String</name> <modifier>*</modifier></type>
<name>pgVersionToStr</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><ternary><condition><expr><name>version</name> <operator>&gt;=</operator> <name>PG_VERSION_10</name></expr> ?</condition><then>
        <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>version</name> <operator>/</operator> <literal type="number">10000</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%u.%u"</literal></expr></argument>, <argument><expr><name>version</name> <operator>/</operator> <literal type="number">10000</literal></expr></argument>, <argument><expr><name>version</name> <operator>%</operator> <literal type="number">10000</literal> <operator>/</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>pgControlToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PgControl</name> <modifier>*</modifier></type><name>pgControl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strNewFmt</name><argument_list>(
        <argument><expr><literal type="string">"{version: %u, systemId: %"</literal> <name>PRIu64</name> <literal type="string">", walSegmentSize: %u, pageChecksum: %s}"</literal></expr></argument>, <argument><expr><name><name>pgControl</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>pgControl</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>,
        <argument><expr><name><name>pgControl</name><operator>-&gt;</operator><name>walSegmentSize</name></name></expr></argument>, <argument><expr><call><name>cvtBoolToConstZ</name><argument_list>(<argument><expr><name><name>pgControl</name><operator>-&gt;</operator><name>pageChecksum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>String</name> <modifier>*</modifier></type>
<name>pgWalToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PgWal</name> <modifier>*</modifier></type><name>pgWal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"{version: %u, systemId: %"</literal> <name>PRIu64</name> <literal type="string">"}"</literal></expr></argument>, <argument><expr><name><name>pgWal</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>pgWal</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
