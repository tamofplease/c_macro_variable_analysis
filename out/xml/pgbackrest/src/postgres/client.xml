<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/src/postgres/client.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Postgres Client
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libpq-fe.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/wait.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres/client.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Object type
***********************************************************************************************************************************/</comment>
<struct>struct <name>PgClient</name>
<block>{
    <decl_stmt><decl><type><name>PgClientPub</name></type> <name>pub</name></decl>;</decl_stmt>                                                <comment type="line">// Publicly accessible variables</comment>
    <decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>connection</name></decl>;</decl_stmt>                                             <comment type="line">// Pg connection</comment>
}</block>;</struct>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Close protocol connection
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgClientFreeResource</name><parameter_list>(<parameter><decl><type><name>THIS_VOID</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>THIS</name><argument_list>(<argument><expr><name>PgClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PG_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>PgClient</name> <modifier>*</modifier></type>
<name>pgClientNew</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>host</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>database</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TimeMSec</name></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>TIME_MSEC</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>port</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>port</name> <operator>&lt;=</operator> <literal type="number">65535</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>database</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PgClient</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>PgClient</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>, <argument>.callbackQty = <literal type="number">1</literal></argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>PgClient</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>pub</name> <operator>=</operator>
            <block>{
                <expr><operator>.</operator><name>host</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>port</name> <operator>=</operator> <name>port</name></expr>,
                <expr><operator>.</operator><name>database</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>user</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>timeout</name> <operator>=</operator> <name>timeout</name></expr>,
            }</block></expr>,
        }</block></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PG_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Just ignore notices and warnings
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgClientNoticeProcessor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>arg</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>message</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Encode string to escape ' and \
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>pgClientEscape</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_TEST_BEGIN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_TEST_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_TEST_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>string</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>strCatZ</name><argument_list>(<argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Iterate all characters in the string</comment>
    <for>for <control>(<init><decl><type><name>unsigned</name></type> <name>stringIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>stringIdx</name> <operator>&lt;</operator> <call><name>strSize</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>stringIdx</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name>stringChar</name> <init>= <expr><call><name>strZ</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call><index>[<expr><name>stringIdx</name></expr>]</index></expr></init></decl>;</decl_stmt>

        <comment type="line">// These characters are escaped</comment>
        <if_stmt><if>if <condition>(<expr><name>stringChar</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>||</operator> <name>stringChar</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>stringChar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_TEST_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>PgClient</name> <modifier>*</modifier></type>
<name>pgClientOpen</name><parameter_list>(<parameter><decl><type><name>PgClient</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PG_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"invalid connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Base connection string</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>connInfo</name> <init>= <expr><call><name>strCatFmt</name><argument_list>(
            <argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"dbname=%s port=%u"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgClientEscape</name><argument_list>(<argument><expr><call><name>pgClientDatabase</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pgClientPort</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Add user if specified</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pgClientUser</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>connInfo</name></expr></argument>, <argument><expr><literal type="string">" user=%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgClientEscape</name><argument_list>(<argument><expr><call><name>pgClientUser</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Add host if specified</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pgClientHost</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>connInfo</name></expr></argument>, <argument><expr><literal type="string">" host=%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>pgClientEscape</name><argument_list>(<argument><expr><call><name>pgClientHost</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Make the connection</comment>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <call><name>PQconnectdb</name><argument_list>(<argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>connInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Set a callback to shutdown the connection</comment>
        <expr_stmt><expr><call><name>memContextCallbackSet</name><argument_list>(<argument><expr><call><name>objMemContext</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pgClientFreeResource</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Handle errors</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                <argument><expr><name>DbConnectError</name></expr></argument>, <argument><expr><literal type="string">"unable to connect to '%s': %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>connInfo</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strTrim</name><argument_list>(<argument><expr><call><name>strNewZ</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Set notice and warning processor</comment>
        <expr_stmt><expr><call><name>PQsetNoticeProcessor</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name>pgClientNoticeProcessor</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PG_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>Pack</name> <modifier>*</modifier></type>
<name>pgClientQuery</name><parameter_list>(<parameter><decl><type><name>PgClient</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PgClientQueryResult</name></type> <name>resultType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PG_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_ID</name></expr></argument>, <argument><expr><name>resultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>AssertError</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"invalid connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>query</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>resultType</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Pack</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Send the query without waiting for results so we can timeout if needed</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                <argument><expr><name>DbQueryError</name></expr></argument>, <argument><expr><literal type="string">"unable to send query '%s': %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strTrim</name><argument_list>(<argument><expr><call><name>strNewZ</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Wait for a result</comment>
        <decl_stmt><decl><type><name>Wait</name> <modifier>*</modifier></type><name>wait</name> <init>= <expr><call><name>waitNew</name><argument_list>(<argument><expr><call><name>pgClientTimeout</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>busy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <do>do
        <block>{<block_content>
            <expr_stmt><expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>busy</name> <operator>=</operator> <call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        while <condition>(<expr><name>busy</name> <operator>&amp;&amp;</operator> <call><name>waitMore</name><argument_list>(<argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <comment type="line">// If the query is still busy after the timeout attempt to cancel</comment>
        <if_stmt><if>if <condition>(<expr><name>busy</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGcancel</name> <modifier>*</modifier></type><name>cancel</name> <init>= <expr><call><name>PQgetCancel</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If cancel is NULL then more than likely the server process crashed or disconnected</comment>
            <if_stmt><if>if <condition>(<expr><name>cancel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>DbQueryError</name></expr></argument>, <argument><expr><literal type="string">"unable to cancel query '%s': connection was lost"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name></type> <name><name>error</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQcancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>DbQueryError</name></expr></argument>, <argument><expr><literal type="string">"unable to cancel query '%s': %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strTrim</name><argument_list>(<argument><expr><call><name>strNewZ</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>
            <macro><name>FINALLY</name><argument_list>()</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Get the result (even if query was cancelled -- to prevent the connection being left in a bad state)</comment>
        <decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>pgResult</name> <init>= <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <macro><name>TRY_BEGIN</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// Throw timeout error if cancelled</comment>
            <if_stmt><if>if <condition>(<expr><name>busy</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>DbQueryError</name></expr></argument>, <argument><expr><literal type="string">"query '%s' timed out after %"</literal> <name>PRIu64</name> <literal type="string">"ms"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pgClientTimeout</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="line">// If this was a command that returned no results then we are done</comment>
            <decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>pgResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>resultType</name> <operator>!=</operator> <name>pgClientQueryResultNone</name> <operator>&amp;&amp;</operator> <name>resultType</name> <operator>!=</operator> <name>pgClientQueryResultAny</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>DbQueryError</name></expr></argument>, <argument><expr><literal type="string">"result expected from '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>resultType</name> <operator>==</operator> <name>pgClientQueryResultNone</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>DbQueryError</name></expr></argument>, <argument><expr><literal type="string">"no result expected from '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="line">// Expect some rows to be returned</comment>
                <if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                        <argument><expr><name>DbQueryError</name></expr></argument>, <argument><expr><literal type="string">"unable to execute query '%s': %s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strTrim</name><argument_list>(<argument><expr><call><name>strNewZ</name><argument_list>(<argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>pgResult</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Fetch row and column values</comment>
                <decl_stmt><decl><type><name>PackWrite</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pack</name> <init>= <expr><call><name>pckWriteNewP</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>rowTotal</name> <init>= <expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>pgResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>columnTotal</name> <init>= <expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>pgResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>resultType</name> <operator>!=</operator> <name>pgClientQueryResultAny</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>rowTotal</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>DbQueryError</name></expr></argument>, <argument><expr><literal type="string">"expected one row from '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>resultType</name> <operator>==</operator> <name>pgClientQueryResultColumn</name> <operator>&amp;&amp;</operator> <name>columnTotal</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(<argument><expr><name>DbQueryError</name></expr></argument>, <argument><expr><literal type="string">"expected one column from '%s'"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="line">// Get column types</comment>
                <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>columnType</name> <init>= <expr><call><name>memNew</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>columnTotal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>int</name></type> <name>columnIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIdx</name> <operator>&lt;</operator> <name>columnTotal</name></expr>;</condition> <incr><expr><name>columnIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>columnType</name><index>[<expr><name>columnIdx</name></expr>]</index></name> <operator>=</operator> <call><name>PQftype</name><argument_list>(<argument><expr><name>pgResult</name></expr></argument>, <argument><expr><name>columnIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

                <comment type="line">// Get values</comment>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>rowIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rowIdx</name> <operator>&lt;</operator> <name>rowTotal</name></expr>;</condition> <incr><expr><name>rowIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>resultType</name> <operator>==</operator> <name>pgClientQueryResultAny</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>pckWriteArrayBeginP</name><argument_list>(<argument><expr><name>pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <for>for <control>(<init><decl><type><name>int</name></type> <name>columnIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIdx</name> <operator>&lt;</operator> <name>columnTotal</name></expr>;</condition> <incr><expr><name>columnIdx</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>pgResult</name></expr></argument>, <argument><expr><name>rowIdx</name></expr></argument>, <argument><expr><name>columnIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <comment type="line">// If value is zero-length then check if it is null</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>value</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>PQgetisnull</name><argument_list>(<argument><expr><name>pgResult</name></expr></argument>, <argument><expr><name>rowIdx</name></expr></argument>, <argument><expr><name>columnIdx</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>pckWriteNullP</name><argument_list>(<argument><expr><name>pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <comment type="line">// Else convert the value to a variant</comment>
                        <else>else
                        <block>{<block_content>
                            <comment type="line">// Convert column type.  Not all PostgreSQL types are supported but these should suffice.</comment>
                            <switch>switch <condition>(<expr><name><name>columnType</name><index>[<expr><name>columnIdx</name></expr>]</index></name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="line">// Boolean type</comment>
                                <case>case <expr><literal type="number">16</literal></expr>:</case>                            <comment type="line">// bool</comment>
                                    <expr_stmt><expr><call><name>pckWriteBoolP</name><argument_list>(<argument><expr><name>pack</name></expr></argument>, <argument><expr><call><name>varBoolForce</name><argument_list>(<argument><expr><call><name>varNewStrZ</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>defaultWrite</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>

                                <comment type="line">// Text/char types</comment>
                                <case>case <expr><literal type="number">18</literal></expr>:</case>                            <comment type="line">// char</comment>
                                <case>case <expr><literal type="number">19</literal></expr>:</case>                            <comment type="line">// name</comment>
                                <case>case <expr><literal type="number">25</literal></expr>:</case>                            <comment type="line">// text</comment>
                                    <expr_stmt><expr><call><name>pckWriteStrP</name><argument_list>(<argument><expr><name>pack</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>defaultWrite</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>

                                <comment type="line">// 64-bit integer type</comment>
                                <case>case <expr><literal type="number">20</literal></expr>:</case>                            <comment type="line">// int8</comment>
                                    <expr_stmt><expr><call><name>pckWriteI64P</name><argument_list>(<argument><expr><name>pack</name></expr></argument>, <argument><expr><call><name>cvtZToInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>defaultWrite</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>

                                <comment type="line">// 32-bit integer type</comment>
                                <case>case <expr><literal type="number">23</literal></expr>:</case>                            <comment type="line">// int4</comment>
                                    <expr_stmt><expr><call><name>pckWriteI32P</name><argument_list>(<argument><expr><name>pack</name></expr></argument>, <argument><expr><call><name>cvtZToInt</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>defaultWrite</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>

                                <comment type="line">// 32-bit unsigned integer type</comment>
                                <case>case <expr><literal type="number">26</literal></expr>:</case>                            <comment type="line">// oid</comment>
                                    <expr_stmt><expr><call><name>pckWriteU32P</name><argument_list>(<argument><expr><name>pack</name></expr></argument>, <argument><expr><call><name>cvtZToUInt</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>defaultWrite</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>

                                <default>default:</default>
                                    <expr_stmt><expr><call><name>THROW_FMT</name><argument_list>(
                                        <argument><expr><name>FormatError</name></expr></argument>, <argument><expr><literal type="string">"unable to parse type %u in column %d for query '%s'"</literal></expr></argument>,
                                        <argument><expr><name><name>columnType</name><index>[<expr><name>columnIdx</name></expr>]</index></name></expr></argument>, <argument><expr><name>columnIdx</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></switch>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></for>

                    <if_stmt><if>if <condition>(<expr><name>resultType</name> <operator>==</operator> <name>pgClientQueryResultAny</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>pckWriteArrayEndP</name><argument_list>(<argument><expr><name>pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="line">// End pack and return result</comment>
                <expr_stmt><expr><call><name>pckWriteEndP</name><argument_list>(<argument><expr><name>pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pckMove</name><argument_list>(<argument><expr><call><name>pckWriteResult</name><argument_list>(<argument><expr><name>pack</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>memContextPrior</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>
        <macro><name>FINALLY</name><argument_list>()</argument_list></macro>
        <block>{<block_content>
            <comment type="line">// Free the result</comment>
            <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>pgResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>ServiceError</name></expr></argument>, <argument><expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"NULL result required to complete request"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>TRY_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>PACK</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>pgClientClose</name><parameter_list>(<parameter><decl><type><name>PgClient</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>PG_CLIENT</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memContextCallbackClear</name><argument_list>(<argument><expr><call><name>objMemContext</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>String</name> <modifier>*</modifier></type>
<name>pgClientToLog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PgClient</name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>strNewFmt</name><argument_list>(
        <argument><expr><literal type="string">"{host: %s, port: %u, database: %s, user: %s, queryTimeout %"</literal> <name>PRIu64</name> <literal type="string">"}"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strToLog</name><argument_list>(<argument><expr><call><name>pgClientHost</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>pgClientPort</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strToLog</name><argument_list>(<argument><expr><call><name>pgClientDatabase</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strToLog</name><argument_list>(<argument><expr><call><name>pgClientUser</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pgClientTimeout</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
