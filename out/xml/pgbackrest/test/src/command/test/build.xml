<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pgbackrest/test/src/command/test/build.c"><comment type="block" format="doxygen">/***********************************************************************************************************************************
Test Build Handler
***********************************************************************************************************************************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build.auto.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"build/common/render.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command/test/build.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/posix/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"version.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Object type
***********************************************************************************************************************************/</comment>
<struct>struct <name>TestBuild</name>
<block>{
    <decl_stmt><decl><type><name>TestBuildPub</name></type> <name>pub</name></decl>;</decl_stmt>                                               <comment type="line">// Publicly accessible variables</comment>
}</block>;</struct>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Constants
***********************************************************************************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MESON_COMMENT_BLOCK</name></cpp:macro>                                                                                                        \
    <cpp:value>"############################################################################################################################" \
    "########"</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>TestBuild</name> <modifier>*</modifier></type>
<name>testBldNew</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pathRepo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pathTest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>vm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>vmId</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>TestDefModule</name> <modifier>*</modifier><specifier>const</specifier></type> <name>module</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>test</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>scale</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LogLevel</name></type> <name>logLevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>logTime</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>timeZone</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>coverage</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>profile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>optimize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pathRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>pathTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>vmId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM_P</name><argument_list>(<argument><expr><name>VOID</name></expr></argument>, <argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT</name></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>UINT64</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>ENUM</name></expr></argument>, <argument><expr><name>logLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>logTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>timeZone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>coverage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>profile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BOOL</name></expr></argument>, <argument><expr><name>optimize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pathRepo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>pathTest</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>vm</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>module</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>scale</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>TestBuild</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>OBJ_NEW_BEGIN</name><argument_list>(<argument>TestBuild</argument>, <argument>.childQty = MEM_CONTEXT_QTY_MAX</argument>)</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Create object</comment>
        <expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>OBJ_NEW_ALLOC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <operator>(</operator><name>TestBuild</name><operator>)</operator>
        <block>{
            <expr><operator>.</operator><name>pub</name> <operator>=</operator>
            <block>{
                <expr><operator>.</operator><name>pathRepo</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>pathRepo</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>pathTest</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>pathTest</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>vm</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>vmId</name> <operator>=</operator> <name>vmId</name></expr>,
                <expr><operator>.</operator><name>module</name> <operator>=</operator> <name>module</name></expr>,
                <expr><operator>.</operator><name>test</name> <operator>=</operator> <name>test</name></expr>,
                <expr><operator>.</operator><name>scale</name> <operator>=</operator> <name>scale</name></expr>,
                <expr><operator>.</operator><name>logLevel</name> <operator>=</operator> <name>logLevel</name></expr>,
                <expr><operator>.</operator><name>logTime</name> <operator>=</operator> <name>logTime</name></expr>,
                <expr><operator>.</operator><name>timeZone</name> <operator>=</operator> <call><name>strDup</name><argument_list>(<argument><expr><name>timeZone</name></expr></argument>)</argument_list></call></expr>,
                <expr><operator>.</operator><name>coverage</name> <operator>=</operator> <name>coverage</name></expr>,
                <expr><operator>.</operator><name>profile</name> <operator>=</operator> <name>profile</name></expr>,
                <expr><operator>.</operator><name>optimize</name> <operator>=</operator> <name>optimize</name></expr>,
            }</block></expr>,
        }</block></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>storageRepo</name></name> <operator>=</operator> <call><name>storagePosixNewP</name><argument_list>(<argument><expr><call><name>testBldPathRepo</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>storageTest</name></name> <operator>=</operator> <call><name>storagePosixNewP</name><argument_list>(<argument><expr><call><name>testBldPathTest</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>OBJ_NEW_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>TEST_BUILD</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Shim functions in a module
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>testBldShim</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>shimC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>functionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>shimC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>functionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>inList</name> <init>= <expr><call><name>strLstNewSplitZ</name><argument_list>(<argument><expr><name>shimC</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>strEmpty</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>inList</name></expr></argument>, <argument><expr><call><name>strLstSize</name><argument_list>(<argument><expr><name>inList</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>inIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>inIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>inList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>inIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>in</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>inList</name></expr></argument>, <argument><expr><name>inIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Check if this line contains a shimmed function</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>functionIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>functionIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>functionList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>functionIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>function</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>functionList</name></expr></argument>, <argument><expr><name>functionIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>strBeginsWith</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>function</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strChr</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strSize</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>inIdx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                    <comment type="line">// If static then build a declaration so the function is able to call itself</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>strBeginsWithZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>inList</name></expr></argument>, <argument><expr><name>inIdx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"static "</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>scanIdx</name> <init>= <expr><name>inIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>scanIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>inList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>scanIdx</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>scan</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>inList</name></expr></argument>, <argument><expr><name>scanIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>strEqZ</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <break>break;</break></block_content></block></if></if_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>strEndsWithZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>inList</name></expr></argument>, <argument><expr><name>scanIdx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                            <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>strTrim</name><argument_list>(<argument><expr><call><name>strDup</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>

                        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>inList</name></expr></argument>, <argument><expr><name>inIdx</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="line">// Alter the function name so it can be shimmed</comment>
                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\n%s_SHIMMED%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strSub</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><call><name>strSize</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="line">// Just copy the line when a function is not found</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>inIdx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>strCat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Write files into the test path and keep a list of files written
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>testBldWrite</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storage</name></decl></parameter>, <parameter><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fileList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Buffer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>content</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STORAGE</name></expr></argument>, <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING_LIST</name></expr></argument>, <argument><expr><name>fileList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRINGZ</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>BUFFER</name></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <comment type="line">// Only write if the content has changed</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>Buffer</name> <modifier>*</modifier><specifier>const</specifier></type> <name>current</name> <init>= <expr><call><name>storageGetP</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>ignoreMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>current</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>bufEq</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>storagePutP</name><argument_list>(<argument><expr><call><name>storageNewWriteP</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>strLstAddZ</name><argument_list>(<argument><expr><name>fileList</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***********************************************************************************************************************************
Generate a relative path from the compare path to the base path

??? This function has not been hardened for edge cases, e.g. paths are equal. Probably this should he moved to the storage module.
***********************************************************************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>cmdBldPathRelative</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>compare</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>base</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>compare</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>baseList</name> <init>= <expr><call><name>strLstNewSplitZ</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>compareList</name> <init>= <expr><call><name>strLstNewSplitZ</name><argument_list>(<argument><expr><name>compare</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>compareIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">// Find the part of the paths that is the same</comment>
        <while>while <condition>(
            <expr><name>compareIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>baseList</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>compareIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>compareList</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>strEq</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>baseList</name></expr></argument>, <argument><expr><name>compareIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>compareList</name></expr></argument>, <argument><expr><name>compareIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>compareIdx</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="line">// Generate ../ part of relative path</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>dotIdx</name> <init>= <expr><name>compareIdx</name></expr></init></decl>;</init> <condition><expr><name>dotIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>baseList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>dotIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Add remaining path</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>pathIdx</name> <init>= <expr><name>compareIdx</name></expr></init></decl>;</init> <condition><expr><name>pathIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>compareList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pathIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>compareList</name></expr></argument>, <argument><expr><name>pathIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**********************************************************************************************************************************/</comment>
<function><type><name>void</name></type>
<name>testBldUnit</name><parameter_list>(<parameter><decl><type><name>TestBuild</name> <modifier>*</modifier><specifier>const</specifier></type> <name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>FUNCTION_LOG_BEGIN</name><argument_list>(<argument><expr><name>logLevelDebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FUNCTION_LOG_PARAM</name><argument_list>(<argument><expr><name>TEST_BUILD</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FUNCTION_LOG_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>userInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <macro><name>MEM_CONTEXT_TEMP_BEGIN</name><argument_list>()</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storageUnit</name> <init>= <expr><call><name>storagePosixNewP</name><argument_list>(
            <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/unit-%u/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>testBldPathTest</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>testBldVmId</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>testBldVm</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>write</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>Storage</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storageTestId</name> <init>= <expr><call><name>storagePosixNewP</name><argument_list>(
            <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/test-%u"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>testBldPathTest</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>testBldVmId</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>write</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storageUnitList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>TestDefModule</name> <modifier>*</modifier><specifier>const</specifier></type> <name>module</name> <init>= <expr><call><name>testBldModule</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pathUnit</name> <init>= <expr><call><name>storagePathP</name><argument_list>(<argument><expr><name>storageUnit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pathRepo</name> <init>= <expr><call><name>testBldPathRepo</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pathRepoRel</name> <init>= <expr><call><name>cmdBldPathRelative</name><argument_list>(<argument><expr><name>pathUnit</name></expr></argument>, <argument><expr><name>pathRepo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Build shim modules</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>shimIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shimIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>shimList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>shimIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>TestDefShim</name> <modifier>*</modifier><specifier>const</specifier></type> <name>shim</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>shimList</name></name></expr></argument>, <argument><expr><name>shimIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>shimFile</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"src/%s.c"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>shim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>shimC</name> <init>= <expr><call><name>strCatBuf</name><argument_list>(
                <argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name>storageGetP</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><call><name>testBldStorageRepo</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathRepo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>shimFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>testBldWrite</name><argument_list>(<argument><expr><name>storageUnit</name></expr></argument>, <argument><expr><name>storageUnitList</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>shimFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BUFSTR</name><argument_list>(<argument><expr><call><name>testBldShim</name><argument_list>(<argument><expr><name>shimC</name></expr></argument>, <argument><expr><name><name>shim</name><operator>-&gt;</operator><name>functionList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Build harness modules</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>harnessList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>harnessIncludeList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>harnessIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>harnessIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>harnessList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>harnessIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>TestDefHarness</name> <modifier>*</modifier><specifier>const</specifier></type> <name>harness</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>harnessList</name></name></expr></argument>, <argument><expr><name>harnessIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>harnessFile</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"test/src/common/%s.c"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>bldEnum</name><argument_list>(<argument><expr><literal type="string">"harness"</literal></expr></argument>, <argument><expr><name><name>harness</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier></type><name>harnessPath</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathRepo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>harnessFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// If there are includes then copy and update the harness</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstEmpty</name><argument_list>(<argument><expr><name><name>harness</name><operator>-&gt;</operator><name>includeList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>includeReplace</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>includeIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>includeIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>harness</name><operator>-&gt;</operator><name>includeList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>includeIdx</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>include</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>harness</name><operator>-&gt;</operator><name>includeList</name></name></expr></argument>, <argument><expr><name>includeIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                        <argument><expr><name>includeReplace</name></expr></argument>, <argument><expr><literal type="string">"%s#include \"%s/src/%s.c\""</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>includeIdx</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"\n"</literal></expr></else></ternary></expr></argument>,
                        <argument><expr><ternary><condition><expr><call><name>lstExists</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>shimList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>include</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathUnit</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathRepo</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>include</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>harnessIncludeList</name></expr></argument>, <argument><expr><name>include</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>harnessC</name> <init>= <expr><call><name>strCatBuf</name><argument_list>(<argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>storageGetP</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><call><name>testBldStorageRepo</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>harnessPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>harnessC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[SHIM_MODULE]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>includeReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>testBldWrite</name><argument_list>(<argument><expr><name>storageUnit</name></expr></argument>, <argument><expr><name>storageUnitList</name></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>harnessFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BUFSTR</name><argument_list>(<argument><expr><name>harnessC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>harnessList</name></expr></argument>, <argument><expr><name>harnessFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="line">// Else harness can be referenced directly from the repo path</comment>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strLstAddFmt</name><argument_list>(<argument><expr><name>harnessList</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathRepoRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>harnessFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="line">// Copy meson_options.txt</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <expr_stmt><expr><call><name>testBldWrite</name><argument_list>(
            <argument><expr><name>storageUnit</name></expr></argument>, <argument><expr><name>storageUnitList</name></expr></argument>, <argument><expr><literal type="string">"meson_options.txt"</literal></expr></argument>,
            <argument><expr><call><name>storageGetP</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><call><name>testBldStorageRepo</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"meson_options.txt"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Build meson.build</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>mesonBuild</name> <init>= <expr><call><name>strCatBuf</name><argument_list>(
            <argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>storageGetP</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><call><name>testBldStorageRepo</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"meson.build"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Comment out subdirs that are not used for testing</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>mesonBuild</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"subdir('"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"# subdir('"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Write build.auto.in</comment>
        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(
            <argument><expr><name>mesonBuild</name></expr></argument>,
            <argument><expr><literal type="string">"\n"</literal>
            <name>MESON_COMMENT_BLOCK</name> <literal type="string">"\n"</literal>
            <literal type="string">"# Write configuration\n"</literal>
            <name>MESON_COMMENT_BLOCK</name> <literal type="string">"\n"</literal>
            <literal type="string">"configure_file(output: 'build.auto.h', configuration: configuration)\n"</literal>
            <literal type="string">"\n"</literal>
            <literal type="string">"add_global_arguments('-DERROR_MESSAGE_BUFFER_SIZE=131072', language : 'c')\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Configure features</comment>
        <if_stmt><if>if <condition>(<expr><name><name>module</name><operator>-&gt;</operator><name>feature</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>mesonBuild</name></expr></argument>, <argument><expr><literal type="string">"add_global_arguments('-DHRN_INTEST_%s', language : 'c')\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>feature</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>module</name><operator>-&gt;</operator><name>featureList</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>featureIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>featureIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>featureList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>featureIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                    <argument><expr><name>mesonBuild</name></expr></argument>, <argument><expr><literal type="string">"add_global_arguments('-DHRN_FEATURE_%s', language : 'c')\n"</literal></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>featureList</name></name></expr></argument>, <argument><expr><name>featureIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Add compiler flags</comment>
        <if_stmt><if>if <condition>(<expr><name><name>module</name><operator>-&gt;</operator><name>flag</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>mesonBuild</name></expr></argument>, <argument><expr><literal type="string">"add_global_arguments('%s', language : 'c')\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>flag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Add coverage</comment>
        <if_stmt><if>if <condition>(<expr><call><name>testBldCoverage</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>mesonBuild</name></expr></argument>, <argument><expr><literal type="string">"add_global_arguments('-DDEBUG_COVERAGE', language : 'c')\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Add container flag</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEqZ</name><argument_list>(<argument><expr><call><name>testBldVm</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>mesonBuild</name></expr></argument>, <argument><expr><literal type="string">"add_global_arguments('-DTEST_CONTAINER_REQUIRED', language : 'c')\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="line">// Build unit test</comment>
        <expr_stmt><expr><call><name>strCatZ</name><argument_list>(
            <argument><expr><name>mesonBuild</name></expr></argument>,
            <argument><expr><literal type="string">"\n"</literal>
            <name>MESON_COMMENT_BLOCK</name> <literal type="string">"\n"</literal>
            <literal type="string">"# Unit test\n"</literal>
            <name>MESON_COMMENT_BLOCK</name> <literal type="string">"\n"</literal>
            <literal type="string">"src_unit = files(\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>dependIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>dependIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>dependList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>dependIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>depend</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>dependList</name></name></expr></argument>, <argument><expr><name>dependIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strLstExists</name><argument_list>(<argument><expr><name>harnessIncludeList</name></expr></argument>, <argument><expr><name>depend</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>mesonBuild</name></expr></argument>, <argument><expr><literal type="string">"    '%s/src/%s.c',\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathRepoRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>depend</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="line">// Add harnesses</comment>
        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>harnessIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>harnessIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>harnessList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>harnessIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>TestDefHarness</name> <modifier>*</modifier><specifier>const</specifier></type> <name>harness</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>harnessList</name></name></expr></argument>, <argument><expr><name>harnessIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Add harness depends</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>harnessDependPath</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"test/src/common/%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>bldEnum</name><argument_list>(<argument><expr><literal type="string">"harness"</literal></expr></argument>, <argument><expr><name><name>harness</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>StorageIterator</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storageItr</name> <init>= <expr><call><name>storageNewItrP</name><argument_list>(
                <argument><expr><call><name>testBldStorageRepo</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>harnessDependPath</name></expr></argument>, <argument><expr><operator>.</operator><name>expression</name> <operator>=</operator> <call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"\\.c$"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>.</operator><name>sortOrder</name> <operator>=</operator> <name>sortOrderAsc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><call><name>storageItrMore</name><argument_list>(<argument><expr><name>storageItr</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                    <argument><expr><name>mesonBuild</name></expr></argument>, <argument><expr><literal type="string">"    '%s/%s/%s',\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathRepoRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>harnessDependPath</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>storageItrNext</name><argument_list>(<argument><expr><name>storageItr</name></expr></argument>)</argument_list></call><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

            <comment type="line">// Add harness if no includes are in module or coverage includes</comment>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>includeIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init>;</init> <condition><expr><name>includeIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>harness</name><operator>-&gt;</operator><name>includeList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>includeIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>include</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>harness</name><operator>-&gt;</operator><name>includeList</name></name></expr></argument>, <argument><expr><name>includeIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>lstExists</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>coverageList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>include</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strLstExists</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>includeList</name></name></expr></argument>, <argument><expr><name>include</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><name>includeIdx</name> <operator>!=</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>harness</name><operator>-&gt;</operator><name>includeList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>mesonBuild</name></expr></argument>, <argument><expr><literal type="string">"    '%s',\n"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>harnessList</name></expr></argument>, <argument><expr><name>harnessIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
            <argument><expr><name>mesonBuild</name></expr></argument>,
            <argument><expr><literal type="string">"    '%s/test/src/common/harnessTest.c',\n"</literal>
            <literal type="string">"    'test.c',\n"</literal>
            <literal type="string">")\n"</literal>
            <literal type="string">"\n"</literal>
            <literal type="string">"executable(\n"</literal>
            <literal type="string">"    'test-unit',\n"</literal>
            <literal type="string">"    sources: src_unit,\n"</literal></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathRepoRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Add C args</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cArg</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>testBldOptimize</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>module</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>testDefTypePerformance</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>cArg</name></expr></argument>, <argument><expr><literal type="string">"\n        '-O2',"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>testBldProfile</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(
                <argument><expr><name>cArg</name></expr></argument>,
                <argument><expr><literal type="string">"\n        '-pg',"</literal>
                <literal type="string">"\n        '-no-pie',"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEmpty</name><argument_list>(<argument><expr><name>cArg</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                <argument><expr><name>mesonBuild</name></expr></argument>,
                <argument><expr><literal type="string">"    c_args: [%s\n"</literal>
                <literal type="string">"    ],\n"</literal></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>cArg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Add linker args</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>linkArg</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>testBldProfile</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strCatZ</name><argument_list>(
                <argument><expr><name>linkArg</name></expr></argument>,
                <argument><expr><literal type="string">"\n        '-pg',"</literal>
                <literal type="string">"\n        '-no-pie',"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strEmpty</name><argument_list>(<argument><expr><name>linkArg</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                <argument><expr><name>mesonBuild</name></expr></argument>,
                <argument><expr><literal type="string">"    link_args: [%s\n"</literal>
                <literal type="string">"    ],\n"</literal></expr></argument>,
                <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>linkArg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
            <argument><expr><name>mesonBuild</name></expr></argument>,
            <argument><expr><literal type="string">"    include_directories:\n"</literal>
            <literal type="string">"        include_directories(\n"</literal>
            <literal type="string">"            '.',\n"</literal>
            <literal type="string">"            '%s/src',\n"</literal>
            <literal type="string">"            '%s/test/src',\n"</literal>
            <literal type="string">"        ),\n"</literal>
            <literal type="string">"    dependencies: [\n"</literal>
            <literal type="string">"        lib_bz2,\n"</literal>
            <literal type="string">"        lib_openssl,\n"</literal>
            <literal type="string">"        lib_lz4,\n"</literal>
            <literal type="string">"        lib_pq,\n"</literal>
            <literal type="string">"        lib_xml,\n"</literal>
            <literal type="string">"        lib_yaml,\n"</literal>
            <literal type="string">"        lib_z,\n"</literal>
            <literal type="string">"        lib_zstd,\n"</literal>
            <literal type="string">"    ],\n"</literal>
            <literal type="string">")\n"</literal></expr></argument>,
            <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathRepoRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathRepoRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>testBldWrite</name><argument_list>(<argument><expr><name>storageUnit</name></expr></argument>, <argument><expr><name>storageUnitList</name></expr></argument>, <argument><expr><literal type="string">"meson.build"</literal></expr></argument>, <argument><expr><call><name>BUFSTR</name><argument_list>(<argument><expr><name>mesonBuild</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Build test.c</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>testC</name> <init>= <expr><call><name>strCatBuf</name><argument_list>(
            <argument><expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>storageGetP</name><argument_list>(<argument><expr><call><name>storageNewReadP</name><argument_list>(<argument><expr><call><name>testBldStorageRepo</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"test/src/test.c"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Enable debug test trace</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>testBldProfile</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>module</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>testDefTypePerformance</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_DEBUG_TEST_TRACE]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"#define DEBUG_TEST_TRACE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_DEBUG_TEST_TRACE]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"// Debug test trace not enabled"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="line">// Files to test/include</comment>
        <decl_stmt><decl><type><name>StringList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>testIncludeFileList</name> <init>= <expr><call><name>strLstNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>module</name><operator>-&gt;</operator><name>coverageList</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>coverageIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>coverageIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>coverageList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>coverageIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>TestDefCoverage</name> <modifier>*</modifier><specifier>const</specifier></type> <name>coverage</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>coverageList</name></name></expr></argument>, <argument><expr><name>coverageIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>coverage</name><operator>-&gt;</operator><name>coverable</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>coverage</name><operator>-&gt;</operator><name>include</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>testIncludeFileList</name></expr></argument>, <argument><expr><name><name>coverage</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>module</name><operator>-&gt;</operator><name>includeList</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>includeIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>includeIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>includeList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>includeIdx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strLstAdd</name><argument_list>(<argument><expr><name>testIncludeFileList</name></expr></argument>, <argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>includeList</name></name></expr></argument>, <argument><expr><name>includeIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>testIncludeFile</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>testIncludeFileIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>testIncludeFileIdx</name> <operator>&lt;</operator> <call><name>strLstSize</name><argument_list>(<argument><expr><name>testIncludeFileList</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>testIncludeFileIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>include</name> <init>= <expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>testIncludeFileList</name></expr></argument>, <argument><expr><name>testIncludeFileIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>harnessIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init>;</init> <condition><expr><name>harnessIdx</name> <operator>&lt;</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>harnessList</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>harnessIdx</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>TestDefHarness</name> <modifier>*</modifier><specifier>const</specifier></type> <name>harness</name> <init>= <expr><call><name>lstGet</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>harnessList</name></name></expr></argument>, <argument><expr><name>harnessIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>strLstExists</name><argument_list>(<argument><expr><name><name>harness</name><operator>-&gt;</operator><name>includeList</name></name></expr></argument>, <argument><expr><name>include</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><name>testIncludeFileIdx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strCatChr</name><argument_list>(<argument><expr><name>testIncludeFile</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>harnessIdx</name> <operator>!=</operator> <call><name>lstSize</name><argument_list>(<argument><expr><name><name>module</name><operator>-&gt;</operator><name>harnessList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>testIncludeFile</name></expr></argument>, <argument><expr><literal type="string">"#include \"%s\""</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>strLstGet</name><argument_list>(<argument><expr><name>harnessList</name></expr></argument>, <argument><expr><name>harnessIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(<argument><expr><name>testIncludeFile</name></expr></argument>, <argument><expr><literal type="string">"#include \"%s/src/%s.c\""</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathRepoRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>include</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_INCLUDE]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>testIncludeFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Test path</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_PATH]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>storagePathP</name><argument_list>(<argument><expr><name>storageTestId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Harness data path</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pathHarnessData</name> <init>= <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/data-%u"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>testBldPathTest</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>testBldVmId</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_HRN_PATH]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pathHarnessData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Harness repo path</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_HRN_PATH_REPO]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pathRepo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Path to the project exe when it exists</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>pathProjectExe</name> <init>= <expr><call><name>storagePathP</name><argument_list>(
            <argument><expr><call><name>testBldStorageTest</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strNewFmt</name><argument_list>(
                <argument><expr><literal type="string">"%s/%s%s/"</literal> <name>PROJECT_BIN</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>strEqZ</name><argument_list>(<argument><expr><call><name>testBldVm</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"build"</literal></expr> </then><else>: <expr><literal type="string">"bin"</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>testBldVm</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><ternary><condition><expr><call><name>strEqZ</name><argument_list>(<argument><expr><call><name>testBldVm</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"/src"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_PROJECT_EXE]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pathProjectExe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Path to source -- used to construct __FILENAME__ tests</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_PGB_PATH]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"../%s"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathRepoRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Test log level</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(
            <argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_LOG_LEVEL_TEST]}"</literal></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>bldEnum</name><argument_list>(<argument><expr><literal type="string">"logLevel"</literal></expr></argument>, <argument><expr><call><name>strLower</name><argument_list>(<argument><expr><call><name>strNewZ</name><argument_list>(<argument><expr><call><name>logLevelStr</name><argument_list>(<argument><expr><call><name>testBldLogLevel</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Log time/timestamp</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_TIMING]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>cvtBoolToConstZ</name><argument_list>(<argument><expr><call><name>testBldLogTime</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Test timezone</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(
            <argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_TZ]}"</literal></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><ternary><condition><expr><call><name>testBldTimeZone</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr> ?</condition><then>
                <expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"// No timezone specified"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"setenv(\"TZ\", \"%s\", true);"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>testBldTimeZone</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Scale performance test</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_SCALE]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><call><name>testBldScale</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Does this test run in a container?</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_CONTAINER]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>cvtBoolToConstZ</name><argument_list>(<argument><expr><operator>!</operator><call><name>strEqZ</name><argument_list>(<argument><expr><call><name>testBldVm</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// User/group info</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_GROUP]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>groupName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_GROUP_ID]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><call><name>groupId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_USER]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>userName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_USER_ID]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><call><name>userId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Test id</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_IDX]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><call><name>testBldVmId</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Include test file</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(
            <argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_INCLUDE]}"</literal></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"#include \"%s/test/src/module/%sTest.c\""</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathRepoRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><call><name>bldEnum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>module</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Test list</comment>
        <decl_stmt><decl><type><name>String</name> <modifier>*</modifier><specifier>const</specifier></type> <name>testList</name> <init>= <expr><call><name>strNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>testIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>testIdx</name> <operator>&lt;</operator> <name><name>module</name><operator>-&gt;</operator><name>total</name></name></expr>;</condition> <incr><expr><name>testIdx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>testIdx</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strCatZ</name><argument_list>(<argument><expr><name>testList</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>strCatFmt</name><argument_list>(
                <argument><expr><name>testList</name></expr></argument>, <argument><expr><literal type="string">"hrnAdd(%3u, %8s);"</literal></expr></argument>, <argument><expr><name>testIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                <argument><expr><call><name>cvtBoolToConstZ</name><argument_list>(<argument><expr><call><name>testBldTest</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>testBldTest</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>testIdx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_LIST]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>testList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Profiling</comment>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_PROFILE]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><call><name>cvtBoolToConstZ</name><argument_list>(<argument><expr><call><name>testBldProfile</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strReplace</name><argument_list>(<argument><expr><name>testC</name></expr></argument>, <argument><expr><call><name>STRDEF</name><argument_list>(<argument><expr><literal type="string">"{[C_TEST_PATH_BUILD]}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strNewFmt</name><argument_list>(<argument><expr><literal type="string">"%s/build"</literal></expr></argument>, <argument><expr><call><name>strZ</name><argument_list>(<argument><expr><name>pathUnit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Write file</comment>
        <expr_stmt><expr><call><name>testBldWrite</name><argument_list>(<argument><expr><name>storageUnit</name></expr></argument>, <argument><expr><name>storageUnitList</name></expr></argument>, <argument><expr><literal type="string">"test.c"</literal></expr></argument>, <argument><expr><call><name>BUFSTR</name><argument_list>(<argument><expr><name>testC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Clean files that are not valid for this test</comment>
        <comment type="line">// -------------------------------------------------------------------------------------------------------------------------</comment>
        <decl_stmt><decl><type><name>StorageIterator</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storageItr</name> <init>= <expr><call><name>storageNewItrP</name><argument_list>(<argument><expr><name>storageUnit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>.</operator><name>recurse</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><call><name>storageItrMore</name><argument_list>(<argument><expr><name>storageItr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>StorageInfo</name></type> <name>info</name> <init>= <expr><call><name>storageItrNext</name><argument_list>(<argument><expr><name>storageItr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>storageTypeFile</name> <operator>||</operator> <call><name>strBeginsWithZ</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"build/"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strLstExists</name><argument_list>(<argument><expr><name>storageUnitList</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>storageRemoveP</name><argument_list>(<argument><expr><name>storageUnit</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>.</operator><name>errorOnMissing</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block>
    <expr_stmt><expr><call><name>MEM_CONTEXT_TEMP_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>FUNCTION_LOG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
