<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/time_utils.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/timestamp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/date.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_coerce.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_bucket.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>subtract_interval_from_now</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Interval</name> <modifier>*</modifier></type><name>interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>res</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamptz_timestamp</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_mi_interval</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_mi_interval</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamptz_timestamp</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_mi_interval</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_date</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown time type %s"</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_time_datum_convert_arg</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>type</name> <init>= <expr><operator>*</operator><name>argtype</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>infuncid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>typeioparam</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>timetype</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>infuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><call><name>get_func_nargs</name><argument_list>(<argument><expr><name>infuncid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<comment type="block">/* Functions that take one input argument, e.g., the Date function */</comment>
				<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>infuncid</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">3</literal></expr>:</case>
				<comment type="block">/* Timestamp functions take three input arguments */</comment>
				<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>OidFunctionCall3</name><argument_list>(<argument><expr><name>infuncid</name></expr></argument>,
									   <argument><expr><name>arg</name></expr></argument>,
									   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time argument"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Time argument requires an explicit cast."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<expr_stmt><expr><operator>*</operator><name>argtype</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>arg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the internal time value from a pseudo-type function argument.
 *
 * API functions that take supported time types as arguments often use a
 * pseudo-type parameter to represent these. For instance, the "any"
 * pseudo-type is often used to represent any of these supported types.
 *
 * The downside of "any", however, is that it lacks type information and often
 * forces users to add explicit type casts. For instance, with the following
 * API call
 *
 * drop_chunk('conditions', '2020-10-01');
 *
 * the argument type will be UNKNOWNOID. And the user would have to add
 * an explicit type cast:
 *
 * drop_chunks('conditions', '2020-10-01'::date);
 *
 * However, we can handle the UNKNOWNOID case since we have the time type
 * information in internal metadata (e.g., the time column type of a
 * hypertable) and we can try to convert the argument to that type.
 *
 * Thus, there are two cases:
 *
 * 1. An explicit cast was done --&gt; the type is given in argtype.
 * 2. No cast was done --&gt; we try to convert the argument to the known time
 *    type.
 *
 * If an unsupported type is given, or the typeless argument has a nonsensical
 * string, then there will be an error raised.
 */</comment>
<function><type><name>int64</name></type>
<name>ts_time_value_from_arg</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>argtype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If no explicit cast was done by the user, try to convert the argument
	 * to the time type used by the continuous aggregate. */</comment>
	<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>ts_time_datum_convert_arg</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argtype</name></expr></argument>, <argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argtype</name> <operator>==</operator> <name>INTERVALOID</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(
						 <argument><expr><literal type="string">"can only use an INTERVAL for TIMESTAMP, TIMESTAMPTZ, and DATE types"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>subtract_interval_from_now</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>, <argument><expr><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argtype</name> <operator>=</operator> <name>timetype</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>argtype</name> <operator>!=</operator> <name>timetype</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>argtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timetype</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid time argument type \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try casting the argument to \"%s\"."</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to coerce a type to a supported time type.
 *
 * To support custom time types in hypertables, we need to know the type's
 * boundaries in order to, e.g., construct dimensional chunk constraints. The
 * custom time type will inherit the valid time range of the supported time
 * type it can be casted to.
 *
 * Currently, we only support custom time types that are binary compatible
 * with bigint and then it also inherits the valid time range of a bigint.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>coerce_to_time_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ts_type_is_int8_binary_compatible</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>INT8OID</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported time type \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the min time datum for a time type.
 *
 * Note that the min is not the same the actual "min" of the underlying
 * storage for date and timestamps.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_time_datum_get_min</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>TS_DATE_MIN</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>TS_TIMESTAMP_MIN</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>TS_TIMESTAMP_MIN</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>PG_INT16_MIN</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>PG_INT32_MIN</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>PG_INT64_MIN</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>ts_time_datum_get_min</name><argument_list>(<argument><expr><call><name>coerce_to_time_type</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the end time datum for a time type.
 *
 * Note that the end is not the same as "max" (hence not named max). The end
 * is exclusive for date and timestamps, and might not be the same as the max
 * value for the underlying storage type (e.g., TIMESTAMP_END is before
 * PG_INT64_MAX). Instead, the max value for dates and timestamps represent
 * -Infinity and +Infinity.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_time_datum_get_end</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>TS_DATE_END</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>TS_TIMESTAMP_END</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>TS_TIMESTAMP_END</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"END is not defined for \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>ts_time_datum_get_end</name><argument_list>(<argument><expr><call><name>coerce_to_time_type</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_time_datum_get_max</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>TS_DATE_END</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>TS_TIMESTAMP_END</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>TS_TIMESTAMP_END</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>PG_INT16_MAX</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>PG_INT32_MAX</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>PG_INT64_MAX</name></expr></argument>)</argument_list></call></expr>;</return>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>ts_time_datum_get_max</name><argument_list>(<argument><expr><call><name>coerce_to_time_type</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_time_datum_get_nobegin</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>DATEVAL_NOBEGIN</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>DT_NOBEGIN</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>DT_NOBEGIN</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"NOBEGIN is not defined for \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>ts_time_datum_get_nobegin</name><argument_list>(<argument><expr><call><name>coerce_to_time_type</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_time_datum_get_nobegin_or_min</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IS_TIMESTAMP_TYPE</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_datum_get_nobegin</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ts_time_datum_get_min</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>ts_time_datum_get_noend</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>DATEVAL_NOEND</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>DT_NOEND</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>DT_NOEND</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"NOEND is not defined for \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>ts_time_datum_get_noend</name><argument_list>(<argument><expr><call><name>coerce_to_time_type</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the min for a time type in internal time.
 */</comment>
<function><type><name>int64</name></type>
<name>ts_time_get_min</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><name>TS_DATE_INTERNAL_MIN</name></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<return>return <expr><name>TS_TIMESTAMP_INTERNAL_MIN</name></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><name>TS_TIMESTAMP_INTERNAL_MIN</name></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><name>PG_INT16_MIN</name></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><name>PG_INT32_MIN</name></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><name>PG_INT64_MIN</name></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>ts_time_get_min</name><argument_list>(<argument><expr><call><name>coerce_to_time_type</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the max for a time type in internal time.
 */</comment>
<function><type><name>int64</name></type>
<name>ts_time_get_max</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><name>TS_DATE_INTERNAL_END</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<return>return <expr><name>TS_TIMESTAMP_INTERNAL_END</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><name>TS_TIMESTAMP_INTERNAL_END</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><name>PG_INT16_MAX</name></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><name>PG_INT32_MAX</name></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><name>PG_INT64_MAX</name></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>ts_time_get_max</name><argument_list>(<argument><expr><call><name>coerce_to_time_type</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the end value time for a time type in internal time.
 *
 * The end is not a valid time value (it is exclusive).
 */</comment>
<function><type><name>int64</name></type>
<name>ts_time_get_end</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><name>TS_DATE_INTERNAL_END</name></expr>;</return>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<return>return <expr><name>TS_TIMESTAMP_INTERNAL_END</name></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><name>TS_TIMESTAMP_INTERNAL_END</name></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"END is not defined for \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>ts_time_get_end</name><argument_list>(<argument><expr><call><name>coerce_to_time_type</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the end (exclusive) or fall back to max.
 *
 * Integer time types have no definition for END, so we fall back to max.
 */</comment>
<function><type><name>int64</name></type>
<name>ts_time_get_end_or_max</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IS_TIMESTAMP_TYPE</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_get_end</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ts_time_get_max</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>ts_time_get_nobegin</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><name>TS_TIME_NOBEGIN</name></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"-Infinity not defined for \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>ts_time_get_nobegin</name><argument_list>(<argument><expr><call><name>coerce_to_time_type</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>ts_time_get_nobegin_or_min</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IS_TIMESTAMP_TYPE</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_get_nobegin</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ts_time_get_min</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>ts_time_get_noend</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><name>TS_TIME_NOEND</name></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"+Infinity not defined for \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>ts_time_get_noend</name><argument_list>(<argument><expr><call><name>coerce_to_time_type</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>ts_time_get_noend_or_max</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IS_TIMESTAMP_TYPE</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_get_noend</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ts_time_get_max</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an interval to a time value in a saturating way.
 *
 * In contrast to, e.g., PG's timestamp_pl_interval, this function adds an
 * interval in a saturating way without throwing an error in case of
 * overflow. Instead it clamps to max for integer types end NOEND for date and
 * timestamp types.
 */</comment>
<function><type><name>int64</name></type>
<name>ts_time_saturating_add</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>timeval</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>interval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>timeval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>interval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>timeval</name> <operator>&gt;</operator> <operator>(</operator><call><name>ts_time_get_max</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>interval</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_get_noend_or_max</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>timeval</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>interval</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>timeval</name> <operator>&lt;</operator> <operator>(</operator><call><name>ts_time_get_min</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>interval</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_get_nobegin_or_min</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>timeval</name> <operator>+</operator> <name>interval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subtract an interval from a time value in a saturating way.
 *
 * In contrast to, e.g., PG's timestamp_mi_interval, this function subtracts
 * an interval in a saturating way without throwing an error in case of
 * overflow. Instead, it clamps to min for integer types and NOBEGIN for date
 * and timestamp types.
 */</comment>
<function><type><name>int64</name></type>
<name>ts_time_saturating_sub</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>timeval</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>interval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>timeval</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>interval</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>timeval</name> <operator>&lt;</operator> <operator>(</operator><call><name>ts_time_get_min</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>interval</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_get_nobegin_or_min</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>timeval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>interval</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>timeval</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><call><name>ts_time_get_max</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>interval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ts_time_get_noend_or_max</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>timeval</name> <operator>-</operator> <name>interval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>ts_subtract_integer_from_now_saturating</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>now_func</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>interval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>timetype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>now</name> <init>= <expr><call><name>OidFunctionCall0</name><argument_list>(<argument><expr><name>now_func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>time_min</name> <init>= <expr><call><name>ts_time_get_min</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>time_max</name> <init>= <expr><call><name>ts_time_get_max</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>nowval</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_INTEGER_TYPE</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>timetype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>nowval</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>nowval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>INT8OID</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>nowval</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported integer time type \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>timetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name>nowval</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>interval</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nowval</name></expr></argument> &gt;</argument_list></name> <name>time_max</name> <operator>+</operator> <name>interval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>time_max</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>nowval</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>interval</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nowval</name> <operator>&lt;</operator> <name>time_min</name> <operator>+</operator> <name>interval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>time_min</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>nowval</name> <operator>-</operator> <name>interval</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TS_DEBUG</name></cpp:ifdef>
<comment type="block">/* return mock time for testing */</comment>
<function><type><name>Datum</name></type>
<name>ts_get_mock_time_or_current_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>res</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>ts_current_timestamp_mock</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ts_current_timestamp_mock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>timestamptz_in</name></expr></argument>,
								  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>ts_current_timestamp_mock</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
