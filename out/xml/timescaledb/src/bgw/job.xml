<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/bgw/job.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pgstat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_authid.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_func.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parser.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postmaster/bgworker.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/ipc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcop/tcopprot.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/timestamp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lock.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/proc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/procarray.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/sinvaladt.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/elog.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/jsonb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"job.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scanner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"job_stat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"license_guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TELEMETRY</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"telemetry/telemetry.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/chunk_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw_policy/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bgw/scheduler.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cross_module_fn.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsonb_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_assert.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TELEMETRY_INITIAL_NUM_RUNS</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>scheduler_test_hook_type</name></type> <name>scheduler_test_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>job_entrypoint_function_name</name> <init>= <expr><literal type="string">"ts_bgw_job_entrypoint"</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TELEMETRY</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_telemetry_job</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><enum>enum <name>JobLockLifetime</name>
<block>{
	<decl><name>SESSION_LOCK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>TXN_LOCK</name></decl>,
}</block></enum></type> <name>JobLockLifetime</name>;</typedef>

<function><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type>
<name>ts_bgw_job_start</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>user_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwParams</name></type> <name>bgw_params</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>job_id</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>user_oid</name> <operator>=</operator> <name>user_oid</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TELEMETRY</name></cpp:ifdef>
		<expr><operator>.</operator><name>croak_silently</name> <operator>=</operator> <call><name>is_telemetry_job</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>bgw_params</name><operator>.</operator><name>bgw_main</name></name></expr></argument>, <argument><expr><name>job_entrypoint_function_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>bgw_params</name><operator>.</operator><name>bgw_main</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ts_bgw_start_worker</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>application_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>bgw_params</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>job_execute_function</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><call><name>CreateExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>es</name> <init>= <expr><call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>funcexpr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Run configuration check validation function.
 *
 * This will run the configuration check validation function registered for
 * the job. If a new job is added, the job_id is going to be zero.
 */</comment>
<function><type><name>void</name></type>
<name>ts_bgw_job_run_config_check</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>check</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>, <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Nothing to check if there is no check function provided */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>check</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* NULL config may be valid */</comment>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>config</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>JSONBOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>JSONBOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>JsonbPGetDatum</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcexpr</name> <init>=
		<expr><call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>check</name></expr></argument>, <argument><expr><name>VOIDOID</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_func_prokind</name><argument_list>(<argument><expr><name>check</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROKIND_FUNCTION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>job_execute_function</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported function type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Only functions are allowed as custom configuration checks"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use a FUNCTION instead"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Run the check function on a configuration. It will generate errors if there
 * is anything wrong with the configuration, otherwise just return. If the
 * check function does not exist, no checking will be done.*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>job_config_check</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>, <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcname</name></decl>;</decl_stmt>

	<comment type="block">/* Both should either be empty or contain a schema and name */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>check_schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator>
		   <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>check_schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If there is no function, just return */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>check_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>funcname</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>check_schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>check_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name><name>argtypes</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>JSONBOID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Only functions allowed as custom checks, as procedures can cause errors with COMMIT
	 * statements */</comment>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* a check function has been registered but it can't be found anymore
	 because it was dropped or renamed. Allow alter_job to run if that's the case
	 without validating the config but also print a warning */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_bgw_job_run_config_check</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
			 <argument><expr><literal type="string">"function %s.%s(config jsonb) not found, skipping config validation for "</literal>
			 <literal type="string">"job %d"</literal></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>check_schema</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>check_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* this function fills in a jsonb with the non-null fields of
 the error data and also includes the proc name and schema in the jsonb
 we include these here to avoid adding these fields to the table */</comment>
<function><type><specifier>static</specifier> <name>Jsonb</name> <modifier>*</modifier></type>
<name>ts_errdata_to_jsonb</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>proc_schema</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>proc_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>parse_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"sqlerrcode"</literal></expr></argument>, <argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"message"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"detail"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"hint"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"filename"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_int32</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"lineno"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"funcname"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"domain"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>context_domain</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"context_domain"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context_domain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"context"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"schema_name"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"table_name"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"column_name"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"datatype_name"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"constraint_name"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"internalquery"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"detail_log"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>proc_schema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"proc_schema"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>proc_schema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>proc_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"proc_name"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>proc_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* we add the schema qualified name here as well*/</comment>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BgwJob</name> <modifier>*</modifier></type>
<name>bgw_job_from_tupleinfo</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>alloc_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_bgw_job</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_bgw_job</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * allow for embedding with arbitrary alloc_size, which means we can't use
	 * the STRUCT_FROM_TUPLE macro
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>alloc_size</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BgwJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>job</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>, <argument><expr><name>alloc_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Using heap_deform_tuple instead of GETSTRUCT since the tuple can
	 * contain NULL values. Some of these cannot really be null, but we check
	 * anyway since it is cheap and will avoid problems in the future. Note
	 * that the job structure is zeroed, so we only need to update the field
	 * if it is non-NULL.
	 */</comment>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_application_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>application_name</name></name></expr></argument>,
				   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(
					   <argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_application_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_schedule_interval</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schedule_interval</name></name> <operator>=</operator>
			<operator>*</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_schedule_interval</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_max_runtime</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>max_runtime</name></name> <operator>=</operator>
			<operator>*</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_max_runtime</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_max_retries</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>max_retries</name></name> <operator>=</operator>
			<call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_max_retries</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_fixed_schedule</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>fixed_schedule</name></name> <operator>=</operator>
			<call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_fixed_schedule</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_initial_start</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>initial_start</name></name> <operator>=</operator>
			<call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_initial_start</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_timezone</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>timezone</name></name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_timezone</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_retry_period</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>retry_period</name></name> <operator>=</operator>
			<operator>*</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_retry_period</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_proc_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_schema</name></name></expr></argument>,
				   <argument><expr><call><name>NameStr</name><argument_list>(
					   <argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_proc_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_proc_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_name</name></name></expr></argument>,
				   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_proc_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>check_schema</name></name></expr></argument>,
				   <argument><expr><call><name>NameStr</name><argument_list>(
					   <argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_schema</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>check_name</name></name></expr></argument>,
				   <argument><expr><call><name>NameStr</name><argument_list>(
					   <argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_name</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_owner</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>owner</name></name></expr></argument>,
				   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_owner</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_scheduled</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>scheduled</name></name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_scheduled</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name> <operator>=</operator>
			<call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>old_ctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_config</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>config</name></name> <operator>=</operator> <call><name>DatumGetJsonbP</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_config</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>job</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>AccumData</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>alloc_size</name></decl>;</decl_stmt>
}</block></struct></type> <name>AccumData</name>;</typedef>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>bgw_job_accum_tuple_found</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AccumData</name> <modifier>*</modifier></type><name>list_data</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>bgw_job_from_tupleinfo</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name><name>list_data</name><operator>-&gt;</operator><name>alloc_size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>orig</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>list_data</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>list_data</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanFilterResult</name></type>
<name>bgw_job_filter_scheduled</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>scheduled</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_bgw_job_scheduled</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Ensure</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>, <argument><expr><literal type="string">"scheduled column was null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>scheduled</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is meant to be used by the scheduler only
 * it does not include the config field which saves us from
 * detoasting and makes memory management in the scheduler
 * simpler as otherwise the config field would have to be
 * freed separately when freeing jobs which would prevent
 * the use of list_free_deep.
 * The scheduler does not need the config field only the
 * individual jobs do.
 * The scheduler requires jobs to be sorted by id
 * which is guaranteed by the index scan on the primary key
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_bgw_job_get_scheduled</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>alloc_size</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>BGW_JOB</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>iterator</name><operator>.</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>, <argument><expr><name>BGW_JOB_PKEY_IDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>.</operator><name>ctx</name><operator>.</operator><name>filter</name></name> <operator>=</operator> <name>bgw_job_filter_scheduled</name></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>, <decl><type ref="prev"/><name>isnull</name></decl>, <decl><type ref="prev"/><name>initial_start_isnull</name></decl>, <decl><type ref="prev"/><name>timezone_isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>value</name></decl>, <decl><type ref="prev"/><name>initial_start</name></decl>, <decl><type ref="prev"/><name>timezone</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>, <argument><expr><name>alloc_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FormData_bgw_job</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TELEMETRY</name></cpp:ifdef>
		<comment type="block">/* ignore telemetry jobs if telemetry is disabled */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_telemetry_on</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_telemetry_job</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* handle NULL columns */</comment>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_bgw_job_hypertable_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name> <operator>=</operator> <ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name>initial_start</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_bgw_job_initial_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>initial_start_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>initial_start_isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>initial_start</name></name> <operator>=</operator> <call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name>initial_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>initial_start</name></name> <operator>=</operator> <name>DT_NOBEGIN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>timezone</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_bgw_job_timezone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timezone_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>timezone_isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>timezone</name></name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>timezone</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* We skip config, check_name, and check_schema since the scheduler
		 * doesn't need these, it saves us from detoasting, and simplifies
		 * freeing job lists in the scheduler as otherwise the config field
		 * would have to be freed separately when freeing a job. */</comment>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>config</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>old_ctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jobs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>jobs</name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>jobs</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_bgw_job_get_all</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>alloc_size</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AccumData</name></type> <name>list_data</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>list</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>alloc_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BgwJob</name></expr></argument>)</argument_list></sizeof></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <operator>&amp;</operator><name>list_data</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>bgw_job_accum_tuple_found</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>,
		<expr><operator>.</operator><name>result_mctx</name> <operator>=</operator> <name>mctx</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>list_data</name><operator>.</operator><name>list</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scan_by_proc_name</name><parameter_list>(<parameter><decl><type><name>ScanKeyData</name> <modifier>*</modifier></type><name>scankey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_bgw_job_proc_hypertable_id_idx_proc_name</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>proc_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scan_by_proc_schema</name><parameter_list>(<parameter><decl><type><name>ScanKeyData</name> <modifier>*</modifier></type><name>scankey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc_schema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_bgw_job_proc_hypertable_id_idx_proc_schema</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>proc_schema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scan_by_hypertable_id</name><parameter_list>(<parameter><decl><type><name>ScanKeyData</name> <modifier>*</modifier></type><name>scankey</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_bgw_job_proc_hypertable_id_idx_hypertable_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_bgw_job_find_by_proc_and_hypertable_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc_schema</name></decl></parameter>,
										  <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AccumData</name></type> <name>list_data</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>list</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>alloc_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BgwJob</name></expr></argument>)</argument_list></sizeof></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>, <argument><expr><name>BGW_JOB_PROC_HYPERTABLE_ID_IDX</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <operator>&amp;</operator><name>list_data</name></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>scankey</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>scankey</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>bgw_job_accum_tuple_found</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_proc_schema</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>proc_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_scan_by_proc_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>proc_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_scan_by_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>list_data</name><operator>.</operator><name>list</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_bgw_job_find_by_proc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc_schema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AccumData</name></type> <name>list_data</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>list</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>alloc_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BgwJob</name></expr></argument>)</argument_list></sizeof></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>, <argument><expr><name>BGW_JOB_PROC_HYPERTABLE_ID_IDX</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <operator>&amp;</operator><name>list_data</name></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>scankey</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>scankey</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>bgw_job_accum_tuple_found</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_proc_schema</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>proc_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_scan_by_proc_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>proc_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>list_data</name><operator>.</operator><name>list</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_bgw_job_find_by_hypertable_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AccumData</name></type> <name>list_data</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>list</name> <operator>=</operator> <name>NIL</name></expr>,
		<expr><operator>.</operator><name>alloc_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BgwJob</name></expr></argument>)</argument_list></sizeof></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>, <argument><expr><name>BGW_JOB_PROC_HYPERTABLE_ID_IDX</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <operator>&amp;</operator><name>list_data</name></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>scankey</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>scankey</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>bgw_job_accum_tuple_found</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_hypertable_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>list_data</name><operator>.</operator><name>list</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scan_by_job_id</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>, <argument><expr><name>BGW_JOB_PKEY_IDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_bgw_job_pkey_idx_id</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_INT4EQ</name></expr></argument>,
								   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Lock a job tuple using an advisory lock. Advisory job locks are used to
 * lock the job row while a job is running to prevent a job from being
 * modified while in the middle of a run. This lock should be taken before
 * bgw_job table lock to avoid deadlocks.
 *
 * We use an advisory lock instead of a tuple lock because we want the lock on
 * the job id and not on the tid of the row (in case it is vacuumed or updated
 * in some way). We don't want the job modified while it is running for safety
 * reasons. Finally, we use this lock to be able to send a signal to the PID
 * of the running job. This is used by delete because, a job deletion sends a
 * SIGINT to the running job to cancel it.
 *
 * We acquire a SHARE lock on the job during scheduling and when the job is
 * running so that it cannot be deleted during those times and an EXCLUSIVE
 * lock when deleting.
 *
 * returns whether or not the lock was obtained (false return only possible if
 * block==false)
 */</comment>

<function><type><name>bool</name></type>
<name>ts_lock_job_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>session_lock</name></decl></parameter>, <parameter><decl><type><name>LOCKTAG</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>block</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Use a special pseudo-random field 4 value to avoid conflicting with user-advisory-locks */</comment>
	<expr_stmt><expr><call><name>TS_SET_LOCKTAG_ADVISORY</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>job_id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>LockAcquire</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>session_lock</name></expr></argument>, <argument><expr><operator>!</operator><name>block</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BgwJob</name> <modifier>*</modifier></type>
<name>ts_bgw_job_find_with_lock</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>bgw_job_id</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>tuple_lock_mode</name></decl></parameter>,
						  <parameter><decl><type><name>JobLockLifetime</name></type> <name>lock_type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>block</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>got_lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Take a share lock on the table to prevent concurrent data changes during scan. This lock will
	 * be released after the scan */</comment>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>BGW_JOB</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>, <argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>

	<comment type="block">/* take advisory lock before relation lock */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>got_lock</name> <operator>=</operator>
			  <call><name>ts_lock_job_id</name><argument_list>(<argument><expr><name>bgw_job_id</name></expr></argument>, <argument><expr><name>tuple_lock_mode</name></expr></argument>, <argument><expr><name>lock_type</name> <operator>==</operator> <name>SESSION_LOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* return NULL if lock could not be acquired */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>init_scan_by_job_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>bgw_job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>job</name> <operator>=</operator> <call><name>bgw_job_from_tupleinfo</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BgwJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jobs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>jobs</name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>jobs</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>jobs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><operator>(</operator><name>BgwJob</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"more than one job with same job_id %d"</literal></expr></argument>, <argument><expr><name>bgw_job_id</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"job_id: %d, application_name: %s, procedure: %s.%s, scheduled: %s"</literal></expr></argument>,
							   <argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
							   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>application_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><ternary><condition><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>scheduled</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We don't care about duplicate jobs in release builds and will take the
	 * last job */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>jobs</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>job</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Take a lock on the job for the duration of the txn. This prevents
 *  the job from being deleted.
 *
 *  Returns true if the job is found ( we block till we can acquire a lock
 *                               so we will always lock here)
 *          false if the job is missing.
 */</comment>
<function><type><name>bool</name></type>
<name>ts_bgw_job_get_share_lock</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>bgw_job_id</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>got_lock</name></decl>;</decl_stmt>
	<comment type="block">/* note the mode here is equivalent to FOR SHARE row locks */</comment>
	<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>ts_bgw_job_find_with_lock</name><argument_list>(<argument><expr><name>bgw_job_id</name></expr></argument>,
											<argument><expr><name>mctx</name></expr></argument>,
											<argument><expr><name>RowShareLock</name></expr></argument>,
											<argument><expr><name>TXN_LOCK</name></expr></argument>,
											<argument><expr><name>true</name></expr></argument>, <comment type="block">/* block */</comment>
											<argument><expr><operator>&amp;</operator><name>got_lock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>job</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>got_lock</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* since we blocked for a lock , this is an unexpected condition */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not acquire share lock for job=%d"</literal></expr></argument>, <argument><expr><name>bgw_job_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BgwJob</name> <modifier>*</modifier></type>
<name>ts_bgw_job_find</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>bgw_job_id</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mctx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fail_if_not_found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>= <expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>BGW_JOB</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>mctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_job_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>bgw_job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_found</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>job</name> <operator>=</operator> <call><name>bgw_job_from_tupleinfo</name><argument_list>(<argument><expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BgwJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_found</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>num_found</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fail_if_not_found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"job %d not found"</literal></expr></argument>, <argument><expr><name>bgw_job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>job</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_job_lock_for_delete</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>got_lock</name></decl>;</decl_stmt>

	<comment type="block">/* Try getting an exclusive lock on the tuple in a non-blocking manner. Note this is the
	 * equivalent of a row-based FOR UPDATE lock */</comment>
	<expr_stmt><expr><name>got_lock</name> <operator>=</operator> <call><name>ts_lock_job_id</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>,
							  <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
							  <comment type="block">/* session_lock */</comment> <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>,
							  <comment type="block">/* block */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>got_lock</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If I couldn't get a lock, try killing the background worker that's running the job.
		 * This is probably not bulletproof but best-effort is good enough here. */</comment>
		<decl_stmt><decl><type><name>VirtualTransactionId</name> <modifier>*</modifier></type><name>vxid</name> <init>= <expr><call><name>GetLockConflicts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>VirtualTransactionIdIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>vxid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>BackendIdGetProc</name><argument_list>(<argument><expr><name><name>vxid</name><operator>-&gt;</operator><name>backendId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>proc</name><operator>-&gt;</operator><name>isBackgroundWorker</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					 <argument><expr><literal type="string">"cancelling the background worker for job %d (pid %d)"</literal></expr></argument>,
					 <argument><expr><name>job_id</name></expr></argument>,
					 <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_cancel_backend</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We have to grab this lock before proceeding so grab it in a blocking manner now */</comment>
		<expr_stmt><expr><name>got_lock</name> <operator>=</operator> <call><name>ts_lock_job_id</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>,
								  <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
								  <comment type="block">/* session_lock */</comment> <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>,
								  <comment type="block">/* block */</comment> <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Ensure</name><argument_list>(<argument><expr><name>got_lock</name></expr></argument>, <argument><expr><literal type="string">"unable to lock job id %d"</literal></expr></argument>, <argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>bgw_job_tuple_delete</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull_job_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_bgw_job_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull_job_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>job_id</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Ensure</name><argument_list>(<argument><expr><operator>!</operator><name>isnull_job_id</name></expr></argument>, <argument><expr><literal type="string">"job id was null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also delete the bgw_stat entry */</comment>
	<expr_stmt><expr><call><name>ts_bgw_job_stat_delete</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete any stats in bgw_policy_chunk_stats related to this job */</comment>
	<expr_stmt><expr><call><name>ts_bgw_policy_chunk_stats_delete_row_only_by_job_id</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_delete_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>bgw_job_delete_scan</name><parameter_list>(<parameter><decl><type><name>ScanKeyData</name> <modifier>*</modifier></type><name>scankey</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name></decl>;</decl_stmt>

	<comment type="block">/* get job lock before relation lock */</comment>
	<expr_stmt><expr><call><name>get_job_lock_for_delete</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scanctx</name> <operator>=</operator> <operator>(</operator><name>ScannerCtx</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>, <argument><expr><name>BGW_JOB_PKEY_IDX</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <literal type="number">1</literal></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>limit</name> <operator>=</operator> <literal type="number">1</literal></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>bgw_job_tuple_delete</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
		<expr><operator>.</operator><name>result_mctx</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>,
	}</block></expr>;</expr_stmt>

	<return>return <expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function will try to delete the job identified by `job_id`. If the job is currently running,
 * this function will send a `SIGINT` to the job, and wait for the job to terminate before deleting
 * the job. In the event that it cannot  send the signal (for instance, if the job is not in a
 * transaction, we have no way to send the signal), it will still wait for the job to terminate and
 * release the job lock, or will ERROR due to a lock or deadlock timeout. In this case,  the user
 * has to  manually determine the `pid` of the BGW and send an `SIGINT` or a `SIGKILL`.
 */</comment>
<function><type><name>bool</name></type>
<name>ts_bgw_job_delete_by_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_bgw_job_pkey_idx_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>bgw_job_delete_scan</name><argument_list>(<argument><expr><name>scankey</name></expr></argument>, <argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function only updates the fields modifiable with alter_job. */</comment>
<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>bgw_job_tuple_update_by_id</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>updated_job</name> <init>= <expr><operator>(</operator><name>BgwJob</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_bgw_job</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isnull</name><index>[<expr><name>Natts_bgw_job</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>doReplace</name><index>[<expr><name>Natts_bgw_job</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>old_schedule_interval</name> <init>=
		<expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_bgw_job_schedule_interval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* when we update the schedule interval, modify the next start time as well*/</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_eq</name></expr></argument>,
										  <argument><expr><name>old_schedule_interval</name></expr></argument>,
										  <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schedule_interval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BgwJobStat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><call><name>ts_bgw_job_stat_find</name><argument_list>(<argument><expr><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>stat</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TimestampTz</name></type> <name>next_start</name> <init>= <expr><call><name>DatumGetTimestampTz</name><argument_list>(
				<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>,
									<argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>last_finish</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schedule_interval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/* allow DT_NOBEGIN for next_start here through allow_unset=true in the case that
			 * last_finish is DT_NOBEGIN,
			 * This means the value is counted as unset which is what we want */</comment>
			<expr_stmt><expr><call><name>ts_bgw_job_stat_update_next_start</name><argument_list>(<argument><expr><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>next_start</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_schedule_interval</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schedule_interval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_schedule_interval</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_max_runtime</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>max_runtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_max_runtime</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_max_retries</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>max_retries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_max_retries</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_retry_period</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>retry_period</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_retry_period</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_scheduled</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>scheduled</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_scheduled</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_config</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>check_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>check_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>check_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>config</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>job_config_check</name><argument_list>(<argument><expr><name>updated_job</name></expr></argument>, <argument><expr><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>config</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_config</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>JsonbPGetDatum</name><argument_list>(<argument><expr><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>config</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_config</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>updated_job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>doReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_update</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Overwrite job with specified job_id with the given fields
 *
 * This function only updates the fields modifiable with alter_job.
 */</comment>
<function><type><name>bool</name></type>
<name>ts_bgw_job_update_by_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>, <parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanTupLock</name></type> <name>scantuplock</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>waitpolicy</name> <operator>=</operator> <name>LockWaitBlock</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>LockTupleExclusive</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{ <expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>)</argument_list></call></expr>,
						   <expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>, <argument><expr><name>BGW_JOB_PKEY_IDX</name></expr></argument>)</argument_list></call></expr>,
						   <expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <literal type="number">1</literal></expr>,
						   <expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
						   <expr><operator>.</operator><name>data</name> <operator>=</operator> <name>job</name></expr>,
						   <expr><operator>.</operator><name>limit</name> <operator>=</operator> <literal type="number">1</literal></expr>,
						   <expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>bgw_job_tuple_update_by_id</name></expr>,
						   <expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>,
						   <expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
						   <expr><operator>.</operator><name>result_mctx</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>,
						   <expr><operator>.</operator><name>tuplock</name> <operator>=</operator> <operator>&amp;</operator><name>scantuplock</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_bgw_job_pkey_idx_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ts_bgw_job_check_max_retries</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwJobStat</name> <modifier>*</modifier></type><name>job_stat</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>job_stat</name> <operator>=</operator> <call><name>ts_bgw_job_stat_find</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* stop to execute failing jobs after reached the "max_retries" option */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>max_retries</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>job_stat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>consecutive_failures</name></name> <operator>&gt;=</operator> <name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>max_retries</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"job %d reached max_retries after %d consecutive failures"</literal></expr></argument>,
						<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
						<argument><expr><name><name>job_stat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>consecutive_failures</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Job %d unscheduled as max_retries reached %d, consecutive failures %d."</literal></expr></argument>,
						   <argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
						   <argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>max_retries</name></name></expr></argument>,
						   <argument><expr><name><name>job_stat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>consecutive_failures</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use alter_job(%d, scheduled =&gt; TRUE) SQL function to reschedule."</literal></expr></argument>,
						 <argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>scheduled</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>scheduled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_bgw_job_update_by_id</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_bgw_job_permission_check</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>owner_oid</name> <init>= <expr><call><name>get_role_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_privs_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>owner_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient permissions to alter job %d"</literal></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_bgw_job_validate_job_owner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>owner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>role_tup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_authid</name></type> <name>rform</name> <init>= <expr><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>role_tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rform</name><operator>-&gt;</operator><name>rolcanlogin</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>role_tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to start background process as role \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>rform</name><operator>-&gt;</operator><name>rolname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Hypertable owner must have LOGIN permission to run background tasks."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>role_tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TELEMETRY</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_telemetry_job</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_schema</name></name></expr></argument>, <argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_name</name></name></expr></argument>, <argument><expr><literal type="string">"policy_telemetry"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>bool</name></type>
<name>ts_bgw_job_execute</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TELEMETRY</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>is_telemetry_job</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In the first 12 hours, we want telemetry to ping every
		 * hour. After that initial period, we default to the
		 * schedule_interval listed in the job table.
		 */</comment>
		<decl_stmt><decl><type><name>Interval</name></type> <name>one_hour</name> <init>= <expr><block>{ <expr><operator>.</operator><name>time</name> <operator>=</operator> <literal type="number">1</literal> <operator>*</operator> <name>USECS_PER_HOUR</name></expr> }</block></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>ts_bgw_job_run_and_set_next_start</name><argument_list>(<argument><expr><name>job</name></expr></argument>,
												 <argument><expr><name>ts_telemetry_main_wrapper</name></expr></argument>,
												 <argument><expr><name>TELEMETRY_INITIAL_NUM_RUNS</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>one_hour</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TS_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>scheduler_test_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>scheduler_test_hook</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>job_execute</name></name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_bgw_job_has_timeout</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name></type> <name>zero_val</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>time</name> <operator>=</operator> <literal type="number">0</literal></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_gt</name></expr></argument>,
											<argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>max_runtime</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zero_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the timestamp at which to kill the job due to a timeout */</comment>
<function><type><name>TimestampTz</name></type>
<name>ts_bgw_job_timeout_at</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>start_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* timestamptz plus interval */</comment>
	<return>return <expr><call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>,
												   <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>start_time</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>max_runtime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_bgw_job_entrypoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>zero_guc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>guc_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>config_change</name> <init>=
		<expr><call><name>set_config_option</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>, <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>config_change</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"guc \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>guc_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>config_change</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not set \"%s\" guc"</literal></expr></argument>, <argument><expr><name>guc_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function creates an entry in the job_errors table
 * when a background job throws a runtime error or the job scheduler
 * detects that the job crashed
 */</comment>
<function><type><name>bool</name></type>
<name>ts_job_errors_insert_tuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FormData_job_error</name> <modifier>*</modifier></type><name>job_err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>JOB_ERRORS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_job_error</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_job_error</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_job_error_job_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>job_err</name><operator>-&gt;</operator><name>job_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_job_error_start_time</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>job_err</name><operator>-&gt;</operator><name>start_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_job_error_finish_time</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>job_err</name><operator>-&gt;</operator><name>finish_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>job_err</name><operator>-&gt;</operator><name>pid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_job_error_pid</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>job_err</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_job_error_pid</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>job_err</name><operator>-&gt;</operator><name>error_data</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_job_error_error_data</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>JsonbPGetDatum</name><argument_list>(<argument><expr><name><name>job_err</name><operator>-&gt;</operator><name>error_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_job_error_error_data</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_insert_values</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Die silently without printing a message.
 *
 * This will also abort any connection attempts and reads that are blocking,
 * e.g., waiting for responses from the telemetry server. Also indicate to the
 * postmaster that it does not have to print a message.
 *
 * We do this deliberately to avoid having a telemetry job that blocks a
 * shutdown, but that means that the job has to be very careful about what it
 * writes and not use any atexit routines.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>croak</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We exit using exit status 0 so that it will only generate a debug log
	 * message. If we exit with 1, it will log the exiting process with a log
	 * message, which we want to avoid. */</comment>
	<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>Datum</name></type>
<name>ts_bgw_job_entrypoint</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>db_oid</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>MyBgworkerEntry</name><operator>-&gt;</operator><name>bgw_main_arg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BgwParams</name></type> <name>params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JobResult</name></type> <name>res</name> <init>= <expr><name>JOB_FAILURE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>got_lock</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name><name>MyBgworkerEntry</name><operator>-&gt;</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BgwParams</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Ensure</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>user_oid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>params</name><operator>.</operator><name>job_id</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>,
		   <argument><expr><literal type="string">"job id or user oid was zero - job_id: %d, user_oid: %d"</literal></expr></argument>,
		   <argument><expr><name><name>params</name><operator>.</operator><name>job_id</name></name></expr></argument>,
		   <argument><expr><name><name>params</name><operator>.</operator><name>user_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BackgroundWorkerBlockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Setup any signal handlers here */</comment>

	<comment type="block">/*
	 * do not use the default `bgworker_die` sigterm handler because it does
	 * not respect critical sections. We install an silent signal handler for
	 * invisible jobs, which will then die without printing an error message.
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>params</name><operator>.</operator><name>croak_silently</name></name></expr> ?</condition><then> <expr><name>croak</name></expr> </then><else>: <expr><name>die</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BackgroundWorkerInitializeConnectionByOid</name><argument_list>(<argument><expr><name>db_oid</name></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>user_oid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_license_enable_module_loading</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Grab a session lock on the job row to prevent concurrent deletes. Lock is released
	 * when the job process exits */</comment>
	<expr_stmt><expr><name>job</name> <operator>=</operator> <call><name>ts_bgw_job_find_with_lock</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>job_id</name></name></expr></argument>,
									<argument><expr><name>TopMemoryContext</name></expr></argument>,
									<argument><expr><name>RowShareLock</name></expr></argument>,
									<argument><expr><name>SESSION_LOCK</name></expr></argument>,
									<comment type="block">/* block */</comment> <argument><expr><name>true</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>got_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>job</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"job %d not found when running the background worker"</literal></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>job_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_appname</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>application_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>start_time</name> <init>= <expr><name>DT_NOBEGIN</name></expr></init></decl>, <decl><type ref="prev"/><name>finish_time</name> <init>= <expr><name>DT_NOBEGIN</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type> <name>proc_schema</name> <init>= <expr><block>{ <expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr> }</block></expr> }</block></expr></init></decl>, <decl><type ref="prev"/><name>proc_name</name> <init>= <expr><block>{ <expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * we do not necessarily have a valid parallel worker context in
		 * background workers, so disable parallel execution by default
		 */</comment>
		<expr_stmt><expr><call><name>zero_guc</name><argument_list>(<argument><expr><literal type="string">"max_parallel_workers_per_gather"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>zero_guc</name><argument_list>(<argument><expr><literal type="string">"max_parallel_workers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>zero_guc</name><argument_list>(<argument><expr><literal type="string">"max_parallel_maintenance_workers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ts_bgw_job_execute</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* The job is responsible for committing or aborting it's own txns */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"TimescaleDB background job \"%s\" failed to end the transaction"</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>application_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* If there was an error, rollback what was done before the error */</comment>
			<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Free the old job if it exists, it's no longer needed, and since it's
		 * in the TopMemoryContext it won't be freed otherwise.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><name>job</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>job</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Note that the mark_start happens in the scheduler right before the
		 * job is launched. Try to get a lock on the job again. Because the error
		 * removed the session lock. Don't block and only record if the lock was actually
		 * obtained.
		 */</comment>
		<expr_stmt><expr><name>job</name> <operator>=</operator> <call><name>ts_bgw_job_find_with_lock</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>job_id</name></name></expr></argument>,
										<argument><expr><name>TopMemoryContext</name></expr></argument>,
										<argument><expr><name>RowShareLock</name></expr></argument>,
										<argument><expr><name>TXN_LOCK</name></expr></argument>,
										<comment type="block">/* block */</comment> <argument><expr><name>false</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>got_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>job</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ts_bgw_job_stat_mark_end</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><name>JOB_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_bgw_job_check_max_retries</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_name</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_schema</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>job</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * the rethrow will log the error; but also log which job threw the
		 * error
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"job %d threw an error"</literal></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>job_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FormData_job_error</name></type> <name>jerr</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<comment type="line">// switch away from error context to not lose the data</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>BgwJobStat</name> <modifier>*</modifier></type><name>job_stat</name> <init>= <expr><call><name>ts_bgw_job_stat_find</name><argument_list>(<argument><expr><name><name>params</name><operator>.</operator><name>job_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>job_stat</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>start_time</name> <operator>=</operator> <name><name>job_stat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>last_start</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>finish_time</name> <operator>=</operator> <name><name>job_stat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>last_finish</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* We include the procname in the error data and expose it in the view
		 to avoid adding an extra field in the table */</comment>
		<expr_stmt><expr><name><name>jerr</name><operator>.</operator><name>error_data</name></name> <operator>=</operator> <call><name>ts_errdata_to_jsonb</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc_schema</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jerr</name><operator>.</operator><name>job_id</name></name> <operator>=</operator> <name><name>params</name><operator>.</operator><name>job_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jerr</name><operator>.</operator><name>start_time</name></name> <operator>=</operator> <name>start_time</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jerr</name><operator>.</operator><name>finish_time</name></name> <operator>=</operator> <name>finish_time</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jerr</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ts_job_errors_insert_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that the mark_start happens in the scheduler right before the job
	 * is launched
	 */</comment>
	<expr_stmt><expr><call><name>ts_bgw_job_stat_mark_end</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>job</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>job</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
		 <argument><expr><literal type="string">"exiting job %d with %s"</literal></expr></argument>,
		 <argument><expr><name><name>params</name><operator>.</operator><name>job_id</name></name></expr></argument>,
		 <argument><expr><operator>(</operator><ternary><condition><expr><name>res</name> <operator>==</operator> <name>JOB_SUCCESS</name></expr> ?</condition><then> <expr><literal type="string">"success"</literal></expr> </then><else>: <expr><literal type="string">"failure"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_bgw_job_set_scheduler_test_hook</name><parameter_list>(<parameter><decl><type><name>scheduler_test_hook_type</name></type> <name>hook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>scheduler_test_hook</name> <operator>=</operator> <name>hook</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_bgw_job_set_job_entrypoint_function_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>func_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>job_entrypoint_function_name</name> <operator>=</operator> <name>func_name</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_bgw_job_run_and_set_next_start</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>, <parameter><decl><type><name>job_main_func</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>initial_runs</name></decl></parameter>,
								  <parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>next_interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwJobStat</name> <modifier>*</modifier></type><name>job_stat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>func</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Now update next_start. */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>job_stat</name> <operator>=</operator> <call><name>ts_bgw_job_stat_find</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that setting next_start explicitly from this function will
	 * override any backoff calculation due to failure.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>job_stat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>total_runs</name></name> <operator>&lt;</operator> <name>initial_runs</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>next_start</name> <init>=
			<expr><call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>,
													<argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>job_stat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>last_start</name></name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>next_interval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ts_bgw_job_stat_set_next_start</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>next_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert a new job in the bgw_job relation */</comment>
<function><type><name>int</name></type>
<name>ts_bgw_job_insert_relation</name><parameter_list>(<parameter><decl><type><name>Name</name></type> <name>application_name</name></decl></parameter>, <parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>schedule_interval</name></decl></parameter>,
						   <parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>max_runtime</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>max_retries</name></decl></parameter>, <parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>retry_period</name></decl></parameter>,
						   <parameter><decl><type><name>Name</name></type> <name>proc_schema</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>proc_name</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>check_schema</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>check_name</name></decl></parameter>,
						   <parameter><decl><type><name>Name</name></type> <name>owner</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>scheduled</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fixed_schedule</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>,
						   <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>initial_start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>timezone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_bgw_job</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_bgw_job</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>job_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>app_name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_schedule_interval</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>schedule_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_max_runtime</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>max_runtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_max_retries</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>max_retries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_retry_period</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>retry_period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_proc_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><name>proc_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_proc_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><name>proc_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>check_schema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><name>check_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_schema</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>check_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><name>check_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_check_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_owner</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_scheduled</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>scheduled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_fixed_schedule</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>fixed_schedule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* initial_start must have a value if the schedule is fixed */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>fixed_schedule</name> <operator>||</operator> <operator>!</operator><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>initial_start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>initial_start</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_initial_start</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_initial_start</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>initial_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_initial_start</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_initial_start</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>initial_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>hypertable_id</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>config</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_config</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_config</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>JsonbPGetDatum</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>timezone</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_timezone</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_timezone</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>job_id</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>ts_catalog_table_next_seq_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>app_name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s [%d]"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>application_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_application_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>app_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_insert_values</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_id</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function ensures the schedule interval is acceptable in the case
 * of fixed job schedules. Intervals that mix months with day and time
 * components are not acceptable since internally we use time_bucket and
 * cannot bucket by such an interval.
 */</comment>
<function><type><name>void</name></type>
<name>ts_bgw_job_validate_schedule_interval</name><parameter_list>(<parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>schedule_interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_month</name></decl>, <decl><type ref="prev"/><name>has_day</name></decl>, <decl><type ref="prev"/><name>has_time</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>has_month</name> <operator>=</operator> <name><name>schedule_interval</name><operator>-&gt;</operator><name>month</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>has_day</name> <operator>=</operator> <name><name>schedule_interval</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>has_time</name> <operator>=</operator> <name><name>schedule_interval</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>has_month</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>has_day</name> <operator>||</operator> <name>has_time</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"month intervals cannot have day or time component"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Fixed schedule jobs do not support such schedule intervals."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Express the interval in terms of days or time instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>ts_bgw_job_validate_timezone</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>timezone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_zone</name></expr></argument>,
						<argument><expr><name>timezone</name></expr></argument>,
						<argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><call><name>ts_timer_get_current_timestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>timezone</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
