<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/bgw/job_stat.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgrprotos.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"job_stat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scanner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"timer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsonb_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_bucket.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_INTERVALS_BACKOFF</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FAILURES_MULTIPLIER</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_WAIT_AFTER_CRASH_MS</name></cpp:macro> <cpp:value>(5 * 60 * 1000)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>bgw_job_stat_next_start_was_set</name><parameter_list>(<parameter><decl><type><name>FormData_bgw_job_stat</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>fd</name><operator>-&gt;</operator><name>next_start</name></name> <operator>!=</operator> <name>DT_NOBEGIN</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>bgw_job_stat_tuple_found</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwJobStat</name> <modifier>*</modifier><modifier>*</modifier></type><name>job_stat_pp</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>job_stat_pp</name> <operator>=</operator> <call><name>STRUCT_FROM_SLOT</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>, <argument><expr><name>BgwJobStat</name></expr></argument>, <argument><expr><name>FormData_bgw_job_stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return SCAN_CONTINUE because we check for multiple tuples as an error
	 * condition.
	 */</comment>
	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>bgw_job_stat_scan_one</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>indexid</name></decl></parameter>, <parameter><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>tuple_found_func</name></type> <name>tuple_found</name></decl></parameter>,
					  <parameter><decl><type><name>tuple_filter_func</name></type> <name>tuple_filter</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB_STAT</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>BGW_JOB_STAT</name></expr></argument>, <argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <name>nkeys</name></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>SCANNER_F_KEEPLOCK</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>tuple_found</name></expr>,
		<expr><operator>.</operator><name>filter</name> <operator>=</operator> <name>tuple_filter</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>data</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>lockmode</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ts_scanner_scan_one</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"bgw job stat"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>bgw_job_stat_scan_job_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>bgw_job_id</name></decl></parameter>, <parameter><decl><type><name>tuple_found_func</name></type> <name>tuple_found</name></decl></parameter>,
						 <parameter><decl><type><name>tuple_filter_func</name></type> <name>tuple_filter</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_bgw_job_stat_pkey_idx_job_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>bgw_job_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>bgw_job_stat_scan_one</name><argument_list>(<argument><expr><name>BGW_JOB_STAT_PKEY_IDX</name></expr></argument>,
								 <argument><expr><name>scankey</name></expr></argument>,
								 <argument><expr><literal type="number">1</literal></expr></argument>,
								 <argument><expr><name>tuple_found</name></expr></argument>,
								 <argument><expr><name>tuple_filter</name></expr></argument>,
								 <argument><expr><name>data</name></expr></argument>,
								 <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>BgwJobStat</name> <modifier>*</modifier></type>
<name>ts_bgw_job_stat_find</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>bgw_job_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwJobStat</name> <modifier>*</modifier></type><name>job_stat</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>bgw_job_stat_scan_job_id</name><argument_list>(<argument><expr><name>bgw_job_id</name></expr></argument>,
							 <argument><expr><name>bgw_job_stat_tuple_found</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>job_stat</name></expr></argument>,
							 <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>job_stat</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>bgw_job_stat_tuple_delete</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_catalog_delete_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_bgw_job_stat_delete</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>bgw_job_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>bgw_job_stat_scan_job_id</name><argument_list>(<argument><expr><name>bgw_job_id</name></expr></argument>,
							 <argument><expr><name>bgw_job_stat_tuple_delete</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Mark the start of a job. This should be done in a separate transaction by the scheduler
 *  before the bgw for a job is launched. This ensures that the job is counted as started
 * before /any/ job specific code is executed. A job that has been started but never ended
 * is assumed to have crashed. We use this conservative design since no process in the database
 * instance can write once a crash happened in any job. Therefore our only choice is to deduce
 * a crash from the lack of a write (the marked end write in this case).
 */</comment>
<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>bgw_job_stat_tuple_mark_start</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_bgw_job_stat</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><operator>(</operator><name>FormData_bgw_job_stat</name> <operator>*</operator><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>last_start</name></name> <operator>=</operator> <call><name>ts_timer_get_current_timestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>last_finish</name></name> <operator>=</operator> <name>DT_NOBEGIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>next_start</name></name> <operator>=</operator> <name>DT_NOBEGIN</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>total_runs</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is undone by any of the end marks. This is so that we count
	 * crashes conservatively. Pretty much the crash is incremented in the
	 * beginning and then decremented during `bgw_job_stat_tuple_mark_end`.
	 * Thus, it only remains incremented if the job is never marked as having
	 * ended. This happens when: 1) the job crashes 2) another process crashes
	 * while the job is running 3) the scheduler gets a SIGTERM while the job
	 * is running
	 *
	 * Unfortunately, 3 cannot be helped because when a scheduler gets a
	 * SIGTERM it sends SIGTERMS to it's any running jobs as well. Since you
	 * aren't supposed to write to the DB Once you get a sigterm, neither the
	 * job nor the scheduler can mark the end of a job.
	 */</comment>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>last_run_success</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>total_crashes</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>consecutive_crashes</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <call><name>ts_clear_flags_32</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>LAST_CRASH_REPORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_update</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>JobResult</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl>;</decl_stmt>
}</block></struct></type> <name>JobResultCtx</name>;</typedef>

<comment type="block">/*
 * time_bucket(schedule_interval, finish_time, origin =&gt; initial_start)
 */</comment>
<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>get_next_scheduled_execution_slot</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>finish_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>fixed_schedule</name></name> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>timebucket_fini</name></decl>, <decl><type ref="prev"/><name>result</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>schedint_datum</name> <init>= <expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schedule_interval</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>timezone</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_timestamptz_bucket</name></expr></argument>,
									 <argument><expr><name>schedint_datum</name></expr></argument>,
									 <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>initial_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>timebucket_fini</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>ts_timestamptz_bucket</name></expr></argument>,
											  <argument><expr><name>schedint_datum</name></expr></argument>,
											  <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>finish_time</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>initial_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* always the next time_bucket */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>, <argument><expr><name>timebucket_fini</name></expr></argument>, <argument><expr><name>schedint_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tz</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>timezone</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>timebucket_fini</name> <operator>=</operator> <call><name>DirectFunctionCall4</name><argument_list>(<argument><expr><name>ts_timestamptz_timezone_bucket</name></expr></argument>,
											  <argument><expr><name>schedint_datum</name></expr></argument>,
											  <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>finish_time</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>initial_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* always the next time_bucket */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>, <argument><expr><name>timebucket_fini</name></expr></argument>, <argument><expr><name>schedint_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>ts_timestamptz_timezone_bucket</name></expr></argument>,
									 <argument><expr><name>schedint_datum</name></expr></argument>,
									 <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>initial_start</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_mi</name></expr></argument>, <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>initial_start</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* if we have a month component, the origin doesn't work so we must manually
	 include the offset */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schedule_interval</name><operator>.</operator><name>month</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * adding the schedule interval above to get the next bucket might still not hit
	 * the next bucket if we are crossing DST. So we can end up with a next_start value
	 * that is actually less than the finish time of the job. Hence, we have to make sure
	 * the next scheduled slot we compute is in the future and not in the past
	 */</comment>
	<while>while <condition>(<expr><call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>finish_time</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>schedint_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<return>return <expr><call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>calculate_next_start_on_success_fixed</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>finish_time</name></decl></parameter>, <parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>next_slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>next_slot</name> <operator>=</operator> <call><name>get_next_scheduled_execution_slot</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><name>finish_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>next_slot</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>calculate_next_start_on_success_drifting</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>last_finish</name></decl></parameter>, <parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>ts</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>,
												 <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>last_finish</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schedule_interval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ts</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>calculate_next_start_on_success</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>finish_time</name></decl></parameter>, <parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* next_start is the previously calculated next_start for this job */</comment>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>ts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_finish</name> <init>= <expr><name>finish_time</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>finish_time</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>last_finish</name> <operator>=</operator> <call><name>ts_timer_get_current_timestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* calculate next_start differently depending on drift/no drift */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>fixed_schedule</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>calculate_next_start_on_success_fixed</name><argument_list>(<argument><expr><name>last_finish</name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>calculate_next_start_on_success_drifting</name><argument_list>(<argument><expr><name>last_finish</name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>ts</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>float8</name></type>
<name>calculate_jitter_percent</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/* returns a number in the range [-0.125, 0.125] */</comment>
	<decl_stmt><decl><type><name>uint8</name></type> <name>percent</name> <init>= <expr><call><name>random</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>ldexp</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><literal type="number">16</literal> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>percent</name> <operator>%</operator> <literal type="number">32</literal><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* For failures we have backoff based on consecutive failures
 * along with a ceiling at schedule_interval * MAX_INTERVALS_BACKOFF / 1 minute
 * for jobs failing at runtime / for jobs failing to launch.
 * We also limit the backoff in case of consecutive failures as we don't
 * want to pass in input that leads to out of range timestamps and don't want to
 * put off the next start time for the job indefinitely
 */</comment>
<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>calculate_next_start_on_failure</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>finish_time</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>consecutive_failures</name></decl></parameter>, <parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>launch_failure</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type> <name>jitter</name> <init>= <expr><call><name>calculate_jitter_percent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Have to be declared volatile because they are modified between
	 * setjmp/longjmp calls.
	 */</comment>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>TimestampTz</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>res_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>TimestampTz</name></type> <name>last_finish</name> <init>= <expr><name>finish_time</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* consecutive failures includes this failure */</comment>
	<decl_stmt><decl><type><name>float8</name></type> <name>multiplier</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>consecutive_failures</name> <operator>&gt;</operator> <name>MAX_FAILURES_MULTIPLIER</name></expr> ?</condition><then> <expr><name>MAX_FAILURES_MULTIPLIER</name></expr> </then><else>:
																		  <expr><name>consecutive_failures</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consecutive_failures</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>multiplier</name> <operator>&lt;</operator> <literal type="number">63</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>
	<comment type="block">/* 2^(consecutive_failures) - 1, at most 2^20 */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>max_slots</name> <init>= <expr><operator>(</operator><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>multiplier</name><operator>)</operator> <operator>-</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>rand_backoff</name> <init>= <expr><call><name>random</name><argument_list>()</argument_list></call> <operator>%</operator> <operator>(</operator><name>max_slots</name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>finish_time</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s: invalid finish time"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_finish</name> <operator>=</operator> <call><name>ts_timer_get_current_timestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><literal type="string">"next start on failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>ival</name></decl>;</decl_stmt>
		<comment type="block">/* ival_max is the ceiling = MAX_INTERVALS_BACKOFF * schedule_interval */</comment>
		<decl_stmt><decl><type><name>Datum</name></type> <name>ival_max</name></decl>;</decl_stmt>
		<comment type="line">// max wait time to launch job is 1 minute</comment>
		<decl_stmt><decl><type><name>Interval</name></type> <name>interval_max</name> <init>= <expr><block>{ <expr><operator>.</operator><name>time</name> <operator>=</operator> <literal type="number">60000000</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Interval</name></type> <name>retry_ival</name> <init>= <expr><block>{ <expr><operator>.</operator><name>time</name> <operator>=</operator> <literal type="number">2000000</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>retry_ival</name><operator>.</operator><name>time</name></name> <operator>+=</operator> <name>rand_backoff</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>launch_failure</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// random backoff seconds in [2, 2 + 2^f]</comment>
			<expr_stmt><expr><name>ival</name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retry_ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ival_max</name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>interval_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* ival = retry_period * (consecutive_failures)  */</comment>
			<expr_stmt><expr><name>ival</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_mul</name></expr></argument>,
									   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>retry_period</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>multiplier</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* ival_max is the ceiling = MAX_INTERVALS_BACKOFF * schedule_interval */</comment>
			<expr_stmt><expr><name>ival_max</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_mul</name></expr></argument>,
										   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schedule_interval</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>MAX_INTERVALS_BACKOFF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_cmp</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>, <argument><expr><name>ival_max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ival</name> <operator>=</operator> <name>ival_max</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Add some random jitter to prevent stampeding-herds, interval will be within about +-13%
		 */</comment>
		<expr_stmt><expr><name>ival</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_mul</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>+</operator> <name>jitter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DatumGetTimestampTz</name><argument_list>(
			<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>, <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>last_finish</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>errdata</name> <init>= <expr><call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not calculate next start on failure: resetting value"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Error: %s."</literal></expr></argument>, <argument><expr><name><name>errdata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>==</operator> <name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res_set</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>nowt</name></decl>;</decl_stmt>
		<comment type="block">/* job-&gt;fd_retry_period is a valid non-null value */</comment>
		<expr_stmt><expr><name>nowt</name> <operator>=</operator> <call><name>ts_timer_get_current_timestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>,
													  <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>nowt</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>retry_period</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* for fixed_schedules, we make sure that if the calculated next_start time
	 * surpasses the next scheduled slot, then next_start will be set to the value
	 * of the next scheduled slot, so we don't get off track */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>fixed_schedule</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>next_slot</name> <init>= <expr><call><name>get_next_scheduled_execution_slot</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><name>finish_time</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;</operator> <name>next_slot</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>next_slot</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>calculate_next_start_on_failed_launch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consecutive_failed_launches</name></decl></parameter>, <parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>ts_timer_get_current_timestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>failure_calc</name> <init>=
		<expr><call><name>calculate_next_start_on_failure</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>consecutive_failed_launches</name></expr></argument>, <argument><expr><name>job</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>failure_calc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* For crashes, the logic is the similar as for failures except we also have
 *  a minimum wait after a crash that we wait, so that if an operator needs to disable the job,
 *  there will be enough time before another crash.
 */</comment>
<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>calculate_next_start_on_crash</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>consecutive_crashes</name></decl></parameter>, <parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>ts_timer_get_current_timestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>failure_calc</name> <init>=
		<expr><call><name>calculate_next_start_on_failure</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>consecutive_crashes</name></expr></argument>, <argument><expr><name>job</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>min_time</name> <init>= <expr><call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>MIN_WAIT_AFTER_CRASH_MS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>min_time</name> <operator>&gt;</operator> <name>failure_calc</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>min_time</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>failure_calc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>bgw_job_stat_tuple_mark_end</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JobResultCtx</name> <modifier>*</modifier></type><name>result_ctx</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_bgw_job_stat</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><operator>(</operator><name>FormData_bgw_job_stat</name> <operator>*</operator><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>duration</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>last_finish</name></name> <operator>=</operator> <call><name>ts_timer_get_current_timestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>duration</name> <operator>=</operator> <call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_mi</name></expr></argument>,
													 <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>last_finish</name></name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>last_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* undo marking created by start marks */</comment>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>last_run_success</name></name> <operator>=</operator> <ternary><condition><expr><name><name>result_ctx</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>JOB_SUCCESS</name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>total_crashes</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>consecutive_crashes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <call><name>ts_clear_flags_32</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>LAST_CRASH_REPORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>result_ctx</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>JOB_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>total_success</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>consecutive_failures</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>last_successful_finish</name></name> <operator>=</operator> <name><name>fd</name><operator>-&gt;</operator><name>last_finish</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>total_duration</name></name> <operator>=</operator>
			<operator>*</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_pl</name></expr></argument>,
												   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>total_duration</name></name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Mark the next start at the end if the job itself hasn't */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bgw_job_stat_next_start_was_set</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>next_start</name></name> <operator>=</operator> <call><name>calculate_next_start_on_success</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>last_finish</name></name></expr></argument>, <argument><expr><name><name>result_ctx</name><operator>-&gt;</operator><name>job</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>total_failures</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>consecutive_failures</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>total_duration_failures</name></name> <operator>=</operator>
			<operator>*</operator><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>interval_pl</name></expr></argument>,
												   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>total_duration_failures</name></name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>duration</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Mark the next start at the end if the job itself hasn't (this may
		 * have happened before failure) and the failure was not in starting.
		 * If the failure was in starting, then next_start should have been
		 * restored in `on_failure_to_start_job` and thus we don't change it here.
		 * Even if it wasn't restored, then keep it as DT_NOBEGIN to mark it as highest priority.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bgw_job_stat_next_start_was_set</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>result_ctx</name><operator>-&gt;</operator><name>result</name></name> <operator>!=</operator> <name>JOB_FAILURE_TO_START</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>next_start</name></name> <operator>=</operator> <call><name>calculate_next_start_on_failure</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>last_finish</name></name></expr></argument>,
															 <argument><expr><name><name>fd</name><operator>-&gt;</operator><name>consecutive_failures</name></name></expr></argument>,
															 <argument><expr><name><name>result_ctx</name><operator>-&gt;</operator><name>job</name></name></expr></argument>,
															 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ts_catalog_update</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>bgw_job_stat_tuple_mark_crash_reported</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_bgw_job_stat</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><operator>(</operator><name>FormData_bgw_job_stat</name> <operator>*</operator><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <call><name>ts_set_flags_32</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>LAST_CRASH_REPORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_update</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>bgw_job_stat_tuple_set_next_start</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name> <modifier>*</modifier></type><name>next_start</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_bgw_job_stat</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><operator>(</operator><name>FormData_bgw_job_stat</name> <operator>*</operator><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>next_start</name></name> <operator>=</operator> <operator>*</operator><name>next_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_update</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>bgw_job_stat_insert_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>bgw_job_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>mark_start</name></decl></parameter>,
							 <parameter><decl><type><name>TimestampTz</name></type> <name>next_start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_bgw_job_stat</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_bgw_job_stat</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name></type> <name>zero_ival</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>time</name> <operator>=</operator> <literal type="number">0</literal></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_job_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>bgw_job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mark_start</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_last_start</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>TimestampGetDatum</name><argument_list>(<argument><expr><call><name>ts_timer_get_current_timestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_last_start</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>DT_NOBEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_last_finish</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>DT_NOBEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_next_start</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>next_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_last_successful_finish</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>DT_NOBEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_total_runs</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>mark_start</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_total_duration</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zero_ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_total_duration_failures</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zero_ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_total_success</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_total_failures</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_consecutive_failures</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_flags</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>JOB_STAT_FLAGS_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mark_start</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This is udone by any of the end marks */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_last_run_success</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_total_crashes</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_consecutive_crashes</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_last_run_success</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_total_crashes</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_bgw_job_stat_consecutive_crashes</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_insert_values</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_bgw_job_stat_mark_start</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>bgw_job_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We grab a ShareRowExclusiveLock here because we need to ensure that no
	 * job races and adds a job when we insert the relation as well since that
	 * can trigger a failure when inserting a row for the job. We use the
	 * RowExclusiveLock in the scan since we cannot use NoLock (relation_open
	 * requires a lock that it not NoLock). */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>=
		<expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BGW_JOB_STAT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bgw_job_stat_scan_job_id</name><argument_list>(<argument><expr><name>bgw_job_id</name></expr></argument>,
								  <argument><expr><name>bgw_job_stat_tuple_mark_start</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>bgw_job_stat_insert_relation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>bgw_job_id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>DT_NOBEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_bgw_job_stat_mark_end</name><parameter_list>(<parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>, <parameter><decl><type><name>JobResult</name></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JobResultCtx</name></type> <name>res</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>job</name> <operator>=</operator> <name>job</name></expr>,
		<expr><operator>.</operator><name>result</name> <operator>=</operator> <name>result</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bgw_job_stat_scan_job_id</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
								  <argument><expr><name>bgw_job_stat_tuple_mark_end</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>,
								  <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unable to find job statistics for job %d"</literal></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_bgw_job_stat_mark_crash_reported</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>bgw_job_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bgw_job_stat_scan_job_id</name><argument_list>(<argument><expr><name>bgw_job_id</name></expr></argument>,
								  <argument><expr><name>bgw_job_stat_tuple_mark_crash_reported</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unable to find job statistics for job %d"</literal></expr></argument>, <argument><expr><name>bgw_job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_bgw_job_stat_end_was_marked</name><parameter_list>(<parameter><decl><type><name>BgwJobStat</name> <modifier>*</modifier></type><name>jobstat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>!</operator><call><name>TIMESTAMP_IS_NOBEGIN</name><argument_list>(<argument><expr><name><name>jobstat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>last_finish</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_bgw_job_stat_set_next_start</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>next_start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Cannot use DT_NOBEGIN as that's the value used to indicate "not set" */</comment>
	<if_stmt><if>if <condition>(<expr><name>next_start</name> <operator>==</operator> <name>DT_NOBEGIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot set next start to -infinity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bgw_job_stat_scan_job_id</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>,
								  <argument><expr><name>bgw_job_stat_tuple_set_next_start</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>next_start</name></expr></argument>,
								  <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unable to find job statistics for job %d"</literal></expr></argument>, <argument><expr><name>job_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* update next_start if job stat exists */</comment>
<function><type><name>TSDLLEXPORT</name> <name>bool</name></type>
<name>ts_bgw_job_stat_update_next_start</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>job_id</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>next_start</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_unset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Cannot use DT_NOBEGIN as that's the value used to indicate "not set" */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_unset</name> <operator>&amp;&amp;</operator> <name>next_start</name> <operator>==</operator> <name>DT_NOBEGIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot set next start to -infinity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>bgw_job_stat_scan_job_id</name><argument_list>(<argument><expr><name>job_id</name></expr></argument>,
									 <argument><expr><name>bgw_job_stat_tuple_set_next_start</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>next_start</name></expr></argument>,
									 <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_bgw_job_stat_upsert_next_start</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>bgw_job_id</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>next_start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Cannot use DT_NOBEGIN as that's the value used to indicate "not set" */</comment>
	<if_stmt><if>if <condition>(<expr><name>next_start</name> <operator>==</operator> <name>DT_NOBEGIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot set next start to -infinity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We grab a ShareRowExclusiveLock here because we need to ensure that no
	 * job races and adds a job when we insert the relation as well since that
	 * can trigger a failure when inserting a row for the job. We use the
	 * RowExclusiveLock in the scan since we cannot use NoLock (relation_open
	 * requires a lock that it not NoLock). */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>=
		<expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BGW_JOB_STAT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bgw_job_stat_scan_job_id</name><argument_list>(<argument><expr><name>bgw_job_id</name></expr></argument>,
								  <argument><expr><name>bgw_job_stat_tuple_set_next_start</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>next_start</name></expr></argument>,
								  <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>bgw_job_stat_insert_relation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>bgw_job_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>next_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_bgw_job_stat_should_execute</name><parameter_list>(<parameter><decl><type><name>BgwJobStat</name> <modifier>*</modifier></type><name>jobstat</name></decl></parameter>, <parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Stub to allow the system to disable jobs based on the number of crashes
	 * or failures.
	 */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TimestampTz</name></type>
<name>ts_bgw_job_stat_next_start</name><parameter_list>(<parameter><decl><type><name>BgwJobStat</name> <modifier>*</modifier></type><name>jobstat</name></decl></parameter>, <parameter><decl><type><name>BgwJob</name> <modifier>*</modifier></type><name>job</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>consecutive_failed_launches</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* give the system some room to breathe, wait before trying to launch again */</comment>
	<if_stmt><if>if <condition>(<expr><name>consecutive_failed_launches</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>calculate_next_start_on_failed_launch</name><argument_list>(<argument><expr><name>consecutive_failed_launches</name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>jobstat</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Never previously run - run right away */</comment>
		<return>return <expr><name>DT_NOBEGIN</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>jobstat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>consecutive_crashes</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Update the errors table regarding the crash */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_flags_are_set_32</name><argument_list>(<argument><expr><name><name>jobstat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name>LAST_CRASH_REPORTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* add the proc_schema, proc_name to the jsonb */</comment>
			<decl_stmt><decl><type><name>NameData</name></type> <name>proc_schema</name> <init>= <expr><block>{ <expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr> }</block></expr> }</block></expr></init></decl>, <decl><type ref="prev"/><name>proc_name</name> <init>= <expr><block>{ <expr><operator>.</operator><name>data</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_schema</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_schema</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc_name</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>proc_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>parse_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"proc_schema"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>proc_schema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_jsonb_add_str</name><argument_list>(<argument><expr><name>parse_state</name></expr></argument>, <argument><expr><literal type="string">"proc_name"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>proc_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WJB_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><specifier>const</specifier> <name>FormData_job_error</name></type> <name>jerr</name> <init>= <expr><block>{
				<expr><operator>.</operator><name>error_data</name> <operator>=</operator> <call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>,
				<expr><operator>.</operator><name>start_time</name> <operator>=</operator> <name><name>jobstat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>last_start</name></name></expr>,
				<expr><operator>.</operator><name>finish_time</name> <operator>=</operator> <call><name>ts_timer_get_current_timestamp</name><argument_list>()</argument_list></call></expr>,
				<expr><operator>.</operator><name>pid</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
				<expr><operator>.</operator><name>job_id</name> <operator>=</operator> <name><name>jobstat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr>,
			}</block></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ts_job_errors_insert_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ts_bgw_job_stat_mark_crash_reported</name><argument_list>(<argument><expr><name><name>jobstat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><call><name>calculate_next_start_on_crash</name><argument_list>(<argument><expr><name><name>jobstat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>consecutive_crashes</name></name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>jobstat</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>next_start</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
