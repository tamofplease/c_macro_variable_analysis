<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/import/planner.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>

<comment type="block">/*
 * This file contains source code that was copied and/or modified from
 * the PostgreSQL database, which is licensed under the open-source
 * PostgreSQL License. Please see the NOTICE at the top level
 * directory for a copy of the PostgreSQL License.
 *
 * These function were copied from the PostgreSQL core planner, since
 * they were declared static in the core planner, but we need them for
 * our manipulations.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_collation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_statistic.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/nodeAgg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/clauses.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/cost.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paramassign.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/placeholder.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/planmain.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/planner.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/datum.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planner.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">130003</literal></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>EquivalenceMember</name> <modifier>*</modifier></type><name>find_ec_member_matching_expr</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
													   <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>EquivalenceMember</name> <modifier>*</modifier></type><name>find_computable_ec_member</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
													<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>,
													<parameter><decl><type><name>bool</name></type> <name>require_parallel_safe</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>replace_nestloop_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>replace_nestloop_params_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>inject_projection_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parallel_safe</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* copied verbatim from prepunion.c */</comment>
<function><type><name>void</name></type>
<name>ts_make_inh_translation_list</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>oldrelation</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>newrelation</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>translated_vars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>old_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>oldrelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>new_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>oldnatts</name> <init>= <expr><name><name>old_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>newnatts</name> <init>= <expr><name><name>new_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>old_attno</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>old_attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>old_attno</name> <operator>&lt;</operator> <name>oldnatts</name></expr>;</condition> <incr><expr><name>old_attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>atttypid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>atttypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>attcollation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>new_attno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>old_tupdesc</name></expr></argument>, <argument><expr><name>old_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Just put NULL into this list entry */</comment>
			<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vars</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>atttypid</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>atttypmod</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When we are generating the "translation list" for the parent table
		 * of an inheritance set, no need to search for matches.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>oldrelation</name> <operator>==</operator> <name>newrelation</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vars</name></expr></argument>,
						   <argument><expr><call><name>makeVar</name><argument_list>(<argument><expr><name>newvarno</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <operator>(</operator><name>old_attno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
								   <argument><expr><name>atttypid</name></expr></argument>,
								   <argument><expr><name>atttypmod</name></expr></argument>,
								   <argument><expr><name>attcollation</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Otherwise we have to search for the matching column by name.
		 * There's no guarantee it'll have the same column position, because
		 * of cases like ALTER TABLE ADD COLUMN and multiple inheritance.
		 * However, in simple cases it will be the same column number, so try
		 * that before we go groveling through all the columns.
		 *
		 * Note: the test for (att = ...) != NULL cannot fail, it's just a
		 * notational device to include the assignment into the if-clause.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>old_attno</name> <operator>&lt;</operator> <name>newnatts</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>new_tupdesc</name></expr></argument>, <argument><expr><name>old_attno</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>new_attno</name> <operator>=</operator> <name>old_attno</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init><expr><name>new_attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>new_attno</name> <operator>&lt;</operator> <name>newnatts</name></expr>;</condition> <incr><expr><name>new_attno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>new_tupdesc</name></expr></argument>, <argument><expr><name>new_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>new_attno</name> <operator>&gt;=</operator> <name>newnatts</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><literal type="string">"could not find inherited attribute \"%s\" of relation \"%s\""</literal></expr></argument>,
					 <argument><expr><name>attname</name></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Found it, check type and collation match */</comment>
		<if_stmt><if>if <condition>(<expr><name>atttypid</name> <operator>!=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator> <name>atttypmod</name> <operator>!=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"attribute \"%s\" of relation \"%s\" does not match parent's type"</literal></expr></argument>,
				 <argument><expr><name>attname</name></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>attcollation</name> <operator>!=</operator> <name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"attribute \"%s\" of relation \"%s\" does not match parent's collation"</literal></expr></argument>,
				 <argument><expr><name>attname</name></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vars</name></expr></argument>,
					   <argument><expr><call><name>makeVar</name><argument_list>(<argument><expr><name>newvarno</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <operator>(</operator><name>new_attno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
							   <argument><expr><name>atttypid</name></expr></argument>,
							   <argument><expr><name>atttypmod</name></expr></argument>,
							   <argument><expr><name>attcollation</name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>translated_vars</name> <operator>=</operator> <name>vars</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* copied verbatim from planner.c */</comment>
<function><type><name><name>struct</name> <name>PathTarget</name></name> <modifier>*</modifier></type>
<name>ts_make_partial_grouping_target</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannerInfo</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>grouping_target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>Query</name></name> <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>partial_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>List</name></name> <modifier>*</modifier></type><name>non_group_cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>List</name></name> <modifier>*</modifier></type><name>non_group_exprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>partial_target</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>grouping_target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>Expr</name></name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator>struct <name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sgref</name> <init>= <expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>grouping_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sgref</name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator>
			<call><name>get_sortgroupref_clause_noerr</name><argument_list>(<argument><expr><name>sgref</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * It's a grouping column, so add it to the partial_target as-is.
			 * (This allows the upper agg step to repeat the grouping calcs.)
			 */</comment>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>partial_target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>sgref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Non-grouping column, so just remember the expression for later
			 * call to pull_var_clause.
			 */</comment>
			<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If there's a HAVING clause, we'll need the Vars/Aggrefs it uses, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Pull out all the Vars, PlaceHolderVars, and Aggrefs mentioned in
	 * non-group cols (plus HAVING), and add them to the partial_target if not
	 * already present.  (An expression used directly as a GROUP BY item will
	 * be present already.)  Note this includes Vars used in resjunk items, so
	 * we are covering the needs of ORDER BY and window specifications.
	 */</comment>
	<expr_stmt><expr><name>non_group_exprs</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator>struct <name>Node</name> <operator>*</operator><operator>)</operator> <name>non_group_cols</name></expr></argument>,
									  <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator> <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
										  <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_new_columns_to_pathtarget</name><argument_list>(<argument><expr><name>partial_target</name></expr></argument>, <argument><expr><name>non_group_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust Aggrefs to put them in partial mode.  At this point all Aggrefs
	 * are at the top level of the target list, so we can just scan the list
	 * rather than recursing through the expression trees.
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>partial_target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>Aggref</name></name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator>struct <name>Aggref</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>Aggref</name></name> <modifier>*</modifier></type><name>newaggref</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We shouldn't need to copy the substructure of the Aggref node,
			 * but flat-copy the node itself to avoid damaging other trees.
			 */</comment>
			<expr_stmt><expr><name>newaggref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newaggref</name></expr></argument>, <argument><expr><name>aggref</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>Aggref</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* For now, assume serialization is required */</comment>
			<expr_stmt><expr><call><name>mark_partial_aggref</name><argument_list>(<argument><expr><name>newaggref</name></expr></argument>, <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>newaggref</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* clean up cruft */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>non_group_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX this causes some redundant cost calculation ... */</comment>
	<return>return <expr><call><name>set_pathtarget_cost_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>partial_target</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* copied verbatim from selfuncs.c */</comment>
<function><type><name>bool</name></type>
<name>ts_get_variable_range</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sortop</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>min</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>tmin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>tmax</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>have_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>typLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>typByVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>opfuncoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * XXX It's very tempting to try to use the actual column min and max, if
	 * we can get them relatively-cheaply with an index probe.  However, since
	 * this function is called many times during join planning, that could
	 * have unpleasant effects on planning speed.  Need more investigation
	 * before enabling this.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>get_actual_variable_range</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>vardata</name></expr></argument>, <argument><expr><name>sortop</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no stats available, so default result */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we can't apply the sortop to the stats data, just fail.  In
	 * principle, if there's a histogram and no MCVs, we could return the
	 * histogram endpoints without ever applying the sortop ... but it's
	 * probably not worth trying, because whatever the caller wants to do with
	 * the endpoints would likely fail the security check too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>statistic_proc_security_check</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><operator>(</operator><name>opfuncoid</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>atttype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a histogram, grab the first and last values.
	 *
	 * If there is a histogram that is sorted with some other operator than
	 * the one we want, fail --- this suggests that there is data we can't
	 * use.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>,
						 <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
						 <argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>,
						 <argument><expr><name>sortop</name></expr></argument>,
						 <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tmin</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmax</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_data</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>, <argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have most-common-values info, look for extreme MCVs.  This is
	 * needed even if we also have a histogram, since the histogram excludes
	 * the MCVs.  However, usually the MCVs will not be the extreme values, so
	 * avoid unnecessary data copying.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>,
						 <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
						 <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>tmin_is_mcv</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>tmax_is_mcv</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>opproc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>opfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sslot</name><operator>.</operator><name>nvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_data</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tmin</name> <operator>=</operator> <name>tmax</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmin_is_mcv</name> <operator>=</operator> <name>tmax_is_mcv</name> <operator>=</operator> <name>have_data</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(
					<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>, <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>, <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tmin</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmin_is_mcv</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(
					<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>, <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>, <argument><expr><name>tmax</name></expr></argument>, <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tmax</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmax_is_mcv</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>tmin_is_mcv</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tmin</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>tmin</name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>tmax_is_mcv</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tmax</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>tmax</name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <name>tmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>tmax</name></expr>;</expr_stmt>
	<return>return <expr><name>have_data</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">130003</literal></expr></cpp:if>
<comment type="block">/*
 * find_ec_member_matching_expr
 *		Locate an EquivalenceClass member matching the given expr, if any;
 *		return NULL if no match.
 *
 * "Matching" is defined as "equal after stripping RelabelTypes".
 * This is used for identifying sort expressions, and we need to allow
 * binary-compatible relabeling for some cases involving binary-compatible
 * sort operators.
 *
 * Child EC members are ignored unless they belong to given 'relids'.
 */</comment>
<function><type><specifier>static</specifier> <name>EquivalenceMember</name> <modifier>*</modifier></type>
<name>find_ec_member_matching_expr</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* We ignore binary-compatible relabeling on both ends */</comment>
	<while>while <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>emexpr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We shouldn't be trying to sort by an equivalence class that
		 * contains a constant, so no need to consider such cases any further.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ignore child members unless they belong to the requested rel.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Match if same expression (after stripping relabel).
		 */</comment>
		<expr_stmt><expr><name>emexpr</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>emexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>emexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>emexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>emexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>emexpr</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>em</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_exprlist_member
 *	  Subroutine for find_computable_ec_member: is "node" in "exprs"?
 *
 * Per the requirements of that function, "exprs" might or might not have
 * TargetEntry superstructure.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_exprlist_member</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_computable_ec_member
 *		Locate an EquivalenceClass member that can be computed from the
 *		expressions appearing in "exprs"; return NULL if no match.
 *
 * "exprs" can be either a list of bare expression trees, or a list of
 * TargetEntry nodes.  Either way, it should contain Vars and possibly
 * Aggrefs and WindowFuncs, which are matched to the corresponding elements
 * of the EquivalenceClass's expressions.
 *
 * Unlike find_ec_member_matching_expr, there's no special provision here
 * for binary-compatible relabeling.  This is intentional: if we have to
 * compute an expression in this way, setrefs.c is going to insist on exact
 * matches of Vars to the source tlist.
 *
 * Child EC members are ignored unless they belong to given 'relids'.
 * Also, non-parallel-safe expressions are ignored if 'require_parallel_safe'.
 *
 * Note: some callers pass root == NULL for notational reasons.  This is OK
 * when require_parallel_safe is false.
 */</comment>
<function><type><specifier>static</specifier> <name>EquivalenceMember</name> <modifier>*</modifier></type>
<name>find_computable_ec_member</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>require_parallel_safe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>exprvars</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We shouldn't be trying to sort by an equivalence class that
		 * contains a constant, so no need to consider such cases any further.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ignore child members unless they belong to the requested rel.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Match if all Vars and quasi-Vars are available in "exprs".
		 */</comment>
		<expr_stmt><expr><name>exprvars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>,
								   <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator> <name>PVC_INCLUDE_WINDOWFUNCS</name> <operator>|</operator>
									   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc2</argument>, <argument>exprvars</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_exprlist_member</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>exprvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lc2</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* we hit a non-available Var */</comment>

		<comment type="block">/*
		 * If requested, reject expressions that are not parallel-safe.  We
		 * check this last because it's a rather expensive test.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>require_parallel_safe</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<return>return <expr><name>em</name></expr>;</return> <comment type="block">/* found usable expression */</comment>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * make_pathkey_from_sortinfo
 *    Given an expression and sort-order information, create a PathKey.
 *    The result is always a "canonical" PathKey, but it might be redundant.
 *
 * expr is the expression, and nullable_relids is the set of base relids
 * that are potentially nullable below it.
 *
 * If the PathKey is being generated from a SortGroupClause, sortref should be
 * the SortGroupClause's SortGroupRef; otherwise zero.
 *
 * If rel is not NULL, it identifies a specific relation we're considering
 * a path for, and indicates that child EC members for that relation can be
 * considered.  Otherwise child members are ignored.  (See the comments for
 * get_eclass_for_sort_expr.)
 *
 * create_it is true if we should create any missing EquivalenceClass
 * needed to represent the sort key.  If it's false, we return NULL if the
 * sort key isn't already present in any EquivalenceClass.
 */</comment>
<function><type><name>PathKey</name> <modifier>*</modifier></type>
<name>ts_make_pathkey_from_sortinfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>opcintype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reverse_sort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls_first</name></decl></parameter>,
							  <parameter><decl><type><name>Index</name></type> <name>sortref</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type> <name>strategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>equality_op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>eclass</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>strategy</name> <operator>=</operator> <ternary><condition><expr><name>reverse_sort</name></expr> ?</condition><then> <expr><name>BTGreaterStrategyNumber</name></expr> </then><else>: <expr><name>BTLessStrategyNumber</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * EquivalenceClasses need to contain opfamily lists based on the family
	 * membership of mergejoinable equality operators, which could belong to
	 * more than one opfamily.  So we have to look up the opfamily's equality
	 * operator and get its membership.
	 */</comment>
	<expr_stmt><expr><name>equality_op</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>equality_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
			 <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
			 <argument><expr><name>opcintype</name></expr></argument>,
			 <argument><expr><name>opcintype</name></expr></argument>,
			 <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>opfamilies</name> <operator>=</operator> <call><name>get_mergejoin_opfamilies</name><argument_list>(<argument><expr><name>equality_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opfamilies</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* certainly should find some */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find opfamilies for equality operator %u"</literal></expr></argument>, <argument><expr><name>equality_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now find or (optionally) create a matching EquivalenceClass */</comment>
	<expr_stmt><expr><name>eclass</name> <operator>=</operator> <call><name>get_eclass_for_sort_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name>expr</name></expr></argument>,
									  <argument><expr><name>nullable_relids</name></expr></argument>,
									  <argument><expr><name>opfamilies</name></expr></argument>,
									  <argument><expr><name>opcintype</name></expr></argument>,
									  <argument><expr><name>collation</name></expr></argument>,
									  <argument><expr><name>sortref</name></expr></argument>,
									  <argument><expr><name>rel</name></expr></argument>,
									  <argument><expr><name>create_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fail if no EC and !create_it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eclass</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* And finally we can find or create a PathKey node */</comment>
	<return>return <expr><call><name>make_canonical_pathkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>eclass</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>nulls_first</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_pathkey_from_sortop
 *    Like make_pathkey_from_sortinfo, but work from a sort operator.
 *
 * This should eventually go away, but we need to restructure SortGroupClause
 * first.
 */</comment>
<function><type><name>PathKey</name> <modifier>*</modifier></type>
<name>ts_make_pathkey_from_sortop</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ordering_op</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>nulls_first</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>sortref</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>opfamily</name></decl>, <decl><type ref="prev"/><name>opcintype</name></decl>, <decl><type ref="prev"/><name>collation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>strategy</name></decl>;</decl_stmt>

	<comment type="block">/* Find the operator in pg_amop --- failure shouldn't happen */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ordering_op_properties</name><argument_list>(<argument><expr><name>ordering_op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcintype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"operator %u is not a valid ordering operator"</literal></expr></argument>, <argument><expr><name>ordering_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Because SortGroupClause doesn't carry collation, consult the expr */</comment>
	<expr_stmt><expr><name>collation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ts_make_pathkey_from_sortinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>expr</name></expr></argument>,
										 <argument><expr><name>nullable_relids</name></expr></argument>,
										 <argument><expr><name>opfamily</name></expr></argument>,
										 <argument><expr><name>opcintype</name></expr></argument>,
										 <argument><expr><name>collation</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>strategy</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name><operator>)</operator></expr></argument>,
										 <argument><expr><name>nulls_first</name></expr></argument>,
										 <argument><expr><name>sortref</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name>create_it</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_sort --- basic routine to build a Sort plan node
 *
 * Caller must have built the sortColIdx, sortOperators, collations, and
 * nullsFirst arrays already.
 */</comment>
<function><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type>
<name>make_sort</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Sort</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name></name> <operator>=</operator> <name>sortColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator> <name>sortOperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>collations</name></name> <operator>=</operator> <name>collations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name></name> <operator>=</operator> <name>nullsFirst</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_sort_from_pathkeys
 *    Create sort plan to sort according to given pathkeys
 *
 *    'lefttree' is the node which yields input tuples
 *    'pathkeys' is the list of pathkeys by which the result is to be sorted
 *    'relids' is the set of relations required by prepare_sort_from_pathkeys()
 */</comment>
<function><type><name>Sort</name> <modifier>*</modifier></type>
<name>ts_make_sort_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>numsortkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

	<comment type="block">/* Compute sort column info, and adjust lefttree as needed */</comment>
	<expr_stmt><expr><name>lefttree</name> <operator>=</operator> <call><name>ts_prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>,
											 <argument><expr><name>pathkeys</name></expr></argument>,
											 <argument><expr><name>relids</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>numsortkeys</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>sortColIdx</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>sortOperators</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>collations</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now build the Sort node */</comment>
	<return>return <expr><call><name>make_sort</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>numsortkeys</name></expr></argument>, <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * prepare_sort_from_pathkeys
 *	  Prepare to sort according to given pathkeys
 *
 * This is used to set up for Sort, MergeAppend, and Gather Merge nodes.  It
 * calculates the executor's representation of the sort key information, and
 * adjusts the plan targetlist if needed to add resjunk sort columns.
 *
 * Input parameters:
 *	  'lefttree' is the plan node which yields input tuples
 *	  'pathkeys' is the list of pathkeys by which the result is to be sorted
 *	  'relids' identifies the child relation being sorted, if any
 *	  'reqColIdx' is NULL or an array of required sort key column numbers
 *	  'adjust_tlist_in_place' is true if lefttree must be modified in-place
 *
 * We must convert the pathkey information into arrays of sort key column
 * numbers, sort operator OIDs, collation OIDs, and nulls-first flags,
 * which is the representation the executor wants.  These are returned into
 * the output parameters *p_numsortkeys etc.
 *
 * When looking for matches to an EquivalenceClass's members, we will only
 * consider child EC members if they belong to given 'relids'.  This protects
 * against possible incorrect matches to child expressions that contain no
 * Vars.
 *
 * If reqColIdx isn't NULL then it contains sort key column numbers that
 * we should match.  This is used when making child plans for a MergeAppend;
 * it's an error if we can't match the columns.
 *
 * If the pathkeys include expressions that aren't simple Vars, we will
 * usually need to add resjunk items to the input plan's targetlist to
 * compute these expressions, since a Sort or MergeAppend node itself won't
 * do any such calculations.  If the input plan type isn't one that can do
 * projections, this means adding a Result node just to do the projection.
 * However, the caller can pass adjust_tlist_in_place = true to force the
 * lefttree tlist to be modified in-place regardless of whether the node type
 * can project --- we use this for fixing the tlist of MergeAppend itself.
 *
 * Returns the node which is to be the input to the Sort (either lefttree,
 * or a Result stacked atop lefttree).
 *
 * static function copied from createplan.c
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>ts_prepare_sort_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>reqColIdx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>adjust_tlist_in_place</name></decl></parameter>,
							  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>p_numsortkeys</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_sortColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_sortOperators</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_collations</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_nullsFirst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numsortkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We will need at most list_length(pathkeys) sort columns; possibly less
	 */</comment>
	<expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sortColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sortOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nullsFirst</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>i</argument>, <argument>pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>pk_datatype</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>sortop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the pathkey's EquivalenceClass is volatile, then it must
			 * have come from an ORDER BY clause, and we have to match it to
			 * that same targetlist entry.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* can't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"volatile EquivalenceClass has no sortref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>em_datatype</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>reqColIdx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we are given a sort column number to match, only consider
			 * the single TLE at that position.  It's possible that there is
			 * no such TLE, in which case fall through and generate a resjunk
			 * targetentry (we assume this must have happened in the parent
			 * plan as well).  If there is a TLE but it doesn't match the
			 * pathkey's EC, we do the same, which is probably the wrong thing
			 * but we'll leave it to caller to complain about the mismatch.
			 */</comment>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>reqColIdx</name><index>[<expr><name>numsortkeys</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tle</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>em</name> <operator>=</operator> <call><name>find_ec_member_matching_expr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>em</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* found expr at right place in tlist */</comment>
					<expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>tle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise, we can sort by any non-constant expression listed in
			 * the pathkey's EquivalenceClass.  For now, we take the first
			 * tlist item found in the EC. If there's no match, we'll generate
			 * a resjunk entry using the first EC member that is an expression
			 * in the input's vars.  (The non-const restriction only matters
			 * if the EC is below_outer_join; but if it isn't, it won't
			 * contain consts anyway, else we'd have discarded the pathkey as
			 * redundant.)
			 *
			 * XXX if we have a choice, is there any way of figuring out which
			 * might be cheapest to execute?  (For example, int4lt is likely
			 * much cheaper to execute than numericlt, but both might appear
			 * in the same equivalence class...)  Not clear that we ever will
			 * have an interesting choice in practice, so it may not matter.
			 */</comment>
			<macro><name>foreach</name> <argument_list>(<argument>j</argument>, <argument>tlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>em</name> <operator>=</operator> <call><name>find_ec_member_matching_expr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>em</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* found expr already in tlist */</comment>
					<expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>tle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No matching tlist item; look for a computable expression.
			 */</comment>
			<expr_stmt><expr><name>em</name> <operator>=</operator> <call><name>find_computable_ec_member</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>em</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find pathkey item to sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Do we need to insert a Result node?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>adjust_tlist_in_place</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_projection_capable_plan</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* copy needed so we don't modify input's tlist below */</comment>
				<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lefttree</name> <operator>=</operator> <call><name>inject_projection_plan</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Don't bother testing is_projection_capable_plan again */</comment>
			<expr_stmt><expr><name>adjust_tlist_in_place</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Add resjunk entry to input's tlist
			 */</comment>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt> <comment type="block">/* just in case NIL before */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Look up the correct sort operator from the PathKey's slightly
		 * abstracted representation.
		 */</comment>
		<expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
									 <argument><expr><name>pk_datatype</name></expr></argument>,
									 <argument><expr><name>pk_datatype</name></expr></argument>,
									 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
				 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>,
				 <argument><expr><name>pk_datatype</name></expr></argument>,
				 <argument><expr><name>pk_datatype</name></expr></argument>,
				 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Add the column to the sort arrays */</comment>
		<expr_stmt><expr><name><name>sortColIdx</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortOperators</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collations</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nullsFirst</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numsortkeys</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Return results */</comment>
	<expr_stmt><expr><operator>*</operator><name>p_numsortkeys</name> <operator>=</operator> <name>numsortkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_sortColIdx</name> <operator>=</operator> <name>sortColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_sortOperators</name> <operator>=</operator> <name>sortOperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_collations</name> <operator>=</operator> <name>collations</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_nullsFirst</name> <operator>=</operator> <name>nullsFirst</name></expr>;</expr_stmt>

	<return>return <expr><name>lefttree</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * copied verbatim from createplan.c
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_build_path_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>sortgrouprefs</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>v</argument>, <argument>path-&gt;pathtarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If it's a parameterized path, there might be lateral references in
		 * the tlist, which need to be replaced with Params.  There's no need
		 * to remake the TargetEntry nodes, so apply this to each list item
		 * separately.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>resno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sortgrouprefs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>sortgrouprefs</name><index>[<expr><name>resno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * replace_nestloop_params
 *    Replace outer-relation Vars and PlaceHolderVars in the given expression
 *    with nestloop Params
 *
 * All Vars and PlaceHolderVars belonging to the relation(s) identified by
 * root-&gt;curOuterRels are replaced by Params, and entries are added to
 * root-&gt;curOuterParams if not already present.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>replace_nestloop_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No setup needed for tree walk, so away we go */</comment>
	<return>return <expr><call><name>replace_nestloop_params_mutator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>replace_nestloop_params_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Upper-level Vars should be long gone at this point */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If not to be replaced, we can just return the Var unmodified */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Replace the Var with a nestloop Param */</comment>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>replace_nestloop_param_var</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Upper-level PlaceHolderVars should be long gone at this point */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check whether we need to replace the PHV.  We use bms_overlap as a
		 * cheap/quick test to see if the PHV might be evaluated in the outer
		 * rels, and then grab its PlaceHolderInfo to tell for sure.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>find_placeholder_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ph_eval_at</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We can't replace the whole PHV, but we might still need to
			 * replace Vars or PHVs within its expression, in case it ends up
			 * actually getting evaluated here.  (It might get evaluated in
			 * this plan node, or some child node; in the latter case we don't
			 * really need to process the expression here, but we haven't got
			 * enough info to tell if that's the case.)  Flat-copy the PHV
			 * node and then recurse on its expression.
			 *
			 * Note that after doing this, we might have different
			 * representations of the contents of the same PHV in different
			 * parts of the plan tree.  This is OK because equal() will just
			 * match on phid/phlevelsup, so setrefs.c will still recognize an
			 * upper-level reference to a lower-level copy of the same PHV.
			 */</comment>
			<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>newphv</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newphv</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newphv</name><operator>-&gt;</operator><name>phexpr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>replace_nestloop_params_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newphv</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Replace the PlaceHolderVar with a nestloop Param */</comment>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>replace_nestloop_param_placeholdervar</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>replace_nestloop_params_mutator</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>root</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_result
 *	  Build a Result plan node
 */</comment>
<function><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type>
<name>make_result</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>resconstantqual</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Result</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>resconstantqual</name></name> <operator>=</operator> <name>resconstantqual</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy cost and size info from a lower plan node to an inserted node.
 * (Most callers alter the info after copying it.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_plan_costsize</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>
	<comment type="block">/* Assume the inserted node is not parallel-aware. */</comment>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* Assume the inserted node is parallel-safe, if child plan is. */</comment>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * inject_projection_plan
 *	  Insert a Result node to do a projection step.
 *
 * This is used in a few places where we decide on-the-fly that we need a
 * projection step as part of the tree generated for some Path node.
 * We should try to get rid of this in favor of doing it more honestly.
 *
 * One reason it's ugly is we have to be told the right parallel_safe marking
 * to apply (since the tlist might be unsafe even if the child plan is safe).
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>inject_projection_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parallel_safe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In principle, we should charge tlist eval cost plus cpu_per_tuple per
	 * row for the Result node.  But the former has probably been factored in
	 * already and the latter was not accounted for during Path construction,
	 * so being formally correct might just make the EXPLAIN output look less
	 * consistent not more so.  Hence, just copy the subplan's cost.
	 */</comment>
	<expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>parallel_safe</name></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>
</unit>
