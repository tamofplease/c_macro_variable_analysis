<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/chunk_index.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/htup_details.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/dependency.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/index.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/indexing.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/objectaddress.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_constraint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_depend.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_index.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/cluster.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/defrem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablecmds.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/parsenodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgroids.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scanner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scan_iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>chunk_index_insert</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>chunk_index</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hypertable_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ts_chunk_index_create_post_adjustment</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>template_indexrel</name></decl></parameter>,
												 <parameter><decl><type><name>Relation</name></type> <name>chunkrel</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexinfo</name></decl></parameter>,
												 <parameter><decl><type><name>bool</name></type> <name>isconstraint</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_tablespace</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>create_index_colnames</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colnames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexrel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>idxattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>indexrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>idxattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>colnames</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Pick a name for a chunk index.
 *
 * The chunk's index name will the original index name prefixed with the chunk's
 * table name, modulo any conflict resolution we need to do.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>chunk_index_choose_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tabname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>main_index_name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>namespaceid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>idxname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* makeObjectName will ensure the index name fits within a NAME type */</comment>
		<expr_stmt><expr><name>idxname</name> <operator>=</operator> <call><name>makeObjectName</name><argument_list>(<argument><expr><name>tabname</name></expr></argument>, <argument><expr><name>main_index_name</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name>idxname</name></expr></argument>, <argument><expr><name>namespaceid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* found a conflict, so try a new name component */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>idxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>++</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>label</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>idxname</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjust_expr_attnos</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>ht_relid</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>ii</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>chunkrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Get a list of references to all Vars in the expression */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>vars</name></expr></argument>, <argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ii</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get a list of references to all Vars in the predicate */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>vars</name></expr></argument>, <argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ii</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>get_attname</name><argument_list>(<argument><expr><name>ht_relid</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name><name>chunkrel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index attribute %s not found in chunk"</literal></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust column reference attribute numbers for regular indexes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_adjust_colref_attnos</name><parameter_list>(<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>ii</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ht_relid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>chunkrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ii</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* zeroes indicate expressions */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ii</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* we must not use get_attname on the index here as the index column names
		 * are independent of parent relation column names. Instead we need to look
		 * up the attno of the referenced hypertable column and do the matching
		 * with the hypertable column name */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>get_attname</name><argument_list>(<argument><expr><name>ht_relid</name></expr></argument>, <argument><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attno</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name><name>chunkrel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index attribute %s not found in chunk"</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>attno</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_adjust_indexinfo_attnos</name><parameter_list>(<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ht_relid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>chunkrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Adjust a hypertable's index attribute numbers to match a chunk.
	 *
	 * A hypertable's IndexInfo for one of its indexes references the attributes
	 * (columns) in the hypertable by number. These numbers might not be the same
	 * for the corresponding attribute in one of its chunks. To be able to use an
	 * IndexInfo from a hypertable's index to create a corresponding index on a
	 * chunk, we need to adjust the attribute numbers to match the chunk.
	 *
	 * We need to handle 3 places:
	 * - direct column references in ii_IndexAttrNumbers
	 * - references in expressions in ii_Expressions
	 * - references in expressions in ii_Predicate
	 */</comment>
	<expr_stmt><expr><call><name>chunk_adjust_colref_attnos</name><argument_list>(<argument><expr><name>indexinfo</name></expr></argument>, <argument><expr><name>ht_relid</name></expr></argument>, <argument><expr><name>chunkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>indexinfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>||</operator> <name><name>indexinfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>adjust_expr_attnos</name><argument_list>(<argument><expr><name>ht_relid</name></expr></argument>, <argument><expr><name>indexinfo</name></expr></argument>, <argument><expr><name>chunkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_INDEX_TABLESPACE_OFFSET</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/*
 * Pick a chunk index's tablespace at an offset from the chunk's tablespace in
 * order to avoid colocating chunks and their indexes in the same tablespace.
 * This hopefully leads to more I/O parallelism.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>chunk_index_select_tablespace</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>chunkrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tablespace</name> <modifier>*</modifier></type><name>tspc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tablespace_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tspc</name> <operator>=</operator> <call><name>ts_hypertable_get_tablespace_at_offset_from</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>,
													   <argument><expr><name><name>chunkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>,
													   <argument><expr><name>CHUNK_INDEX_TABLESPACE_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>tspc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tablespace_oid</name> <operator>=</operator> <name><name>tspc</name><operator>-&gt;</operator><name>tablespace_oid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>tablespace_oid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>ts_chunk_index_get_tablespace</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>template_indexrel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>chunkrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Determine the index's tablespace. Use the main index's tablespace, or,
	 * if not set, select one at an offset from the chunk's tablespace.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>template_indexrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>template_indexrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>chunk_index_select_tablespace</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>, <argument><expr><name>chunkrel</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a chunk index based on the configuration of the "parent" index.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>chunk_relation_index_create</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>htrel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>template_indexrel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>chunkrel</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>isconstraint</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_tablespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexinfo</name> <init>= <expr><call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>template_indexrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>hypertable_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>skip_mapping</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the supplied template index is not on the hypertable we must not do attnum
	 * mapping based on the hypertable. Ideally we would check for the template being
	 * on the chunk but we cannot do that since when we rebuild a chunk the new chunk
	 * has a different id. But the template index should always be either on the
	 * hypertable or on a relation with the same physical layout as chunkrel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><name><name>template_indexrel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>htrel</name><operator>-&gt;</operator><name>rd_id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>skip_mapping</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Convert the IndexInfo's attnos to match the chunk instead of the
	 * hypertable
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_mapping</name> <operator>&amp;&amp;</operator>
		<call><name>chunk_index_need_attnos_adjustment</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>htrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>chunkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ts_adjust_indexinfo_attnos</name><argument_list>(<argument><expr><name>indexinfo</name></expr></argument>, <argument><expr><name><name>htrel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>chunkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hypertable_id</name> <operator>=</operator> <call><name>ts_hypertable_relid_to_id</name><argument_list>(<argument><expr><name><name>htrel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ts_chunk_index_create_post_adjustment</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>,
												 <argument><expr><name>template_indexrel</name></expr></argument>,
												 <argument><expr><name>chunkrel</name></expr></argument>,
												 <argument><expr><name>indexinfo</name></expr></argument>,
												 <argument><expr><name>isconstraint</name></expr></argument>,
												 <argument><expr><name>index_tablespace</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ts_chunk_index_create_post_adjustment</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>template_indexrel</name></decl></parameter>,
									  <parameter><decl><type><name>Relation</name></type> <name>chunkrel</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isconstraint</name></decl></parameter>,
									  <parameter><decl><type><name>Oid</name></type> <name>index_tablespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_indexrelid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>reloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>indclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name> <modifier>*</modifier></type><name>indclassoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colnames</name> <init>= <expr><call><name>create_index_colnames</name><argument_list>(<argument><expr><name>template_indexrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tablespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits16</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>template_indexrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"cache lookup failed for index relation %u"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>template_indexrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indclass</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
							   <argument><expr><name><name>template_indexrel</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>,
							   <argument><expr><name>Anum_pg_index_indclass</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indclassoid</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexname</name> <operator>=</operator> <call><name>chunk_index_choose_name</name><argument_list>(<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>chunkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>template_indexrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>chunkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_tablespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tablespace</name> <operator>=</operator> <name>index_tablespace</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tablespace</name> <operator>=</operator> <call><name>ts_chunk_index_get_tablespace</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>, <argument><expr><name>template_indexrel</name></expr></argument>, <argument><expr><name>chunkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* assign flags for index creation and constraint creation */</comment>
	<if_stmt><if>if <condition>(<expr><name>isconstraint</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>INDEX_CREATE_ADD_CONSTRAINT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>template_indexrel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>INDEX_CREATE_IS_PRIMARY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunk_indexrelid</name> <operator>=</operator> <call><name>index_create</name><argument_list>(<argument><expr><name>chunkrel</name></expr></argument>,
									<argument><expr><name>indexname</name></expr></argument>,
									<argument><expr><name>InvalidOid</name></expr></argument>,
									<argument><expr><name>InvalidOid</name></expr></argument>,
									<argument><expr><name>InvalidOid</name></expr></argument>,
									<argument><expr><name>InvalidOid</name></expr></argument>,
									<argument><expr><name>indexinfo</name></expr></argument>,
									<argument><expr><name>colnames</name></expr></argument>,
									<argument><expr><name><name>template_indexrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>,
									<argument><expr><name>tablespace</name></expr></argument>,
									<argument><expr><name><name>template_indexrel</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>,
									<argument><expr><name><name>indclassoid</name><operator>-&gt;</operator><name>values</name></name></expr></argument>,
									<argument><expr><name><name>template_indexrel</name><operator>-&gt;</operator><name>rd_indoption</name></name></expr></argument>,
									<argument><expr><name>reloptions</name></expr></argument>,
									<argument><expr><name>flags</name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>,	   <comment type="block">/* constr_flags constant and 0
											* for now */</comment>
									<argument><expr><name>false</name></expr></argument>, <comment type="block">/* allow system table mods */</comment>
									<argument><expr><name>false</name></expr></argument>, <comment type="block">/* is internal */</comment>
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* constraintId */</comment>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunk_indexrelid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_index_insert_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>chunk_index</name></decl></parameter>,
							<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parent_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_chunk_index</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_chunk_index</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_index_chunk_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_index_index_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>chunk_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_index_hypertable_id</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_index_hypertable_index_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
		<call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>parent_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_insert_values</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an parent-child index mapping to the catalog.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_index_insert</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>chunk_index</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hypertable_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK_INDEX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator>
		<call><name>chunk_index_insert_relation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>chunk_index</name></expr></argument>, <argument><expr><name>hypertable_id</name></expr></argument>, <argument><expr><name>hypertable_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_chunk_index_create_from_constraint</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>hypertable_constraint</name></decl></parameter>,
									  <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_constraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_indexrelid</name> <init>= <expr><call><name>get_constraint_index</name><argument_list>(<argument><expr><name>chunk_constraint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>hypertable_indexrelid</name> <init>= <expr><call><name>get_constraint_index</name><argument_list>(<argument><expr><name>hypertable_constraint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>chunk_indexrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>hypertable_indexrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chunk_index_insert</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>,
					   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_indexrelid</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>hypertable_id</name></expr></argument>,
					   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>hypertable_indexrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new chunk index as a child of a parent hypertable index.
 *
 * The chunk index is created based on the information from the parent index
 * relation. This function is typically called when a new chunk is created and
 * it should, for each hypertable index, have a corresponding index of its own.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_index_create</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>hypertable_rel</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>hypertable_idxrel</name></decl></parameter>,
				   <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>chunkrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constraint_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_tblspc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_indexrelid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraint_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there is an associated constraint then that constraint created
		 * both the index and the catalog entry for the index
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>chunk_indexrelid</name> <operator>=</operator> <call><name>chunk_relation_index_create</name><argument_list>(<argument><expr><name>hypertable_rel</name></expr></argument>,
												   <argument><expr><name>hypertable_idxrel</name></expr></argument>,
												   <argument><expr><name>chunkrel</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>,
												   <argument><expr><name>index_tblspc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chunk_index_insert</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>,
					   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_indexrelid</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>hypertable_id</name></expr></argument>,
					   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>hypertable_idxrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_chunk_index_create_from_adjusted_index_info</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>hypertable_idxrel</name></decl></parameter>,
											   <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>chunkrel</name></decl></parameter>,
											   <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_indexrelid</name> <init>= <expr><call><name>ts_chunk_index_create_post_adjustment</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>,
																 <argument><expr><name>hypertable_idxrel</name></expr></argument>,
																 <argument><expr><name>chunkrel</name></expr></argument>,
																 <argument><expr><name>indexinfo</name></expr></argument>,
																 <argument><expr><name>false</name></expr></argument>,
																 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>chunk_index_insert</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>,
					   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_indexrelid</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>hypertable_id</name></expr></argument>,
					   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>hypertable_idxrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create all indexes on a chunk, given the indexes that exists on the chunk's
 * hypertable.
 */</comment>
<function><type><name>void</name></type>
<name>ts_chunk_index_create_all</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>hypertable_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>hypertable_relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunkrelid</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>index_tblspc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>htrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>chunkrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>chunk_relkind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>chunkrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Foreign table chunks don't support indexes */</comment>
	<if_stmt><if>if <condition>(<expr><name>chunk_relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunk_relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>htrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>hypertable_relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Need ShareLock on the heap relation we are creating indexes on */</comment>
	<expr_stmt><expr><name>chunkrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>chunkrelid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should only add those indexes that aren't created from constraints,
	 * since those are added separately.
	 *
	 * Ideally, we should just be able to check the index relation's rd_index
	 * struct for the flags indisunique, indisprimary, indisexclusion to
	 * figure out if this is a constraint-supporting index. However,
	 * indisunique is true both for plain unique indexes and those created
	 * from constraints. Instead, we prune the main table's index list,
	 * removing those indexes that are supporting a constraint.
	 */</comment>
	<expr_stmt><expr><name>indexlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>htrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>indexlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>hypertable_idxoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>hypertable_idxrel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>hypertable_idxoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>chunk_index_create</name><argument_list>(<argument><expr><name>htrel</name></expr></argument>,
						   <argument><expr><name>hypertable_id</name></expr></argument>,
						   <argument><expr><name>hypertable_idxrel</name></expr></argument>,
						   <argument><expr><name>chunk_id</name></expr></argument>,
						   <argument><expr><name>chunkrel</name></expr></argument>,
						   <argument><expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name>hypertable_idxoid</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>index_tblspc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>hypertable_idxrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>chunkrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>htrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>chunk_index_scan</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>indexid</name></decl></parameter>, <parameter><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>tuple_found_func</name></type> <name>tuple_found</name></decl></parameter>,
				 <parameter><decl><type><name>tuple_filter_func</name></type> <name>tuple_filter</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Catalog</name> <modifier>*</modifier></type><name>catalog</name> <init>= <expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScannerCtx</name></type> <name>scanctx</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table</name> <operator>=</operator> <call><name>catalog_get_table_id</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK_INDEX</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>index</name> <operator>=</operator> <call><name>catalog_get_index</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>CHUNK_INDEX</name></expr></argument>, <argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>nkeys</name> <operator>=</operator> <name>nkeys</name></expr>,
		<expr><operator>.</operator><name>scankey</name> <operator>=</operator> <name>scankey</name></expr>,
		<expr><operator>.</operator><name>tuple_found</name> <operator>=</operator> <name>tuple_found</name></expr>,
		<expr><operator>.</operator><name>filter</name> <operator>=</operator> <name>tuple_filter</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>data</name></expr>,
		<expr><operator>.</operator><name>lockmode</name> <operator>=</operator> <name>lockmode</name></expr>,
		<expr><operator>.</operator><name>scandirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ts_scanner_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chunk_index_scan_update</name><parameter_list>(<parameter><type><name>idxid</name></type></parameter>, <parameter><type><name>scankey</name></type></parameter>, <parameter><type><name>nkeys</name></type></parameter>, <parameter><type><name>tuple_found</name></type></parameter>, <parameter><type><name>tuple_filter</name></type></parameter>, <parameter><type><name>data</name></type></parameter>)</parameter_list></cpp:macro>            \
	<cpp:value>chunk_index_scan(idxid, scankey, nkeys, tuple_found, tuple_filter, data, RowExclusiveLock)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>ChunkIndexMapping</name> <modifier>*</modifier></type>
<name>chunk_index_mapping_from_tuple</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>ChunkIndexMapping</name> <modifier>*</modifier></type><name>cim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_chunk_index</name> <modifier>*</modifier></type><name>chunk_index</name> <init>= <expr><operator>(</operator><name>FormData_chunk_index</name> <operator>*</operator><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name><name>chunk_index</name><operator>-&gt;</operator><name>chunk_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>nspoid_chunk</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>nspoid_hyper</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cim</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cim</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkIndexMapping</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>cim</name><operator>-&gt;</operator><name>chunkoid</name></name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cim</name><operator>-&gt;</operator><name>indexoid</name></name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk_index</name><operator>-&gt;</operator><name>index_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nspoid_chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cim</name><operator>-&gt;</operator><name>parent_indexoid</name></name> <operator>=</operator>
		<call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk_index</name><operator>-&gt;</operator><name>hypertable_index_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nspoid_hyper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cim</name><operator>-&gt;</operator><name>hypertableoid</name></name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>cim</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_index_collect</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>mappings</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkIndexMapping</name> <modifier>*</modifier></type><name>cim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldmctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cim</name> <operator>=</operator> <call><name>chunk_index_mapping_from_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldmctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>mappings</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>mappings</name></expr></argument>, <argument><expr><name>cim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldmctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_chunk_index_get_mappings</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>hypertable_indexrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>hypertable_indexrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mappings</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_hypertable_id_hypertable_index_name_idx_hypertable_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_hypertable_id_hypertable_index_name_idx_hypertable_index_name</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>indexname</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>chunk_index_scan</name><argument_list>(<argument><expr><name>CHUNK_INDEX_HYPERTABLE_ID_HYPERTABLE_INDEX_NAME_IDX</name></expr></argument>,
					 <argument><expr><name>scankey</name></expr></argument>,
					 <argument><expr><literal type="number">2</literal></expr></argument>,
					 <argument><expr><name>chunk_index_collect</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>mappings</name></expr></argument>,
					 <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>mappings</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>ChunkIndexDeleteData</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>index_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>drop_index</name></decl>;</decl_stmt>
}</block></struct></type> <name>ChunkIndexDeleteData</name>;</typedef>

<comment type="block">/* Find all internal dependencies to be able to delete all the objects in one
 * go. We do this by scanning the dependency table and keeping all the tables
 * in our internal schema. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_collect_objects_for_deletion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>relobj</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>deprel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><name>relobj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_objid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>relobj</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>deprel</name></expr></argument>,
							  <argument><expr><name>DependDependerIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>scankey</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>scankey</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							  <argument><expr><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>record</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>refobj</name> <init>= <expr><block>{ <expr><operator>.</operator><name>classId</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>refclassid</name></name></expr>, <expr><operator>.</operator><name>objectId</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>refobjid</name></name></expr> }</block></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>deptype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DEPENDENCY_INTERNAL</name></expr>:</case>
				<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>refobj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<continue>continue;</continue> <comment type="block">/* Do nothing */</comment>
		</block_content>}</block></switch>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>deprel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_index_tuple_delete</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_chunk_index</name> <modifier>*</modifier></type><name>chunk_index</name> <init>= <expr><operator>(</operator><name>FormData_chunk_index</name> <operator>*</operator><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaid</name> <init>= <expr><call><name>ts_chunk_get_schema_id</name><argument_list>(<argument><expr><name><name>chunk_index</name><operator>-&gt;</operator><name>chunk_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkIndexDeleteData</name> <modifier>*</modifier></type><name>cid</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_catalog_delete_tid</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tuple_tid</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cid</name><operator>-&gt;</operator><name>drop_index</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>idxobj</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>classId</name> <operator>=</operator> <name>RelationRelationId</name></expr>,
			<expr><operator>.</operator><name>objectId</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk_index</name><operator>-&gt;</operator><name>index_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>schemaid</name></expr></argument>)</argument_list></call></expr>,
		}</block></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>idxobj</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If we use performDeletion here it will fail if there are
			 * internal dependencies on the object since we are restricting
			 * the cascade.
			 *
			 * If we automatically cascade here, we might drop user-defined
			 * dependencies, which we do not want, so instead we collect the
			 * internal dependencies and use the function
			 * performMultipleDeletions.
			 *
			 * The function performMultipleDeletions accept a list of objects
			 * and if there are dependencies between any of the objects given
			 * to the function, it will not generate an error for that but
			 * rather proceed with the deletion. If there are any dependencies
			 * (internal or not) outside this set of objects, it will still
			 * abort the deletion and print an error. */</comment>
			<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name> <init>= <expr><call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>chunk_collect_objects_for_deletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idxobj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanFilterResult</name></type>
<name>chunk_index_name_and_schema_filter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_chunk_index</name> <modifier>*</modifier></type><name>chunk_index</name> <init>= <expr><operator>(</operator><name>FormData_chunk_index</name> <operator>*</operator><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkIndexDeleteData</name> <modifier>*</modifier></type><name>cid</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanFilterResult</name></type> <name>result</name> <init>= <expr><name>SCAN_EXCLUDE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk_index</name><operator>-&gt;</operator><name>index_name</name></name></expr></argument>, <argument><expr><name><name>cid</name><operator>-&gt;</operator><name>index_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name><name>chunk_index</name><operator>-&gt;</operator><name>chunk_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>chunk</name> <operator>&amp;&amp;</operator> <call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>, <argument><expr><name><name>cid</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>SCAN_INCLUDE</name></expr>;</expr_stmt>
			<goto>goto <name>end_filter</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk_index</name><operator>-&gt;</operator><name>hypertable_index_name</name></name></expr></argument>, <argument><expr><name><name>cid</name><operator>-&gt;</operator><name>index_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name><name>chunk_index</name><operator>-&gt;</operator><name>hypertable_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>ht</name> <operator>&amp;&amp;</operator> <call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>, <argument><expr><name><name>cid</name><operator>-&gt;</operator><name>schema</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>SCAN_INCLUDE</name></expr>;</expr_stmt>
			<goto>goto <name>end_filter</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

<label><name>end_filter</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_chunk_index_delete</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>drop_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkIndexDeleteData</name></type> <name>data</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>drop_index</name> <operator>=</operator> <name>drop_index</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_chunk_id_index_name_idx_chunk_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_chunk_id_index_name_idx_index_name</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_index_scan_update</name><argument_list>(<argument><expr><name>CHUNK_INDEX_CHUNK_ID_INDEX_NAME_IDX</name></expr></argument>,
								   <argument><expr><name>scankey</name></expr></argument>,
								   <argument><expr><literal type="number">2</literal></expr></argument>,
								   <argument><expr><name>chunk_index_tuple_delete</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_chunk_index_delete_by_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>index_name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>drop_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkIndexDeleteData</name></type> <name>data</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>index_name</name> <operator>=</operator> <name>index_name</name></expr>,
		<expr><operator>.</operator><name>drop_index</name> <operator>=</operator> <name>drop_index</name></expr>,
		<expr><operator>.</operator><name>schema</name> <operator>=</operator> <name>schema</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>chunk_index_scan_update</name><argument_list>(<argument><expr><name>INVALID_INDEXID</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><name>chunk_index_tuple_delete</name></expr></argument>,
							<argument><expr><name>chunk_index_name_and_schema_filter</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_chunk_index_delete_by_chunk_id</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>drop_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkIndexDeleteData</name></type> <name>data</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>drop_index</name> <operator>=</operator> <name>drop_index</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_chunk_id_index_name_idx_chunk_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_index_scan_update</name><argument_list>(<argument><expr><name>CHUNK_INDEX_CHUNK_ID_INDEX_NAME_IDX</name></expr></argument>,
								   <argument><expr><name>scankey</name></expr></argument>,
								   <argument><expr><literal type="number">1</literal></expr></argument>,
								   <argument><expr><name>chunk_index_tuple_delete</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_index_tuple_found</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkIndexMapping</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cim</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>chunk_index_mapping_from_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>cim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_chunk_index_get_by_indexrelid</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_indexrelid</name></decl></parameter>, <parameter><decl><type><name>ChunkIndexMapping</name> <modifier>*</modifier></type><name>cim_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>tuples_found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_indexrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cim_out</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_chunk_id_index_name_idx_chunk_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_chunk_id_index_name_idx_index_name</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuples_found</name> <operator>=</operator> <call><name>chunk_index_scan</name><argument_list>(<argument><expr><name>CHUNK_INDEX_CHUNK_ID_INDEX_NAME_IDX</name></expr></argument>,
									<argument><expr><name>scankey</name></expr></argument>,
									<argument><expr><literal type="number">2</literal></expr></argument>,
									<argument><expr><name>chunk_index_tuple_found</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>cim_out</name></expr></argument>,
									<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuples_found</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanFilterResult</name></type>
<name>chunk_hypertable_index_name_filter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkIndexMapping</name> <modifier>*</modifier></type><name>cim</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hypertable_indexname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>cim</name><operator>-&gt;</operator><name>parent_indexoid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>hypertable_indexname_datum</name> <init>=
		<expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>, <argument><expr><name>Anum_chunk_index_hypertable_index_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name>hypertable_indexname_datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hypertable_indexname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SCAN_INCLUDE</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>SCAN_EXCLUDE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>bool</name></type>
<name>ts_chunk_index_get_by_hypertable_indexrelid</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>hypertable_indexrelid</name></decl></parameter>,
											<parameter><decl><type><name>ChunkIndexMapping</name> <modifier>*</modifier></type><name>cim_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>tuples_found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cim_out</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cim_out</name><operator>-&gt;</operator><name>parent_indexoid</name></name> <operator>=</operator> <name>hypertable_indexrelid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_chunk_id_index_name_idx_chunk_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuples_found</name> <operator>=</operator> <call><name>chunk_index_scan</name><argument_list>(<argument><expr><name>CHUNK_INDEX_CHUNK_ID_INDEX_NAME_IDX</name></expr></argument>,
									<argument><expr><name>scankey</name></expr></argument>,
									<argument><expr><literal type="number">1</literal></expr></argument>,
									<argument><expr><name>chunk_index_tuple_found</name></expr></argument>,
									<argument><expr><name>chunk_hypertable_index_name_filter</name></expr></argument>,
									<argument><expr><name>cim_out</name></expr></argument>,
									<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuples_found</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>ChunkIndexRenameInfo</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldname</name></decl>, <modifier>*</modifier><name>newname</name>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isparent</name></decl>;</decl_stmt>
}</block></struct></type> <name>ChunkIndexRenameInfo</name>;</typedef>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_index_tuple_rename</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkIndexRenameInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_chunk_index</name> <modifier>*</modifier></type><name>chunk_index</name> <init>= <expr><operator>(</operator><name>FormData_chunk_index</name> <operator>*</operator><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>isparent</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the renaming is for a hypertable index, we also rename all
		 * corresponding chunk indexes
		 */</comment>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_id</name><argument_list>(<argument><expr><name><name>chunk_index</name><operator>-&gt;</operator><name>chunk_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_schemaoid</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>chunk_index_name</name> <init>=
			<expr><call><name>chunk_index_choose_name</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>, <argument><expr><name>chunk_schemaoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_indexrelid</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk_index</name><operator>-&gt;</operator><name>index_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>chunk_schemaoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ts_chunk_constraint_adjust_meta</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>,
										<argument><expr><name><name>info</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>,
										<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk_index</name><operator>-&gt;</operator><name>index_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>chunk_index_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the metadata */</comment>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk_index</name><operator>-&gt;</operator><name>index_name</name></name></expr></argument>, <argument><expr><name>chunk_index_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk_index</name><operator>-&gt;</operator><name>hypertable_index_name</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Rename the chunk index */</comment>
		<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>chunk_indexrelid</name></expr></argument>, <argument><expr><name>chunk_index_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk_index</name><operator>-&gt;</operator><name>index_name</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ts_catalog_update</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>isparent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>SCAN_DONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scan_by_chunk_id_index_name</name><parameter_list>(<parameter><decl><type><name>ScanIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>index_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ctx</name><operator>.</operator><name>index</name></name> <operator>=</operator>
		<call><name>catalog_get_index</name><argument_list>(<argument><expr><call><name>ts_catalog_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CHUNK_INDEX</name></expr></argument>, <argument><expr><name>CHUNK_INDEX_CHUNK_ID_INDEX_NAME_IDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_chunk_index_chunk_id</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_INT4EQ</name></expr></argument>,
								   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_scan_iterator_scan_key_init</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>,
								   <argument><expr><name>Anum_chunk_index_index_name</name></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>F_NAMEEQ</name></expr></argument>,
								   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>index_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust internal metadata after index/constraint rename
 */</comment>
<function><type><name>int</name></type>
<name>ts_chunk_index_adjust_meta</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ht_index_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_name</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanIterator</name></type> <name>iterator</name> <init>=
		<expr><call><name>ts_scan_iterator_create</name><argument_list>(<argument><expr><name>CHUNK_INDEX</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_scan_by_chunk_id_index_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name>old_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>ts_scanner_foreach</name><argument_list>(<argument>&amp;iterator</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_chunk_index</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>doReplace</name><index>[<expr><name>Natts_chunk_index</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_chunk_index</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>ts_scan_iterator_tuple_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>new_tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_index_hypertable_index_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator>
			<call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>ht_index_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_index_hypertable_index_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_index_index_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>doReplace</name><index>[<expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>Anum_chunk_index_index_name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_tuple</name> <operator>=</operator>
			<call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>ts_scanner_get_tupledesc</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>doReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ts_catalog_update</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_chunk_index_rename</name><parameter_list>(<parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_indexrelid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>chunk_indexrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkIndexRenameInfo</name></type> <name>renameinfo</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>oldname</name> <operator>=</operator> <name>indexname</name></expr>,
		<expr><operator>.</operator><name>newname</name> <operator>=</operator> <name>new_name</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_chunk_id_index_name_idx_chunk_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_chunk_id_index_name_idx_index_name</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_index_scan_update</name><argument_list>(<argument><expr><name>CHUNK_INDEX_CHUNK_ID_INDEX_NAME_IDX</name></expr></argument>,
								   <argument><expr><name>scankey</name></expr></argument>,
								   <argument><expr><literal type="number">2</literal></expr></argument>,
								   <argument><expr><name>chunk_index_tuple_rename</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>renameinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_chunk_index_rename_parent</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>hypertable_indexrelid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>hypertable_indexrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkIndexRenameInfo</name></type> <name>renameinfo</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>oldname</name> <operator>=</operator> <name>indexname</name></expr>,
		<expr><operator>.</operator><name>newname</name> <operator>=</operator> <name>new_name</name></expr>,
		<expr><operator>.</operator><name>isparent</name> <operator>=</operator> <name>true</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_hypertable_id_hypertable_index_name_idx_hypertable_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_hypertable_id_hypertable_index_name_idx_hypertable_index_name</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_index_scan_update</name><argument_list>(<argument><expr><name>CHUNK_INDEX_HYPERTABLE_ID_HYPERTABLE_INDEX_NAME_IDX</name></expr></argument>,
								   <argument><expr><name>scankey</name></expr></argument>,
								   <argument><expr><literal type="number">2</literal></expr></argument>,
								   <argument><expr><name>chunk_index_tuple_rename</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>renameinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ScanTupleResult</name></type>
<name>chunk_index_tuple_set_tablespace</name><parameter_list>(<parameter><decl><type><name>TupleInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tablespace</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>should_free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ts_scanner_fetch_heap_tuple</name><argument_list>(<argument><expr><name>ti</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_chunk_index</name> <modifier>*</modifier></type><name>chunk_index</name> <init>= <expr><operator>(</operator><name>FormData_chunk_index</name> <operator>*</operator><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaoid</name> <init>= <expr><call><name>ts_chunk_get_schema_id</name><argument_list>(<argument><expr><name><name>chunk_index</name><operator>-&gt;</operator><name>chunk_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>indexrelid</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>chunk_index</name><operator>-&gt;</operator><name>index_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>schemaoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_SetTableSpace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>tablespace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_alter_table_with_event_trigger</name><argument_list>(<argument><expr><name>indexrelid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>SCAN_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ts_chunk_index_set_tablespace</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>hypertable_indexrelid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tablespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>indexname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>hypertable_indexrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_hypertable_id_hypertable_index_name_idx_hypertable_id</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_chunk_index_hypertable_id_hypertable_index_name_idx_hypertable_index_name</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>chunk_index_scan_update</name><argument_list>(<argument><expr><name>CHUNK_INDEX_HYPERTABLE_ID_HYPERTABLE_INDEX_NAME_IDX</name></expr></argument>,
								   <argument><expr><name>scankey</name></expr></argument>,
								   <argument><expr><literal type="number">2</literal></expr></argument>,
								   <argument><expr><name>chunk_index_tuple_set_tablespace</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tablespace</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TSDLLEXPORT</name> <name>void</name></type>
<name>ts_chunk_index_mark_clustered</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>chunkrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>chunkrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>mark_index_clustered</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indexrelid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_chunk_index_clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>chunk_index_duplicate_index</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>hypertable_rel</name></decl></parameter>, <parameter><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>src_chunk</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_index_oid</name></decl></parameter>,
							<parameter><decl><type><name>Relation</name></type> <name>dest_chunk_rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_tablespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>chunk_index_rel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>chunk_index_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkIndexMapping</name></type> <name>cim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>constraint_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>new_chunk_indexrelid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ts_chunk_index_get_by_indexrelid</name><argument_list>(<argument><expr><name>src_chunk</name></expr></argument>, <argument><expr><name>chunk_index_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>constraint_oid</name> <operator>=</operator> <call><name>get_index_constraint</name><argument_list>(<argument><expr><name><name>cim</name><operator>.</operator><name>parent_indexoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_chunk_indexrelid</name> <operator>=</operator> <call><name>chunk_relation_index_create</name><argument_list>(<argument><expr><name>hypertable_rel</name></expr></argument>,
													   <argument><expr><name>chunk_index_rel</name></expr></argument>,
													   <argument><expr><name>dest_chunk_rel</name></expr></argument>,
													   <argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraint_oid</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><name>index_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>chunk_index_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>new_chunk_indexrelid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create versions of every index over src_chunkrelid over chunkrelid.
 * Returns the relids of the new indexes created.
 * New indexes are in the same order as RelationGetIndexList.
 */</comment>
<function><type><name>TSDLLEXPORT</name> <name>List</name> <modifier>*</modifier></type>
<name>ts_chunk_index_duplicate</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>src_chunkrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dest_chunkrelid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>src_index_oids</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>index_tablespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>hypertable_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>src_chunk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>dest_chunk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>index_oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>index_elem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_index_oids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>src_chunk</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>src_chunk_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>src_chunkrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dest_chunk_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>dest_chunkrelid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>src_chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>src_chunkrelid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hypertable_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>src_chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>index_oids</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>src_chunk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>index_elem</argument>, <argument>index_oids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_index_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>index_elem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>new_chunk_indexrelid</name> <init>= <expr><call><name>chunk_index_duplicate_index</name><argument_list>(<argument><expr><name>hypertable_rel</name></expr></argument>,
															   <argument><expr><name>src_chunk</name></expr></argument>,
															   <argument><expr><name>chunk_index_oid</name></expr></argument>,
															   <argument><expr><name>dest_chunk_rel</name></expr></argument>,
															   <argument><expr><name>index_tablespace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>new_index_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>new_index_oids</name></expr></argument>, <argument><expr><name>new_chunk_indexrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>hypertable_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>dest_chunk_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>src_chunk_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>src_index_oids</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>src_index_oids</name> <operator>=</operator> <name>index_oids</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>new_index_oids</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>chunk_index_clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>ts_chunk_index_clone</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_index_oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>chunk_index_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>hypertable_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>chunk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>constraint_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>new_chunk_indexrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkIndexMapping</name></type> <name>cim</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>chunk_index_rel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>chunk_index_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name><name>chunk_index_rel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_chunk_index_get_by_indexrelid</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>chunk_index_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_hypertable_permissions_check</name><argument_list>(<argument><expr><name><name>cim</name><operator>.</operator><name>hypertableoid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hypertable_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>cim</name><operator>.</operator><name>hypertableoid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Need ShareLock on the heap relation we are creating indexes on */</comment>
	<expr_stmt><expr><name>chunk_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>chunk_index_rel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>constraint_oid</name> <operator>=</operator> <call><name>get_index_constraint</name><argument_list>(<argument><expr><name><name>cim</name><operator>.</operator><name>parent_indexoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_chunk_indexrelid</name> <operator>=</operator> <call><name>chunk_relation_index_create</name><argument_list>(<argument><expr><name>hypertable_rel</name></expr></argument>,
													   <argument><expr><name>chunk_index_rel</name></expr></argument>,
													   <argument><expr><name>chunk_rel</name></expr></argument>,
													   <argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraint_oid</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>hypertable_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>chunk_index_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>new_chunk_indexrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_chunk_index_replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>ts_chunk_index_replace</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_index_oid_old</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_index_oid_new</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>index_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkIndexMapping</name></type> <name>cim</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>constraint_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>index_rel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>chunk_index_oid_old</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check permissions */</comment>
	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name><name>index_rel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_chunk_index_get_by_indexrelid</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>chunk_index_oid_old</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_hypertable_permissions_check</name><argument_list>(<argument><expr><name><name>cim</name><operator>.</operator><name>hypertableoid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>constraint_oid</name> <operator>=</operator> <call><name>get_index_constraint</name><argument_list>(<argument><expr><name>chunk_index_oid_old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraint_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>constraintobj</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>classId</name> <operator>=</operator> <name>ConstraintRelationId</name></expr>,
			<expr><operator>.</operator><name>objectId</name> <operator>=</operator> <name>constraint_oid</name></expr>,
		}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>constraintobj</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>idxobj</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>classId</name> <operator>=</operator> <name>RelationRelationId</name></expr>,
			<expr><operator>.</operator><name>objectId</name> <operator>=</operator> <name>chunk_index_oid_old</name></expr>,
		}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idxobj</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>chunk_index_oid_new</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ts_chunk_index_move_all</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index_tblspc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>chunkrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>chunk_relkind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* execute ALTER INDEX .. SET TABLESPACE for each index on the chunk */</comment>
	<decl_stmt><decl><type><name>AlterTableCmd</name></type> <name>cmd</name> <init>= <expr><block>{ <expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_AlterTableCmd</name></expr>,
						  <expr><operator>.</operator><name>subtype</name> <operator>=</operator> <name>AT_SetTableSpace</name></expr>,
						  <expr><operator>.</operator><name>name</name> <operator>=</operator> <macro><name>get_tablespace_name</name><argument_list>(<argument>index_tblspc</argument>)</argument_list></macro></expr> }</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Foreign table chunks don't support indexes */</comment>
	<if_stmt><if>if <condition>(<expr><name>chunk_relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunk_relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunkrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>chunkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>indexlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_idxoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ts_alter_table_with_event_trigger</name><argument_list>(<argument><expr><name>chunk_idxoid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>chunkrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
