<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/nodes/hypertable_modify.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/execPartition.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/nodeModifyTable.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;foreign/foreign.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/execnodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/extensible.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/plannodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/plancat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/lmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_dispatch_plan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_dispatch_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cross_module_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_modify.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_append/chunk_append.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/hypertable_data_node.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fireASTriggers</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fireBSTriggers</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecModifyTable</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecProcessReturning</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleSlot</name></decl></parameter>,
											<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitInsertProjection</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitUpdateProjection</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecCheckPlanOutput</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>resultRel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecGetInsertNewTuple</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecInsert</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
								  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecBatchInsert</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
							<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>slots</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>planSlots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numSlots</name></decl></parameter>,
							<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecDelete</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
								  <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
								  <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>processReturning</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changingPart</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>tupleDeleted</name></decl></parameter>,
								  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>epqreturnslot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecUpdate</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
								  <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>, <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecOnConflictUpdate</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
								 <parameter><decl><type><name>ItemPointer</name></type> <name>conflictTid</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
								 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>excludedSlot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
								 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>returning</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecCheckTupleVisible</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecCheckTIDVisible</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
								<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tempSlot</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_chunk_dispatch_states</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>substate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>substate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>csstate</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScanState</name></expr></argument>, <argument><expr><name>substate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>ts_is_chunk_dispatch_state</name><argument_list>(<argument><expr><name>substate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>substate</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * In case of remote insert, the ChunkDispatchState could be a
			 * child of a ServerDispatchState subnode.
			 */</comment>
			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>csstate-&gt;custom_ps</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>get_chunk_dispatch_states</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>T_ResultState</name></expr>:</case>
			<return>return <expr><call><name>get_chunk_dispatch_states</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>ResultState</name></expr></argument>, <argument><expr><name>substate</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * HypertableInsert (with corresponding executor node) is a plan node that
 * implements INSERTs for hypertables. It is mostly a wrapper around the
 * ModifyTable plan node that simply calls the wrapped ModifyTable plan without
 * doing much else, apart from some initial state setup.
 *
 * The wrapping is needed to setup state in the execution phase, and give access
 * to the ModifyTableState node to sub-plan states in the PlanState tree. For
 * instance, the ChunkDispatchState node needs to set the arbiter index list in
 * the ModifyTableState node whenever it inserts into a new chunk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypertable_modify_begin</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HypertableModifyState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>HypertableModifyState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_dispatch_states</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>mt</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * To make statement trigger defined on the hypertable work
	 * we need to set the hypertable as the rootRelation otherwise
	 * statement trigger defined only on the hypertable will not fire.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mt</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_DELETE</name> <operator>||</operator> <name><name>mt</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>rootRelation</name></name> <operator>=</operator> <name><name>mt</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ps</name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mt</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mtstate</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTableState</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is not the primary ModifyTable node, postgres added it to the
	 * beginning of es_auxmodifytables, to be executed by ExecPostprocessPlan.
	 * Unfortunately that strips off the HypertableInsert node leading to
	 * tuple routing not working in INSERTs inside CTEs. To make INSERTs
	 * inside CTEs work we have to fix es_auxmodifytables and add back the
	 * HypertableModifyState.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_auxmodifytables</name></name> <operator>&amp;&amp;</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_auxmodifytables</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>mtstate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_auxmodifytables</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Find all ChunkDispatchState subnodes and set their parent
		 * ModifyTableState node
		 * We assert we only have 1 ModifyTable subpath when we create
		 * the HypertableInsert path so this should not have changed here.
		 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* setup chunk dispatch state only for INSERTs */</comment>
		<expr_stmt><expr><name>chunk_dispatch_states</name> <operator>=</operator> <call><name>get_chunk_dispatch_states</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Ensure that we found at least one ChunkDispatchState node */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>chunk_dispatch_states</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunk_dispatch_states</argument>)</argument_list></macro>
			<expr_stmt><expr><call><name>ts_chunk_dispatch_state_set_parent</name><argument_list>(<argument><expr><operator>(</operator><name>ChunkDispatchState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>hypertable_modify_exec</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<return>return <expr><call><name>ExecProcNode</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>ModifyTableState</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>ExecModifyTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypertable_modify_end</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypertable_modify_rescan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hypertable_modify_explain</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HypertableModifyState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>HypertableModifyState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>mt</name><operator>-&gt;</operator><name>fdwPrivLists</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>ModifyTableState</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>rti</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>mt</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<comment type="block">/*
	 * The targetlist for this node will have references that cannot be resolved by
	 * EXPLAIN. So for EXPLAIN VERBOSE we clear the targetlist so that EXPLAIN does not
	 * complain. PostgreSQL does something equivalent and does not print the targetlist
	 * for ModifyTable for EXPLAIN VERBOSE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>operation</name> <operator>==</operator> <name>CMD_DELETE</name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>verbose</name></name> <operator>&amp;&amp;</operator>
		<call><name>ts_is_chunk_append_plan</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name><operator>)</operator><operator>-&gt;</operator><name>custom_scan_tlist</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since we hijack the ModifyTable node instrumentation on ModifyTable will
	 * be missing so we set it to instrumentation of HypertableModify node.
	 */</comment>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>instrument</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Insert on distributed hypertable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>node_names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
							 <argument><expr><literal type="string">" %s.%s\n"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>state-&gt;serveroids</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><call><name>GetForeignServer</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>node_names</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>node_names</name></expr></argument>, <argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>ExplainPropertyList</name><argument_list>(<argument><expr><literal type="string">"Data nodes"</literal></expr></argument>, <argument><expr><name>node_names</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Let the foreign data wrapper add its part of the explain, but only
		 * if this was using the non-direct API. */</comment>
		<if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name>fdw_private</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>ExplainForeignModify</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>state</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>ExplainForeignModify</name></name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>,
													<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr></argument>,
													<argument><expr><name>fdw_private</name></expr></argument>,
													<argument><expr><literal type="number">0</literal></expr></argument>,
													<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomExecMethods</name></type> <name>hypertable_modify_state_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"HypertableModifyState"</literal></expr>,
	<expr><operator>.</operator><name>BeginCustomScan</name> <operator>=</operator> <name>hypertable_modify_begin</name></expr>,
	<expr><operator>.</operator><name>EndCustomScan</name> <operator>=</operator> <name>hypertable_modify_end</name></expr>,
	<expr><operator>.</operator><name>ExecCustomScan</name> <operator>=</operator> <name>hypertable_modify_exec</name></expr>,
	<expr><operator>.</operator><name>ReScanCustomScan</name> <operator>=</operator> <name>hypertable_modify_rescan</name></expr>,
	<expr><operator>.</operator><name>ExplainCustomScan</name> <operator>=</operator> <name>hypertable_modify_explain</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>hypertable_modify_state_create</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HypertableModifyState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>serverid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>HypertableModifyState</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HypertableModifyState</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomScanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>cscan_state</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>hypertable_modify_state_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mt</name></name> <operator>=</operator> <name>mt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mt</name><operator>-&gt;</operator><name>arbiterIndexes</name></name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the list of data nodes to insert on.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>serveroids</name></name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the FDW routine for the first data node. It should be the same for
	 * all of them
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>serveroids</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>serverid</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>serveroids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <call><name>GetFdwRoutineByServerId</name><argument_list>(<argument><expr><name>serverid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomScanMethods</name></type> <name>hypertable_modify_plan_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"HypertableModify"</literal></expr>,
	<expr><operator>.</operator><name>CreateCustomScanState</name> <operator>=</operator> <name>hypertable_modify_state_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Make a targetlist to meet CustomScan expectations.
 *
 * When a CustomScan isn't scanning a real relation (scanrelid=0), it will build
 * a virtual TupleDesc for the scan "input" based on custom_scan_tlist. The
 * "output" targetlist is then expected to reference the attributes of the
 * input's TupleDesc. Without projection, the targetlist will be only Vars with
 * varno set to INDEX_VAR (to indicate reference to the TupleDesc instead of a
 * real relation) and matching the order of the attributes in the TupleDesc.
 *
 * Any other order, or non-Vars, will lead to the CustomScan performing
 * projection.
 *
 * Since the CustomScan for hypertable insert just wraps ModifyTable, no
 * projection is needed, so we'll build a targetlist to avoid this.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>make_var_targetlist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>INDEX_VAR</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>resno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>xpr</name></name></expr></argument>, <argument><expr><name>resno</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Plan the private FDW data for a remote hypertable. Note that the private data
 * for a result relation is a list, so we return a list of lists, one for each
 * result relation.  In case of no remote modify, we still need to return a list
 * of empty lists.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plan_remote_modify</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>HypertableModifyPath</name> <modifier>*</modifier></type><name>hmpath</name></decl></parameter>, <parameter><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mt</name></decl></parameter>,
				   <parameter><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Keep any existing direct modify plans */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>direct_modify_plans</name> <init>= <expr><name><name>mt</name><operator>-&gt;</operator><name>fdwDirectModifyPlans</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Iterate all subplans / result relations to check which ones are inserts
	 * into hypertables. In case we find a remote hypertable insert, we either
	 * have to plan it using the FDW or, in case of data node dispatching, we
	 * just need to mark the plan as "direct" to let ModifyTable know it
	 * should not invoke the regular FDW modify API. */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>mt-&gt;resultRelations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Index</name></type> <name>rti</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fdwprivate</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_distributed_insert</name> <init>= <expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>hmpath</name><operator>-&gt;</operator><name>distributed_insert_plans</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If data node batching is supported, we won't actually use the FDW
		 * direct modify API (everything is done in DataNodeDispatch), but we
		 * need to trick ModifyTable to believe we're doing direct modify so
		 * that it doesn't invoke the non-direct FDW API for inserts. Instead,
		 * it should handle only returning projections as if it was a direct
		 * modify. We do this by adding the result relation's plan to
		 * fdwDirectModifyPlans. See ExecModifyTable for more details. */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_distributed_insert</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>direct_modify_plans</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>direct_modify_plans</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_distributed_insert</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name>fdwroutine</name> <operator>&amp;&amp;</operator> <name><name>fdwroutine</name><operator>-&gt;</operator><name>PlanForeignModify</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>ts_is_hypertable</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fdwprivate</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>PlanForeignModify</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fdwprivate</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>fdw_private_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fdw_private_list</name></expr></argument>, <argument><expr><name>fdwprivate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>fdwDirectModifyPlans</name></name> <operator>=</operator> <name>direct_modify_plans</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>fdwPrivLists</name></name> <operator>=</operator> <name>fdw_private_list</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct the HypertableInsert's target list based on the ModifyTable's
 * target list, which now exists after having been created by
 * set_plan_references().
 */</comment>
<function><type><name>void</name></type>
<name>ts_hypertable_modify_fixup_tlist</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cscan</name><operator>-&gt;</operator><name>methods</name></name> <operator>==</operator> <operator>&amp;</operator><name>hypertable_modify_plan_methods</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>, <argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>mt</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* The input is the output of the child ModifyTable node */</comment>
				<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator> <name><name>mt</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr>;</expr_stmt>

				<comment type="block">/* The output is a direct mapping of the input */</comment>
				<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>make_var_targetlist</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ROWID_VAR only exists in PG14+ */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ts_replace_rowid_vars</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name>ROWID_VAR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RowIdentityVarInfo</name> <modifier>*</modifier></type><name>ridinfo</name> <init>=
				<expr><operator>(</operator><name>RowIdentityVarInfo</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>row_identity_vars</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>ridinfo</name><operator>-&gt;</operator><name>rowidvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>tle</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>hypertable_modify_plan_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_plans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HypertableModifyPath</name> <modifier>*</modifier></type><name>hmpath</name> <init>= <expr><operator>(</operator><name>HypertableModifyPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>, <argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>hypertable_modify_plan_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name> <operator>=</operator> <name>custom_plans</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Copy costs, etc., from the original plan */</comment>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>mt</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>mt</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>mt</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>plan_width</name></name> <operator>=</operator> <name><name>mt</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_width</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name><name>hmpath</name><operator>-&gt;</operator><name>serveroids</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get the foreign data wrapper routines for the first data node. Should be
		 * the same for all data nodes. */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>serverid</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>hmpath</name><operator>-&gt;</operator><name>serveroids</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineByServerId</name><argument_list>(<argument><expr><name>serverid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * A remote hypertable is not a foreign table since it cannot have indexes
	 * in that case. But we run the FDW planning for the hypertable here as if
	 * it was a foreign table. This is because when we do an FDW insert of a
	 * foreign table chunk, we actually would like to do that as if the INSERT
	 * happened on the root table. Thus we need the plan state from the root
	 * table, which we can reuse on every chunk. This plan state includes,
	 * e.g., a deparsed INSERT statement that references the hypertable
	 * instead of a chunk.
	 */</comment>
	<expr_stmt><expr><call><name>plan_remote_modify</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>hmpath</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>, <argument><expr><name>fdwroutine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The tlist is always NIL since the ModifyTable subplan doesn't have its
	 * targetlist set until set_plan_references (setrefs.c) is run */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tlist</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Target list handling here needs special attention. Intuitively, we'd like
	 * to adopt the target list of the ModifyTable subplan we wrap without
	 * further projection. For a CustomScan this means setting the "input"
	 * custom_scan_tlist to the ModifyTable's target list and having an "output"
	 * targetlist that references the TupleDesc that is created from the
	 * custom_scan_tlist at execution time. Now, while this seems
	 * straight-forward, there are several things with how ModifyTable nodes are
	 * handled in the planner that complicates this:
	 *
	 * - First, ModifyTable doesn't have a targetlist set at this point, and
	 *   it is only set later in set_plan_references (setrefs.c) if there's a
	 *	 RETURNING clause.
	 *
	 * - Second, top-level plan nodes, except for ModifyTable nodes, need to
	 *	 have a targetlist matching root-&gt;processed_tlist. This is asserted in
	 *	 apply_tlist_labeling, which is called in create_plan (createplan.c)
	 *	 immediately after this function returns. ModifyTable is exempted
	 *	 because it doesn't always have a targetlist that matches
	 *	 processed_tlist. So, even if we had access to ModifyTable's
	 *	 targetlist here we wouldn't be able to use it since we're a
	 *	 CustomScan and thus not exempted.
	 *
	 * - Third, a CustomScan's targetlist should reference the attributes of the
	 *   TupleDesc that gets created from the custom_scan_tlist at the start of
	 *   execution. This means we need to make the targetlist into all Vars with
	 *   attribute numbers that correspond to the TupleDesc instead of result
	 *   relation in the ModifyTable.
	 *
	 * To get around these issues, we set the targetlist here to
	 * root-&gt;processed_tlist, and at the end of planning when the ModifyTable's
	 * targetlist is set, we go back and fix up the CustomScan's targetlist.
	 */</comment>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For UPDATE/DELETE processed_tlist will have ROWID_VAR. We need to remove
	 * those because set_customscan_references will bail if it sees
	 * ROWID_VAR entries in the targetlist.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>mt</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name><name>mt</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
			<call><name>ts_replace_rowid_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>mt</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>mt</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator> <call><name>ts_is_chunk_append_plan</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator>
				<call><name>ts_replace_rowid_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>mt</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>mt</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/*
	 * For postgres versions &lt; PG14 we only route INSERT through our custom node.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator> <name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * we save the original list of arbiter indexes here
	 * because we modify that list during execution and
	 * we still need the original list in case that plan
	 * gets reused.
	 *
	 * We also pass on the data nodes to insert on.
	 */</comment>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>arbiterIndexes</name></name></expr></argument>, <argument><expr><name><name>hmpath</name><operator>-&gt;</operator><name>serveroids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomPathMethods</name></type> <name>hypertable_modify_path_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"HypertableModifyPath"</literal></expr>,
	<expr><operator>.</operator><name>PlanCustomPath</name> <operator>=</operator> <name>hypertable_modify_plan_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>Path</name> <modifier>*</modifier></type>
<name>ts_hypertable_modify_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ModifyTablePath</name> <modifier>*</modifier></type><name>mtpath</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>,
								 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>&amp;</operator><name><name>mtpath</name><operator>-&gt;</operator><name>path</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name> <init>= <expr><call><name>ts_hypertable_cache_pin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>distributed_insert_plans</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HypertableModifyPath</name> <modifier>*</modifier></type><name>hmpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<comment type="block">/* Since it's theoretically possible for ModifyTablePath to have multiple subpaths
	 * in PG &lt; 14 we assert that we only get 1 subpath here. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>mtpath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>mtpath</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>mtpath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* This should never happen but if it ever does it's safer to
		 * error here as the rest of the code assumes there is only 1 subpath.
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"multiple top-level subpaths found during INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<comment type="block">/* PG14 only copies child rows and width if returningLists is not
	 * empty. Since we do not know target chunks during planning we
	 * do not have that information when postgres creates the path.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mtpath</name><operator>-&gt;</operator><name>returningLists</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>mtpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>mtpath</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mtpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>mtpath</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>Index</name></type> <name>rti</name> <init>= <expr><name><name>mtpath</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mtpath</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>ts_guc_max_insert_batch_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Remember that this will become a data node dispatch/copy
			 * plan. We need to know later whether or not to plan this
			 * using the FDW API. */</comment>
			<expr_stmt><expr><name>distributed_insert_plans</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>distributed_insert_plans</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>distributed_insert_path_create</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>mtpath</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>ts_chunk_dispatch_path_create</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>mtpath</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>hmpath</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HypertableModifyPath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy costs, etc. */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hmpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hmpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_CustomPath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hmpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CustomScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hmpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>mtpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hmpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>hypertable_modify_path_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hmpath</name><operator>-&gt;</operator><name>distributed_insert_plans</name></name> <operator>=</operator> <name>distributed_insert_plans</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hmpath</name><operator>-&gt;</operator><name>serveroids</name></name> <operator>=</operator> <call><name>ts_hypertable_get_available_data_node_server_oids</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>&amp;</operator><name><name>hmpath</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<expr_stmt><expr><name><name>mtpath</name><operator>-&gt;</operator><name>subpaths</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>subpath</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>mtpath</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
<comment type="block">/* ----------------------------------------------------------------
 *	   ExecModifyTable
 *
 *		Perform table modifications as required, and return RETURNING results
 *		if needed.
 * ----------------------------------------------------------------
 *
 * modified version of ExecModifyTable from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecModifyTable</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTableState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type> <name>operation</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>subplanstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tuple_ctid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>oldtupdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkDispatchState</name> <modifier>*</modifier></type><name>cds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This should NOT get called during EvalPlanQual; we should have passed a
	 * subplan tree to EvalPlanQual, instead.  Use a runtime test not just
	 * Assert because this condition is easy to miss in testing.  (Note:
	 * although ModifyTable should not get executed within an EvalPlanQual
	 * operation, we do have to allow it to be initialized and shut down in
	 * case it is within a CTE subplan.  Hence this test must be here, not in
	 * ExecInitModifyTable.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epq_active</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ModifyTable should not be called during EvalPlanQual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we've already completed processing, don't try to do more.  We need
	 * this test because ExecPostprocessPlan might call us an extra time, and
	 * our subplan's nodes aren't necessarily robust against being called
	 * extra times.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On first call, fire BEFORE STATEMENT triggers before proceeding.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>fireBSTriggers</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fireBSTriggers</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fireBSTriggers</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Preload local variables */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_lastResultIndex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>subplanstate</name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ts_is_chunk_dispatch_state</name><argument_list>(<argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cds</name> <operator>=</operator> <operator>(</operator><name>ChunkDispatchState</name> <operator>*</operator><operator>)</operator> <name>subplanstate</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>get_chunk_dispatch_states</name><argument_list>(<argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cds</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><call><name>get_chunk_dispatch_states</name><argument_list>(<argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Fetch rows from subplan, and execute the required table modification
	 * for each row.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Reset the per-output-tuple exprcontext.  This is needed because
		 * triggers expect to use that context as workspace.  It's a bit ugly
		 * to do this below the top level of the plan, however.  We might need
		 * to rethink this later.
		 */</comment>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset per-tuple memory context used for processing on conflict and
		 * returning clauses, to free any expression evaluation storage
		 * allocated in the previous cycle.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>planSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* No more tuples to process? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * When there are multiple result relations, each tuple contains a
		 * junk column that gives the OID of the rel from which it came.
		 * Extract it and select the correct result relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_resultOidAttno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>resultoid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>planSlot</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_resultOidAttno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tableoid is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>resultoid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If it's not the same as last time, we need to locate the rel */</comment>
			<if_stmt><if>if <condition>(<expr><name>resultoid</name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_lastResultOid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>ExecLookupResultRelByOid</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>resultoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If resultRelInfo-&gt;ri_usesFdwDirectModify is true, all we need to do
		 * here is compute the RETURNING expressions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * A scan slot containing the data that was actually inserted,
			 * updated or deleted has already been made available to
			 * ExecProcessReturning by IterateDirectModify, so no need to
			 * provide it here.
			 */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcessReturning</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>slot</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>EvalPlanQualSetSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name>planSlot</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupleid</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldtuple</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * For UPDATE/DELETE, fetch the row identity info for the tuple to be
		 * updated/deleted.  For a heap relation, that's a TID; otherwise we
		 * may have a wholerow junk attr that carries the old tuple in toto.
		 * Keep this in step with the part of ExecInitModifyTable that sets up
		 * ri_RowIdAttNo.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name>relkind</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
			<comment type="block">/* Since this is a hypertable relkind should be RELKIND_RELATION for a local
			 * chunk or  RELKIND_FOREIGN_TABLE for a chunk that is a foreign table
			 * (OSM chunks)
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
				<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ri_RowIdAttNo refers to a ctid attribute */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RowIdAttNo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RowIdAttNo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* shouldn't ever get a null result... */</comment>
				<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ctid is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>tupleid</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tuple_ctid</name> <operator>=</operator> <operator>*</operator><name>tupleid</name></expr>;</expr_stmt> <comment type="block">/* be sure we don't free ctid!! */</comment>
				<expr_stmt><expr><name>tupleid</name> <operator>=</operator> <operator>&amp;</operator><name>tuple_ctid</name></expr>;</expr_stmt>
			</block_content>}</block></if>

			<comment type="block">/*
			 * Use the wholerow attribute, when available, to reconstruct the
			 * old relation tuple.  The old tuple serves one or both of two
			 * purposes: 1) it serves as the OLD tuple for row triggers, 2) it
			 * provides values for any unchanged columns for the NEW tuple of
			 * an UPDATE, because the subplan does not produce all the columns
			 * of the target table.
			 *
			 * Note that the wholerow attribute does not carry system columns,
			 * so foreign table triggers miss seeing those, except that we
			 * know enough here to set t_tableOid.  Quite separately from
			 * this, the FDW may fetch its own junk attrs to identify the row.
			 *
			 * Other relevant relkinds, currently limited to views, always
			 * have a wholerow attribute.
			 */</comment>
			<if type="elseif">else if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RowIdAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RowIdAttNo</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* shouldn't ever get a null result... */</comment>
				<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wholerow is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>oldtupdata</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>oldtupdata</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name><name>oldtupdata</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtupdata</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Historically, view triggers see invalid t_tableOid. */</comment>
				<expr_stmt><expr><name><name>oldtupdata</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_VIEW</name><operator>)</operator></expr> ?</condition><then>
											<expr><name>InvalidOid</name></expr> </then><else>:
											<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

				<expr_stmt><expr><name>oldtuple</name> <operator>=</operator> <operator>&amp;</operator><name>oldtupdata</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Only foreign tables are allowed to omit a row-ID attr */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CMD_INSERT</name></expr>:</case>
				<comment type="block">/* Initialize projection info if first time for this table */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectNewInfoValid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecInitInsertProjection</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecGetInsertNewTuple</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecInsert</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>cds</name><operator>-&gt;</operator><name>rri</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
				<comment type="block">/* Initialize projection info if first time for this table */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectNewInfoValid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecInitUpdateProjection</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Make the new tuple by combining plan's output tuple with
				 * the old tuple being updated.
				 */</comment>
				<expr_stmt><expr><name>oldSlot</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_oldTupleSlot</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>oldtuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Use the wholerow junk attr as the old tuple. */</comment>
					<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>oldSlot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Fetch the most recent version of old tuple. */</comment>
					<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupleid</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_fetch_row_version</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><name>oldSlot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch tuple being updated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecGetUpdateNewTuple</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>, <argument><expr><name>oldSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Now apply the update. */</comment>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecUpdate</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								  <argument><expr><name>resultRelInfo</name></expr></argument>,
								  <argument><expr><name>tupleid</name></expr></argument>,
								  <argument><expr><name>oldtuple</name></expr></argument>,
								  <argument><expr><name>slot</name></expr></argument>,
								  <argument><expr><name>planSlot</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>,
								  <argument><expr><name>estate</name></expr></argument>,
								  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_DELETE</name></expr>:</case>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecDelete</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								  <argument><expr><name>resultRelInfo</name></expr></argument>,
								  <argument><expr><name>tupleid</name></expr></argument>,
								  <argument><expr><name>oldtuple</name></expr></argument>,
								  <argument><expr><name>planSlot</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>,
								  <argument><expr><name>estate</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* processReturning */</comment>
								  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <comment type="block">/* changingPart */</comment>
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * If we got a RETURNING result, return it to caller.  We'll continue
		 * the work on next call.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>slot</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Insert remaining tuples for batch insert.
	 */</comment>
	<expr_stmt><expr><name>relinfos</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_opened_result_relations</name></name></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>relinfos</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlots</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecBatchInsert</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
							<argument><expr><name>resultRelInfo</name></expr></argument>,
							<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_Slots</name></name></expr></argument>,
							<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PlanSlots</name></name></expr></argument>,
							<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlots</name></name></expr></argument>,
							<argument><expr><name>estate</name></expr></argument>,
							<argument><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We're done, but fire AFTER STATEMENT triggers before exiting.
	 */</comment>
	<expr_stmt><expr><call><name>fireASTriggers</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mt_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process BEFORE EACH STATEMENT triggers
 *
 * copied verbatim from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fireBSTriggers</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecBSInsertTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecBSUpdateTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecBSUpdateTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecBSDeleteTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Process AFTER EACH STATEMENT triggers
 *
 * copied verbatim from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fireASTriggers</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecASUpdateTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ExecASInsertTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecASUpdateTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecASDeleteTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * ExecProcessReturning --- evaluate a RETURNING list
 *
 * resultRelInfo: current result rel
 * tupleSlot: slot holding tuple actually inserted/updated/deleted
 * planSlot: slot holding tuple returned by top subplan node
 *
 * Note: If tupleSlot is NULL, the FDW should have already provided econtext's
 * scan tuple.
 *
 * Returns a slot holding the result tuple
 *
 * copied verbatim from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecProcessReturning</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleSlot</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProjectionInfo</name> <modifier>*</modifier></type><name>projectReturning</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>projectReturning</name><operator>-&gt;</operator><name>pi_exprContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make tuple and any needed join variables available to ExecProject */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupleSlot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>tupleSlot</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>planSlot</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * RETURNING expressions might reference the tableoid column, so
	 * reinitialize tts_tableOid before evaluating them.
	 */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute the RETURNING expressions */</comment>
	<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name>projectReturning</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitInsertProjection
 *		Do one-time initialization of projection data for INSERT tuples.
 *
 * INSERT queries may need a projection to filter out junk attrs in the tlist.
 *
 * This is also a convenient place to verify that the
 * output of an INSERT matches the target table.
 *
 * copied verbatim from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitInsertProjection</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>need_projection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Extract non-junk columns of the subplan's result tlist. */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>subplan-&gt;targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>insertTargetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>insertTargetList</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>need_projection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * The junk-free list must produce a tuple suitable for the result
	 * relation.
	 */</comment>
	<expr_stmt><expr><call><name>ExecCheckPlanOutput</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>insertTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We'll need a slot matching the table's format. */</comment>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_newTupleSlot</name></name> <operator>=</operator>
		<call><name>table_slot_create</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build ProjectionInfo if needed (it probably isn't). */</comment>
	<if_stmt><if>if <condition>(<expr><name>need_projection</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>relDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* need an expression context to do the projection */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectNew</name></name> <operator>=</operator> <call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name>insertTargetList</name></expr></argument>,
															   <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></argument>,
															   <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_newTupleSlot</name></name></expr></argument>,
															   <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>,
															   <argument><expr><name>relDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectNewInfoValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitUpdateProjection
 *		Do one-time initialization of projection data for UPDATE tuples.
 *
 * UPDATE always needs a projection, because (1) there's always some junk
 * attrs, and (2) we may need to merge values of not-updated columns from
 * the old tuple into the final tuple.  In UPDATE, the tuple arriving from
 * the subplan contains only new values for the changed columns, plus row
 * identity info in the junk attrs.
 *
 * This is "one-time" for any given result rel, but we might touch more than
 * one result rel in the course of an inherited UPDATE, and each one needs
 * its own projection due to possible column order variation.
 *
 * This is also a convenient place to verify that the output of an UPDATE
 * matches the target table (ExecBuildUpdateProjection does that).
 *
 * copied verbatim from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitUpdateProjection</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>relDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>whichrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>updateColnos</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Usually, mt_lastResultIndex matches the target rel.  If it happens not
	 * to, we can get the index the hard way with an integer division.
	 */</comment>
	<expr_stmt><expr><name>whichrel</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_lastResultIndex</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>resultRelInfo</name> <operator>!=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>+</operator> <name>whichrel</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>whichrel</name> <operator>=</operator> <name>resultRelInfo</name> <operator>-</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>whichrel</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>whichrel</name> <operator>&lt;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_nrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>updateColnos</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>updateColnosLists</name></name></expr></argument>, <argument><expr><name>whichrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For UPDATE, we use the old tuple to fill up missing values in the tuple
	 * produced by the subplan to get the new tuple.  We need two slots, both
	 * matching the table's desired format.
	 */</comment>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_oldTupleSlot</name></name> <operator>=</operator>
		<call><name>table_slot_create</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_newTupleSlot</name></name> <operator>=</operator>
		<call><name>table_slot_create</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* need an expression context to do the projection */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectNew</name></name> <operator>=</operator> <call><name>ExecBuildUpdateProjection</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
															 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* subplan did the evaluation */</comment>
															 <argument><expr><name>updateColnos</name></expr></argument>,
															 <argument><expr><name>relDesc</name></expr></argument>,
															 <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></argument>,
															 <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_newTupleSlot</name></name></expr></argument>,
															 <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectNewInfoValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Verify that the tuples to be produced by INSERT match the
 * target relation's rowtype
 *
 * We do this to guard against stale plans.  If plan invalidation is
 * functioning properly then we should never get a failure here, but better
 * safe than sorry.  Note that this is called after we have obtained lock
 * on the target rel, so the rowtype can't change underneath us.
 *
 * The plan output is represented by its targetlist, because that makes
 * handling the dropped-column case easier.
 *
 * We used to use this for UPDATE as well, but now the equivalent checks
 * are done in ExecBuildUpdateProjection.
 *
 * copied verbatim from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecCheckPlanOutput</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>resultRel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>resultDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* caller removed junk items already */</comment>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&gt;=</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Query has too many columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>resultDesc</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attno</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Normal case: demand type match */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table has type %s at ordinal position %d, but query expects "</literal>
								   <literal type="string">"%s."</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>attno</name></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * For a dropped column, we can't check atttypid (it's likely 0).
			 * In any case the planner has most likely inserted an INT4 null.
			 * What we insist on is just *some* NULL constant.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Query provides a value for a dropped column at ordinal "</literal>
								   <literal type="string">"position %d."</literal></expr></argument>,
								   <argument><expr><name>attno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>!=</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Query has too few columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecGetInsertNewTuple
 *		This prepares a "new" tuple ready to be inserted into given result
 *		relation, by removing any junk columns of the plan's output tuple
 *		and (if necessary) coercing the tuple to the right tuple format.
 *
 * copied verbatim from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecGetInsertNewTuple</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProjectionInfo</name> <modifier>*</modifier></type><name>newProj</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_projectNew</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If there's no projection to be done, just make sure the slot is of the
	 * right type for the target rel.  If the planSlot is the right type we
	 * can use it as-is, else copy the data into ri_newTupleSlot.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newProj</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_newTupleSlot</name><operator>-&gt;</operator><name>tts_ops</name></name> <operator>!=</operator> <name><name>planSlot</name><operator>-&gt;</operator><name>tts_ops</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_newTupleSlot</name></name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_newTupleSlot</name></name></expr>;</return>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>planSlot</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Else project; since the projection output slot is ri_newTupleSlot, this
	 * will also fix any slot-type problem.
	 *
	 * Note: currently, this is dead code, because INSERT cases don't receive
	 * any junk columns so there's never a projection to be done.
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>newProj</name><operator>-&gt;</operator><name>pi_exprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>planSlot</name></expr>;</expr_stmt>
	<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name>newProj</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInsert
 *
 *		For INSERT, we have to insert the tuple into the target relation
 *		(or partition thereof) and insert appropriate tuples into the index
 *		relations.
 *
 *		slot contains the new tuple value to be stored.
 *		planSlot is the output of the ModifyTable's subplan; we use it
 *		to access "junk" columns that are not going to be stored.
 *
 *		Returns RETURNING result if any, otherwise NULL.
 *
 *		This may change the currently active tuple conversion map in
 *		mtstate-&gt;mt_transition_capture, so the callers must take care to
 *		save the previous value to avoid losing track of it.
 * ----------------------------------------------------------------
 *
 * copied and modified version of ExecInsert from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecInsert</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>resultRelationDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>recheckIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>ar_insert_trig_tcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OnConflictAction</name></type> <name>onconflict</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>resultRelationDesc</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the table's indexes, if we have not done so already, so that we
	 * can add new index entries for the inserted tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>onconflict</name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * BEFORE ROW INSERT Triggers.
	 *
	 * Note: We fire BEFORE ROW TRIGGERS for every attempted insertion in an
	 * INSERT ... ON CONFLICT statement.  We cannot check for constraint
	 * violations before firing these triggers, because they can change the
	 * values to insert.  Also, they can run arbitrary user-defined code with
	 * side-effects that we can't cancel by just not inserting the tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecBRInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* "do nothing" */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* INSTEAD OF ROW INSERT Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecIRInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* "do nothing" */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * GENERATED expressions might reference the tableoid column, so
		 * (re-)initialize tts_tableOid before evaluating them.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute stored generated columns
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecComputeStoredGenerated</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the FDW supports batching, and batching is requested, accumulate
		 * rows and insert them in batches. Otherwise use the per-row inserts.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_BatchSize</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If a certain number of tuples have already been accumulated, or
			 * a tuple has come for a different relation than that for the
			 * accumulated tuples, perform the batch insert
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlots</name></name> <operator>==</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_BatchSize</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecBatchInsert</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>,
								<argument><expr><name>resultRelInfo</name></expr></argument>,
								<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_Slots</name></name></expr></argument>,
								<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PlanSlots</name></name></expr></argument>,
								<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlots</name></name></expr></argument>,
								<argument><expr><name>estate</name></expr></argument>,
								<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlots</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_Slots</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_Slots</name></name> <operator>=</operator>
					<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleTableSlot</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_BatchSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PlanSlots</name></name> <operator>=</operator>
					<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleTableSlot</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_BatchSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Initialize the batch slots. We don't know how many slots will
			 * be needed, so we initialize them as the batch grows, and we
			 * keep them across batches. To mitigate an inefficiency in how
			 * resource owner handles objects with many references (as with
			 * many slots all referencing the same tuple descriptor) we copy
			 * the appropriate tuple descriptor for each slot.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlots</name></name> <operator>&gt;=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlotsInitialized</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tdesc</name> <init>= <expr><call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleDesc</name></type> <name>plan_tdesc</name> <init>= <expr><call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>planSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_Slots</name><index>[<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlots</name></name></expr>]</index></name> <operator>=</operator>
					<call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tdesc</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_ops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PlanSlots</name><index>[<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlots</name></name></expr>]</index></name> <operator>=</operator>
					<call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>plan_tdesc</name></expr></argument>, <argument><expr><name><name>planSlot</name><operator>-&gt;</operator><name>tts_ops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* remember how many batch slots we initialized */</comment>
				<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlotsInitialized</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_Slots</name><index>[<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlots</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PlanSlots</name><index>[<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlots</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumSlots</name></name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * insert into foreign table: let the FDW do it
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator>
			<call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>ExecForeignInsert</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * AFTER ROW Triggers or RETURNING expressions might reference the
		 * tableoid column, so (re-)initialize tts_tableOid before evaluating
		 * them.  (This covers the case where the FDW replaced the slot.)
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>WCOKind</name></type> <name>wco_kind</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Constraints and GENERATED expressions might reference the tableoid
		 * column, so (re-)initialize tts_tableOid before evaluating them.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute stored generated columns
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecComputeStoredGenerated</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check any RLS WITH CHECK policies.
		 *
		 * Normally we should check INSERT policies. But if the insert is the
		 * result of a partition key update that moved the tuple to a new
		 * partition, we should instead check UPDATE policies, because we are
		 * executing policies defined on the target table, and not those
		 * defined on the child partitions.
		 */</comment>
		<expr_stmt><expr><name>wco_kind</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator></expr> ?</condition><then> <expr><name>WCO_RLS_UPDATE_CHECK</name></expr> </then><else>: <expr><name>WCO_RLS_INSERT_CHECK</name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/*
		 * ExecWithCheckOptions() will skip any WCOs which are not of the kind
		 * we are looking for at this point.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>wco_kind</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check the constraints of the tuple.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Also check the tuple against the partition constraint, if there is
		 * one; except that if we got here via tuple-routing, we don't need to
		 * if there's no BR trigger defined on the partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RootResultRelInfo</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			 <operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>onconflict</name> <operator>!=</operator> <name>ONCONFLICT_NONE</name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Perform a speculative insertion. */</comment>
			<decl_stmt><decl><type><name>uint32</name></type> <name>specToken</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>conflictTid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>specConflict</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>arbiterIndexes</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>arbiterIndexes</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Do a non-conclusive check for conflicts first.
			 *
			 * We're not holding any locks yet, so this doesn't guarantee that
			 * the later insert won't conflict.  But it avoids leaving behind
			 * a lot of canceled speculative insertions, if you run a lot of
			 * INSERT ON CONFLICT statements that do conflict.
			 *
			 * We loop back here if we find a conflict below, either during
			 * the pre-check, or when we re-check after inserting the tuple
			 * speculatively.
			 */</comment>
		<label><name>vlock</name>:</label>
			<expr_stmt><expr><name>specConflict</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheckIndexConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
										   <argument><expr><name>slot</name></expr></argument>,
										   <argument><expr><name>estate</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>conflictTid</name></expr></argument>,
										   <argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* committed conflict tuple found */</comment>
				<if_stmt><if>if <condition>(<expr><name>onconflict</name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * In case of ON CONFLICT DO UPDATE, execute the UPDATE
					 * part.  Be prepared to retry if the UPDATE fails because
					 * of another concurrent UPDATE/DELETE to the conflict
					 * tuple.
					 */</comment>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>returning</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>ExecOnConflictUpdate</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>,
											 <argument><expr><name>resultRelInfo</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>conflictTid</name></expr></argument>,
											 <argument><expr><name>planSlot</name></expr></argument>,
											 <argument><expr><name>slot</name></expr></argument>,
											 <argument><expr><name>estate</name></expr></argument>,
											 <argument><expr><name>canSetTag</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>returning</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>InstrCountTuples2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>returning</name></expr>;</return>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<goto>goto <name>vlock</name>;</goto></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * In case of ON CONFLICT DO NOTHING, do nothing. However,
					 * verify that the tuple is visible to the executor's MVCC
					 * snapshot at higher isolation levels.
					 *
					 * Using ExecGetReturningSlot() to store the tuple for the
					 * recheck isn't that pretty, but we can't trivially use
					 * the input slot, because it might not be of a compatible
					 * type. As there's no conflicting usage of
					 * ExecGetReturningSlot() in the DO NOTHING case...
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>onconflict</name> <operator>==</operator> <name>ONCONFLICT_NOTHING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExecCheckTIDVisible</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										<argument><expr><name>resultRelInfo</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>conflictTid</name></expr></argument>,
										<argument><expr><call><name>ExecGetReturningSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>InstrCountTuples2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Before we start insertion proper, acquire our "speculative
			 * insertion lock".  Others can use that to wait for us to decide
			 * if we're going to go ahead with the insertion, instead of
			 * waiting for the whole transaction to complete.
			 */</comment>
			<expr_stmt><expr><name>specToken</name> <operator>=</operator> <call><name>SpeculativeInsertionLockAcquire</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* insert the tuple, with the speculative token */</comment>
			<expr_stmt><expr><call><name>table_tuple_insert_speculative</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>,
										   <argument><expr><name>slot</name></expr></argument>,
										   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><name>specToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* insert index entries for tuple */</comment>
			<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
												   <argument><expr><name>slot</name></expr></argument>,
												   <argument><expr><name>estate</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>,
												   <argument><expr><name>true</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>specConflict</name></expr></argument>,
												   <argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* adjust the tuple's state accordingly */</comment>
			<expr_stmt><expr><call><name>table_tuple_complete_speculative</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>specToken</name></expr></argument>, <argument><expr><operator>!</operator><name>specConflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Wake up anyone waiting for our decision.  They will re-check
			 * the tuple, see that it's no longer speculative, and wait on our
			 * XID as if this was a regularly inserted tuple all along.  Or if
			 * we killed the tuple, they will see it's dead, and proceed as if
			 * the tuple never existed.
			 */</comment>
			<expr_stmt><expr><call><name>SpeculativeInsertionLockRelease</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If there was a conflict, start from the beginning.  We'll do
			 * the pre-check again, which will now find the conflicting tuple
			 * (unless it aborts before we get there).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>specConflict</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>vlock</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Since there was no insertion conflict, we're done */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* insert the tuple normally */</comment>
			<expr_stmt><expr><call><name>table_tuple_insert</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* insert index entries for tuple */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator>
					<call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>canSetTag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this insert is the result of a partition key update that moved the
	 * tuple to a new partition, put this row into the transition NEW TABLE,
	 * if there is one. We need to do this separately for DELETE and INSERT
	 * because they happen on different tables.
	 */</comment>
	<expr_stmt><expr><name>ar_insert_trig_tcs</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>&amp;&amp;</operator>
		<name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_update_new_table</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecARUpdateTriggersCompat</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
								   <argument><expr><name>resultRelInfo</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* src_partinfo */</comment>
								   <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* dst_partinfo */</comment>
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>slot</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_crosspart_update */</comment>
		)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We've already captured the NEW TABLE row, so make sure any AR
		 * INSERT trigger fired below doesn't capture it again.
		 */</comment>
		<expr_stmt><expr><name>ar_insert_trig_tcs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* AFTER ROW INSERT Triggers */</comment>
	<expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>recheckIndexes</name></expr></argument>, <argument><expr><name>ar_insert_trig_tcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check any WITH CHECK OPTION constraints from parent views.  We are
	 * required to do this after testing all constraints and uniqueness
	 * violations per the SQL spec, so we do it after actually inserting the
	 * record into the heap and all indexes.
	 *
	 * ExecWithCheckOptions will elog(ERROR) if a violation is found, so the
	 * tuple will never be seen, if it violates the WITH CHECK OPTION.
	 *
	 * ExecWithCheckOptions() will skip any WCOs which are not of the kind we
	 * are looking for at this point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_VIEW_CHECK</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Process RETURNING if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecProcessReturning</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecBatchInsert
 *
 *		Insert multiple tuples in an efficient way.
 *		Currently, this handles inserting into a foreign table without
 *		RETURNING clause.
 * ----------------------------------------------------------------
 *
 * copied verbatim from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecBatchInsert</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>slots</name></decl></parameter>,
				<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>planSlots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numSlots</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numInserted</name> <init>= <expr><name>numSlots</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>rslots</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * insert into foreign table: let the FDW do it
	 */</comment>
	<expr_stmt><expr><name>rslots</name> <operator>=</operator> <call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>ExecForeignBatchInsert</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
																  <argument><expr><name>resultRelInfo</name></expr></argument>,
																  <argument><expr><name>slots</name></expr></argument>,
																  <argument><expr><name>planSlots</name></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name>numInserted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numInserted</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>rslots</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * AFTER ROW Triggers or RETURNING expressions might reference the
		 * tableoid column, so (re-)initialize tts_tableOid before evaluating
		 * them.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* AFTER ROW INSERT Triggers */</comment>
		<expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check any WITH CHECK OPTION constraints from parent views.  See the
		 * comment in ExecInsert.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_VIEW_CHECK</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>canSetTag</name> <operator>&amp;&amp;</operator> <name>numInserted</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>+=</operator> <name>numInserted</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecUpdate
 *
 *		note: we can't run UPDATE queries with transactions
 *		off because UPDATEs are actually INSERTs and our
 *		scan will mistakenly loop forever, updating the tuple
 *		it just inserted..  This should be fixed but until it
 *		is, we don't want to get stuck in an infinite loop
 *		which corrupts your database..
 *
 *		When updating a table, tupleid identifies the tuple to
 *		update and oldtuple is NULL.  When updating a view, oldtuple
 *		is passed to the INSTEAD OF triggers and identifies what to
 *		update, and tupleid is invalid.  When updating a foreign table,
 *		tupleid is invalid; the FDW has to figure out which row to
 *		update using data from the planSlot.  oldtuple is passed to
 *		foreign table triggers; it is NULL when the foreign table has
 *		no relevant triggers.
 *
 *		slot contains the new tuple value to be stored.
 *		planSlot is the output of the ModifyTable's subplan; we use it
 *		to access values from other input tables (for RETURNING),
 *		row-ID junk columns, etc.
 *
 *		Returns RETURNING result if any, otherwise NULL.
 * ----------------------------------------------------------------
 *
 * copied and modified version of ExecUpdate from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecUpdate</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
		   <parameter><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>, <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
		   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>resultRelationDesc</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_Result</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_FailureData</name></type> <name>tmfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>recheckIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the table's indexes, if we have not done so already, so that we
	 * can add new index entries for the updated tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* BEFORE ROW UPDATE Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_update_before_row</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecBRUpdateTriggersCompat</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										<argument><expr><name>epqstate</name></expr></argument>,
										<argument><expr><name>resultRelInfo</name></expr></argument>,
										<argument><expr><name>tupleid</name></expr></argument>,
										<argument><expr><name>oldtuple</name></expr></argument>,
										<argument><expr><name>slot</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* "do nothing" */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* INSTEAD OF ROW UPDATE Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_update_instead_row</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecIRUpdateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* "do nothing" */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * GENERATED expressions might reference the tableoid column, so
		 * (re-)initialize tts_tableOid before evaluating them.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute stored generated columns
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecComputeStoredGenerated</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>CMD_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * update in foreign table: let the FDW do it
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator>
			<call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>ExecForeignUpdate</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * AFTER ROW Triggers or RETURNING expressions might reference the
		 * tableoid column, so (re-)initialize tts_tableOid before evaluating
		 * them.  (This covers the case where the FDW replaced the slot.)
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>partition_constraint_failed</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>update_indexes</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Constraints and GENERATED expressions might reference the tableoid
		 * column, so (re-)initialize tts_tableOid before evaluating them.
		 */</comment>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute stored generated columns
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecComputeStoredGenerated</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>CMD_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check any RLS UPDATE WITH CHECK policies
		 *
		 * If we generate a new candidate tuple after EvalPlanQual testing, we
		 * must loop back here and recheck any RLS policies and constraints.
		 * (We don't need to redo triggers, however.  If there are any BEFORE
		 * triggers then trigger.c will have done table_tuple_lock to lock the
		 * correct tuple, so there's no need to do them again.)
		 */</comment>
	<label><name>lreplace</name>:</label><empty_stmt>;</empty_stmt>

		<comment type="block">/* ensure slot is independent, consider e.g. EPQ */</comment>
		<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If partition constraint fails, this row might get moved to another
		 * partition, in which case we should check the RLS CHECK policy just
		 * before inserting into the new partition, rather than doing it here.
		 * This is because a trigger on that partition might again change the
		 * row.  So skip the WCO checks if the partition constraint fails.
		 */</comment>
		<expr_stmt><expr><name>partition_constraint_failed</name> <operator>=</operator> <name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>&amp;&amp;</operator>
									  <operator>!</operator><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partition_constraint_failed</name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ExecWithCheckOptions() will skip any WCOs which are not of the
			 * kind we are looking for at this point.
			 */</comment>
			<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_RLS_UPDATE_CHECK</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If a partition check failed, try to move the row into the right
		 * partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>partition_constraint_failed</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cross chunk updates not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check the constraints of the tuple.  We've already checked the
		 * partition constraint above; however, we must still ensure the tuple
		 * passes all other constraints, so we will call ExecConstraints() and
		 * have it validate all remaining checks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * replace the heap tuple
		 *
		 * Note: if es_crosscheck_snapshot isn't InvalidSnapshot, we check
		 * that the row to be updated is visible to that snapshot, and throw a
		 * can't-serialize error if not. This is a special-case behavior
		 * needed for referential integrity updates in transaction-snapshot
		 * mode transactions.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>table_tuple_update</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>,
									<argument><expr><name>tupleid</name></expr></argument>,
									<argument><expr><name>slot</name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr></argument>,
									<argument><expr><name>true</name></expr></argument> <comment type="block">/* wait for commit */</comment>,
									<argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>lockmode</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>update_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TM_SelfModified</name></expr>:</case>

				<comment type="block">/*
				 * The target tuple was already updated or deleted by the
				 * current command, or by a later command in the current
				 * transaction.  The former case is possible in a join UPDATE
				 * where multiple tuples join to the same target tuple. This
				 * is pretty questionable, but Postgres has always allowed it:
				 * we just execute the first update action and ignore
				 * additional update attempts.
				 *
				 * The latter case arises if the tuple is modified by a
				 * command in a BEFORE trigger, or perhaps by a command in a
				 * volatile function used in the query.  In such situations we
				 * should not ignore the update, but it is equally unsafe to
				 * proceed.  We don't want to discard the original UPDATE
				 * while keeping the triggered actions based on it; and we
				 * have no principled way to merge this update with the
				 * previous ones.  So throwing an error is the only safe
				 * course.
				 *
				 * If a trigger actually intends this type of interaction, it
				 * can re-execute the UPDATE (assuming it can figure out how)
				 * and then return NULL to cancel the outer update.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tmfd</name><operator>.</operator><name>cmax</name></name> <operator>!=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TRIGGERED_DATA_CHANGE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be updated was already modified by an operation "</literal>
									<literal type="string">"triggered by the current command"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using an AFTER trigger instead of a BEFORE trigger "</literal>
									 <literal type="string">"to propagate changes to other rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Else, already updated by self; nothing to do */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			<case>case <expr><name>TM_Ok</name></expr>:</case>
				<break>break;</break>

			<case>case <expr><name>TM_Updated</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inputslot</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>epqslot</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldSlot</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Already know that we're going to need to do EPQ, so
				 * fetch tuple directly into the right slot.
				 */</comment>
				<expr_stmt><expr><name>inputslot</name> <operator>=</operator> <call><name>EvalPlanQualSlot</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>,
											 <argument><expr><name>resultRelationDesc</name></expr></argument>,
											 <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>table_tuple_lock</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>,
										  <argument><expr><name>tupleid</name></expr></argument>,
										  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
										  <argument><expr><name>inputslot</name></expr></argument>,
										  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
										  <argument><expr><name>lockmode</name></expr></argument>,
										  <argument><expr><name>LockWaitBlock</name></expr></argument>,
										  <argument><expr><name>TUPLE_LOCK_FLAG_FIND_LAST_VERSION</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>TM_Ok</name></expr>:</case>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tmfd</name><operator>.</operator><name>traversed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>epqslot</name> <operator>=</operator> <call><name>EvalPlanQual</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>,
											   <argument><expr><name>resultRelationDesc</name></expr></argument>,
											   <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>,
											   <argument><expr><name>inputslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<comment type="block">/* Tuple not passing quals anymore, exiting... */</comment>
							<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

						<comment type="block">/* Make sure ri_oldTupleSlot is initialized. */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectNewInfoValid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ExecInitUpdateProjection</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/* Fetch the most recent version of old tuple. */</comment>
						<expr_stmt><expr><name>oldSlot</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_oldTupleSlot</name></name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_fetch_row_version</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>,
														   <argument><expr><name>tupleid</name></expr></argument>,
														   <argument><expr><name>SnapshotAny</name></expr></argument>,
														   <argument><expr><name>oldSlot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch tuple being updated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecGetUpdateNewTuple</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>epqslot</name></expr></argument>, <argument><expr><name>oldSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>lreplace</name>;</goto>

					<case>case <expr><name>TM_Deleted</name></expr>:</case>
						<comment type="block">/* tuple already deleted; nothing to do */</comment>
						<return>return <expr><name>NULL</name></expr>;</return>

					<case>case <expr><name>TM_SelfModified</name></expr>:</case>

						<comment type="block">/*
						 * This can be reached when following an update
						 * chain from a tuple updated by another session,
						 * reaching a tuple that was already updated in
						 * this transaction. If previously modified by
						 * this command, ignore the redundant update,
						 * otherwise error out.
						 *
						 * See also TM_SelfModified response to
						 * table_tuple_update() above.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>tmfd</name><operator>.</operator><name>cmax</name></name> <operator>!=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TRIGGERED_DATA_CHANGE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be updated was already modified by an "</literal>
											<literal type="string">"operation triggered by the current command"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using an AFTER trigger instead of a BEFORE "</literal>
											 <literal type="string">"trigger to propagate changes to other rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<return>return <expr><name>NULL</name></expr>;</return>

					<default>default:</default>
						<comment type="block">/* see table_tuple_lock call in ExecDelete() */</comment>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected table_tuple_lock status: %u"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></switch>
			</block_content>}</block>

			<break>break;</break>

			<case>case <expr><name>TM_Deleted</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent delete"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* tuple already deleted; nothing to do */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized table_tuple_update status: %u"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></switch>

		<comment type="block">/* insert index entries for tuple if necessary */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>update_indexes</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator>
				<call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>canSetTag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* AFTER ROW UPDATE Triggers */</comment>
	<expr_stmt><expr><call><name>ExecARUpdateTriggersCompat</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
							   <argument><expr><name>resultRelInfo</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>tupleid</name></expr></argument>,
							   <argument><expr><name>oldtuple</name></expr></argument>,
							   <argument><expr><name>slot</name></expr></argument>,
							   <argument><expr><name>recheckIndexes</name></expr></argument>,
							   <argument><expr><ternary><condition><expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr> ?</condition><then>
								   <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name></expr> </then><else>:
								   <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></else></ternary></expr></argument>,
							   <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_crosspart_update */</comment>
	)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check any WITH CHECK OPTION constraints from parent views.  We are
	 * required to do this after testing all constraints and uniqueness
	 * violations per the SQL spec, so we do it after actually updating the
	 * record in the heap and all indexes.
	 *
	 * ExecWithCheckOptions() will skip any WCOs which are not of the kind we
	 * are looking for at this point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_VIEW_CHECK</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Process RETURNING if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ExecProcessReturning</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecOnConflictUpdate --- execute UPDATE of INSERT ON CONFLICT DO UPDATE
 *
 * Try to lock tuple for update as part of speculative insertion.  If
 * a qual originating from ON CONFLICT DO UPDATE is satisfied, update
 * (but still lock row, even though it may not satisfy estate's
 * snapshot).
 *
 * Returns true if we're done (with or without an update), or false if
 * the caller must retry the INSERT from scratch.
 *
 * copied verbatim from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecOnConflictUpdate</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
					 <parameter><decl><type><name>ItemPointer</name></type> <name>conflictTid</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>excludedSlot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>returning</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>onConflictSetWhere</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_WhereClause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>existing</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_Existing</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_FailureData</name></type> <name>tmfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_Result</name></type> <name>test</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>xminDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/* Determine lock mode to use */</comment>
	<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <call><name>ExecUpdateLockMode</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lock tuple for update.  Don't follow updates when tuple cannot be
	 * locked without doing so.  A row locking conflict here means our
	 * previous conclusion that the tuple is conclusively committed is not
	 * true anymore.
	 */</comment>
	<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>table_tuple_lock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
							<argument><expr><name>conflictTid</name></expr></argument>,
							<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
							<argument><expr><name>existing</name></expr></argument>,
							<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
							<argument><expr><name>lockmode</name></expr></argument>,
							<argument><expr><name>LockWaitBlock</name></expr></argument>,
							<argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>test</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TM_Ok</name></expr>:</case>
			<comment type="block">/* success! */</comment>
			<break>break;</break>

		<case>case <expr><name>TM_Invisible</name></expr>:</case>

			<comment type="block">/*
			 * This can occur when a just inserted tuple is updated again in
			 * the same command. E.g. because multiple rows with the same
			 * conflicting key values are inserted.
			 *
			 * This is somewhat similar to the ExecUpdate() TM_SelfModified
			 * case.  We do not want to proceed because it would lead to the
			 * same row being updated a second time in some unspecified order,
			 * and in contrast to plain UPDATEs there's no historical behavior
			 * to break.
			 *
			 * It is the user's responsibility to prevent this situation from
			 * occurring.  These problems are why SQL-2003 similarly specifies
			 * that for SQL MERGE, an exception must be raised in the event of
			 * an attempt to update the same row twice.
			 */</comment>
			<expr_stmt><expr><name>xminDatum</name> <operator>=</operator> <call><name>slot_getsysattr</name><argument_list>(<argument><expr><name>existing</name></expr></argument>, <argument><expr><name>MinTransactionIdAttributeNumber</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>DatumGetTransactionId</name><argument_list>(<argument><expr><name>xminDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON CONFLICT DO UPDATE command cannot affect row a second time"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Ensure that no rows proposed for insertion within the same "</literal>
								 <literal type="string">"command have duplicate constrained values."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* This shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attempted to lock invisible tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TM_SelfModified</name></expr>:</case>

			<comment type="block">/*
			 * This state should never be reached. As a dirty snapshot is used
			 * to find conflicting tuples, speculative insertion wouldn't have
			 * seen this row to conflict with.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected self-updated tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TM_Updated</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * As long as we don't support an UPDATE of INSERT ON CONFLICT for
			 * a partitioned table we shouldn't reach to a case where tuple to
			 * be lock is moved to another partition due to concurrent update
			 * of the partition key.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ItemPointerIndicatesMovedPartitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmfd</name><operator>.</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Tell caller to try again from the very start.
			 *
			 * It does not make sense to use the usual EvalPlanQual() style
			 * loop here, as the new version of the row might not conflict
			 * anymore, or the conflicting tuple has actually been deleted.
			 */</comment>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><name>TM_Deleted</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent delete"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* see TM_Updated case */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ItemPointerIndicatesMovedPartitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmfd</name><operator>.</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized table_tuple_lock status: %u"</literal></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* Success, the tuple is locked. */</comment>

	<comment type="block">/*
	 * Verify that the tuple is visible to our MVCC snapshot if the current
	 * isolation level mandates that.
	 *
	 * It's not sufficient to rely on the check within ExecUpdate() as e.g.
	 * CONFLICT ... WHERE clause may prevent us from reaching that.
	 *
	 * This means we only ever continue when a new command in the current
	 * transaction could see the row, even though in READ COMMITTED mode the
	 * tuple will not be visible according to the current statement's
	 * snapshot.  This is in line with the way UPDATE deals with newer tuple
	 * versions.
	 */</comment>
	<expr_stmt><expr><call><name>ExecCheckTupleVisible</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make tuple and any needed join variables available to ExecQual and
	 * ExecProject.  The EXCLUDED tuple is installed in ecxt_innertuple, while
	 * the target's existing tuple is installed in the scantuple.  EXCLUDED
	 * has been made to reference INNER_VAR in setrefs.c, but there is no
	 * other redirection.
	 */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>existing</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>excludedSlot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>onConflictSetWhere</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* see return below */</comment>
		<expr_stmt><expr><call><name>InstrCountFiltered1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return> <comment type="block">/* done with the tuple */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check target's existing tuple against UPDATE-applicable USING
		 * security barrier quals (if any), enforced here as RLS checks/WCOs.
		 *
		 * The rewriter creates UPDATE RLS checks/WCOs for UPDATE security
		 * quals, and stores them as WCOs of "kind" WCO_RLS_CONFLICT_CHECK,
		 * but that's almost the extent of its special handling for ON
		 * CONFLICT DO UPDATE.
		 *
		 * The rewriter will also have associated UPDATE applicable straight
		 * RLS checks/WCOs for the benefit of the ExecUpdate() call that
		 * follows.  INSERTs and UPDATEs naturally have mutually exclusive WCO
		 * kinds, so there is no danger of spurious over-enforcement in the
		 * INSERT or UPDATE path.
		 */</comment>
		<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_RLS_CONFLICT_CHECK</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>existing</name></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Project the new tuple version */</comment>
	<expr_stmt><expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that it is possible that the target tuple has been modified in
	 * this session, after the above table_tuple_lock. We choose to not error
	 * out in that case, in line with ExecUpdate's treatment of similar cases.
	 * This can happen if an UPDATE is triggered from within ExecQual(),
	 * ExecWithCheckOptions() or ExecProject() above, e.g. by selecting from a
	 * wCTE in the ON CONFLICT's SET.
	 */</comment>

	<comment type="block">/* Execute UPDATE with projection */</comment>
	<expr_stmt><expr><operator>*</operator><name>returning</name> <operator>=</operator> <call><name>ExecUpdate</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>,
							<argument><expr><name>resultRelInfo</name></expr></argument>,
							<argument><expr><name>conflictTid</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name></expr></argument>,
							<argument><expr><name>planSlot</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>,
							<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
							<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clear out existing tuple, as there might not be another conflict among
	 * the next input rows. Don't want to hold resources till the end of the
	 * query.
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCheckTupleVisible -- verify tuple is visible
 *
 * It would not be consistent with guarantees of the higher isolation levels to
 * proceed with avoiding insertion (taking speculative insertion's alternative
 * path) on the basis of another tuple that is not visible to MVCC snapshot.
 * Check for the need to raise a serialization failure, and do so as necessary.
 *
 * copied verbatim from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecCheckTupleVisible</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_satisfies_snapshot</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>xminDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>xminDatum</name> <operator>=</operator> <call><name>slot_getsysattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>MinTransactionIdAttributeNumber</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>DatumGetTransactionId</name><argument_list>(<argument><expr><name>xminDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We should not raise a serialization failure if the conflict is
		 * against a tuple inserted by our own transaction, even if it's not
		 * visible to our snapshot.  (This would happen, for example, if
		 * conflicting keys are proposed for insertion in a single command.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCheckTIDVisible -- convenience variant of ExecCheckTupleVisible()
 *
 * copied verbatim from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecCheckTIDVisible</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
					<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tempSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Redundantly check isolation level */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_fetch_row_version</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><name>tempSlot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch conflicting tuple for ON CONFLICT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecCheckTupleVisible</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tempSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>tempSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecDelete
 *
 *		DELETE is like UPDATE, except that we delete the tuple and no
 *		index modifications are needed.
 *
 *		When deleting from a table, tupleid identifies the tuple to
 *		delete and oldtuple is NULL.  When deleting from a view,
 *		oldtuple is passed to the INSTEAD OF triggers and identifies
 *		what to delete, and tupleid is invalid.  When deleting from a
 *		foreign table, tupleid is invalid; the FDW has to figure out
 *		which row to delete using data from the planSlot.  oldtuple is
 *		passed to foreign table triggers; it is NULL when the foreign
 *		table has no relevant triggers.  We use tupleDeleted to indicate
 *		whether the tuple is actually deleted, callers can use it to
 *		decide whether to continue the operation.  When this DELETE is a
 *		part of an UPDATE of partition-key, then the slot returned by
 *		EvalPlanQual() is passed back using output parameter epqslot.
 *
 *		Returns RETURNING result if any, otherwise NULL.
 * ----------------------------------------------------------------
 *
 * copied from executor/nodeModifyTable.c
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecDelete</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
		   <parameter><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>, <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>processReturning</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changingPart</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>tupleDeleted</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>epqreturnslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>resultRelationDesc</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_Result</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_FailureData</name></type> <name>tmfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>ar_delete_trig_tcs</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tupleDeleted</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tupleDeleted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* BEFORE ROW DELETE Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_delete_before_row</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>dodelete</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dodelete</name> <operator>=</operator>
			<call><name>ExecBRDeleteTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>epqreturnslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dodelete</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* INSTEAD OF ROW DELETE Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_delete_instead_row</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>dodelete</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldtuple</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dodelete</name> <operator>=</operator> <call><name>ExecIRDeleteTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dodelete</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * delete from foreign table: let the FDW do it
		 *
		 * We offer the returning slot as a place to store RETURNING data,
		 * although the FDW can return some other slot if it wants.
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecGetReturningSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator>
			<call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>ExecForeignDelete</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * RETURNING expressions might reference the tableoid column, so
		 * (re)initialize tts_tableOid before evaluating them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecStoreAllNullTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * delete the tuple
		 *
		 * Note: if es_crosscheck_snapshot isn't InvalidSnapshot, we check
		 * that the row to be deleted is visible to that snapshot, and throw a
		 * can't-serialize error if not. This is a special-case behavior
		 * needed for referential integrity updates in transaction-snapshot
		 * mode transactions.
		 */</comment>
	<label><name>ldelete</name>:</label><empty_stmt>;</empty_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>tupleid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"cannot update/delete rows from chunk \"%s\" as it is compressed"</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>table_tuple_delete</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>,
									<argument><expr><name>tupleid</name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
									<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr></argument>,
									<argument><expr><name>true</name></expr></argument> <comment type="block">/* wait for commit */</comment>,
									<argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>,
									<argument><expr><name>changingPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TM_SelfModified</name></expr>:</case>

				<comment type="block">/*
				 * The target tuple was already updated or deleted by the
				 * current command, or by a later command in the current
				 * transaction.  The former case is possible in a join DELETE
				 * where multiple tuples join to the same target tuple. This
				 * is somewhat questionable, but Postgres has always allowed
				 * it: we just ignore additional deletion attempts.
				 *
				 * The latter case arises if the tuple is modified by a
				 * command in a BEFORE trigger, or perhaps by a command in a
				 * volatile function used in the query.  In such situations we
				 * should not ignore the deletion, but it is equally unsafe to
				 * proceed.  We don't want to discard the original DELETE
				 * while keeping the triggered actions based on its deletion;
				 * and it would be no better to allow the original DELETE
				 * while discarding updates that it triggered.  The row update
				 * carries some information that might be important according
				 * to business rules; so throwing an error is the only safe
				 * course.
				 *
				 * If a trigger actually intends this type of interaction, it
				 * can re-execute the DELETE and then return NULL to cancel
				 * the outer delete.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tmfd</name><operator>.</operator><name>cmax</name></name> <operator>!=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TRIGGERED_DATA_CHANGE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be deleted was already modified by an operation "</literal>
									<literal type="string">"triggered by the current command"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using an AFTER trigger instead of a BEFORE trigger "</literal>
									 <literal type="string">"to propagate changes to other rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Else, already deleted by self; nothing to do */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			<case>case <expr><name>TM_Ok</name></expr>:</case>
				<break>break;</break>

			<case>case <expr><name>TM_Updated</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>inputslot</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>epqslot</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Already know that we're going to need to do EPQ, so
				 * fetch tuple directly into the right slot.
				 */</comment>
				<expr_stmt><expr><call><name>EvalPlanQualBegin</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>inputslot</name> <operator>=</operator> <call><name>EvalPlanQualSlot</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>,
											 <argument><expr><name>resultRelationDesc</name></expr></argument>,
											 <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>table_tuple_lock</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>,
										  <argument><expr><name>tupleid</name></expr></argument>,
										  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
										  <argument><expr><name>inputslot</name></expr></argument>,
										  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
										  <argument><expr><name>LockTupleExclusive</name></expr></argument>,
										  <argument><expr><name>LockWaitBlock</name></expr></argument>,
										  <argument><expr><name>TUPLE_LOCK_FLAG_FIND_LAST_VERSION</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>TM_Ok</name></expr>:</case>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tmfd</name><operator>.</operator><name>traversed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>epqslot</name> <operator>=</operator> <call><name>EvalPlanQual</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>,
											   <argument><expr><name>resultRelationDesc</name></expr></argument>,
											   <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>,
											   <argument><expr><name>inputslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<comment type="block">/* Tuple not passing quals anymore, exiting... */</comment>
							<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * If requested, skip delete and pass back the
						 * updated row.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>epqreturnslot</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><operator>*</operator><name>epqreturnslot</name> <operator>=</operator> <name>epqslot</name></expr>;</expr_stmt>
							<return>return <expr><name>NULL</name></expr>;</return>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<goto>goto <name>ldelete</name>;</goto></block_content></block></else></if_stmt>

					<case>case <expr><name>TM_SelfModified</name></expr>:</case>

						<comment type="block">/*
						 * This can be reached when following an update
						 * chain from a tuple updated by another session,
						 * reaching a tuple that was already updated in
						 * this transaction. If previously updated by this
						 * command, ignore the delete, otherwise error
						 * out.
						 *
						 * See also TM_SelfModified response to
						 * table_tuple_delete() above.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>tmfd</name><operator>.</operator><name>cmax</name></name> <operator>!=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TRIGGERED_DATA_CHANGE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be deleted was already modified by an "</literal>
											<literal type="string">"operation triggered by the current command"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using an AFTER trigger instead of a BEFORE "</literal>
											 <literal type="string">"trigger to propagate changes to other rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<return>return <expr><name>NULL</name></expr>;</return>

					<case>case <expr><name>TM_Deleted</name></expr>:</case>
						<comment type="block">/* tuple already deleted; nothing to do */</comment>
						<return>return <expr><name>NULL</name></expr>;</return>

					<default>default:</default>

						<comment type="block">/*
						 * TM_Invisible should be impossible because we're
						 * waiting for updated row versions, and would
						 * already have errored out if the first version
						 * is invisible.
						 *
						 * TM_Updated should be impossible, because we're
						 * locking the latest version via
						 * TUPLE_LOCK_FLAG_FIND_LAST_VERSION.
						 */</comment>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected table_tuple_lock status: %u"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></switch>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>TM_Deleted</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent delete"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* tuple already deleted; nothing to do */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized table_tuple_delete status: %u"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Note: Normally one would think that we have to delete index tuples
		 * associated with the heap tuple now...
		 *
		 * ... but in POSTGRES, we have no need to do this because VACUUM will
		 * take care of it later.  We can't delete index tuples immediately
		 * anyway, since the tuple is still visible to other transactions.
		 */</comment>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>canSetTag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Tell caller that the delete actually happened. */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupleDeleted</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tupleDeleted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this delete is the result of a partition key update that moved the
	 * tuple to a new partition, put this row into the transition OLD TABLE,
	 * if there is one. We need to do this separately for DELETE and INSERT
	 * because they happen on different tables.
	 */</comment>
	<expr_stmt><expr><name>ar_delete_trig_tcs</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>&amp;&amp;</operator>
		<name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_update_old_table</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecARUpdateTriggersCompat</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
								   <argument><expr><name>resultRelInfo</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>tupleid</name></expr></argument>,
								   <argument><expr><name>oldtuple</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We've already captured the NEW TABLE row, so make sure any AR
		 * DELETE trigger fired below doesn't capture it again.
		 */</comment>
		<expr_stmt><expr><name>ar_delete_trig_tcs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* AFTER ROW DELETE Triggers */</comment>
	<expr_stmt><expr><call><name>ExecARDeleteTriggersCompat</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>ar_delete_trig_tcs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process RETURNING if present and if requested */</comment>
	<if_stmt><if>if <condition>(<expr><name>processReturning</name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have to put the target tuple into a slot, which means first we
		 * gotta fetch it.  We can use the trigger tuple slot.
		 */</comment>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>rslot</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* FDW must have provided a slot containing the deleted row */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecGetReturningSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>oldtuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecForceStoreHeapTuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_fetch_row_version</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch deleted tuple for DELETE RETURNING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>rslot</name> <operator>=</operator> <call><name>ExecProcessReturning</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Before releasing the target tuple again, make sure rslot has a
		 * local copy of any pass-by-reference values.
		 */</comment>
		<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>rslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>rslot</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
