<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/nodes/chunk_append/planner.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/extensible.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/appendinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/pathnode.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/placeholder.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/planmain.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/prep.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/subselect.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_append/chunk_append.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_append/transform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/hypertable_modify.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"import/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type><name>make_sort</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>adjust_childscan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomScanMethods</name></type> <name>chunk_append_plan_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"ChunkAppend"</literal></expr>,
	<expr><operator>.</operator><name>CreateCustomScanState</name> <operator>=</operator> <name>ts_chunk_append_state_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>bool</name></type>
<name>ts_is_chunk_append_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG15_GE</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>castNode</name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>methods</name> <operator>==</operator>
				   <operator>&amp;</operator><name>chunk_append_plan_methods</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>methods</name> <operator>==</operator> <operator>&amp;</operator><name>chunk_append_plan_methods</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_chunk_append_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>TryRegisterCustomScanMethods</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunk_append_plan_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>adjust_childscan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
				 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><call><name>ts_get_appendrelinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>childSortCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>childColIdx</name></decl>;</decl_stmt>

	<comment type="block">/* push down targetlist to children */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tlist</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute sort column info, and adjust subplan's tlist as needed */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>ts_prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>plan</name></expr></argument>,
										 <argument><expr><name>pathkeys</name></expr></argument>,
										 <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										 <argument><expr><name>sortColIdx</name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>childSortCols</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>childColIdx</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>sortOperators</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>collations</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* inject sort node if child sort order does not match desired order */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator>
			<call><name>make_sort</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>childSortCols</name></expr></argument>, <argument><expr><name>childColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>ts_chunk_append_plan_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_plans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parent_clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_ri_clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_rt_indexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_private</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>limit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ChunkAppendPath</name> <modifier>*</modifier></type><name>capath</name> <init>= <expr><operator>(</operator><name>ChunkAppendPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>chunk_append_plan_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>ts_build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<comment type="block">/*
	 * If this is a child of HypertableModify we need to adjust
	 * targetlists to not have any ROWID_VAR references as postgres
	 * asserts that scan targetlists do not have them in setrefs.c
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>ts_replace_rowid_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_plan</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc_path</name></decl>;</decl_stmt>
		<macro><name>forboth</name> <argument_list>(<argument>lc_path</argument>, <argument>path-&gt;custom_paths</argument>, <argument>lc_plan</argument>, <argument>custom_plans</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>child_plan</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>child_path</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* push down targetlist to children */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>child_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* if this is an append child we need to adjust targetlist references */</comment>
				<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>=
					<expr><call><name>ts_get_appendrelinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>child_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>child_plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator>
					<call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tlist</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>child_plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If this is an ordered append node we need to ensure the columns
		 * required for sorting are present in the targetlist and all children
		 * return sorted output. Children not returning sorted output will be
		 * wrapped in a sort node.
		 */</comment>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_plan</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc_path</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>numCols</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_indexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_ops</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_collations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_nulls</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Compute sort column info, and adjust MergeAppend's tlist as needed */</comment>
		<expr_stmt><expr><call><name>ts_prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>,
									  <argument><expr><name>pathkeys</name></expr></argument>,
									  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>numCols</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>sortColIdx</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>sortOperators</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>collations</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * collect sort information to make available to explain
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>sort_indexes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>sort_indexes</name></expr></argument>, <argument><expr><name><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sort_ops</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>sort_ops</name></expr></argument>, <argument><expr><name><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sort_collations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>sort_collations</name></expr></argument>, <argument><expr><name><name>collations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sort_nulls</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>sort_nulls</name></expr></argument>, <argument><expr><name><name>nullsFirst</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>sort_options</name> <operator>=</operator> <call><name>list_make4</name><argument_list>(<argument><expr><name>sort_indexes</name></expr></argument>, <argument><expr><name>sort_ops</name></expr></argument>, <argument><expr><name>sort_collations</name></expr></argument>, <argument><expr><name>sort_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>forboth</name> <argument_list>(<argument>lc_path</argument>, <argument>path-&gt;custom_paths</argument>, <argument>lc_plan</argument>, <argument>custom_plans</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * If the planner injected a Result node to do projection
			 * we can safely remove the Result node if it does not have
			 * a one-time filter because ChunkAppend can do projection.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>castNode</name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>resconstantqual</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>lefttree</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_childpath</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc_childplan</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>merge_plan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>MergeAppend</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>merge_path</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>MergeAppendPath</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Since for space partitioning the MergeAppend below ChunkAppend
				 * still has the hypertable as rel we can copy sort properties and
				 * target list from toplevel ChunkAppend.
				 */</comment>
				<expr_stmt><expr><name><name>merge_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>merge_plan</name><operator>-&gt;</operator><name>sortColIdx</name></name> <operator>=</operator> <name>sortColIdx</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>merge_plan</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator> <name>sortOperators</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>merge_plan</name><operator>-&gt;</operator><name>collations</name></name> <operator>=</operator> <name>collations</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>merge_plan</name><operator>-&gt;</operator><name>nullsFirst</name></name> <operator>=</operator> <name>nullsFirst</name></expr>;</expr_stmt>

				<macro><name>forboth</name> <argument_list>(<argument>lc_childpath</argument>, <argument>merge_path-&gt;subpaths</argument>, <argument>lc_childplan</argument>, <argument>merge_plan-&gt;mergeplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_childplan</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>adjust_childscan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_childplan</name></expr></argument>)</argument_list></call></expr></argument>,
															<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_childpath</name></expr></argument>)</argument_list></call></expr></argument>,
															<argument><expr><name>pathkeys</name></expr></argument>,
															<argument><expr><name>tlist</name></expr></argument>,
															<argument><expr><name>sortColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>adjust_childscan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_path</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>,
												   <argument><expr><name>tlist</name></expr></argument>,
												   <argument><expr><name>sortColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* decouple input tlist from output tlist in case output tlist gets modified later */</comment>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name> <operator>=</operator> <name>custom_plans</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we do either startup or runtime exclusion, we need to pass restrictinfo
	 * clauses into executor.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>capath</name><operator>-&gt;</operator><name>startup_exclusion</name></name> <operator>||</operator> <name><name>capath</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name> <argument_list>(<argument>lc_child</argument>, <argument>cscan-&gt;custom_plans</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Scan</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><call><name>ts_chunk_append_get_scan_plan</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_child</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>scan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>scan</name><operator>-&gt;</operator><name>scanrelid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>chunk_ri_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>chunk_ri_clauses</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>chunk_rt_indexes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>chunk_rt_indexes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><call><name>ts_get_appendrelinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>scanrelid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>ts_transform_cross_datatype_comparison</name><argument_list>(
						<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>chunk_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>chunk_clauses</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><name>chunk_ri_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>chunk_ri_clauses</name></expr></argument>, <argument><expr><name>chunk_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>chunk_rt_indexes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>chunk_rt_indexes</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>chunk_ri_clauses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>chunk_ri_clauses</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>chunk_rt_indexes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* pass down the parent clauses if doing parent exclusion */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>capath</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>parent_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>parent_clauses</name></expr></argument>, <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>capath</name><operator>-&gt;</operator><name>pushdown_limit</name></name> <operator>&amp;&amp;</operator> <name><name>capath</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>limit</name> <operator>=</operator> <name><name>capath</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>custom_private</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>list_make5_int</name><argument_list>(<argument><expr><name><name>capath</name><operator>-&gt;</operator><name>startup_exclusion</name></name></expr></argument>,
											   <argument><expr><name><name>capath</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name></expr></argument>,
											   <argument><expr><name><name>capath</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name></expr></argument>,
											   <argument><expr><name>limit</name></expr></argument>,
											   <argument><expr><name><name>capath</name><operator>-&gt;</operator><name>first_partial_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>custom_private</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>custom_private</name></expr></argument>, <argument><expr><name>chunk_ri_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>custom_private</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>custom_private</name></expr></argument>, <argument><expr><name>chunk_rt_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>custom_private</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>custom_private</name></expr></argument>, <argument><expr><name>sort_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>custom_private</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>custom_private</name></expr></argument>, <argument><expr><name>parent_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator> <name>custom_private</name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_sort --- basic routine to build a Sort plan node
 *
 * Caller must have built the sortColIdx, sortOperators, collations, and
 * nullsFirst arrays already.
 */</comment>
<function><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type>
<name>make_sort</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Sort</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name></name> <operator>=</operator> <name>sortColIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator> <name>sortOperators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>collations</name></name> <operator>=</operator> <name>collations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name></name> <operator>=</operator> <name>nullsFirst</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Scan</name> <modifier>*</modifier></type>
<name>ts_chunk_append_get_scan_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Sort</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
		<case>case <expr><name>T_TidScan</name></expr>:</case>
		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr>;</return>
			<break>break;</break>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<return>return <expr><name>NULL</name></expr>;</return>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid child of chunk append: %s"</literal></expr></argument>, <argument><expr><call><name>ts_get_node_name</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
