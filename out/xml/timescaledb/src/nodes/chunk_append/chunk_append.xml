<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/nodes/chunk_append/chunk_append.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/pathnode.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/tlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/typcache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planner/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_append/chunk_append.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"func_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type><name>find_equality_join_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>sort_var</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>ht_relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>eq_opr</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>join_conditions</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomPathMethods</name></type> <name>chunk_append_path_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"ChunkAppend"</literal></expr>,
	<expr><operator>.</operator><name>PlanCustomPath</name> <operator>=</operator> <name>ts_chunk_append_plan_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>bool</name></type>
<name>ts_is_chunk_append_path</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>CustomPath</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>castNode</name><argument_list>(<argument><expr><name>CustomPath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>methods</name> <operator>==</operator> <operator>&amp;</operator><name>chunk_append_path_methods</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>has_joins</name><parameter_list>(<parameter><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>jointree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Path</name> <modifier>*</modifier></type>
<name>ts_chunk_append_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>parallel_aware</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ordered</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nested_oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkAppendPath</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>rows</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>total_cost</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>ChunkAppendPath</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkAppendPath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CustomScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We keep the pathkeys from the original path here because
	 * the original path was either a MergeAppendPath and this
	 * will become an ordered append or the original path is an
	 * AppendPath and since we do not reorder children the order
	 * will be kept intact. For the AppendPath case with pathkeys
	 * it was most likely an Append with only a single child.
	 * We could skip the ChunkAppend path creation if there is
	 * only a single child but we decided earlier that ChunkAppend
	 * would be beneficial for this query so we treat it the same
	 * as if it had multiple children.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>AppendPath</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>MergeAppendPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <ternary><condition><expr><name>ts_guc_enable_parallel_chunk_append</name></expr> ?</condition><then> <expr><name>parallel_aware</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set flags. We can set CUSTOMPATH_SUPPORT_BACKWARD_SCAN and
	 * CUSTOMPATH_SUPPORT_MARK_RESTORE. The only interesting flag is the first
	 * one (backward scan), but since we are not scanning a real relation we
	 * need not indicate that we support backward scans. Lower-level index
	 * scanning nodes will scan backward if necessary, so once tuples get to
	 * this node they will be in a given order already.
	 */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>chunk_append_path_methods</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Figure out whether there's a hard limit on the number of rows that
	 * query_planner's result subplan needs to return.  Even if we know a
	 * hard limit overall, it doesn't apply if the query has any
	 * grouping/aggregation operations, or SRFs in the tlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
		<name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name> <operator>||</operator>
		<call><name>has_joins</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>&gt;</operator> <name>PG_INT32_MAX</name> <operator>||</operator>
		<name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
		<operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * check if we should do startup and runtime exclusion
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_exclusion</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ts_guc_enable_runtime_exclusion</name> <operator>&amp;&amp;</operator> <call><name>ts_contain_param</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_var</name></decl>;</decl_stmt>

			<comment type="block">/* We have two types of exclusion:
			 *
			 * Parent exclusion fires if the entire hypertable can be excluded.
			 * This happens if doing things like joining against a parameter
			 * value that is an empty array or NULL. It doesn't happen often,
			 * but when it does, it speeds up the query immensely. It's also cheap
			 * to check for this condition as you check this once per hypertable
			 * at runtime.
			 *
			 * Child exclusion works by seeing if there is a contradiction between
			 * the chunks constraints and the expression on parameter values. For example,
			 * it can evaluate whether a time parameter from a subquery falls outside
			 * the range of the chunk. It is more widely applicable than the parent
			 * exclusion but is also more expensive to evaluate since you have to perform
			 * the check on every chunk. Child exclusion can only apply if one of the quals
			 * involves a partitioning column.
			 *
			 */</comment>
			<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<macro><name>foreach</name> <argument_list>(<argument>lc_var</argument>, <argument>pull_var_clause((Node *) rinfo-&gt;clause, <literal type="number">0</literal>)</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<comment type="block">/*
				 * varattno 0 is whole row and varattno less than zero are
				 * system columns so we skip those even though
				 * ts_is_partitioning_column would return the correct
				 * answer for those as well
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Index</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<call><name>ts_is_partitioning_column</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<comment type="block">/*
	 * Our strategy is to use child exclusion if possible (if a partitioning
	 * column is used) and fall back to parent exclusion if we can't use child
	 * exclusion. Please note: there is no point to using both child and parent
	 * exclusion at the same time since child exclusion would always exclude
	 * the same chunks that parent exclusion would.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name> <operator>&amp;&amp;</operator> <name><name>path</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make sure our subpath is either an Append or MergeAppend node
	 */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_AppendPath</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AppendPath</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>append</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>&amp;&amp;</operator> <name><name>append</name><operator>-&gt;</operator><name>first_partial_path</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>first_partial_path</name></name> <operator>=</operator> <name><name>append</name><operator>-&gt;</operator><name>first_partial_path</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>children</name> <operator>=</operator> <name><name>append</name><operator>-&gt;</operator><name>subpaths</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_MergeAppendPath</name></expr>:</case>
			<comment type="block">/*
			 * check if ordered append is applicable, only assert ordered here
			 * checked properly in ts_ordered_append_should_optimize
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ordered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * we only push down LIMIT for ordered append
			 */</comment>
			<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>pushdown_limit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>MergeAppendPath</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpaths</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid child of chunk append: %s"</literal></expr></argument>, <argument><expr><call><name>ts_get_node_name</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ordered</name> <operator>||</operator> <name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>num_dimensions</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>=</operator> <name>children</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For space partitioning we need to change the shape of the plan
		 * into a MergeAppend for each time slice with all space partitions below
		 * The final plan for space partitioning will look like this:
		 *
		 * Custom Scan (ChunkAppend)
		 *   Hypertable: space
		 *   -&gt;  Merge Append
		 *         Sort Key: _hyper_9_56_chunk."time"
		 *         -&gt;  Index Scan
		 *         -&gt;  Index Scan
		 *         -&gt;  Index Scan
		 *   -&gt;  Merge Append
		 *         Sort Key: _hyper_9_55_chunk."time"
		 *         -&gt;  Index Scan
		 *         -&gt;  Index Scan
		 *         -&gt;  Index Scan
		 *
		 * We do not check sort order at this stage but injecting of Sort
		 * nodes happens when the plan is created instead.
		 */</comment>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>flat</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>children</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nested_children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>has_scan_childs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>nested_oids</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_oid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>current_oids</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>merge_childs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>append</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>flat</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<macro><name>foreach</name> <argument_list>(<argument>lc_oid</argument>, <argument>current_oids</argument>)</argument_list></macro>
			<block>{<block_content>
				<comment type="block">/* postgres may have pruned away some children already */</comment>
				<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>flat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>parent_relid</name> <init>= <expr><name><name>child</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>is_not_pruned</name> <init>=
					<expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc_oid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>parent_relid</name></expr>]</index></name><operator>-&gt;</operator><name>relid</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>is_not_pruned</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>merge_childs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>merge_childs</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>flat</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name>children</name></expr></argument>, <argument><expr><name>flat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>flat</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>merge_childs</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>append</name> <operator>=</operator> <call><name>create_merge_append_path_compat</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name>rel</name></expr></argument>,
														 <argument><expr><name>merge_childs</name></expr></argument>,
														 <argument><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>,
														 <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nested_children</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nested_children</name></expr></argument>, <argument><expr><name>append</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>merge_childs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>has_scan_childs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nested_children</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nested_children</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>merge_childs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>flat</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if we do not have scans as direct childs of this
		 * node we disable startup and runtime exclusion
		 * in this node
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_scan_childs</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_exclusion</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>=</operator> <name>nested_children</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>path-&gt;cpath.custom_paths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If there is a LIMIT clause we only include as many chunks as
		 * planner thinks are needed to satisfy LIMIT clause.
		 * We do this to prevent planner choosing parallel plan which might
		 * otherwise look preferable cost wise.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>pushdown_limit</name></name> <operator>||</operator> <name><name>path</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>rows</name> <operator>&lt;</operator> <name><name>path</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name><name>child</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rows</name> <operator>+=</operator> <name><name>child</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>startup_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if conditions for doing ordered append optimization are fulfilled
 */</comment>
<function><type><name>bool</name></type>
<name>ts_ordered_append_should_optimize</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>join_conditions</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>order_attno</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>reverse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sort</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>sort</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>column</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>ht_relid</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>sort_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>ht_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>sort_var</name></decl>;</decl_stmt>

	<comment type="block">/* these are checked in caller so we only Assert */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ts_guc_enable_optimizations</name> <operator>&amp;&amp;</operator> <name>ts_guc_enable_ordered_append</name> <operator>&amp;&amp;</operator>
		   <name>ts_guc_enable_chunk_append</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * only do this optimization for queries with an ORDER BY clause,
	 * caller checked this, so only asserting
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* direct column reference */</comment>
		<expr_stmt><expr><name>sort_var</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * check for bucketing functions
		 *
		 * If ORDER BY clause only has 1 expression and the expression is a
		 * bucketing function we can still do Ordered Append, the 1 expression
		 * limit could only be safely removed if we ensure chunk boundaries
		 * are not crossed.
		 *
		 * The following example demonstrates this requirement:
		 *
		 * Chunk 1 has (time, device_id)
		 * 0 1
		 * 0 2
		 *
		 * Chunk 2 has (time, device_id)
		 * 10 1
		 * 10 2
		 *
		 * The ORDER BY clause is time_bucket(100,time), device_id
		 * The result when transforming to an ordered append would be the following:
		 * (time_bucket(100, time), device_id)
		 * 0 1
		 * 0 2
		 * 0 1
		 * 0 2
		 *
		 * The order of the device_ids is wrong so we cannot safely remove the MergeAppend
		 * unless we eliminate the possibility that a bucket spans multiple chunks.
		 */</comment>
		<decl_stmt><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>ts_func_cache_get_bucketing_func</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>funcid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>transformed</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>transformed</name> <operator>=</operator> <call><name><name>info</name><operator>-&gt;</operator><name>sort_transform</name></name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>transformed</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>sort_var</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>transformed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

	<comment type="block">/* ordered append won't work for system columns / whole row orderings */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sort_var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sort_relid</name> <operator>=</operator> <name><name>sort_var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tce</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>sort_var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
							<argument><expr><name>TYPECACHE_EQ_OPR</name> <operator>|</operator> <name>TYPECACHE_LT_OPR</name> <operator>|</operator> <name>TYPECACHE_GT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check sort operation is either less than or greater than */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sort</name><operator>-&gt;</operator><name>sortop</name></name> <operator>!=</operator> <name><name>tce</name><operator>-&gt;</operator><name>lt_opr</name></name> <operator>&amp;&amp;</operator> <name><name>sort</name><operator>-&gt;</operator><name>sortop</name></name> <operator>!=</operator> <name><name>tce</name><operator>-&gt;</operator><name>gt_opr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * check the ORDER BY column actually belongs to our hypertable
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sort_relid</name> <operator>==</operator> <name>ht_relid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ORDER BY column belongs to our hypertable */</comment>
		<expr_stmt><expr><name>ht_var</name> <operator>=</operator> <name>sort_var</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If the ORDER BY does not match our hypertable but we are joining
		 * against another hypertable on the time column doing an ordered
		 * append here is still beneficial because we can skip the sort
		 * step for the MergeJoin
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>join_conditions</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>ht_var</name> <operator>=</operator> <call><name>find_equality_join_var</name><argument_list>(<argument><expr><name>sort_var</name></expr></argument>, <argument><expr><name>ht_relid</name></expr></argument>, <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>eq_opr</name></name></expr></argument>, <argument><expr><name>join_conditions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ht_var</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Check hypertable column is the first dimension of the hypertable */</comment>
	<expr_stmt><expr><name>column</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name><name>ht_var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ht</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>dimensions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>order_attno</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>reverse</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>order_attno</name> <operator>=</operator> <name><name>ht_var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>reverse</name> <operator>=</operator> <ternary><condition><expr><name><name>sort</name><operator>-&gt;</operator><name>sortop</name></name> <operator>==</operator> <name><name>tce</name><operator>-&gt;</operator><name>lt_opr</name></name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find equality join between column referenced by sort_var and Relation
 * with relid ht_relid
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>find_equality_join_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>sort_var</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>ht_relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>eq_opr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>join_conditions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>sort_relid</name> <init>= <expr><name><name>sort_var</name><operator>-&gt;</operator><name>varno</name></name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>join_conditions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name> <operator>==</operator> <name>eq_opr</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Is this a join condition referencing our hypertable */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Index</name><operator>)</operator> <name><name>left</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>sort_relid</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Index</name><operator>)</operator> <name><name>right</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>ht_relid</name> <operator>&amp;&amp;</operator>
				 <name><name>left</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>sort_var</name><operator>-&gt;</operator><name>varattno</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>right</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Index</name><operator>)</operator> <name><name>left</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>ht_relid</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Index</name><operator>)</operator> <name><name>right</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>sort_relid</name> <operator>&amp;&amp;</operator>
				 <name><name>right</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>sort_var</name><operator>-&gt;</operator><name>varattno</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>left</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
</unit>
