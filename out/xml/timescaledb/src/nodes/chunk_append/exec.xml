<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/nodes/chunk_append/exec.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_collation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/executor.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/nodeSubplan.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/bitmapset.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/cost.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/plancat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/prep.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/restrictinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rewrite/rewriteManip.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/ruleutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/typcache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_append/chunk_append.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"loader/lwlocks.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_SUBPLAN_INDEX</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_MATCHING_SUBPLANS</name></cpp:macro> <cpp:value>(-2)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>ParallelChunkAppendState</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>next_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>finished</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>ParallelChunkAppendState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ChunkAppendState</name>
<block>{
	<decl_stmt><decl><type><name>CustomScanState</name></type> <name>csstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier><modifier>*</modifier></type><name>subplanstates</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>exclusion_ctx</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>num_subplans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>first_partial_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>filtered_first_partial_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>current</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>ht_reloid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>startup_exclusion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>runtime_exclusion_parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>runtime_exclusion_children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>runtime_initialized</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>limit</name></decl>;</decl_stmt>

	<comment type="block">/* list of subplans after planning */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_subplans</name></decl>;</decl_stmt>
	<comment type="block">/* list of constraints indexed like initial_subplans */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_constraints</name></decl>;</decl_stmt>
	<comment type="block">/* list of restrictinfo clauses indexed like initial_subplans */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_ri_clauses</name></decl>;</decl_stmt>
	<comment type="block">/* List of restrictinfo clauses on the parent hypertable */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_parent_clauses</name></decl>;</decl_stmt>

	<comment type="block">/* list of subplans after startup exclusion */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>filtered_subplans</name></decl>;</decl_stmt>
	<comment type="block">/* list of relation constraints after startup exclusion */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>filtered_constraints</name></decl>;</decl_stmt>
	<comment type="block">/* list of restrictinfo clauses after startup exclusion */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>filtered_ri_clauses</name></decl>;</decl_stmt>

	<comment type="block">/* valid subplans for runtime exclusion */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>valid_subplans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

	<comment type="block">/* sort options if this append is ordered, only used for EXPLAIN */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_options</name></decl>;</decl_stmt>

	<comment type="block">/* number of loops and exclusions for EXPLAIN */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>runtime_number_loops</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>runtime_number_exclusions_parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>runtime_number_exclusions_children</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelChunkAppendState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>choose_next_subplan</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ChunkAppendState</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
}</block></struct></type> <name>ChunkAppendState</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>chunk_append_exec</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chunk_append_begin</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chunk_append_end</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chunk_append_rescan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chunk_append_explain</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>chunk_append_estimate_dsm</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chunk_append_initialize_dsm</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>,
										<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>coordinate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chunk_append_reinitialize_dsm</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>,
										  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>coordinate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chunk_append_initialize_worker</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>coordinate</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomExecMethods</name></type> <name>chunk_append_state_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>BeginCustomScan</name> <operator>=</operator> <name>chunk_append_begin</name></expr>,
	<expr><operator>.</operator><name>ExecCustomScan</name> <operator>=</operator> <name>chunk_append_exec</name></expr>,
	<expr><operator>.</operator><name>EndCustomScan</name> <operator>=</operator> <name>chunk_append_end</name></expr>,
	<expr><operator>.</operator><name>ReScanCustomScan</name> <operator>=</operator> <name>chunk_append_rescan</name></expr>,
	<expr><operator>.</operator><name>ExplainCustomScan</name> <operator>=</operator> <name>chunk_append_explain</name></expr>,
	<expr><operator>.</operator><name>EstimateDSMCustomScan</name> <operator>=</operator> <name>chunk_append_estimate_dsm</name></expr>,
	<expr><operator>.</operator><name>InitializeDSMCustomScan</name> <operator>=</operator> <name>chunk_append_initialize_dsm</name></expr>,
	<expr><operator>.</operator><name>ReInitializeDSMCustomScan</name> <operator>=</operator> <name>chunk_append_reinitialize_dsm</name></expr>,
	<expr><operator>.</operator><name>InitializeWorkerCustomScan</name> <operator>=</operator> <name>chunk_append_initialize_worker</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>choose_next_subplan_non_parallel</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>choose_next_subplan_for_worker</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>constify_restrictinfos</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>can_exclude_chunk</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>baserestrictinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_startup_exclusion</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>constify_param_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>constify_restrictinfo_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfos</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initialize_constraints</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_rt_indexes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>LWLock</name> <modifier>*</modifier></type><name>chunk_append_get_lock_pointer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_sort_group_keys</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_sortorder_options</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>sortexpr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sortOperator</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>nullsFirst</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>ts_chunk_append_state_create</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>settings</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>ChunkAppendState</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkAppendState</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomScanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>chunk_append_state_methods</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>initial_subplans</name></name> <operator>=</operator> <name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>initial_ri_clauses</name></name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sort_options</name></name> <operator>=</operator> <call><name>lfourth</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>initial_parent_clauses</name></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>startup_exclusion</name></name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <call><name>linitial_int</name><argument_list>(<argument><expr><name>settings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <call><name>lsecond_int</name><argument_list>(<argument><expr><name>settings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <call><name>lthird_int</name><argument_list>(<argument><expr><name>settings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <call><name>lfourth_int</name><argument_list>(<argument><expr><name>settings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>first_partial_plan</name></name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><call><name>list_nth_cell</name><argument_list>(<argument><expr><name>settings</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_subplans</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>initial_subplans</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_ri_clauses</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>initial_ri_clauses</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_first_partial_plan</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>first_partial_plan</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>choose_next_subplan</name></name> <operator>=</operator> <name>choose_next_subplan_non_parallel</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>exclusion_ctx</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
												 <argument><expr><literal type="string">"ChunkApppend exclusion"</literal></expr></argument>,
												 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_startup_exclusion</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>filtered_children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>filtered_ri_clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>filtered_constraints</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_clauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>filtered_first_partial_plan</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>first_partial_plan</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * create skeleton plannerinfo for estimate_expression_value
	 */</comment>
	<decl_stmt><decl><type><name>PlannerGlobal</name></type> <name>glob</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>boundParams</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name></type> <name>root</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>glob</name> <operator>=</operator> <operator>&amp;</operator><name>glob</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * clauses and constraints should always have the same length as initial_subplans
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>initial_subplans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>initial_ri_clauses</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>initial_subplans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>initial_constraints</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>forthree</name> <argument_list>(<argument>lc_plan</argument>,
			  <argument>state-&gt;initial_subplans</argument>,
			  <argument>lc_constraints</argument>,
			  <argument>state-&gt;initial_constraints</argument>,
			  <argument>lc_clauses</argument>,
			  <argument>state-&gt;initial_ri_clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ri_clauses</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Scan</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><call><name>ts_chunk_append_get_scan_plan</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is a base rel (chunk), check if it can be
		 * excluded from the scan. Otherwise, fall through.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>scan</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>scanrelid</name></name></expr>)</condition>
		<block>{<block_content>
			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>ri_clauses</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>restrictinfos</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>restrictinfos</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><name>restrictinfos</name> <operator>=</operator> <call><name>constify_restrictinfos</name><argument_list>(<argument><expr><operator>&amp;</operator><name>root</name></expr></argument>, <argument><expr><name>restrictinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>can_exclude_chunk</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_constraints</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>restrictinfos</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>first_partial_plan</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>filtered_first_partial_plan</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * if this node does runtime exclusion on the children we keep the constified
			 * expressions to save us some work during runtime exclusion
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>const_ri_clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>restrictinfos</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>const_ri_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>const_ri_clauses</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><name>ri_clauses</name> <operator>=</operator> <name>const_ri_clauses</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>filtered_children</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>filtered_children</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>filtered_ri_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>filtered_ri_clauses</name></expr></argument>, <argument><expr><name>ri_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>filtered_constraints</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>filtered_constraints</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_constraints</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_subplans</name></name> <operator>=</operator> <name>filtered_children</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_ri_clauses</name></name> <operator>=</operator> <name>filtered_ri_clauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_constraints</name></name> <operator>=</operator> <name>filtered_constraints</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_first_partial_plan</name></name> <operator>=</operator> <name>filtered_first_partial_plan</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Complete initialization of the supplied CustomScanState.
 * Standard fields have been initialized by ExecInitCustomScan,
 * but any private fields should be initialized here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_append_begin</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ChunkAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* CustomScan hard-codes the scan and result tuple slot to a fixed
	 * TTSOpsVirtual ops (meaning it expects the slot ops of the child tuple to
	 * also have this type). Oddly, when reading slots from subscan nodes
	 * (children), there is no knowing what tuple slot ops the child slot will
	 * have (e.g., for ChunkAppend it is common that the child is a
	 * seqscan/indexscan that produces a TTSOpsBufferHeapTuple
	 * slot). Unfortunately, any mismatch between slot types when projecting is
	 * asserted by PostgreSQL. To avoid this issue, we mark the scanops as
	 * non-fixed and reinitialize the projection state with this new setting.
	 *
	 * Alternatively, we could copy the child tuple into the scan slot to get
	 * the expected ops before projection, but this would require materializing
	 * and copying the tuple unnecessarily.
	 */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>scanopsfixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Since we sometimes return the scan slot directly from the subnode, the
	 * result slot is not fixed either. */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>resultopsfixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignScanProjectionInfoWithVarno</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><name>INDEX_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initialize_constraints</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>startup_exclusion</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_startup_exclusion</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>NO_MATCHING_SUBPLANS</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>subplanstates</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PlanState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>state-&gt;filtered_subplans</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * we use an array for the states but put it in custom_ps as well
		 * so explain and planstate_tree_walker can find it
		 */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>subplanstates</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplanstates</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * pass down limit to child nodes
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>limit</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplanstates</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>subplanstates</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name></expr>;</expr_stmt>
		<comment type="block">/*
		 * make sure all params are initialized for runtime exclusion
		 */</comment>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplanstates</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_exclude_constraints_using_clauses</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
									  <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>can_exclude</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>exclusion_ctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>restrictinfos</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>restrictinfos</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>restrictinfos</name> <operator>=</operator> <call><name>constify_restrictinfo_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>ps</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>restrictinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>can_exclude</name> <operator>=</operator> <call><name>can_exclude_chunk</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>, <argument><expr><name>restrictinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>exclusion_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>can_exclude</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build bitmap of valid subplans for runtime exclusion
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_runtime_exclusion</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_clauses</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc_constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PlannerGlobal</name></type> <name>glob</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>boundParams</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name></type> <name>root</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>glob</name> <operator>=</operator> <operator>&amp;</operator><name>glob</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>runtime_initialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>runtime_number_loops</name></name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* try to exclude all the chunks using the parents clauses.
		 * here, all constraints are true but exclusion can still
		 * happen because of things like ANY(empty set), and NULL
		 * inference
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>can_exclude_constraints_using_clauses</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
												  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>initial_parent_clauses</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>root</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>runtime_number_exclusions_parent</name></name><operator>++</operator></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>valid_subplans</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>valid_subplans</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_ri_clauses</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lc_clauses</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_ri_clauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc_constraints</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * mark subplans as active/inactive in valid_subplans
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>subplanstates</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Scan</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><call><name>ts_chunk_append_get_scan_plan</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>scan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>scan</name><operator>-&gt;</operator><name>scanrelid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>valid_subplans</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>valid_subplans</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>can_exclude</name> <init>= <expr><call><name>can_exclude_constraints_using_clauses</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
																	 <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_constraints</name></expr></argument>)</argument_list></call></expr></argument>,
																	 <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_clauses</name></expr></argument>)</argument_list></call></expr></argument>,
																	 <argument><expr><operator>&amp;</operator><name>root</name></expr></argument>,
																	 <argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>can_exclude</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>valid_subplans</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>valid_subplans</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>runtime_number_exclusions_children</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>lc_clauses</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_ri_clauses</name></name></expr></argument>, <argument><expr><name>lc_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lc_constraints</name> <operator>=</operator> <call><name>lnext_compat</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_constraints</name></name></expr></argument>, <argument><expr><name>lc_constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the next scan tuple.
 *
 * If any tuples remain, it should fill ps_ResultTupleSlot with the next
 * tuple in the current scan direction, and then return the tuple slot.
 * If not, NULL or an empty slot should be returned.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>chunk_append_exec</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ChunkAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProjectionInfo</name> <modifier>*</modifier></type><name>projinfo</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>subslot</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>==</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>state</name><operator>-&gt;</operator><name>choose_next_subplan</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>subnode</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>==</operator> <name>NO_MATCHING_SUBPLANS</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subnode</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>subplanstates</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * get a tuple from the subplan
		 */</comment>
		<expr_stmt><expr><name>subslot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>subnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>subslot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the subplan gave us something check if we need
			 * to do projection otherwise return as is.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>projinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>subslot</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>subslot</name></expr>;</expr_stmt>

			<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name>projinfo</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name><name>state</name><operator>-&gt;</operator><name>choose_next_subplan</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* loop back and try to get a tuple from the new subplan */</comment>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_next_subplan</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>last_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>last_plan</name> <operator>==</operator> <name>NO_MATCHING_SUBPLANS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NO_MATCHING_SUBPLANS</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>runtime_initialized</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>initialize_runtime_exclusion</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * bms_next_member will return -2 (NO_MATCHING_SUBPLANS) if there are
		 * no more members
		 */</comment>
		<return>return <expr><call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>valid_subplans</name></name></expr></argument>, <argument><expr><name>last_plan</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>next_plan</name> <init>= <expr><name>last_plan</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>next_plan</name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NO_MATCHING_SUBPLANS</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><name>next_plan</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>choose_next_subplan_non_parallel</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <call><name>get_next_subplan</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>choose_next_subplan_for_worker</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelChunkAppendState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>pstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>next_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>start</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* mark just completed subplan as finished */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>finished</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>next_plan</name></name> <operator>==</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>next_plan</name> <operator>=</operator> <call><name>get_next_subplan</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>INVALID_SUBPLAN_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>next_plan</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>next_plan</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>next_plan</name> <operator>==</operator> <name>NO_MATCHING_SUBPLANS</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* all subplans are finished */</comment>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>next_plan</name></name> <operator>=</operator> <name>NO_MATCHING_SUBPLANS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>NO_MATCHING_SUBPLANS</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>start</name> <operator>=</operator> <name>next_plan</name></expr>;</expr_stmt>

	<comment type="block">/* skip finished subplans */</comment>
	<while>while <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>finished</name><index>[<expr><name>next_plan</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>next_plan</name> <operator>=</operator> <call><name>get_next_subplan</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>next_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* wrap around if we reach end of subplan list */</comment>
		<if_stmt><if>if <condition>(<expr><name>next_plan</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>next_plan</name> <operator>=</operator> <call><name>get_next_subplan</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>INVALID_SUBPLAN_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>next_plan</name> <operator>==</operator> <name>start</name> <operator>||</operator> <name>next_plan</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * back at start of search so all subplans are finished
			 *
			 * next_plan should not be &lt; 0 because this means there
			 * are no valid subplans and then the function would
			 * have returned at the check before the while loop but
			 * static analysis marked this so might as well include
			 * that in the check
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>next_plan</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>next_plan</name></name> <operator>=</operator> <name>NO_MATCHING_SUBPLANS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>NO_MATCHING_SUBPLANS</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>next_plan</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>next_plan</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>next_plan</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * if this is not a partial plan we mark it as finished
	 * immediately so it does not get assigned another worker
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>next_plan</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>filtered_first_partial_plan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>finished</name><index>[<expr><name>next_plan</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* advance next_plan for next worker */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>next_plan</name></name> <operator>=</operator> <call><name>get_next_subplan</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * if we reach the end of the list of subplans we set next_plan
	 * to INVALID_SUBPLAN_INDEX to allow rechecking unfinished subplans
	 * on next call
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>next_plan</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>next_plan</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up any private data associated with the CustomScanState.
 *
 * This method is required, but it does not need to do anything if there
 * is no associated data or it will be cleaned up automatically.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_append_end</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ChunkAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplanstates</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Rewind the current scan to the beginning and prepare to rescan the relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_append_rescan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ChunkAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UpdateChangedParamSet</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplanstates</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplanstates</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * detect changed params and reset runtime exclusion state
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
		<call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>valid_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>valid_subplans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>runtime_initialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate the amount of dynamic shared memory that will be required
 * for parallel operation.
 * This may be higher than the amount that will actually be used,
 * but it must not be lower. The return value is in bytes.
 * This callback is optional, and need only be supplied if this
 * custom scan provider supports parallel execution.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>chunk_append_estimate_dsm</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ChunkAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>add_size</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParallelChunkAppendState</name></expr></argument>, <argument><expr><name>finished</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the dynamic shared memory that will be required for
 * parallel operation.
 * coordinate points to a shared memory area of size equal to the return
 * value of EstimateDSMCustomScan.
 * This callback is optional, and need only be supplied if this custom scan
 * provider supports parallel execution.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_append_initialize_dsm</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>coordinate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ChunkAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelChunkAppendState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParallelChunkAppendState</name> <operator>*</operator><operator>)</operator> <name>coordinate</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pscan_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <call><name>chunk_append_get_lock_pointer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>next_plan</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Leader should use the same subplan selection as normal worker threads. If the user wishes to
	 * disallow running plans on the leader they should do so via the parallel_leader_participation
	 * GUC.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>choose_next_subplan</name></name> <operator>=</operator> <name>choose_next_subplan_for_worker</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pcxt</name></name> <operator>=</operator> <name>pcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Re-initialize the dynamic shared memory required for parallel operation
 * when the custom-scan plan node is about to be re-scanned.
 * This callback is optional, and need only be supplied if this custom scan
 * provider supports parallel execution.
 * Recommended practice is that this callback reset only shared state,
 * while the ReScanCustomScan callback resets only local state.
 * Currently, this callback will be called before ReScanCustomScan,
 * but it's best not to rely on that ordering.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_append_reinitialize_dsm</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>coordinate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ChunkAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelChunkAppendState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParallelChunkAppendState</name> <operator>*</operator><operator>)</operator> <name>coordinate</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>next_plan</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>finished</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>num_subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a parallel worker's local state based on the shared state
 * set up by the leader during InitializeDSMCustomScan.
 *
 * This callback is optional, and need only be supplied if this custom scan
 * provider supports parallel execution.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_append_initialize_worker</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>coordinate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ChunkAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelChunkAppendState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParallelChunkAppendState</name> <operator>*</operator><operator>)</operator> <name>coordinate</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <call><name>chunk_append_get_lock_pointer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>choose_next_subplan</name></name> <operator>=</operator> <name>choose_next_subplan_for_worker</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>INVALID_SUBPLAN_INDEX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get a pointer to the LWLock used for coordinating
 * parallel workers
 */</comment>
<function><type><specifier>static</specifier> <name>LWLock</name> <modifier>*</modifier></type>
<name>chunk_append_get_lock_pointer</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier><modifier>*</modifier></type><name>lock</name> <init>= <expr><operator>(</operator><name>LWLock</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>find_rendezvous_variable</name><argument_list>(<argument><expr><name>RENDEZVOUS_CHUNK_APPEND_LWLOCK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>lock</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"LWLock for coordinating parallel workers not initialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>*</operator><name>lock</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert restriction clauses to constants expressions (i.e., if there are
 * mutable functions, they need to be evaluated to constants).  For instance,
 * something like:
 *
 * ...WHERE time &gt; now - interval '1 hour'
 *
 * becomes
 *
 * ...WHERE time &gt; '2017-06-02 11:26:43.935712+02'
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>constify_restrictinfos</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>restrictinfos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>restrictinfos</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>constify_restrictinfo_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>restrictinfos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>constify_param_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>restrictinfos</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>constify_param_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Don't descend into subplans to constify their parameters, because they may not be valid yet
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><operator>(</operator><name>EState</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name> <init>= <expr><call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParamExecData</name></type> <name>prm</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>prm</name><operator>.</operator><name>execPlan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ExecSetParamPlan</name><argument_list>(<argument><expr><name><name>prm</name><operator>.</operator><name>execPlan</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="line">// reload prm as it may have been changed by ExecSetParamPlan call above.</comment>
				<expr_stmt><expr><name>prm</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>prm</name><operator>.</operator><name>execPlan</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>,
										  <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtypmod</name></name></expr></argument>,
										  <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name></expr></argument>,
										  <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
										  <argument><expr><name><name>prm</name><operator>.</operator><name>value</name></name></expr></argument>,
										  <argument><expr><name><name>prm</name><operator>.</operator><name>isnull</name></name></expr></argument>,
										  <argument><expr><name><name>tce</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>constify_param_mutator</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * stripped down version of postgres get_relation_constraints
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ca_get_relation_constraints</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationObjectId</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_notnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We assume the relation has already been safely locked.
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relationObjectId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>constr</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>constr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>num_check</name> <init>= <expr><name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_check</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>cexpr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If this constraint hasn't been fully validated yet, we must
			 * ignore it here.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccvalid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Run each expression through const-simplification and
			 * canonicalization.  This is not just an optimization, but is
			 * necessary, because we will be comparing it to
			 * similarly-processed qual clauses, and may fail to detect valid
			 * matches without this.  This must match the processing done to
			 * qual clauses in preprocess_expression()!  (We can skip the
			 * stuff involving subqueries, however, since we don't allow any
			 * in check constraints.)
			 */</comment>
			<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Fix Vars to have the desired varno */</comment>
			<if_stmt><if>if <condition>(<expr><name>varno</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><name>cexpr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Finally, convert to implicit-AND format (that is, a List) and
			 * append the resulting item(s) to our output list.
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Add NOT NULL constraints in expression form, if requested */</comment>
		<if_stmt><if>if <condition>(<expr><name>include_notnull</name> <operator>&amp;&amp;</operator> <name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>natts</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>NullTest</name> <modifier>*</modifier></type><name>ntest</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
						<call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * argisrow=false is correct even for a composite column,
					 * because attnotnull does not represent a SQL-spec IS NOT
					 * NULL test in such a case, just IS DISTINCT FROM NULL.
					 */</comment>
					<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ntest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exclude child relations (chunks) at execution time based on constraints.
 *
 * constraints is the list of constraint expressions of the relation
 * baserestrictinfo is the list of RestrictInfos
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_exclude_chunk</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>baserestrictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Detect constant-FALSE-or-NULL restriction clauses. If we have such a
	 * clause, no rows from the chunk are going to match. Unlike the postgres
	 * analog of this code in relation_excluded_by_constraints, we can't expect
	 * a single const false restrictinfo in this case, because we don't try to
	 * fold the restrictinfos after evaluating the mutable functions.
	 * We have to check this separately from the subsequent predicate_refuted_by.
	 * That function can also work with the normal CHECK constraints, and they
	 * don't fail if the constraint evaluates to null given the restriction info.
	 * That's why it has to prove that the CHECK constraint evaluates to false,
	 * and this doesn't follow from having a const null restrictinfo.
	 */</comment>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>baserestrictinfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name> <operator>||</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * The constraints are effectively ANDed together, so we can just try to
	 * refute the entire collection at once.  This may allow us to make proofs
	 * that would fail if we took them individually.
	 *
	 * Note: we use rel-&gt;baserestrictinfo, not safe_restrictions as might seem
	 * an obvious optimization.  Some of the clauses might be OR clauses that
	 * have volatile and nonvolatile subclauses, and it's OK to make
	 * deductions with the nonvolatile parts.
	 *
	 * We need strong refutation because we have to prove that the constraints
	 * would yield false, not just NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>predicate_refuted_by</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>, <argument><expr><name>baserestrictinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the constraints for a relation and adjust range table indexes
 * if necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_constraints</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>initial_rt_indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_clauses</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc_plan</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lc_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>initial_rt_indexes</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>initial_subplans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>initial_ri_clauses</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>initial_subplans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>initial_rt_indexes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>forthree</name> <argument_list>(<argument>lc_plan</argument>,
			  <argument>state-&gt;initial_subplans</argument>,
			  <argument>lc_clauses</argument>,
			  <argument>state-&gt;initial_ri_clauses</argument>,
			  <argument>lc_relid</argument>,
			  <argument>initial_rt_indexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Scan</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><call><name>ts_chunk_append_get_scan_plan</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>initial_index</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc_relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relation_constraints</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>scan</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>scanrelid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Index</name></type> <name>rt_index</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>scanrelid</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rt_index</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>relation_constraints</name> <operator>=</operator> <call><name>ca_get_relation_constraints</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Adjust the RangeTableEntry indexes in the restrictinfo
			 * clauses because during planning subquery indexes may be
			 * different from the final index after flattening.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>rt_index</name> <operator>!=</operator> <name>initial_index</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_clauses</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>initial_index</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>scanrelid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>constraints</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>, <argument><expr><name>relation_constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>initial_constraints</name></name> <operator>=</operator> <name>constraints</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>filtered_constraints</name></name> <operator>=</operator> <name>constraints</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Output additional information for EXPLAIN of a custom-scan plan node.
 * This callback is optional. Common data stored in the ScanState,
 * such as the target list and scan relation, will be shown even without
 * this callback, but the callback allows the display of additional,
 * private state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chunk_append_explain</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ChunkAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>sort_options</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>show_sort_group_keys</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyBool</name><argument_list>(<argument><expr><literal type="string">"Startup Exclusion"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>startup_exclusion</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>!=</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyBool</name><argument_list>(<argument><expr><literal type="string">"Runtime Exclusion"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name><operator>)</operator></expr></argument>,
							<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>startup_exclusion</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Chunks excluded during startup"</literal></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>initial_subplans</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_parent</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>runtime_number_loops</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>avg_excluded</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>runtime_number_exclusions_parent</name></name> <operator>/</operator> <name><name>state</name><operator>-&gt;</operator><name>runtime_number_loops</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Hypertables excluded during runtime"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>avg_excluded</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>runtime_exclusion_children</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>runtime_number_loops</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>avg_excluded</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>runtime_number_exclusions_children</name></name> <operator>/</operator> <name><name>state</name><operator>-&gt;</operator><name>runtime_number_loops</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Chunks excluded during runtime"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>avg_excluded</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * adjusted from postgresql explain.c
 * since we have to keep the state in custom_private our sort state
 * is in lists instead of arrays
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_sort_group_keys</name><parameter_list>(<parameter><decl><type><name>ChunkAppendState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sortkeybuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>useprefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>keyno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nkeys</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sort_options</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_indexes</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sort_options</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_ops</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sort_options</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_collations</name> <init>= <expr><call><name>lthird</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sort_options</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_nulls</name> <init>= <expr><call><name>lfourth</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sort_options</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nkeys</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sortkeybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up deparsing context */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>set_deparse_context_plan</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>deparse_cxt</name></name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>set_deparse_context_planstate</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>deparse_cxt</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>useprefix</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>verbose</name></name><operator>)</operator></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* find key expression in tlist */</comment>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>keyresno</name> <init>= <expr><call><name>list_nth_oid</name><argument_list>(<argument><expr><name>sort_indexes</name></expr></argument>, <argument><expr><name>keyno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target</name> <init>=
			<expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>custom_scan_tlist</name></expr></argument>, <argument><expr><name>keyresno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>exprstr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>target</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no tlist entry for key %d"</literal></expr></argument>, <argument><expr><name>keyresno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Deparse the expression, showing any top-level cast */</comment>
		<expr_stmt><expr><name>exprstr</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sortkeybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sortkeybuf</name></expr></argument>, <argument><expr><name>exprstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Append sort order information, if relevant */</comment>
		<if_stmt><if>if <condition>(<expr><name>sort_ops</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>show_sortorder_options</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sortkeybuf</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
								   <argument><expr><call><name>list_nth_oid</name><argument_list>(<argument><expr><name>sort_ops</name></expr></argument>, <argument><expr><name>keyno</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>list_nth_oid</name><argument_list>(<argument><expr><name>sort_collations</name></expr></argument>, <argument><expr><name>keyno</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>list_nth_oid</name><argument_list>(<argument><expr><name>sort_nulls</name></expr></argument>, <argument><expr><name>keyno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Emit one property-list item per sort key */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>sortkeybuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ExplainPropertyList</name><argument_list>(<argument><expr><literal type="string">"Order"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* copied verbatim from postgresql explain.c */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_sortorder_options</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>sortexpr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sortOperator</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>nullsFirst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sortcoltype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>sortexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>reverse</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>sortcoltype</name></expr></argument>, <argument><expr><name>TYPECACHE_LT_OPR</name> <operator>|</operator> <name>TYPECACHE_GT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Print COLLATE if it's not default.  There are some cases where this is
	 * redundant, eg if expression is a column whose declared collation is
	 * that collation, but it's hard to distinguish that here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>collation</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>collname</name> <init>= <expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>collname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Print direction if not ASC, or USING if non-default sort operator */</comment>
	<if_stmt><if>if <condition>(<expr><name>sortOperator</name> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>gt_opr</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reverse</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>sortOperator</name> <operator>!=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>lt_opr</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opname</name> <init>= <expr><call><name>get_opname</name><argument_list>(<argument><expr><name>sortOperator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>opname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>sortOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" USING %s"</literal></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Determine whether operator would be considered ASC or DESC */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_equality_op_for_ordering_op</name><argument_list>(<argument><expr><name>sortOperator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add NULLS FIRST/LAST only if it wouldn't be default */</comment>
	<if_stmt><if>if <condition>(<expr><name>nullsFirst</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>reverse</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>nullsFirst</name> <operator>&amp;&amp;</operator> <name>reverse</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
