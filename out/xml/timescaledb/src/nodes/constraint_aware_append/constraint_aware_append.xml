<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/nodes/constraint_aware_append/constraint_aware_append.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_cast.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_class.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_namespace.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_operator.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/explain.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/executor.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/extensible.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/parsenodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/plannodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/appendinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/cost.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/plancat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rewrite/rewriteManip.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"constraint_aware_append.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_append/transform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Exclude child relations (chunks) at execution time based on constraints.
 *
 * This functions tries to reuse as much functionality as possible from standard
 * constraint exclusion in PostgreSQL that normally happens at planning
 * time. Therefore, we need to fake a number of planning-related data
 * structures.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>excluded_by_constraint</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rt_index</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name></type> <name>rel</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_RelOptInfo</name></expr>,
		<expr><operator>.</operator><name>relid</name> <operator>=</operator> <name>rt_index</name></expr>,
		<expr><operator>.</operator><name>reloptkind</name> <operator>=</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr>,
		<expr><operator>.</operator><name>baserestrictinfo</name> <operator>=</operator> <name>restrictinfos</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>relation_excluded_by_constraints</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>get_plans_for_exclusion</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Optimization: If we want to be able to prune */</comment>
	<comment type="block">/* when the node is a T_Result or T_Sort, then we need to peek */</comment>
	<comment type="block">/* into the subplans of this Result node. */</comment>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Result</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</return>

		<default>default:</default>
			<return>return <expr><name>plan</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_exclude_chunk</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rt_index</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rt_index</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator>
		   <call><name>excluded_by_constraint</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>, <argument><expr><name>restrictinfos</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert restriction clauses to constants expressions (i.e., if there are
 * mutable functions, they need to be evaluated to constants).  For instance,
 * something like:
 *
 * ...WHERE time &gt; now - interval '1 hour'
 *
 * becomes
 *
 * ...WHERE time &gt; '2017-06-02 11:26:43.935712+02'
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>constify_restrictinfos</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>restrictinfos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>restrictinfos</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the scan state and prune any subplans from the Append node below
 * us in the plan tree. Pruning happens by evaluating the subplan's table
 * constraints against a folded version of the restriction clauses in the query.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ca_append_begin</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConstraintAwareAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ConstraintAwareAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_ri_clauses</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_relids</name> <init>= <expr><call><name>lthird</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>appendplans</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>old_appendplans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_clauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_relid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * create skeleton plannerinfo to reuse some PostgreSQL planner functions
	 */</comment>
	<decl_stmt><decl><type><name>Query</name></type> <name>parse</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>resultRelation</name> <operator>=</operator> <name>InvalidOid</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerGlobal</name></type> <name>glob</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>boundParams</name> <operator>=</operator> <name>NULL</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name></type> <name>root</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>glob</name> <operator>=</operator> <operator>&amp;</operator><name>glob</name></expr>,
		<expr><operator>.</operator><name>parse</name> <operator>=</operator> <operator>&amp;</operator><name>parse</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* CustomScan hard-codes the scan and result tuple slot to a fixed
	 * TTSOpsVirtual ops (meaning it expects the slot ops of the child tuple to
	 * also have this type). Oddly, when reading slots from subscan nodes
	 * (children), there is no knowing what tuple slot ops the child slot will
	 * have (e.g., for ChunkAppend it is common that the child is a
	 * seqscan/indexscan that produces a TTSOpsBufferHeapTuple
	 * slot). Unfortunately, any mismatch between slot types when projecting is
	 * asserted by PostgreSQL. To avoid this issue, we mark the scanops as
	 * non-fixed and reinitialize the projection state with this new setting.
	 *
	 * Alternatively, we could copy the child tuple into the scan slot to get
	 * the expected ops before projection, but this would require materializing
	 * and copying the tuple unnecessarily.
	 */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>scanopsfixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Since we sometimes return the scan slot directly from the subnode, the
	 * result slot is not fixed either. */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>resultopsfixed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignScanProjectionInfoWithVarno</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><name>INDEX_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Append</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Append</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>old_appendplans</name> <operator>=</operator> <name><name>append</name><operator>-&gt;</operator><name>appendplans</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>append</name><operator>-&gt;</operator><name>appendplans</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>appendplans</name> <operator>=</operator> <operator>&amp;</operator><name><name>append</name><operator>-&gt;</operator><name>appendplans</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>old_appendplans</name> <operator>=</operator> <name><name>append</name><operator>-&gt;</operator><name>mergeplans</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>append</name><operator>-&gt;</operator><name>mergeplans</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>appendplans</name> <operator>=</operator> <operator>&amp;</operator><name><name>append</name><operator>-&gt;</operator><name>mergeplans</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>T_Result</name></expr>:</case>

			<comment type="block">/*
			 * Append plans are turned into a Result node if empty. This can
			 * happen if children are pruned first by constraint exclusion
			 * while we also remove the main table from the appendplans list,
			 * leaving an empty list. In that case, there is nothing to do.
			 */</comment>
			<return>return;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"invalid child of constraint-aware append: %s"</literal></expr></argument>,
				 <argument><expr><call><name>ts_get_node_name</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * clauses should always have the same length as appendplans because
	 * thats the base for building the lists
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>old_appendplans</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>chunk_ri_clauses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>chunk_relids</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>chunk_ri_clauses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>forthree</name> <argument_list>(<argument>lc_plan</argument>, <argument>old_appendplans</argument>, <argument>lc_clauses</argument>, <argument>chunk_ri_clauses</argument>, <argument>lc_relid</argument>, <argument>chunk_relids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>get_plans_for_exclusion</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_SeqScan</name></expr>:</case>
			<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
			<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<case>case <expr><name>T_TidScan</name></expr>:</case>
			<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<case>case <expr><name>T_CteScan</name></expr>:</case>
			<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If this is a base rel (chunk), check if it can be
				 * excluded from the scan. Otherwise, fall through.
				 */</comment>

				<decl_stmt><decl><type><name>Index</name></type> <name>scanrelid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ri_clauses</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scanrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>ri_clauses</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * The index of the RangeTblEntry might have changed between planning
					 * because of flattening, so we need to adjust the expressions
					 * for the RestrictInfos if they are not equal.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc_relid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>scanrelid</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc_relid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>scanrelid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>restrictinfos</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>restrictinfos</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><name>restrictinfos</name> <operator>=</operator> <call><name>constify_restrictinfos</name><argument_list>(<argument><expr><operator>&amp;</operator><name>root</name></expr></argument>, <argument><expr><name>restrictinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>can_exclude_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>root</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>scanrelid</name></expr></argument>, <argument><expr><name>restrictinfos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><operator>*</operator><name>appendplans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>appendplans</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><literal type="string">"invalid child of constraint-aware append: %s"</literal></expr></argument>,
					 <argument><expr><call><name>ts_get_node_name</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>num_append_subplans</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>appendplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>num_chunks_excluded</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>old_appendplans</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>num_append_subplans</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>num_append_subplans</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>ExecInitNode</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ca_append_exec</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConstraintAwareAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ConstraintAwareAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>subslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check if all append subplans were pruned. In that case there is nothing
	 * to do.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>num_append_subplans</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>subslot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>subslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>subslot</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>subslot</name></expr>;</expr_stmt>

		<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ca_append_end</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ca_append_rescan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>custom_ps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ca_append_explain</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConstraintAwareAppendState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ConstraintAwareAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Hypertable"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Chunks excluded during startup"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>num_chunks_excluded</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomExecMethods</name></type> <name>constraint_aware_append_state_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>BeginCustomScan</name> <operator>=</operator> <name>ca_append_begin</name></expr>,
	<expr><operator>.</operator><name>ExecCustomScan</name> <operator>=</operator> <name>ca_append_exec</name></expr>,
	<expr><operator>.</operator><name>EndCustomScan</name> <operator>=</operator> <name>ca_append_end</name></expr>,
	<expr><operator>.</operator><name>ReScanCustomScan</name> <operator>=</operator> <name>ca_append_rescan</name></expr>,
	<expr><operator>.</operator><name>ExplainCustomScan</name> <operator>=</operator> <name>ca_append_explain</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>constraint_aware_append_state_create</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConstraintAwareAppendState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Append</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>ConstraintAwareAppendState</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConstraintAwareAppendState</name></expr></argument>)</argument_list></sizeof></expr></argument>,
												   <argument><expr><name>T_CustomScanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>csstate</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>constraint_aware_append_state_methods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>subplan</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>append</name><operator>-&gt;</operator><name>plan</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomScanMethods</name></type> <name>constraint_aware_append_plan_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"ConstraintAwareAppend"</literal></expr>,
	<expr><operator>.</operator><name>CreateCustomScanState</name> <operator>=</operator> <name>constraint_aware_append_state_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>constraint_aware_append_plan_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_plans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_ri_clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_relids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_child</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Postgres will inject Result nodes above mergeappend when target lists don't match
	 * because the nodes themselves do not perform projection. The ConstraintAwareAppend
	 * node can do this projection itself, however, so just throw away the result node
	 * Removing the Result node is only safe if there is no one-time filter
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>castNode</name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>resconstantqual</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Result</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>righttree</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected right tree below result node in constraint aware append"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>custom_plans</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			 <comment type="block">/* Not a real relation we are scanning */</comment>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt> <comment type="block">/* Target list we expect as output */</comment>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_plans</name></name> <operator>=</operator> <name>custom_plans</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * create per chunk RestrictInfo
	 *
	 * We also need to walk the expression trees of the restriction clauses and
	 * update any Vars that reference the main table to instead reference the child
	 * table (chunk) we want to exclude.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>MergeAppend</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>mergeplans</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Append</name></expr>:</case>
			<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Append</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>appendplans</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"invalid child of constraint-aware append: %s"</literal></expr></argument>,
				 <argument><expr><call><name>ts_get_node_name</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * we only iterate over the child chunks of this node
	 * so the list of metadata exactly matches the list of
	 * child nodes in the executor
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc_child</argument>, <argument>children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>get_plans_for_exclusion</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_child</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_SeqScan</name></expr>:</case>
			<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
			<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<case>case <expr><name>T_TidScan</name></expr>:</case>
			<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<case>case <expr><name>T_CteScan</name></expr>:</case>
			<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunk_clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Index</name></type> <name>scanrelid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><call><name>ts_get_appendrelinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scanrelid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>ts_transform_cross_datatype_comparison</name><argument_list>(
						<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>chunk_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>chunk_clauses</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><name>chunk_ri_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>chunk_ri_clauses</name></expr></argument>, <argument><expr><name>chunk_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>chunk_relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>chunk_relids</name></expr></argument>, <argument><expr><name>scanrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><literal type="string">"invalid child of constraint-aware append: %s"</literal></expr></argument>,
					 <argument><expr><call><name>ts_get_node_name</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>chunk_ri_clauses</name></expr></argument>, <argument><expr><name>chunk_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt> <comment type="block">/* Target list of tuples
													 * we expect as input */</comment>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>constraint_aware_append_plan_methods</name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CustomPathMethods</name></type> <name>constraint_aware_append_path_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"ConstraintAwareAppend"</literal></expr>,
	<expr><operator>.</operator><name>PlanCustomPath</name> <operator>=</operator> <name>constraint_aware_append_plan_create</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>Path</name> <modifier>*</modifier></type>
<name>ts_constraint_aware_append_path_create</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConstraintAwareAppendPath</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>ConstraintAwareAppendPath</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConstraintAwareAppendPath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CustomScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set flags. We can set CUSTOMPATH_SUPPORT_BACKWARD_SCAN and
	 * CUSTOMPATH_SUPPORT_MARK_RESTORE. The only interesting flag is the first
	 * one (backward scan), but since we are not scanning a real relation we
	 * need not indicate that we support backward scans. Lower-level index
	 * scanning nodes will scan backward if necessary, so once tuples get to
	 * this node they will be in a given order already.
	 */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>custom_paths</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>constraint_aware_append_path_methods</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure our subpath is either an Append or MergeAppend node
	 */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_AppendPath</name></expr>:</case>
		<case>case <expr><name>T_MergeAppendPath</name></expr>:</case>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"invalid child of constraint-aware append: %s"</literal></expr></argument>,
				 <argument><expr><call><name>ts_get_node_name</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>cpath</name><operator>.</operator><name>path</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_constraint_aware_append_possible</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_children</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ts_guc_enable_optimizations</name> <operator>||</operator> <operator>!</operator><name>ts_guc_enable_constraint_aware_append</name> <operator>||</operator>
		<name>constraint_exclusion</name> <operator>==</operator> <name>CONSTRAINT_EXCLUSION_OFF</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_AppendPath</name></expr>:</case>
			<expr_stmt><expr><name>num_children</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>AppendPath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeAppendPath</name></expr>:</case>
			<expr_stmt><expr><name>num_children</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>MergeAppendPath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/* Never use constraint-aware append with only one child, since PG12 will
	 * later prune the (Merge)Append node from such plans, leaving us with an
	 * unexpected child node. */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_children</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there are clauses that have mutable functions, this path is ripe for
	 * execution-time optimization.
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ts_is_constraint_aware_append_path</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>CustomPath</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>castNode</name><argument_list>(<argument><expr><name>CustomPath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>methods</name> <operator>==</operator> <operator>&amp;</operator><name>constraint_aware_append_path_methods</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_constraint_aware_append_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>TryRegisterCustomScanMethods</name><argument_list>(<argument><expr><operator>&amp;</operator><name>constraint_aware_append_plan_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
