<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/nodes/chunk_insert_state.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/attnum.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/tuptable.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;foreign/fdwapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/execnodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/plannodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rewrite/rewriteManip.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/memutils.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rls.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_insert_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/chunk_data_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ts_catalog/continuous_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_dispatch_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"indexing.h"</cpp:file></cpp:include>

<comment type="block">/* Just like ExecPrepareExpr except that it doesn't switch to the query memory context */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ExprState</name> <modifier>*</modifier></type>
<name>prepare_constr_expr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create the constraint exprs inside the current memory context. If this
 * is not done here, then ExecRelCheck will do it for you but put it into
 * the query memory context, which will cause a memory leak.
 *
 * See the comment in `ts_chunk_insert_state_destroy` for more information
 * on the implications of this.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>create_chunk_rri_constraint_expr</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ncheck</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConstrCheck</name> <modifier>*</modifier></type><name>check</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>rri</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ncheck</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>check</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>check</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name></name> <operator>=</operator> <operator>(</operator><name>ExprState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncheck</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExprState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncheck</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>checkconstr</name> <init>= <expr><call><name>stringToNode</name><argument_list>(<argument><expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>prepare_constr_expr</name><argument_list>(<argument><expr><name>checkconstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new ResultRelInfo for a chunk.
 *
 * The ResultRelInfo holds the executor state (e.g., open relation, indexes, and
 * options) for the result relation where tuples will be stored.
 *
 * The Hypertable ResultRelInfo is used as a template for the chunk's new ResultRelInfo.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ResultRelInfo</name> <modifier>*</modifier></type>
<name>create_chunk_result_relation_info</name><parameter_list>(<parameter><decl><type><name>ChunkDispatch</name> <modifier>*</modifier></type><name>dispatch</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri_orig</name> <init>= <expr><name><name>dispatch</name><operator>-&gt;</operator><name>hypertable_result_rel_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>hyper_rti</name> <init>= <expr><name><name>rri_orig</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>rri</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>rri</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>hyper_rti</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy options from the main table's (hypertable's) result relation info */</comment>
	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>=</operator> <name><name>rri_orig</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_WithCheckOptionExprs</name></name> <operator>=</operator> <name><name>rri_orig</name><operator>-&gt;</operator><name>ri_WithCheckOptionExprs</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_junkFilter</name></name> <operator>=</operator> <name><name>rri_orig</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_projectReturning</name></name> <operator>=</operator> <name><name>rri_orig</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_FdwState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>=</operator> <name><name>rri_orig</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>create_chunk_rri_constraint_expr</name><argument_list>(<argument><expr><name>rri</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rri</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ResultRelInfo</name> <modifier>*</modifier></type>
<name>create_compress_chunk_result_relation_info</name><parameter_list>(<parameter><decl><type><name>ChunkDispatch</name> <modifier>*</modifier></type><name>dispatch</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>compress_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri_orig</name> <init>= <expr><name><name>dispatch</name><operator>-&gt;</operator><name>hypertable_result_rel_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>hyper_rti</name> <init>= <expr><name><name>rri_orig</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>rri</name></expr></argument>, <argument><expr><name>compress_rel</name></expr></argument>, <argument><expr><name>hyper_rti</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* RLS policies are not supported if compression is enabled */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rri_orig</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>rri_orig</name><operator>-&gt;</operator><name>ri_WithCheckOptionExprs</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rri_orig</name><operator>-&gt;</operator><name>ri_projectReturning</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_junkFilter</name></name> <operator>=</operator> <name><name>rri_orig</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* compressed rel chunk is on data node. Does not need any FDW access on AN */</comment>
	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_FdwState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rri</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* constraints are executed on the orig base chunk. So we do
	 * not call create_chunk_rri_constraint_expr here
	 */</comment>
	<return>return <expr><name>rri</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ProjectionInfo</name> <modifier>*</modifier></type>
<name>get_adjusted_projection_info_returning</name><parameter_list>(<parameter><decl><type><name>ProjectionInfo</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returning_clauses</name></decl></parameter>,
									   <parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rowtype</name></decl></parameter>,
									   <parameter><decl><type><name>TupleDesc</name></type> <name>chunk_desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found_whole_row</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>returning_clauses</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* map hypertable attnos -&gt; chunk attnos */</comment>
	<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>returning_clauses</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>,
									 <argument><expr><call><name>map_variable_attnos_compat</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>returning_clauses</name></expr></argument>,
																<argument><expr><name>varno</name></expr></argument>,
																<argument><expr><literal type="number">0</literal></expr></argument>,
																<argument><expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>,
																<argument><expr><name><name>map</name><operator>-&gt;</operator><name>outdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
																<argument><expr><name>rowtype</name></expr></argument>,
																<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name>returning_clauses</name></expr></argument>,
								   <argument><expr><name><name>orig</name><operator>-&gt;</operator><name>pi_exprContext</name></name></expr></argument>,
								   <argument><expr><name><name>orig</name><operator>-&gt;</operator><name>pi_state</name><operator>.</operator><name>resultslot</name></name></expr></argument>,
								   <argument><expr><name><name>orig</name><operator>-&gt;</operator><name>pi_state</name><operator>.</operator><name>parent</name></name></expr></argument>,
								   <argument><expr><name>chunk_desc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>translate_clause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>inclause</name></decl></parameter>, <parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>chunk_map</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>hyper_rel</name></decl></parameter>,
				 <parameter><decl><type><name>Relation</name></type> <name>chunk_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>inclause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found_whole_row</name></decl>;</decl_stmt>

	<comment type="block">/* nothing to do here if the chunk_map is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>chunk_map</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* map hypertable attnos -&gt; chunk attnos for the "excluded" table */</comment>
	<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>,
					  <argument><expr><call><name>map_variable_attnos_compat</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>,
												 <argument><expr><name>INNER_VAR</name></expr></argument>,
												 <argument><expr><literal type="number">0</literal></expr></argument>,
												 <argument><expr><name><name>chunk_map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>,
												 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>hyper_rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
												 <argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* map hypertable attnos -&gt; chunk attnos for the hypertable */</comment>
	<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>,
					  <argument><expr><call><name>map_variable_attnos_compat</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>,
												 <argument><expr><name>varno</name></expr></argument>,
												 <argument><expr><literal type="number">0</literal></expr></argument>,
												 <argument><expr><name><name>chunk_map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>,
												 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>hyper_rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
												 <argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>clause</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
<comment type="block">/*
 * adjust_hypertable_tlist - from Postgres source code `adjust_partition_tlist`
 *		Adjust the targetlist entries for a given chunk to account for
 *		attribute differences between hypertable and the chunk
 *
 * The expressions have already been fixed, but here we fix the list to make
 * target resnos match the chunk's attribute numbers.  This results in a
 * copy of the original target list in which the entries appear in resno
 * order, including both the existing entries (that may have their resno
 * changed in-place) and the newly added entries for columns that don't exist
 * in the parent.
 *
 * Scribbles on the input tlist's entries resno so be aware.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>adjust_hypertable_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>chunk_tupdesc</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>outdesc</name></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attrMap</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name><operator>-&gt;</operator><name>attnums</name></name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attrMap</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>chunk_attrno</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>chunk_attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>chunk_attrno</name> <operator>&lt;=</operator> <name><name>chunk_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>chunk_attrno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>chunk_tupdesc</name></expr></argument>, <argument><expr><name>chunk_attrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attrMap</name><index>[<expr><name>chunk_attrno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Use the corresponding entry from the parent's tlist, adjusting
			 * the resno the match the partition's attno.
			 */</comment>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>attrMap</name><index>[<expr><name>chunk_attrno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid translation of ON CONFLICT update statements"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>chunk_attrno</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * For a dropped attribute in the partition, generate a dummy
			 * entry with resno matching the partition's attno.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
							 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>, <comment type="block">/* isnull */</comment>
							 <argument><expr><name>true</name></expr></argument> <comment type="block">/* byval */</comment>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
								  <argument><expr><name>chunk_attrno</name></expr></argument>,
								  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>new_tlist</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
<comment type="block">/*
 * adjust_chunk_colnos
 *		Adjust the list of UPDATE target column numbers to account for
 *		attribute differences between the parent and the partition.
 *
 * adapted from postgres adjust_partition_colnos
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>adjust_chunk_colnos</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnos</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>chunk_rri</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_colnos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>ExecGetChildToRootMap</name><argument_list>(<argument><expr><name>chunk_rri</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrMap</name> <modifier>*</modifier></type><name>attrMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* else we shouldn't be here */</comment>
	<expr_stmt><expr><name>attrMap</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>attrMap</name></name></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>colnos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>parentattrno</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>parentattrno</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>parentattrno</name> <operator>&gt;</operator> <name><name>attrMap</name><operator>-&gt;</operator><name>maplen</name></name> <operator>||</operator>
			<name><name>attrMap</name><operator>-&gt;</operator><name>attnums</name><index>[<expr><name>parentattrno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected attno %d in target column list"</literal></expr></argument>, <argument><expr><name>parentattrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>new_colnos</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>new_colnos</name></expr></argument>, <argument><expr><name><name>attrMap</name><operator>-&gt;</operator><name>attnums</name><index>[<expr><name>parentattrno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_colnos</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Setup ON CONFLICT state for a chunk.
 *
 * Mostly, this is about mapping attribute numbers from the hypertable root to
 * a chunk, accounting for differences in the tuple descriptors due to dropped
 * columns, etc.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_on_conflict_state</name><parameter_list>(<parameter><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ChunkDispatch</name> <modifier>*</modifier></type><name>dispatch</name></decl></parameter>,
						<parameter><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>chunk_map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>hyper_to_chunk_map</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>chunk_rri</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>result_relation_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>hyper_rri</name> <init>= <expr><name><name>dispatch</name><operator>-&gt;</operator><name>hypertable_result_rel_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>chunk_rel</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>result_relation_info</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>hyper_rel</name> <init>= <expr><name><name>hyper_rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTableState</name></expr></argument>, <argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>dispatch_state</name><operator>-&gt;</operator><name>mtstate</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ts_chunk_dispatch_get_on_conflict_action</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>OnConflictSetState</name> <modifier>*</modifier></type><name>onconfl</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>OnConflictSetState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>onconfl</name></expr></argument>, <argument><expr><name><name>hyper_rri</name><operator>-&gt;</operator><name>ri_onConflict</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OnConflictSetState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunk_rri</name><operator>-&gt;</operator><name>ri_onConflict</name></name> <operator>=</operator> <name>onconfl</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<expr_stmt><expr><name><name>chunk_rri</name><operator>-&gt;</operator><name>ri_RootToPartitionMap</name></name> <operator>=</operator> <name>map</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hyper_rri</name><operator>-&gt;</operator><name>ri_onConflict</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need a separate existing slot for each partition, as the
	 * partition could be of a different AM, even if the tuple
	 * descriptors match.
	 */</comment>
	<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_Existing</name></name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name><name>chunk_rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>existing_slot</name></name> <operator>=</operator> <name><name>onconfl</name><operator>-&gt;</operator><name>oc_Existing</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the chunk's tuple descriptor matches exactly the hypertable
	 * (the common case), we can re-use most of the parent's ON
	 * CONFLICT SET state, skipping a bunch of work.  Otherwise, we
	 * need to create state specific to this partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>map</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It's safe to reuse these from the hypertable, as we
		 * only process one tuple at a time (therefore we won't
		 * overwrite needed data in slots), and the results of
		 * projections are independent of the underlying storage.
		 * Projections and where clauses themselves don't store state
		 * / are independent of the underlying storage.
		 */</comment>
		<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name> <operator>=</operator> <name><name>hyper_rri</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name> <operator>=</operator> <name><name>hyper_rri</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_WhereClause</name></name> <operator>=</operator> <name><name>hyper_rri</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_WhereClause</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>conflproj_slot</name></name> <operator>=</operator> <name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>onconflset</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>onconflcols</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Translate expressions in onConflictSet to account for
		 * different attribute numbers.  For that, map partition
		 * varattnos twice: first to catch the EXCLUDED
		 * pseudo-relation (INNER_VAR), and second to handle the main
		 * target relation (firstVarno).
		 */</comment>
		<expr_stmt><expr><name>onconflset</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>outdesc</name></name> <operator>==</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>chunk_map</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>chunk_map</name> <operator>=</operator> <call><name>convert_tuples_by_name_compat</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>hyper_rel</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>onconflset</name> <operator>=</operator> <call><name>translate_clause</name><argument_list>(<argument><expr><name>onconflset</name></expr></argument>,
									  <argument><expr><name>chunk_map</name></expr></argument>,
									  <argument><expr><name><name>hyper_rri</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>,
									  <argument><expr><name>hyper_rel</name></expr></argument>,
									  <argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
		<expr_stmt><expr><name>onconflset</name> <operator>=</operator> <call><name>adjust_hypertable_tlist</name><argument_list>(<argument><expr><name>onconflset</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>hyper_to_chunk_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name><name>chunk_rri</name><operator>-&gt;</operator><name>ri_ChildToRootMap</name></name> <operator>=</operator> <name>chunk_map</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk_rri</name><operator>-&gt;</operator><name>ri_ChildToRootMapValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* Finally, adjust the target colnos to match the chunk. */</comment>
		<if_stmt><if>if <condition>(<expr><name>chunk_map</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>onconflcols</name> <operator>=</operator> <call><name>adjust_chunk_colnos</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>onConflictCols</name></name></expr></argument>, <argument><expr><name>chunk_rri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>onconflcols</name> <operator>=</operator> <name><name>mt</name><operator>-&gt;</operator><name>onConflictCols</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* create the tuple slot for the UPDATE SET projection */</comment>
		<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>conflproj_slot</name></name> <operator>=</operator> <name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name></expr>;</expr_stmt>

		<comment type="block">/* build UPDATE SET projection state */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>hyper_rri</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjInfo</name><operator>-&gt;</operator><name>pi_exprContext</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name> <operator>=</operator> <call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name>onconflset</name></expr></argument>,
													   <argument><expr><name>econtext</name></expr></argument>,
													   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>conflproj_slot</name></name></expr></argument>,
													   <argument><expr><name>NULL</name></expr></argument>,
													   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name> <operator>=</operator> <call><name>ExecBuildUpdateProjection</name><argument_list>(<argument><expr><name>onconflset</name></expr></argument>,
														 <argument><expr><name>true</name></expr></argument>,
														 <argument><expr><name>onconflcols</name></expr></argument>,
														 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></argument>,
														 <argument><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjSlot</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>onconflict_where</name> <init>= <expr><name><name>mt</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Map attribute numbers in the WHERE clause, if it exists.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>onconflict_where</name> <operator>&amp;&amp;</operator> <name>chunk_map</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>translate_clause</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>onconflict_where</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>chunk_map</name></expr></argument>,
											<argument><expr><name><name>hyper_rri</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>,
											<argument><expr><name>hyper_rel</name></expr></argument>,
											<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>chunk_rri</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_WhereClause</name></name> <operator>=</operator> <call><name>ExecInitQual</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>destroy_on_conflict_state</name><parameter_list>(<parameter><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Clean up per-chunk tuple table slots created for ON CONFLICT handling.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>existing_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>existing_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* The ON CONFLICT projection slot is only chunk specific in case the
	 * tuple descriptor didn't match the hypertable */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>hyper_to_chunk_map</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>conflproj_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>conflproj_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Translate hypertable indexes to chunk indexes in the arbiter clause */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_arbiter_indexes</name><parameter_list>(<parameter><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ChunkDispatch</name> <modifier>*</modifier></type><name>dispatch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>arbiter_indexes</name> <init>= <expr><call><name>ts_chunk_dispatch_get_arbiter_indexes</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>arbiter_indexes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>arbiter_indexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>hypertable_index</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ChunkIndexMapping</name></type> <name>cim</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ts_chunk_index_get_by_hypertable_indexrelid</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>hypertable_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cim</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In case of distributed hypertables, we don't have information about the
			 * arbiter index on the remote side, so error out with a helpful hint
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find arbiter index for hypertable index \"%s\" on chunk "</literal>
							<literal type="string">"\"%s\""</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>hypertable_index</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>hypertable</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
						 <expr><call><name>errhint</name><argument_list>(
							 <argument><expr><literal type="string">"Omit the index inference specification for the distributed hypertable"</literal>
							 <literal type="string">" in the ON CONFLICT clause."</literal></expr></argument>)</argument_list></call></expr> </then><else>:
						 <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>arbiter_indexes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>arbiter_indexes</name></name></expr></argument>, <argument><expr><name><name>cim</name><operator>.</operator><name>indexoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result_relation_info</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>arbiter_indexes</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Change the projections to work with chunks instead of hypertables */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjust_projections</name><parameter_list>(<parameter><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>cis</name></decl></parameter>, <parameter><decl><type><name>ChunkDispatch</name> <modifier>*</modifier></type><name>dispatch</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rowtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>chunk_rri</name> <init>= <expr><name><name>cis</name><operator>-&gt;</operator><name>result_relation_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>hyper_rel</name> <init>= <expr><name><name>dispatch</name><operator>-&gt;</operator><name>hypertable_result_rel_info</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>chunk_rel</name> <init>= <expr><name><name>cis</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>chunk_map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OnConflictAction</name></type> <name>onconflict_action</name> <init>= <expr><call><name>ts_chunk_dispatch_get_on_conflict_action</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ts_chunk_dispatch_has_returning</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need the opposite map from cis-&gt;hyper_to_chunk_map. The map needs
		 * to have the hypertable_desc in the out spot for map_variable_attnos
		 * to work correctly in mapping hypertable attnos-&gt;chunk attnos.
		 */</comment>
		<expr_stmt><expr><name>chunk_map</name> <operator>=</operator> <call><name>convert_tuples_by_name_compat</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>hyper_rel</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>chunk_rri</name><operator>-&gt;</operator><name>ri_projectReturning</name></name> <operator>=</operator>
			<call><name>get_adjusted_projection_info_returning</name><argument_list>(<argument><expr><name><name>chunk_rri</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr></argument>,
												   <argument><expr><call><name>ts_chunk_dispatch_get_returning_clauses</name><argument_list>(
													   <argument><expr><name>dispatch</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>chunk_map</name></expr></argument>,
												   <argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>hypertable_result_rel_info</name>
													   <operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>,
												   <argument><expr><name>rowtype</name></expr></argument>,
												   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>chunk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set the chunk's arbiter indexes for ON CONFLICT statements */</comment>
	<if_stmt><if>if <condition>(<expr><name>onconflict_action</name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_arbiter_indexes</name><argument_list>(<argument><expr><name>cis</name></expr></argument>, <argument><expr><name>dispatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>onconflict_action</name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>setup_on_conflict_state</name><argument_list>(<argument><expr><name>cis</name></expr></argument>, <argument><expr><name>dispatch</name></expr></argument>, <argument><expr><name>chunk_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Assumption: we have acquired a lock on the chunk table. This is
 *      important because lock acquisition order is always orignal chunk,
 *      followed by compressed chunk to prevent deadlocks.
 * We now try to acquire a lock on the compressed chunk, if one exists.
 * Note that the insert could have been blocked by a recompress_chunk operation.
 * So the compressed chunk could have moved under us. We need to refetch the chunk
 * to get the correct compressed chunk id (github issue 3400)
 */</comment>
<function><type><specifier>static</specifier> <name>Relation</name></type>
<name>lock_associated_compressed_chunk</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>chunk_id</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>has_compressed_chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>compressed_chunk_id</name> <init>= <expr><call><name>ts_chunk_get_compressed_chunk_id</name><argument_list>(<argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>compressed_chunk_id</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>compress_chunk_relid</name> <init>=
			<expr><call><name>ts_chunk_get_relid</name><argument_list>(<argument><expr><name>compressed_chunk_id</name></expr></argument>, <comment type="block">/* missing_ok = */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>compress_chunk_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>has_compressed_chunk</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><call><name>table_open</name><argument_list>(<argument><expr><name>compress_chunk_relid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>has_compressed_chunk</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create new insert chunk state.
 *
 * This is essentially a ResultRelInfo for a chunk. Initialization of the
 * ResultRelInfo should be similar to ExecInitModifyTable().
 */</comment>
<function><type><specifier>extern</specifier> <name>ChunkInsertState</name> <modifier>*</modifier></type>
<name>ts_chunk_insert_state_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>ChunkDispatch</name> <modifier>*</modifier></type><name>dispatch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>cagg_trig_nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name><name>cagg_trig_args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>, <decl><type ref="prev"/><name>parent_rel</name></decl>, <decl><type ref="prev"/><name>compress_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cis_context</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>,
													  <argument><expr><literal type="string">"chunk insert state memory context"</literal></expr></argument>,
													  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OnConflictAction</name></type> <name>onconflict_action</name> <init>= <expr><call><name>ts_chunk_dispatch_get_on_conflict_action</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resrelinfo</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>relinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_compressed_chunk</name> <init>= <expr><operator>(</operator><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>compressed_chunk_id</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* permissions NOT checked here; were checked at hypertable level */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_enable_rls</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RLS_ENABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hypertables do not support row-level security"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"insert is not on a table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_chunk_validate_chunk_status_for_operation</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>,
												 <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>status</name></name></expr></argument>,
												 <argument><expr><name>CHUNK_INSERT</name></expr></argument>,
												 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>has_compressed_chunk</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>onconflict_action</name> <operator>!=</operator> <name>ONCONFLICT_NONE</name> <operator>||</operator> <call><name>ts_chunk_dispatch_has_returning</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insert with ON CONFLICT or RETURNING clause is not supported on "</literal>
						<literal type="string">"compressed chunks"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>has_compressed_chunk</name> <operator>&amp;&amp;</operator> <call><name>ts_indexing_relation_has_primary_or_unique_index</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insert into a compressed chunk that has primary or unique constraint is "</literal>
						<literal type="string">"not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>compress_rel</name> <operator>=</operator> <call><name>lock_associated_compressed_chunk</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>has_compressed_chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_mcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>cis_context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>relinfo</name> <operator>=</operator> <call><name>create_chunk_result_relation_info</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_compressed_chunk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>resrelinfo</name> <operator>=</operator> <name>relinfo</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* insert the tuple into the compressed chunk instead */</comment>
		<expr_stmt><expr><name>resrelinfo</name> <operator>=</operator> <call><name>create_compress_chunk_result_relation_info</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>, <argument><expr><name>compress_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>CheckValidResultRel</name><argument_list>(<argument><expr><name>resrelinfo</name></expr></argument>, <argument><expr><call><name>ts_chunk_dispatch_get_cmd_type</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkInsertState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>mctx</name></name> <operator>=</operator> <name>cis_context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result_relation_info</name></name> <operator>=</operator> <name>resrelinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name><name>dispatch</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resrelinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>&amp;&amp;</operator>
		<name><name>resrelinfo</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>resrelinfo</name></expr></argument>, <argument><expr><name>onconflict_action</name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>tg</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* instead of triggers can only be created on VIEWs */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tg</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * A statement that targets a parent table in an inheritance or
		 * partitioning hierarchy does not cause the statement-level triggers
		 * of affected child tables to be fired; only the parent table's
		 * statement-level triggers are fired. However, row-level triggers
		 * of any affected child tables will be fired.
		 * During chunk creation we only copy ROW trigger to chunks so
		 * statement triggers should not exist on chunks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tg</name><operator>-&gt;</operator><name>trig_insert_after_statement</name></name> <operator>||</operator> <name><name>tg</name><operator>-&gt;</operator><name>trig_insert_before_statement</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"statement trigger on chunk table not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* AFTER ROW triggers do not work since we redirect the insert
		 * to the compressed chunk. We still want cagg triggers to fire.
		 * We'll call them directly. But raise an error if there are
		 * other triggers
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>has_compressed_chunk</name> <operator>&amp;&amp;</operator> <name><name>tg</name><operator>-&gt;</operator><name>trig_insert_after_row</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>trigger_list</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tg</name><operator>-&gt;</operator><name>numtriggers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tg</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>tg</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tgname</name></expr></argument>,
							<argument><expr><name>CAGGINVAL_TRIGGER_NAME</name></expr></argument>,
							<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>CAGGINVAL_TRIGGER_NAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* collect arg information here */</comment>
					<expr_stmt><expr><name>cagg_trig_nargs</name> <operator>=</operator> <name><name>tg</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tgnargs</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cagg_trig_args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>atol</name><argument_list>(<argument><expr><name><name>tg</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>tgargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>cagg_trig_nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>cagg_trig_args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>atol</name><argument_list>(<argument><expr><name><name>tg</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>tgargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>trigger_list</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>trigger_list</name></expr></argument>, <argument><expr><name><name>tg</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name><name>trigger_list</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"after insert row trigger on compressed chunk not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Triggers: %s"</literal></expr></argument>, <argument><expr><name><name>trigger_list</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Decompress the chunk first before inserting into it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>parent_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>hypertable</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set tuple conversion map, if tuple needs conversion. We don't want to
	 * convert tuples going into foreign tables since these are actually sent to
	 * data nodes for insert on that node's local hypertable. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>hyper_to_chunk_map</name></name> <operator>=</operator>
			<call><name>convert_tuples_by_name_compat</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>adjust_projections</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>dispatch</name></expr></argument>, <argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>has_compressed_chunk</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CompressChunkInsertState</name> <modifier>*</modifier></type><name>compress_info</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CompressChunkInsertState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>htid</name> <init>= <expr><call><name>ts_hypertable_relid_to_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hypertable_relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* this is true as compressed chunks are not created on access node */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>compress_rel</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>compress_info</name><operator>-&gt;</operator><name>compress_rel</name></name> <operator>=</operator> <name>compress_rel</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>compress_row_init</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* need a way to convert from chunk tuple to compressed chunk tuple */</comment>
		<expr_stmt><expr><name><name>compress_info</name><operator>-&gt;</operator><name>compress_state</name></name> <operator>=</operator> <call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>compress_row_init</name></name><argument_list>(<argument><expr><name>htid</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>compress_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>compress_info</name><operator>-&gt;</operator><name>orig_result_relation_info</name></name> <operator>=</operator> <name>relinfo</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cagg_trig_nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <comment type="block">/*we found a cagg trigger earlier */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name><name>compress_info</name><operator>-&gt;</operator><name>has_cagg_trigger</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>compress_info</name><operator>-&gt;</operator><name>cagg_trig_nargs</name></name> <operator>=</operator> <name>cagg_trig_nargs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>compress_info</name><operator>-&gt;</operator><name>cagg_trig_args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>cagg_trig_args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>compress_info</name><operator>-&gt;</operator><name>cagg_trig_args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>cagg_trig_args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>compress_info</name></name> <operator>=</operator> <name>compress_info</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>compress_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Need a tuple table slot to store tuples going into this chunk. We don't
	 * want this slot tied to the executor's tuple table, since that would tie
	 * the slot's lifetime to the entire length of the execution and we want
	 * to be able to dynamically create and destroy chunk insert
	 * state. Otherwise, memory might blow up when there are many chunks being
	 * inserted into. This also means that the slot needs to be destroyed with
	 * the chunk insert state. */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>chunk_id</name></name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>id</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>=
			<expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>resrelinfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>, <argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>user_id</name></name> <operator>=</operator> <ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> </then><else>: <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>chunk_data_nodes</name></name> <operator>=</operator> <call><name>ts_chunk_data_nodes_copy</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dispatch</name><operator>-&gt;</operator><name>hypertable_result_rel_info</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If the hypertable is setup for direct modify, we do not really use
		 * the FDW. Instead exploit the FdwPrivate pointer to pass on the
		 * chunk insert state to DataNodeDispatch so that it knows which data nodes
		 * to insert into. */</comment>
		<expr_stmt><expr><name><name>resrelinfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>resrelinfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>resrelinfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>&amp;&amp;</operator>
			 <name><name>resrelinfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>BeginForeignModify</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If this is a chunk located one or more data nodes, setup the
		 * foreign data wrapper state for the chunk. The private fdw data was
		 * created at the planning stage and contains, among other things, a
		 * deparsed insert statement for the hypertable.
		 */</comment>
		<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name> <init>= <expr><name><name>dispatch</name><operator>-&gt;</operator><name>dispatch_state</name><operator>-&gt;</operator><name>mtstate</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fdwprivate</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>mt</name><operator>-&gt;</operator><name>fdwPrivLists</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NIL</name> <operator>!=</operator> <name>fdwprivate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Since the fdwprivate data is part of the plan it must only
		 * consist of Node objects that can be copied. Therefore, we
		 * cannot directly append the non-Node ChunkInsertState to the
		 * private data. Instead, we make a copy of the private data
		 * before passing it on to the FDW handler function. In the
		 * FDW, the ChunkInsertState will be at the offset defined by
		 * the FdwModifyPrivateChunkInsertState (see
		 * tsl/src/fdw/timescaledb_fdw.c).
		 */</comment>
		<expr_stmt><expr><name>fdwprivate</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>fdwprivate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>resrelinfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>BeginForeignModify</name></name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>,
													  <argument><expr><name>resrelinfo</name></expr></argument>,
													  <argument><expr><name>fdwprivate</name></expr></argument>,
													  <argument><expr><literal type="number">0</literal></expr></argument>,
													  <argument><expr><name><name>dispatch</name><operator>-&gt;</operator><name>eflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>void</name></type>
<name>ts_chunk_insert_state_destroy</name><parameter_list>(<parameter><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>result_relation_info</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rri</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rri</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>&amp;&amp;</operator> <name><name>rri</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>EndForeignModify</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>rri</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>EndForeignModify</name></name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>, <argument><expr><name>rri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroy_on_conflict_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_relation_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The chunk search functions may leak memory, so switch to a temporary
	 * memory context.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>compress_info</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>orig_chunk_rri</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>compress_info</name><operator>-&gt;</operator><name>orig_result_relation_info</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>orig_chunk_rri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>compress_row_end</name></name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>compress_info</name><operator>-&gt;</operator><name>compress_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>compress_row_destroy</name></name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>compress_info</name><operator>-&gt;</operator><name>compress_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ts_chunk_is_unordered</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_chunk_set_unordered</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>compress_info</name><operator>-&gt;</operator><name>compress_rel</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_relation_info</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relkind</name> <operator>==</operator>
			 <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If a distributed chunk shows compressed status on AN,
		 * we mark it as unordered , because the insert now goes into
		 * a previously compressed chunk
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>chunk_relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_relation_info</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>ts_chunk_get_by_relid</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ts_chunk_is_compressed</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>ts_chunk_is_unordered</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ts_chunk_set_unordered</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>slot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Postgres stores cached row types from `get_cached_rowtype` in the
	 * constraint expression and tries to free this type via a callback from the
	 * `per_tuple_exprcontext`. Since we create constraint expressions within
	 * the chunk insert state memory context, this leads to a series of pointers
	 * structured like: `per_tuple_exprcontext -&gt; constraint expr (in chunk
	 * insert state) -&gt; cached row type` if we try to free the the chunk insert
	 * state MemoryContext while the `es_per_tuple_exprcontext` is live,
	 * postgres tries to dereference a dangling pointer in one of
	 * `es_per_tuple_exprcontext`'s callbacks. Normally postgres allocates the
	 * constraint expressions in a parent context of per_tuple_exprcontext so
	 * there is no issue, however we've run into excessive memory usage due to
	 * too many constraints, and want to allocate them for a shorter lifetime so
	 * we free them when SubspaceStore gets to full. This leaves us with a
	 * memory context relationship like the following:
	 *
	 *     query_ctx
	 *       / \
	 *      /   \
	 *   CIS    per_tuple
	 *
	 *
	 * To ensure this doesn't create dangling pointers from the per-tuple
	 * context to the chunk insert state (CIS) when we destroy the CIS, we avoid
	 * freeing the CIS memory context immediately. Instead we change its parent
	 * to be the per-tuple context (if it is still alive) so that it is only
	 * freed once that context is freed:
	 *
	 *     query_ctx
	 *        \
	 *         \
	 *         per_tuple
	 *           \
	 *            \
	 *            CIS
	 *
	 * Note that a previous approach registered the chunk insert state (CIS) to
	 * be freed by a reset callback on the per-tuple context. That caused a
	 * subtle bug because both the per-tuple context and the CIS share the same
	 * parent. Thus, the callback on a child would trigger the deletion of a
	 * sibling, leading to a cyclic relationship:
	 *
	 *     query_ctx
	 *       / \
	 *      /   \
	 *   CIS &lt;-- per_tuple
	 *
	 *
	 * With this cycle, a delete of the query_ctx could first trigger a delete
	 * of the CIS (if not already deleted), then the per_tuple context, followed
	 * by the CIS again (via the callback), and thus a crash.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_per_tuple_exprcontext</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>,
							   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_per_tuple_exprcontext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* invoke cagg trigger on a compressed chunk. AFTER Row Triggers on
 * compressed chunks do not work with the PG framework - so we explicitly
 * call the underlying C function. Note that in the case of a distr. ht, this
 * trigger is executed on the AN.
 * Parameters:
 * chunk_rel : chunk that will be modified (original chunk)
 * chunk_tuple: tuple to be inserted into the chunk (before being transformed
 *            into compressed format)
 */</comment>
<function><type><name>void</name></type>
<name>ts_compress_chunk_invoke_cagg_trigger</name><parameter_list>(<parameter><decl><type><name>CompressChunkInsertState</name> <modifier>*</modifier></type><name>compress_info</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>chunk_rel</name></decl></parameter>,
									  <parameter><decl><type><name>HeapTuple</name></type> <name>chunk_tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>continuous_agg_call_invalidation_trigger</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>hypertable_id</name> <init>= <expr><name><name>compress_info</name><operator>-&gt;</operator><name>cagg_trig_args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>parent_hypertable_id</name> <init>= <expr><name><name>compress_info</name><operator>-&gt;</operator><name>cagg_trig_args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_distributed_ht</name> <init>= <expr><operator>(</operator><name><name>compress_info</name><operator>-&gt;</operator><name>cagg_trig_nargs</name></name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>compress_info</name><operator>-&gt;</operator><name>cagg_trig_nargs</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>parent_hypertable_id</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name><name>compress_info</name><operator>-&gt;</operator><name>cagg_trig_nargs</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>parent_hypertable_id</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>continuous_agg_call_invalidation_trigger</name></name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>,
															  <argument><expr><name>chunk_rel</name></expr></argument>,
															  <argument><expr><name>chunk_tuple</name></expr></argument>,
															  <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* chunk_newtuple */</comment>,
															  <argument><expr><name>false</name></expr></argument> <comment type="block">/* update */</comment>,
															  <argument><expr><name>is_distributed_ht</name></expr></argument>,
															  <argument><expr><name>parent_hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
