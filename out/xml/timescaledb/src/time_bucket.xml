<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/time_bucket.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/date.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/datetime.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgrprotos.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/timestamp.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time_bucket.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_BUCKET</name><parameter_list>(<parameter><type><name>period</name></type></parameter>, <parameter><type><name>timestamp</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>, <parameter><type><name>min</name></type></parameter>, <parameter><type><name>max</name></type></parameter>, <parameter><type><name>result</name></type></parameter>)</parameter_list></cpp:macro>                                   \
	<cpp:value>do                                                                                             \
	{                                                                                              \
		if ((period) &lt;= 0)                                                                         \
			ereport(ERROR,                                                                         \
					(errcode(ERRCODE_INVALID_PARAMETER_VALUE),                                     \
					 errmsg("period must be greater than 0")));                                    \
		if ((offset) != 0)                                                                         \
		{                                                                                          \
			<comment type="block">/* We need to ensure that the timestamp is in range _after_ the */</comment>                     \
			<comment type="block">/* offset is applied: when the offset is positive we need to make */</comment>                   \
			<comment type="block">/* sure the resultant time is at least min, and when negative that */</comment>                  \
			<comment type="block">/* it is less than the max. */</comment>                                                         \
			(offset) = (offset) % (period);                                                        \
			if (((offset) &gt; 0 &amp;&amp; (timestamp) &lt; (min) + (offset)) ||                                \
				((offset) &lt; 0 &amp;&amp; (timestamp) &gt; (max) + (offset)))                                  \
				ereport(ERROR,                                                                     \
						(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),                              \
						 errmsg("timestamp out of range")));                                       \
			(timestamp) -= (offset);                                                               \
		}                                                                                          \
		(result) = ((timestamp) / (period)) * (period);                                            \
		if ((timestamp) &lt; 0 &amp;&amp; (timestamp) % (period))                                             \
		{                                                                                          \
			if ((result) &lt; (min) + (period))                                                       \
				ereport(ERROR,                                                                     \
						(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),                              \
						 errmsg("timestamp out of range")));                                       \
			else                                                                                   \
				(result) = (result) - (period);                                                    \
		}                                                                                          \
		(result) += (offset);                                                                      \
	} while (0)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_int16_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_int16_bucket</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>period</name> <init>= <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>offset</name> <init>= <expr><ternary><condition><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TIME_BUCKET</name><argument_list>(<argument><expr><name>period</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>PG_INT16_MIN</name></expr></argument>, <argument><expr><name>PG_INT16_MAX</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_int32_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_int32_bucket</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>period</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>offset</name> <init>= <expr><ternary><condition><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TIME_BUCKET</name><argument_list>(<argument><expr><name>period</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>PG_INT32_MIN</name></expr></argument>, <argument><expr><name>PG_INT32_MAX</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_int64_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_int64_bucket</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>period</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>offset</name> <init>= <expr><ternary><condition><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TIME_BUCKET</name><argument_list>(<argument><expr><name>period</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>PG_INT64_MIN</name></expr></argument>, <argument><expr><name>PG_INT64_MAX</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JAN_3_2000</name></cpp:macro> <cpp:value>(2 * USECS_PER_DAY)</cpp:value></cpp:define>

<comment type="block">/*
 * The default origin is Monday 2000-01-03. We don't use PG epoch since it starts on a saturday.
 * This makes time-buckets by a week more intuitive and aligns it with date_trunc. Since month
 * bucketing ignores the day component this makes origin for month buckets 2000-01-01.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ORIGIN</name></cpp:macro> <cpp:value>(JAN_3_2000)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_BUCKET_TS</name><parameter_list>(<parameter><type><name>period</name></type></parameter>, <parameter><type><name>timestamp</name></type></parameter>, <parameter><type><name>result</name></type></parameter>, <parameter><type><name>shift</name></type></parameter>)</parameter_list></cpp:macro>                                           \
	<cpp:value>do                                                                                             \
	{                                                                                              \
		if ((period) &lt;= 0)                                                                         \
			ereport(ERROR,                                                                         \
					(errcode(ERRCODE_INVALID_PARAMETER_VALUE),                                     \
					 errmsg("period must be greater than 0")));                                    \
		<comment type="block">/* shift = shift % period, but use TMODULO */</comment>                                              \
		TMODULO(shift, result, period);                                                            \
                                                                                                   \
		if (((shift) &gt; 0 &amp;&amp; (timestamp) &lt; DT_NOBEGIN + (shift)) ||                                 \
			((shift) &lt; 0 &amp;&amp; (timestamp) &gt; DT_NOEND + (shift)))                                     \
			ereport(ERROR,                                                                         \
					(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),                                  \
					 errmsg("timestamp out of range")));                                           \
		(timestamp) -= (shift);                                                                    \
                                                                                                   \
		<comment type="block">/* result = (timestamp / period) * period */</comment>                                               \
		TMODULO(timestamp, result, period);                                                        \
		if ((timestamp) &lt; 0)                                                                       \
		{                                                                                          \
			<comment type="block">/*                                                                                     \
			 * need to subtract another period if remainder &lt; 0 this only happens                  \
			 * if timestamp is negative to begin with and there is a remainder                     \
			 * after division. Need to subtract another period since division                      \
			 * truncates toward 0 in C99.                                                          \
			 */</comment>                                                                                    \
			(result) = ((result) * (period)) - (period);                                           \
		}                                                                                          \
		else                                                                                       \
			(result) *= (period);                                                                  \
                                                                                                   \
		(result) += (shift);                                                                       \
	} while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_month_bucket</name><parameter_list>(<parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Bucketing by a month and non-month cannot be mixed.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>||</operator> <name><name>interval</name><operator>-&gt;</operator><name>time</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"month intervals cannot have day or time component"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * To bucket by month we get the year and month of a date and convert
 * that to the nth month since origin. This allows us to treat month
 * bucketing similar to int bucketing. During this process we ignore
 * the day component and therefore only support bucketing by full months.
 */</comment>
<function><type><specifier>static</specifier> <name>DateADT</name></type>
<name>bucket_month</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>period</name></decl></parameter>, <parameter><decl><type><name>DateADT</name></type> <name>date</name></decl></parameter>, <parameter><decl><type><name>DateADT</name></type> <name>origin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>year</name></decl>, <decl><type ref="prev"/><name>month</name></decl>, <decl><type ref="prev"/><name>day</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>date</name> <operator>+</operator> <name>POSTGRES_EPOCH_JDATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>year</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>month</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>timestamp</name> <init>= <expr><name>year</name> <operator>*</operator> <literal type="number">12</literal> <operator>+</operator> <name>month</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>origin</name> <operator>+</operator> <name>POSTGRES_EPOCH_JDATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>year</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>month</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>offset</name> <init>= <expr><name>year</name> <operator>*</operator> <literal type="number">12</literal> <operator>+</operator> <name>month</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TIME_BUCKET</name><argument_list>(<argument><expr><name>period</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>PG_INT32_MIN</name></expr></argument>, <argument><expr><name>PG_INT32_MAX</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>year</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">12</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>month</name> <operator>=</operator> <name>result</name> <operator>%</operator> <literal type="number">12</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>day</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>date2j</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns the period in the same representation as Postgres Timestamps.
 * Note that this is not our internal representation (microseconds).
 * Always returns an exact value.*/</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int64</name></type>
<name>get_interval_period_timestamp_units</name><parameter_list>(<parameter><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval defined in terms of month, year, century etc. not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>*</operator> <name>USECS_PER_DAY</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_timestamp_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_timestamp_bucket</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * USE NARGS and not IS_NULL to differentiate a NULL argument from a call
	 * with 2 parameters
	 */</comment>
	<decl_stmt><decl><type><name>Timestamp</name></type> <name>origin</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>DEFAULT_ORIGIN</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DateADT</name></type> <name>origin_date</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>validate_month_bucket</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>DateADT</name></type> <name>date</name> <init>= <expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_date</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>origin</name> <operator>!=</operator> <name>DEFAULT_ORIGIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>origin_date</name> <operator>=</operator>
				<call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_date</name></expr></argument>, <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>bucket_month</name><argument_list>(<argument><expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>origin_date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>date_timestamp</name></expr></argument>, <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>period</name> <init>= <expr><call><name>get_interval_period_timestamp_units</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TIME_BUCKET_TS</name><argument_list>(<argument><expr><name>period</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_timestamp_offset_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_timestamp_offset_bucket</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>period</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Apply offset. */</comment>
	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_mi_interval</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_timestamp_bucket</name></expr></argument>, <argument><expr><name>period</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove offset. */</comment>
	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_pl_interval</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_timestamptz_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_timestamptz_bucket</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * USE NARGS and not IS_NULL to differentiate a NULL argument from a call
	 * with 2 parameters
	 */</comment>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>origin</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>DEFAULT_ORIGIN</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>origin</name> <operator>=</operator> <call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DateADT</name></type> <name>origin_date</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>validate_month_bucket</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>DateADT</name></type> <name>date</name> <init>= <expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_date</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>origin</name> <operator>!=</operator> <name>DEFAULT_ORIGIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>origin_date</name> <operator>=</operator>
				<call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_date</name></expr></argument>, <argument><expr><call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>bucket_month</name><argument_list>(<argument><expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>origin_date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>date_timestamp</name></expr></argument>, <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>period</name> <init>= <expr><call><name>get_interval_period_timestamp_units</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TIME_BUCKET_TS</name><argument_list>(<argument><expr><name>period</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMPTZ</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_timestamptz_offset_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_timestamptz_offset_bucket</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>period</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Apply offset. */</comment>
	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_mi_interval</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_timestamptz_bucket</name></expr></argument>, <argument><expr><name>period</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove offset. */</comment>
	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_pl_interval</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_timestamptz_timezone_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * time_bucket(bucket_width INTERVAL, ts TIMESTAMPTZ, timezone TEXT, origin TIMESTAMPTZ DEFAULT
 * NULL, "offset" INTERVAL DEFAULT NULL) RETURNS TIMESTAMPTZ
 */</comment>
<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_timestamptz_timezone_bucket</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>period</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>tzname</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * When called from SQL we will always have 5 args because default values
	 * will be filled in for missing arguments. When called from C with
	 * DirectFunctionCall number of arguments might be less than 5.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>have_origin</name> <init>= <expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>have_offset</name> <init>= <expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need to check for NULL arguments here because the function cannot be
	 * defined STRICT due to the optional arguments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert to local timestamp according to timezone */</comment>
	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>have_offset</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Apply offset. */</comment>
		<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_mi_interval</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_origin</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>origin</name> <init>= <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>ts_timestamp_bucket</name></expr></argument>, <argument><expr><name>period</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_timestamp_bucket</name></expr></argument>, <argument><expr><name>period</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_offset</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Remove offset. */</comment>
		<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_pl_interval</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Convert back to timezone */</comment>
	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>check_period_is_daily</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>period</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>day</name> <init>= <expr><name>USECS_PER_DAY</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>period</name> <operator>&lt;</operator> <name>day</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval must not have sub-day precision"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>period</name> <operator>%</operator> <name>day</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval must be a multiple of a day"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_date_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_date_bucket</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type> <name>date</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type> <name>origin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type> <name>origin_ts</name> <init>= <expr><name>DEFAULT_ORIGIN</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type> <name>timestamp</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* convert to timestamp (NOT tz), bucket, convert back to date */</comment>
	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>date_timestamp</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>origin</name> <operator>=</operator> <call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>origin_ts</name> <operator>=</operator>
				<call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>date_timestamp</name></expr></argument>, <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>validate_month_bucket</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>bucket_month</name><argument_list>(<argument><expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>period</name> <init>= <expr><call><name>get_interval_period_timestamp_units</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* check the period aligns on a date */</comment>
		<expr_stmt><expr><call><name>check_period_is_daily</name><argument_list>(<argument><expr><name>period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>TIME_BUCKET_TS</name><argument_list>(<argument><expr><name>period</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>origin_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_date</name></expr></argument>, <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_date_offset_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_date_offset_bucket</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>period</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>date</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Apply offset. */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name>time</name> <init>= <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>date_mi_interval</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_date</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_date_bucket</name></expr></argument>, <argument><expr><name>period</name></expr></argument>, <argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove offset. */</comment>
	<expr_stmt><expr><name>time</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>date_pl_interval</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_date</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* when working with time_buckets stored in our catalog, we may not know ahead of time which
 * bucketing function to use, this function dynamically dispatches to the correct time_bucket_&lt;foo&gt;
 * based on an inputted timestamp_type*/</comment>
<function><type><name>TSDLLEXPORT</name> <name>int64</name></type>
<name>ts_time_bucket_by_type</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>interval</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>timestamp_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>timestamp_in_time_type</name> <init>= <expr><call><name>ts_internal_to_time_value</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>timestamp_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>interval_in_interval_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>time_bucketed</name></decl>;</decl_stmt>
	<function_decl><type><name>Datum</name></type> (<modifier>*</modifier><name>bucket_function</name>)<parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

	<switch>switch <condition>(<expr><name>timestamp_type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<expr_stmt><expr><name>interval_in_interval_type</name> <operator>=</operator> <call><name>ts_internal_to_interval_value</name><argument_list>(<argument><expr><name>interval</name></expr></argument>, <argument><expr><name>timestamp_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bucket_function</name> <operator>=</operator> <name>ts_int16_bucket</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><name>interval_in_interval_type</name> <operator>=</operator> <call><name>ts_internal_to_interval_value</name><argument_list>(<argument><expr><name>interval</name></expr></argument>, <argument><expr><name>timestamp_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bucket_function</name> <operator>=</operator> <name>ts_int32_bucket</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><name>interval_in_interval_type</name> <operator>=</operator> <call><name>ts_internal_to_interval_value</name><argument_list>(<argument><expr><name>interval</name></expr></argument>, <argument><expr><name>timestamp_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bucket_function</name> <operator>=</operator> <name>ts_int64_bucket</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<expr_stmt><expr><name>interval_in_interval_type</name> <operator>=</operator> <call><name>ts_internal_to_interval_value</name><argument_list>(<argument><expr><name>interval</name></expr></argument>, <argument><expr><name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bucket_function</name> <operator>=</operator> <name>ts_timestamp_bucket</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<expr_stmt><expr><name>interval_in_interval_type</name> <operator>=</operator> <call><name>ts_internal_to_interval_value</name><argument_list>(<argument><expr><name>interval</name></expr></argument>, <argument><expr><name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bucket_function</name> <operator>=</operator> <name>ts_timestamptz_bucket</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<expr_stmt><expr><name>interval_in_interval_type</name> <operator>=</operator> <call><name>ts_internal_to_interval_value</name><argument_list>(<argument><expr><name>interval</name></expr></argument>, <argument><expr><name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bucket_function</name> <operator>=</operator> <name>ts_date_bucket</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid time_bucket type \"%s\""</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>timestamp_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>time_bucketed</name> <operator>=</operator>
		<call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>bucket_function</name></expr></argument>, <argument><expr><name>interval_in_interval_type</name></expr></argument>, <argument><expr><name>timestamp_in_time_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name>time_bucketed</name></expr></argument>, <argument><expr><name>timestamp_type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_time_bucket_ng_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type> <name>ts_date</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval can't combine months with minutes or hours"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Handle minutes, hours and days.
		 */</comment>
		<decl_stmt><decl><type><name>Timestamp</name></type> <name>origin</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>DEFAULT_ORIGIN</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>Timestamp</name></type> <name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>period</name> <init>= <expr><call><name>get_interval_period_timestamp_units</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>TIME_BUCKET_TS</name><argument_list>(<argument><expr><name>period</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Discard any time information and work with the date.
	 */</comment>
	<expr_stmt><expr><name>ts_date</name> <operator>=</operator> <call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_date</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DateADT</name></type> <name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DateADT</name></type> <name>origin</name> <init>= <expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamp_date</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_date</name></expr></argument>,
													 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>ts_date</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>date_timestamp</name></expr></argument>, <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>DateADT</name></type> <name>result</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_date</name></expr></argument>,
													 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>ts_date</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>date_timestamp</name></expr></argument>, <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_timestamptz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_time_bucket_ng_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>interval</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type> <name>ts_date</name> <init>= <expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamptz_date</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DateADT</name></type> <name>origin</name> <init>= <expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>timestamptz_date</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetDateADT</name><argument_list>(<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_date</name></expr></argument>,
													 <argument><expr><name>interval</name></expr></argument>,
													 <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>ts_date</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetDateADT</name><argument_list>(
			<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_date</name></expr></argument>, <argument><expr><name>interval</name></expr></argument>, <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>ts_date</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>date_timestamptz</name></expr></argument>, <argument><expr><call><name>DateADTGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_time_bucket_ng_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name> <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type> <name>date</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type> <name>origin_date</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>origin_year</name> <init>= <expr><literal type="number">2000</literal></expr></init></decl>, <decl><type ref="prev"/><name>origin_month</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>origin_day</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>year</name></decl>, <decl><type ref="prev"/><name>month</name></decl>, <decl><type ref="prev"/><name>day</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>delta</name></decl>, <decl><type ref="prev"/><name>bucket_number</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval must be either days and weeks, or months and years"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval must be at least one day"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>origin_date</name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>origin_date</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>origin_date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>origin_date</name> <operator>+</operator> <name>POSTGRES_EPOCH_JDATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>origin_year</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>origin_month</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>origin_day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>origin_day</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"origin must be the first day of the month"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"When using timestamptz-version of the function, 'origin' is "</literal>
						 <literal type="string">"converted to provided 'timezone'."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Handle months and years */</comment>

		<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>date</name> <operator>+</operator> <name>POSTGRES_EPOCH_JDATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>year</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>month</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>offset</name> <init>= <expr><name>origin_year</name> <operator>*</operator> <literal type="number">12</literal> <operator>+</operator> <name>origin_month</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>timestamp</name> <init>= <expr><name>year</name> <operator>*</operator> <literal type="number">12</literal> <operator>+</operator> <name>month</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>TIME_BUCKET</name><argument_list>(<argument><expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>PG_INT32_MIN</name></expr></argument>, <argument><expr><name>PG_INT32_MAX</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>year</name> <operator>=</operator> <name>result</name> <operator>/</operator> <literal type="number">12</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>month</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>%</operator> <literal type="number">12</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>day</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name>year</name></expr></argument>, <argument><expr><name>month</name></expr></argument>, <argument><expr><name>day</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Handle days and weeks */</comment>

		<if_stmt><if>if <condition>(<expr><name>date</name> <operator>&lt;</operator> <name>origin_date</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"origin must be before the given date"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>delta</name> <operator>=</operator> <name>date</name> <operator>-</operator> <name>origin_date</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bucket_number</name> <operator>=</operator> <name>delta</name> <operator>/</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>date</name> <operator>=</operator> <name>origin_date</name> <operator>+</operator> <name>bucket_number</name> <operator>*</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_time_bucket_ng_timezone</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>timestamp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>interval</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>timestamptz</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>tzname</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Convert 'timestamptz' to TIMESTAMP at given 'tzname'.
	 * The code is equal to 'timestamptz AT TIME ZONE tzname'.
	 */</comment>
	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><name>timestamptz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Then treat resulting timestamp as a regular one */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator>
		<call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_timestamp</name></expr></argument>, <argument><expr><name>interval</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_timezone_origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>TSDLLEXPORT</name> <name>Datum</name></type>
<name>ts_time_bucket_ng_timezone_origin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>timestamp</name></decl>, <decl><type ref="prev"/><name>origin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>interval</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>timestamptz</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>origintz</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>tzname</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Convert 'origin' to TIMESTAMP at given 'tzname'.
	 * The code is equal to 'origin AT TIME ZONE tzname'.
	 */</comment>
	<expr_stmt><expr><name>origin</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><name>origintz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Same for 'timestamptz' */</comment>
	<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamptz_zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><name>timestamptz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Then treat resulting 'timestamp' and 'origin' as a regular ones */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(
		<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>ts_time_bucket_ng_timestamp</name></expr></argument>, <argument><expr><name>interval</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
