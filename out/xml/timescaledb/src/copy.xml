<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/copy.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>

<comment type="block">/*
 * This file contains source code that was copied and/or modified from
 * the PostgreSQL database, which is licensed under the open-source
 * PostgreSQL License. Please see the NOTICE at the top level
 * directory for a copy of the PostgreSQL License.
 *
 * The code copies data to a hypertable or migrates existing data from
 * a table to a hypertable when create_hypertable(..., migrate_data =&gt;
 * 'true', ...) is called.
 *
 * Unfortunately, there aren't any good hooks in the regular COPY code to
 * insert our chunk dispatching. So, most of this code is a straight-up
 * copy of the regular PostgreSQL source code for the COPY command
 * (command/copy.c and command/copyfrom.c), albeit with minor modifications.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/heapam.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/hio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/sysattr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;access/xact.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_trigger_d.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/copy.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/tablecmds.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/trigger.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/executor.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;executor/nodeModifyTable.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/optimizer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_coerce.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_collate.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_expr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_relation.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/bufmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;storage/smgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/elog.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/hsearch.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rel.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/rls.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cross_module_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dimension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/chunk_insert_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"subspace_store.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/copyfrom_internal.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * No more than this many tuples per TSCopyMultiInsertBuffer
 *
 * Caution: Don't make this too big, as we could end up with this many
 * TSCopyMultiInsertBuffer items stored in TSCopyMultiInsertInfo's
 * multiInsertBuffers list.  Increasing this can cause quadratic growth in
 * memory requirements during copies into partitioned tables with a large
 * number of partitions.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BUFFERED_TUPLES</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/*
 * Flush buffers if there are &gt;= this many bytes, as counted by the input
 * size, of tuples stored.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BUFFERED_BYTES</name></cpp:macro> <cpp:value>65535</cpp:value></cpp:define>

<comment type="block">/* Trim the list of buffers back down to this number after flushing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PARTITION_BUFFERS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<comment type="block">/* Stores multi-insert data related to a single relation in CopyFrom. */</comment>
<typedef>typedef <type><struct>struct <name>TSCopyMultiInsertBuffer</name>
<block>{
	<comment type="block">/*
	 * Tuple description for inserted tuple slots. We use a copy of the result
	 * relation tupdesc to disable reference counting for this tupdesc. It is
	 * not needed and is wasting a lot of CPU in ResourceOwner.
	 */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name><name>slots</name><index>[<expr><name>MAX_BUFFERED_TUPLES</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Array to store tuples */</comment>
	<decl_stmt><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name></decl>;</decl_stmt>								<comment type="block">/* The point in space of this buffer */</comment>
	<decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl>;</decl_stmt>					<comment type="block">/* BulkInsertState for this buffer */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nused</name></decl>;</decl_stmt>									<comment type="block">/* number of 'slots' containing tuples */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name><name>linenos</name><index>[<expr><name>MAX_BUFFERED_TUPLES</name></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* Line # of tuple in copy
												 * stream */</comment>
}</block></struct></type> <name>TSCopyMultiInsertBuffer</name>;</typedef>

<comment type="block">/*
 * Stores one or many TSCopyMultiInsertBuffers and details about the size and
 * number of tuples which are stored in them.  This allows multiple buffers to
 * exist at once when COPYing into a partitioned table.
 *
 * The HTAB is used to store the relationship between a chunk and a
 * TSCopyMultiInsertBuffer beyond the lifetime of the ChunkInsertState.
 *
 * Chunks can be closed (e.g., due to timescaledb.max_open_chunks_per_insert).
 * When ts_chunk_dispatch_get_chunk_insert_state is called again for a closed
 * chunk, a new ChunkInsertState is returned.
 */</comment>
<typedef>typedef <type><struct>struct <name>TSCopyMultiInsertInfo</name>
<block>{
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>multiInsertBuffers</name></decl>;</decl_stmt> <comment type="block">/* Maps the chunk ids to the buffers (chunkid -&gt;
								 TSCopyMultiInsertBuffer) */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>bufferedTuples</name></decl>;</decl_stmt>		  <comment type="block">/* number of tuples buffered over all buffers */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>bufferedBytes</name></decl>;</decl_stmt>		  <comment type="block">/* number of bytes from all buffered tuples */</comment>
	<decl_stmt><decl><type><name>CopyChunkState</name> <modifier>*</modifier></type><name>ccstate</name></decl>;</decl_stmt>  <comment type="block">/* Copy chunk state for this TSCopyMultiInsertInfo */</comment>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>			  <comment type="block">/* Executor state used for COPY */</comment>
	<decl_stmt><decl><type><name>CommandId</name></type> <name>mycid</name></decl>;</decl_stmt>		  <comment type="block">/* Command Id used for COPY */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>ti_options</name></decl>;</decl_stmt>			  <comment type="block">/* table insert options */</comment>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>			  <comment type="block">/* The hypertable for the inserts */</comment>
}</block></struct></type> <name>TSCopyMultiInsertInfo</name>;</typedef>

<comment type="block">/*
 * The entry of the multiInsertBuffers HTAB.
 */</comment>
<typedef>typedef <type><struct>struct <name>MultiInsertBufferEntry</name>
<block>{
	<decl_stmt><decl><type><name>int32</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSCopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
}</block></struct></type> <name>MultiInsertBufferEntry</name>;</typedef>

<comment type="block">/*
 * Represents the heap insert method to be used during COPY FROM.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
<typedef>typedef <type><enum>enum <name>CopyInsertMethod</name>
<block>{
	<decl><name>CIM_SINGLE</name></decl>,			  <comment type="block">/* use table_tuple_insert or fdw routine */</comment>
	<decl><name>CIM_MULTI_CONDITIONAL</name></decl> <comment type="block">/* use table_multi_insert only if valid */</comment>
}</block></enum></type> <name>CopyInsertMethod</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Change to another chunk for inserts.
 *
 * Called every time we switch to another chunk for inserts.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>on_chunk_insert_state_changed</name><parameter_list>(<parameter><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Chunk changed, so release the buffer held in BulkInsertState */</comment>
	<expr_stmt><expr><call><name>ReleaseBulkInsertStatePin</name><argument_list>(<argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CopyChunkState</name> <modifier>*</modifier></type>
<name>copy_chunk_state_create</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>CopyFromFunc</name></type> <name>from_func</name></decl></parameter>, <parameter><decl><type><name>CopyFromState</name></type> <name>cstate</name></decl></parameter>,
						<parameter><decl><type><name>TableScanDesc</name></type> <name>scandesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyChunkState</name> <modifier>*</modifier></type><name>ccstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ccstate</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyChunkState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ccstate</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ccstate</name><operator>-&gt;</operator><name>dispatch</name></name> <operator>=</operator> <call><name>ts_chunk_dispatch_create</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ccstate</name><operator>-&gt;</operator><name>cstate</name></name> <operator>=</operator> <name>cstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ccstate</name><operator>-&gt;</operator><name>scandesc</name></name> <operator>=</operator> <name>scandesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ccstate</name><operator>-&gt;</operator><name>next_copy_from</name></name> <operator>=</operator> <name>from_func</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ccstate</name><operator>-&gt;</operator><name>where_clause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>ccstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate memory and initialize a new TSCopyMultiInsertBuffer for this
 * ResultRelInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>TSCopyMultiInsertBuffer</name> <modifier>*</modifier></type>
<name>TSCopyMultiInsertBufferInit</name><parameter_list>(<parameter><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>cis</name></decl></parameter>, <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSCopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>TSCopyMultiInsertBuffer</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TSCopyMultiInsertBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleTableSlot</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_BUFFERED_TUPLES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>bistate</name></name> <operator>=</operator> <call><name>GetBulkInsertState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>point</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>POINT_SIZE</name><argument_list>(<argument><expr><name><name>point</name><operator>-&gt;</operator><name>num_coords</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>point</name></name></expr></argument>, <argument><expr><name>point</name></expr></argument>, <argument><expr><call><name>POINT_SIZE</name><argument_list>(<argument><expr><name><name>point</name><operator>-&gt;</operator><name>num_coords</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make a non-refcounted copy of tupdesc to avoid spending CPU in
	 * ResourceOwner when creating a big number of table slots. This happens
	 * because each new slot pins its tuple descriptor using PinTupleDesc, and
	 * for reference-counting tuples this involves adding a new reference to
	 * ResourceOwner, which is not very efficient for a large number of
	 * references.
	 */</comment>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopyConstr</name><argument_list>(<argument><expr><name><name>cis</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the existing TSCopyMultiInsertBuffer for the chunk or create a new one.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>TSCopyMultiInsertBuffer</name> <modifier>*</modifier></type>
<name>TSCopyMultiInsertInfoGetOrSetupBuffer</name><parameter_list>(<parameter><decl><type><name>TSCopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>, <parameter><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>cis</name></decl></parameter>,
									  <parameter><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>chunk_id</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>miinfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cis</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>point</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunk_id</name> <operator>=</operator> <name><name>cis</name><operator>-&gt;</operator><name>chunk_id</name></name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>MultiInsertBufferEntry</name> <modifier>*</modifier></type><name>entry</name> <init>=
		<expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>chunk_id</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* No insert buffer for this chunk exists, create a new one */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>TSCopyMultiInsertBufferInit</name><argument_list>(<argument><expr><name>cis</name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new HTAB that maps from the chunk_id to the multi-insert buffers.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>TSCopyCreateNewInsertBufferHashMap</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>HASHCTL</name></name></type> <name>hctl</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>keysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MultiInsertBufferEntry</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>hcxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize an already allocated TSCopyMultiInsertInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TSCopyMultiInsertInfoInit</name><parameter_list>(<parameter><decl><type><name>TSCopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name></decl></parameter>,
						  <parameter><decl><type><name>CopyChunkState</name> <modifier>*</modifier></type><name>ccstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>mycid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ti_options</name></decl></parameter>,
						  <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name> <operator>=</operator> <call><name>TSCopyCreateNewInsertBufferHashMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedBytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>ccstate</name></name> <operator>=</operator> <name>ccstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>mycid</name></name> <operator>=</operator> <name>mycid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>ti_options</name></name> <operator>=</operator> <name>ti_options</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>ht</name></name> <operator>=</operator> <name>ht</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if the buffers are full.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>TSCopyMultiInsertInfoIsFull</name><parameter_list>(<parameter><decl><type><name>TSCopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedTuples</name></name> <operator>&gt;=</operator> <name>MAX_BUFFERED_TUPLES</name> <operator>||</operator>
		<name><name>miinfo</name><operator>-&gt;</operator><name>bufferedBytes</name></name> <operator>&gt;=</operator> <name>MAX_BUFFERED_BYTES</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write the tuples stored in 'buffer' out to the table.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>TSCopyMultiInsertBufferFlush</name><parameter_list>(<parameter><decl><type><name>TSCopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>, <parameter><decl><type><name>TSCopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>miinfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>miinfo</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type> <name>mycid</name> <init>= <expr><name><name>miinfo</name><operator>-&gt;</operator><name>mycid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ti_options</name> <init>= <expr><name><name>miinfo</name><operator>-&gt;</operator><name>ti_options</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nused</name> <init>= <expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>slots</name> <init>= <expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * table_multi_insert and reinitialization of the chunk insert state may
	 * leak memory, so switch to short-lived memory context before calling it.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * A chunk can be closed while buffering the tuples. Even when the chunk
	 * insert state is moved to the copy memory context, the underlying
	 * table is closed and pointers (e.g., result_relation_info point) to invalid
	 * addresses. Re-reading the chunk insert state ensures that the table is
	 * open and the pointers are valid.
	 *
	 * No callback on changed chunk is needed, the bulk insert state buffer is
	 * freed in TSCopyMultiInsertBufferCleanup().
	 */</comment>
	<decl_stmt><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>cis</name> <init>=
		<expr><call><name>ts_chunk_dispatch_get_chunk_insert_state</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>ccstate</name><operator>-&gt;</operator><name>dispatch</name></name></expr></argument>,
												 <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>point</name></name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* on chunk changed function */</comment>,
												 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* payload for on chunk changed function */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>cis</name><operator>-&gt;</operator><name>result_relation_info</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Add context information to the copy state, which is used to display
	 * error messages with additional details. Providing this information is
	 * only possible in PG &gt;= 14. Until PG13 the CopyFromState structure is
	 * kept internally in copy.c and no access to its members is possible.
	 * Since PG14, the structure is stored in copyfrom_internal.h and the
	 * members can be accessed.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<decl_stmt><decl><type><name>uint64</name></type> <name>save_cur_lineno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>line_buf_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyFromState</name></type> <name>cstate</name> <init>= <expr><name><name>miinfo</name><operator>-&gt;</operator><name>ccstate</name><operator>-&gt;</operator><name>cstate</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* cstate can be NULL in calls that are invoked from timescaledb_move_from_table_to_chunks. */</comment>
	<if_stmt><if>if <condition>(<expr><name>cstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>line_buf_valid</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>line_buf_valid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>save_cur_lineno</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>table_multi_insert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
					   <argument><expr><name>slots</name></expr></argument>,
					   <argument><expr><name>nused</name></expr></argument>,
					   <argument><expr><name>mycid</name></expr></argument>,
					   <argument><expr><name>ti_options</name></expr></argument>,
					   <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>bistate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nused</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name>cstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>linenos</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/*
		 * If there are any indexes, update them for all the inserted tuples,
		 * and run AFTER ROW INSERT triggers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>recheckIndexes</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuplesCompat</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
														 <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
														 <argument><expr><name>estate</name></expr></argument>,
														 <argument><expr><name>false</name></expr></argument>,
														 <argument><expr><name>false</name></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>,
														 <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
								 <argument><expr><name>resultRelInfo</name></expr></argument>,
								 <argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								 <argument><expr><name>recheckIndexes</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* transition capture */</comment>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * There's no indexes, but see if we need to run AFTER ROW INSERT
		 * triggers anyway.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_after_row</name></name> <operator>||</operator>
				  <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_new_table</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
								 <argument><expr><name>resultRelInfo</name></expr></argument>,
								 <argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								 <argument><expr><name>NIL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* transition capture */</comment>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Mark that all slots are free */</comment>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Chunk could be closed on a subsequent call of ts_chunk_dispatch_get_chunk_insert_state
	 * (e.g., due to timescaledb.max_open_chunks_per_insert). So, ensure the bulk insert is
	 * finished after the flush is complete.
	 */</comment>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>result_relation_info</name> <init>= <expr><name><name>cis</name><operator>-&gt;</operator><name>result_relation_info</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result_relation_info</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_finish_bulk_insert</name><argument_list>(<argument><expr><name><name>result_relation_info</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>ti_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset cur_lineno and line_buf_valid to what they were */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>cstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf_valid</name></name> <operator>=</operator> <name>line_buf_valid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name> <operator>=</operator> <name>save_cur_lineno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name><name>cis</name><operator>-&gt;</operator><name>chunk_id</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Drop used slots and free member for this buffer.
 *
 * The buffer must be flushed before cleanup.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>TSCopyMultiInsertBufferCleanup</name><parameter_list>(<parameter><decl><type><name>TSCopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>, <parameter><decl><type><name>TSCopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Ensure buffer was flushed */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>bistate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Since we only create slots on demand, just drop the non-null ones. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_BUFFERED_TUPLES</name> <operator>&amp;&amp;</operator> <name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>point</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_LT</name></expr></cpp:if>
<comment type="block">/* list_sort comparator to sort TSCopyMultiInsertBuffer by usage */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>TSCmpBuffersByUsage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>b1</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>TSCopyMultiInsertBuffer</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>ListCell</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>nused</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>b2</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>TSCopyMultiInsertBuffer</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>ListCell</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>nused</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>b1</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>b2</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><operator>(</operator><name>b1</name> <operator>&gt;</operator> <name>b2</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>b1</name> <operator>==</operator> <name>b2</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* list_sort comparator to sort TSCopyMultiInsertBuffer by usage */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>TSCmpBuffersByUsage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>b1</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>TSCopyMultiInsertBuffer</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>nused</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>b2</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>TSCopyMultiInsertBuffer</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>nused</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>b1</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>b2</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><operator>(</operator><name>b1</name> <operator>&gt;</operator> <name>b2</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>b1</name> <operator>==</operator> <name>b2</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Flush all buffers by writing the tuples to the chunks. In addition, trim down the
 * amount of multi-insert buffers to MAX_PARTITION_BUFFERS by deleting the least used
 * buffers (the buffers that store least tuples).
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>TSCopyMultiInsertInfoFlush</name><parameter_list>(<parameter><decl><type><name>TSCopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>, <parameter><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>cur_cis</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiInsertBufferEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>current_multi_insert_buffers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>buffers_to_delete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>flushed_chunk_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>buffer_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>current_multi_insert_buffers</name> <operator>=</operator> <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a list of buffers that can be sorted by usage */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>buffer_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>buffer_list</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>buffers_to_delete</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>current_multi_insert_buffers</name> <operator>-</operator> <name>MAX_PARTITION_BUFFERS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sorting is only needed if we want to remove the least used buffers */</comment>
	<if_stmt><if>if <condition>(<expr><name>buffers_to_delete</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>buffer_list</name> <operator>=</operator> <call><name>list_sort_compat</name><argument_list>(<argument><expr><name>buffer_list</name></expr></argument>, <argument><expr><name>TSCmpBuffersByUsage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Flush buffers and delete them if needed */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>buffer_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TSCopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><operator>(</operator><name>TSCopyMultiInsertBuffer</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>flushed_chunk_id</name> <operator>=</operator> <call><name>TSCopyMultiInsertBufferFlush</name><argument_list>(<argument><expr><name>miinfo</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>buffers_to_delete</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Reduce active multi-insert buffers. However, the current used buffer
			 * should not be deleted because it might reused for the next insert.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>cur_cis</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>flushed_chunk_id</name> <operator>!=</operator> <name><name>cur_cis</name><operator>-&gt;</operator><name>chunk_id</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>TSCopyMultiInsertBufferCleanup</name><argument_list>(<argument><expr><name>miinfo</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flushed_chunk_id</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>buffers_to_delete</name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>buffer_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* All buffers have been flushed */</comment>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedBytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * All existing buffers are flushed and the multi-insert states
 * are freed. So, delete old hash map and create a new one for further
 * inserts.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>TSCopyMultiInsertInfoFlushAndCleanup</name><parameter_list>(<parameter><decl><type><name>TSCopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>TSCopyMultiInsertInfoFlush</name><argument_list>(<argument><expr><name>miinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiInsertBufferEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TSCopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>TSCopyMultiInsertBufferCleanup</name><argument_list>(<argument><expr><name>miinfo</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>miinfo</name><operator>-&gt;</operator><name>multiInsertBuffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the next TupleTableSlot that the next tuple should be stored in.
 *
 * Callers must ensure that the buffer is not full.
 *
 * Note: 'miinfo' is unused but has been included for consistency with the
 * other functions in this area.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>TSCopyMultiInsertInfoNextFreeSlot</name><parameter_list>(<parameter><decl><type><name>TSCopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>,
								  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>result_relation_info</name></decl></parameter>,
								  <parameter><decl><type><name>TSCopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>nused</name> <init>= <expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nused</name> <operator>&lt;</operator> <name>MAX_BUFFERED_TUPLES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>nused</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type><name>tts_cb</name> <init>=
			<expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name><name>result_relation_info</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>nused</name></expr>]</index></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>tts_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>nused</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Record the previously reserved TupleTableSlot that was reserved by
 * TSCopyMultiInsertInfoNextFreeSlot as being consumed.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>TSCopyMultiInsertInfoStore</name><parameter_list>(<parameter><decl><type><name>TSCopyMultiInsertInfo</name> <modifier>*</modifier></type><name>miinfo</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rri</name></decl></parameter>,
						   <parameter><decl><type><name>TSCopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						   <parameter><decl><type><name>CopyFromState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>==</operator> <name><name>buffer</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store the line number so we can properly report any errors later */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>lineno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* The structure CopyFromState is private in PG &lt; 14. So we can not access
	 * the members like the line number or the size of the tuple.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>cstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lineno</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cur_lineno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>linenos</name><index>[<expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name></expr>]</index></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>

	<comment type="block">/* Record this slot as being used */</comment>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>nused</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Update how many tuples are stored and their size */</comment>
	<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedTuples</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: There is no reliable way to determine the in-memory size of a virtual
	 * tuple. So, we perform flushing in PG &lt; 14 only based on the number of buffered
	 * tuples and not based on the size.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>cstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>tuplen</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>line_buf</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>miinfo</name><operator>-&gt;</operator><name>bufferedBytes</name></name> <operator>+=</operator> <name>tuplen</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_chunk_state_destroy</name><parameter_list>(<parameter><decl><type><name>CopyChunkState</name> <modifier>*</modifier></type><name>ccstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ts_chunk_dispatch_destroy</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>dispatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>next_copy_from</name><parameter_list>(<parameter><decl><type><name>CopyChunkState</name> <modifier>*</modifier></type><name>ccstate</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>cstate</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>NextCopyFrom</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>cstate</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Error context callback when copying from table to chunk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_table_to_chunk_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scandesc</name> <init>= <expr><operator>(</operator><name>TableScanDesc</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"copying from table %s"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scandesc</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Tests if there are other before insert row triggers besides the
 * ts_insert_blocker trigger.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>has_other_before_insert_row_trigger_than_ts</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>trigdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_TYPE_MATCHES</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_ROW</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_BEFORE</name></expr></argument>,
								  <argument><expr><name>TRIGGER_TYPE_INSERT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Ignore the ts_insert_block trigger */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>, <argument><expr><name>INSERT_BLOCKER_NAME</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* At least one trigger exists */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Use COPY FROM to copy data from file to relation.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>copyfrom</name><parameter_list>(<parameter><decl><type><name>CopyChunkState</name> <modifier>*</modifier></type><name>ccstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>range_table</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>copycontext</name></decl></parameter>,
		 <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>callback</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>saved_resultRelInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* if copies are directed to a chunk that is compressed, we redirect
	 * them to the internal compressed chunk. But we still
	 * need to check triggers, constrainst etc. against the original
	 * chunk (not the internal compressed chunk).
	 * check_resultRelInfo saves that information
	 */</comment>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>check_resultRelInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>ccstate</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* for ExecConstraints() */</comment>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>singleslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>callback</name> <operator>=</operator> <name>callback</name></expr>,
		<expr><operator>.</operator><name>arg</name> <operator>=</operator> <name>arg</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type> <name>mycid</name> <init>= <expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyInsertMethod</name></type> <name>insertMethod</name></decl>;</decl_stmt>				   <comment type="block">/* The insert method for the table */</comment>
	<decl_stmt><decl><type><name>CopyInsertMethod</name></type> <name>currentTupleInsertMethod</name></decl>;</decl_stmt>	   <comment type="block">/* The insert method of the current tuple */</comment>
	<decl_stmt><decl><type><name>TSCopyMultiInsertInfo</name></type> <name>multiInsertInfo</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt> <comment type="block">/* pacify compiler */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>ti_options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>							   <comment type="block">/* start with default options for insert */</comment>
	<decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_before_insert_row_trig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_instead_insert_row_trig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>qualexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkDispatch</name> <modifier>*</modifier></type><name>dispatch</name> <init>= <expr><name><name>ccstate</name><operator>-&gt;</operator><name>dispatch</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>range_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to view \"%s\""</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to materialized view \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to foreign table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to sequence \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot copy to non-table relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*----------
	 * Check to see if we can avoid writing WAL
	 *
	 * If archive logging/streaming is not enabled *and* either
	 *	- table was created in same transaction as this COPY
	 *	- data is being written to relfilenode created in this transaction
	 * then we can skip writing WAL.  It's safe because if the transaction
	 * doesn't commit, we'll discard the table (or the new relfilenode file).
	 * If it does commit, we'll have done the heap_sync at the bottom of this
	 * routine first.
	 *
	 * As mentioned in comments in utils/rel.h, the in-same-transaction test
	 * is not always set correctly, since in rare cases rd_newRelfilenodeSubid
	 * can be cleared before the end of the transaction. The exact case is
	 * when a relation sets a new relfilenode twice in same transaction, yet
	 * the second one fails in an aborted subtransaction, e.g.
	 *
	 * BEGIN;
	 * TRUNCATE t;
	 * SAVEPOINT save;
	 * TRUNCATE t;
	 * ROLLBACK TO save;
	 * COPY ...
	 *
	 * Also, if the target file is new-in-transaction, we assume that checking
	 * FSM for free space is a waste of time, even if we must use WAL because
	 * of archiving.  This could possibly be wrong, but it's unlikely.
	 *
	 * The comments for heap_insert and RelationGetBufferForTuple specify that
	 * skipping WAL logging is only safe if we ensure that our tuples do not
	 * go into pages containing tuples from any other transactions --- but this
	 * must be the case if we have a new table or new relfilenode, so we need
	 * no additional work to enforce that.
	 *----------
	 */</comment>
	<comment type="block">/* createSubid is creation check, newRelfilenodeSubid is truncation check */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name> <operator>||</operator>
		<name><name>ccstate</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ti_options</name> <operator>|=</operator> <name>HEAP_INSERT_SKIP_FSM</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_LT</name></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ti_options</name> <operator>|=</operator> <name>HEAP_INSERT_SKIP_WAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We need a ResultRelInfo so we can use the regular executor's
	 * index-entry-making machinery.  (There used to be a huge amount of code
	 * here that basically duplicated execUtils.c ...)
	 *
	 * WARNING. The dummy rangetable index is decremented by 1 (unchecked)
	 * inside `ExecConstraints` so unless you want to have a overflow, keep it
	 * above zero. See `rt_fetch` in parsetree.h.
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
					  <argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
					  <comment type="block">/* RangeTableIndex */</comment> <argument><expr><literal type="number">1</literal></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>ExecInitRangeTable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>range_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecInitResultRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>CheckValidResultRel</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name> <operator>=</operator> <name>range_table</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecInitRangeTable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatch</name><operator>-&gt;</operator><name>hypertable_result_rel_info</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dispatch</name><operator>-&gt;</operator><name>hypertable_result_rel_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>singleslot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare to catch AFTER triggers. */</comment>
	<expr_stmt><expr><call><name>AfterTriggerBeginQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ccstate</name><operator>-&gt;</operator><name>where_clause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>qualexpr</name> <operator>=</operator> <call><name>ExecInitQual</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>where_clause</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check BEFORE STATEMENT insertion triggers. It's debatable whether we
	 * should do this for COPY, since it's not really an "INSERT" statement as
	 * such. However, executing these triggers maintains consistency with the
	 * EACH ROW triggers that we already fire on COPY.
	 */</comment>
	<expr_stmt><expr><call><name>ExecBSInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bistate</name> <operator>=</operator> <call><name>GetBulkInsertState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up callback to identify error line number.
	 *
	 * It is not necessary to add an entry to the error context stack if we do
	 * not have a CopyFromState or callback. In that case, we just use the existing
	 * error already on the context stack. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ccstate</name><operator>-&gt;</operator><name>cstate</name></name> <operator>&amp;&amp;</operator> <name>callback</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Multi-insert buffers (CIM_MULTI_CONDITIONAL) can only be used if no triggers are
	 * defined on the target table. Otherwise, the tuples may be inserted in an out-of-order
	 * manner, which might violate the semantics of the triggers. So, they are inserted
	 * tuple-per-tuple (CIM_SINGLE). However, the ts_block trigger on the hypertable can
	 * be ignored.
	 */</comment>

	<comment type="block">/* Before INSERT Triggers */</comment>
	<expr_stmt><expr><name>has_before_insert_row_trig</name> <operator>=</operator> <call><name>has_other_before_insert_row_trigger_than_ts</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Instead of INSERT Triggers */</comment>
	<expr_stmt><expr><name>has_instead_insert_row_trig</name> <operator>=</operator>
		<operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Depending on the configured trigger, enable or disable the multi-insert buffers */</comment>
	<if_stmt><if>if <condition>(<expr><name>has_before_insert_row_trig</name> <operator>||</operator> <name>has_instead_insert_row_trig</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>insertMethod</name> <operator>=</operator> <name>CIM_SINGLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Using normal unbuffered copy operation (CIM_SINGLE) "</literal>
						<literal type="string">"because triggers are defined on the destination table."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>insertMethod</name> <operator>=</operator> <name>CIM_MULTI_CONDITIONAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Using optimized multi-buffer copy operation (CIM_MULTI_CONDITIONAL)."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TSCopyMultiInsertInfoInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>,
								  <argument><expr><name>resultRelInfo</name></expr></argument>,
								  <argument><expr><name>ccstate</name></expr></argument>,
								  <argument><expr><name>estate</name></expr></argument>,
								  <argument><expr><name>mycid</name></expr></argument>,
								  <argument><expr><name>ti_options</name></expr></argument>,
								  <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>myslot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>skip_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Point</name> <modifier>*</modifier></type><name>point</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ChunkInsertState</name> <modifier>*</modifier></type><name>cis</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TSCopyMultiInsertBuffer</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset the per-tuple exprcontext. We do this after every tuple, to
		 * clean-up after expression evaluations etc.
		 */</comment>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>myslot</name> <operator>=</operator> <name>singleslot</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>myslot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Switch into its memory context */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ccstate</name><operator>-&gt;</operator><name>next_copy_from</name></name><argument_list>(<argument><expr><name>ccstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Calculate the tuple's point in the N-dimensional hyperspace */</comment>
		<expr_stmt><expr><name>point</name> <operator>=</operator> <call><name>ts_hyperspace_calculate_point</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Find or create the insert state matching the point */</comment>
		<expr_stmt><expr><name>cis</name> <operator>=</operator> <call><name>ts_chunk_dispatch_get_chunk_insert_state</name><argument_list>(<argument><expr><name>dispatch</name></expr></argument>,
													   <argument><expr><name>point</name></expr></argument>,
													   <argument><expr><name>on_chunk_insert_state_changed</name></expr></argument>,
													   <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cis</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Triggers and stuff need to be invoked in query context. */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>currentTupleInsertMethod</name> <operator>=</operator> <name>insertMethod</name></expr>;</expr_stmt>

		<comment type="block">/* Insert tuples into compressed chunks tuple by tuple */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cis</name><operator>-&gt;</operator><name>compress_info</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>currentTupleInsertMethod</name> <operator>=</operator> <name>CIM_SINGLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Determine which triggers exist on this chunk */</comment>
		<expr_stmt><expr><name>has_before_insert_row_trig</name> <operator>=</operator>
			<operator>(</operator><name><name>cis</name><operator>-&gt;</operator><name>result_relation_info</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
			 <name><name>cis</name><operator>-&gt;</operator><name>result_relation_info</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>has_instead_insert_row_trig</name> <operator>=</operator>
			<operator>(</operator><name><name>cis</name><operator>-&gt;</operator><name>result_relation_info</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
			 <name><name>cis</name><operator>-&gt;</operator><name>result_relation_info</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>has_before_insert_row_trig</name> <operator>||</operator> <name>has_instead_insert_row_trig</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Flush pending inserts if this partition can't use
			 * batching, so rows are visible to triggers etc.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>insertMethod</name> <operator>==</operator> <name>CIM_MULTI_CONDITIONAL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>TSCopyMultiInsertInfoFlush</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>, <argument><expr><name>cis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>currentTupleInsertMethod</name> <operator>=</operator> <name>CIM_SINGLE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Convert the tuple to match the chunk's rowtype */</comment>
		<if_stmt><if>if <condition>(<expr><name>currentTupleInsertMethod</name> <operator>==</operator> <name>CIM_SINGLE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>cis</name><operator>-&gt;</operator><name>hyper_to_chunk_map</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>myslot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name><name>cis</name><operator>-&gt;</operator><name>hyper_to_chunk_map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name><name>cis</name><operator>-&gt;</operator><name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Get the multi-insert buffer for the chunk.
			 */</comment>
			<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>TSCopyMultiInsertInfoGetOrSetupBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>, <argument><expr><name>cis</name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Prepare to queue up tuple for later batch insert into
			 * current chunk.
			 */</comment>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>batchslot</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>batchslot</name> <operator>=</operator> <call><name>TSCopyMultiInsertInfoNextFreeSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>,
														  <argument><expr><name><name>cis</name><operator>-&gt;</operator><name>result_relation_info</name></name></expr></argument>,
														  <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>cis</name><operator>-&gt;</operator><name>hyper_to_chunk_map</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>myslot</name> <operator>=</operator> <call><name>execute_attr_map_slot</name><argument_list>(<argument><expr><name><name>cis</name><operator>-&gt;</operator><name>hyper_to_chunk_map</name><operator>-&gt;</operator><name>attrMap</name></name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>batchslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * This looks more expensive than it is (Believe me, I
				 * optimized it away. Twice.). The input is in virtual
				 * form, and we'll materialize the slot below - for most
				 * slot types the copy performs the work materialization
				 * would later require anyway.
				 */</comment>
				<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name>batchslot</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>myslot</name> <operator>=</operator> <name>batchslot</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>qualexpr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>myslot</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>qualexpr</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Set the result relation in the executor state to the target chunk.
		 * This makes sure that the tuple gets inserted into the correct
		 * chunk.
		 */</comment>
		<expr_stmt><expr><name>saved_resultRelInfo</name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>cis</name><operator>-&gt;</operator><name>result_relation_info</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name><name>cis</name><operator>-&gt;</operator><name>compress_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>check_resultRelInfo</name> <operator>=</operator> <name><name>cis</name><operator>-&gt;</operator><name>compress_info</name><operator>-&gt;</operator><name>orig_result_relation_info</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>check_resultRelInfo</name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Set the right relation for triggers */</comment>
		<expr_stmt><expr><call><name>ts_tuptableslot_set_table_oid</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>check_resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>skip_tuple</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* BEFORE ROW INSERT Triggers */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>check_resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
			<name><name>check_resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>skip_tuple</name> <operator>=</operator> <operator>!</operator><call><name>ExecBRInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>check_resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_tuple</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Note that PostgreSQL's copy path would check INSTEAD OF
			 * INSERT/UPDATE/DELETE triggers here, but such triggers can only
			 * exist on views and chunks cannot be views.
			 */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>recheckIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Compute stored generated columns */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>check_resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
				<name><name>check_resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecComputeStoredGeneratedCompat</name><argument_list>(<argument><expr><name>check_resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If the target is a plain table, check the constraints of
			 * the tuple.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>check_resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name><name>check_resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>check_resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>check_resultRelInfo</name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cis</name><operator>-&gt;</operator><name>compress_info</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>currentTupleInsertMethod</name> <operator>==</operator> <name>CIM_SINGLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>compress_slot</name> <init>=
					<expr><call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>compress_row_exec</name></name><argument_list>(<argument><expr><name><name>cis</name><operator>-&gt;</operator><name>compress_info</name><operator>-&gt;</operator><name>compress_state</name></name></expr></argument>, <argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<comment type="block">/* After Row triggers do not work with compressed chunks. So
				 * explicitly call cagg trigger here
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>cis</name><operator>-&gt;</operator><name>compress_info</name><operator>-&gt;</operator><name>has_cagg_trigger</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>HeapTupleTableSlot</name> <modifier>*</modifier></type><name>hslot</name> <init>= <expr><operator>(</operator><name>HeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>myslot</name></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
													   <argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
													   <argument><expr><name><name>myslot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>ts_compress_chunk_invoke_cagg_trigger</name><argument_list>(<argument><expr><name><name>cis</name><operator>-&gt;</operator><name>compress_info</name></name></expr></argument>,
														  <argument><expr><name><name>cis</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
														  <argument><expr><name><name>hslot</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>table_tuple_insert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
								   <argument><expr><name>compress_slot</name></expr></argument>,
								   <argument><expr><name>mycid</name></expr></argument>,
								   <argument><expr><name>ti_options</name></expr></argument>,
								   <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuplesCompat</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
																 <argument><expr><name>compress_slot</name></expr></argument>,
																 <argument><expr><name>estate</name></expr></argument>,
																 <argument><expr><name>false</name></expr></argument>,
																 <argument><expr><name>false</name></expr></argument>,
																 <argument><expr><name>NULL</name></expr></argument>,
																 <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>currentTupleInsertMethod</name> <operator>==</operator> <name>CIM_SINGLE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* OK, store the tuple and create index entries for it */</comment>
					<expr_stmt><expr><call><name>table_tuple_insert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
									   <argument><expr><name>myslot</name></expr></argument>,
									   <argument><expr><name>mycid</name></expr></argument>,
									   <argument><expr><name>ti_options</name></expr></argument>,
									   <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuplesCompat</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
																	 <argument><expr><name>myslot</name></expr></argument>,
																	 <argument><expr><name>estate</name></expr></argument>,
																	 <argument><expr><name>false</name></expr></argument>,
																	 <argument><expr><name>false</name></expr></argument>,
																	 <argument><expr><name>NULL</name></expr></argument>,
																	 <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* AFTER ROW INSERT Triggers */</comment>
					<expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										 <argument><expr><name>check_resultRelInfo</name></expr></argument>,
										 <argument><expr><name>myslot</name></expr></argument>,
										 <argument><expr><name>recheckIndexes</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* transition capture */</comment>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * The slot previously might point into the per-tuple
					 * context. For batching it needs to be longer lived.
					 */</comment>
					<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>myslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Add this tuple to the tuple buffer */</comment>
					<expr_stmt><expr><call><name>TSCopyMultiInsertInfoStore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>,
											   <argument><expr><name>resultRelInfo</name></expr></argument>,
											   <argument><expr><name>buffer</name></expr></argument>,
											   <argument><expr><name>myslot</name></expr></argument>,
											   <argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>cstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If enough inserts have queued up, then flush all
					 * buffers out to their tables.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>TSCopyMultiInsertInfoIsFull</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Flush called with %d bytes and %d buffered tuples"</literal></expr></argument>,
										<argument><expr><name><name>multiInsertInfo</name><operator>.</operator><name>bufferedBytes</name></name></expr></argument>,
										<argument><expr><name><name>multiInsertInfo</name><operator>.</operator><name>bufferedTuples</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>TSCopyMultiInsertInfoFlush</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>, <argument><expr><name>cis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We count only tuples not suppressed by a BEFORE INSERT trigger;
			 * this is the same definition used by execMain.c for counting
			 * tuples inserted by an INSERT command.
			 */</comment>
			<expr_stmt><expr><name>processed</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>saved_resultRelInfo</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name><name>ccstate</name><operator>-&gt;</operator><name>dispatch</name><operator>-&gt;</operator><name>hypertable_result_rel_info</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Flush any remaining buffered tuples */</comment>
	<if_stmt><if>if <condition>(<expr><name>insertMethod</name> <operator>!=</operator> <name>CIM_SINGLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TSCopyMultiInsertInfoFlushAndCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multiInsertInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Done, clean up */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Execute AFTER STATEMENT insertion triggers */</comment>
	<expr_stmt><expr><call><name>ExecASInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle queued AFTER triggers */</comment>
	<expr_stmt><expr><call><name>AfterTriggerEndQuery</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecResetTupleTable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Close any trigger target relations */</comment>
	<expr_stmt><expr><call><name>ExecCleanUpTriggerState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>ExecCloseResultRelations</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecCloseRangeTableRelations</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If we skipped writing WAL, then we need to sync the heap (but not
	 * indexes since those use WAL anyway)
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_LT</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>ti_options</name> <operator>&amp;</operator> <name>HEAP_INSERT_SKIP_WAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_sync</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrimmedsync</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CopyGetAttnums - build an integer list of attnums to be copied
 *
 * The input attnamelist is either the user-specified column list,
 * or NIL if there was none (in which case we want all the non-dropped
 * columns).
 *
 * rel can be NULL ... it's only used for error reports.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>timescaledb_CopyGetAttnums</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attnums</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnamelist</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Generate default column list */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>attr_count</name> <init>= <expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Validate the user-supplied list and extract attnums */</comment>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>attnamelist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>attnum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

			<comment type="block">/* Lookup column name */</comment>
			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Check for duplicates */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified more than once"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>attnums</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_constraints_and_check</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>xactReadOnly</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG13_GE</name></expr></cpp:if>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>=
		<expr><call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>=
		<expr><call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>ACL_INSERT</name></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>cur</argument>, <argument>attnums</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>attno</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExecCheckRTPerms</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Permission check for row security policies.
	 *
	 * check_enable_rls will ereport(ERROR) if the user has requested
	 * something invalid and will otherwise indicate if we should enable RLS
	 * (returns RLS_ENABLED) or not for this COPY statement.
	 *
	 * If the relation has a row security policy and we are to apply it then
	 * perform a "query" copy and allow the normal query processing to handle
	 * the policies.
	 *
	 * If RLS is not enabled for this, then just fall through to the normal
	 * non-filtering relation handling.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_enable_rls</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RLS_ENABLED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY FROM not supported with row-level security"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use INSERT statements instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check read-only transaction and parallel mode */</comment>
	<expr_stmt><expr><name>xactReadOnly</name> <operator>=</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>xactReadOnly</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><literal type="string">"COPY FROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PreventCommandIfParallelMode</name><argument_list>(<argument><expr><literal type="string">"COPY FROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>timescaledb_DoCopy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>processed</name></decl></parameter>, <parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyChunkState</name> <modifier>*</modifier></type><name>ccstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyFromState</name></type> <name>cstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>pipe</name> <init>= <expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>filename</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attnums</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>where_clause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>copycontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Disallow COPY to/from file or program except to superusers. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pipe</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to COPY to or from an external program"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Anyone can COPY to stdout or from stdin. "</literal>
							 <literal type="string">"psql's \\copy command also works for anyone."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to COPY to or from a file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Anyone can COPY to stdout or from stdin. "</literal>
							 <literal type="string">"psql's \\copy command also works for anyone."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_from</name></name> <operator>||</operator> <name>NULL</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"timescale DoCopy should only be called for COPY FROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We never actually write to the main table, but we need RowExclusiveLock
	 * to ensure no one else is. Because of the check above, we know that
	 * `stmt-&gt;relation` is defined, so we are guaranteed to have a relation
	 * available.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>timescaledb_CopyGetAttnums</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_constraints_and_check</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopyFrom</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
						   <argument><expr><name>rel</name></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
						   <argument><expr><name>NULL</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_program</name></name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>,
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>,
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY WHERE clauses are not supported on distributed hypertables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>where_clause</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_COPY_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>where_clause</name> <operator>=</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>where_clause</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>where_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>where_clause</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>where_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>where_clause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>where_clause</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>where_clause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>where_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ccstate</name> <operator>=</operator> <call><name>copy_chunk_state_create</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>next_copy_from</name></expr></argument>, <argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ccstate</name><operator>-&gt;</operator><name>where_clause</name></name> <operator>=</operator> <name>where_clause</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>processed</name> <operator>=</operator> <call><name><name>ts_cm_functions</name><operator>-&gt;</operator><name>distributed_copy</name></name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>ccstate</name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_GE</name></expr></cpp:if>
		<comment type="block">/* Take the copy memory context from cstate, if we can access the struct (PG&gt;=14) */</comment>
		<expr_stmt><expr><name>copycontext</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>copycontext</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<comment type="block">/* Or create a new memory context. */</comment>
		<expr_stmt><expr><name>copycontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><literal type="string">"COPY"</literal></expr></argument>, <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><operator>*</operator><name>processed</name> <operator>=</operator>
			<call><name>copyfrom</name><argument_list>(<argument><expr><name>ccstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>copycontext</name></expr></argument>, <argument><expr><name>CopyFromErrorCallback</name></expr></argument>, <argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>copy_chunk_state_destroy</name><argument_list>(<argument><expr><name>ccstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EndCopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>copycontext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>copycontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>next_copy_from_table_to_chunks</name><parameter_list>(<parameter><decl><type><name>CopyChunkState</name> <modifier>*</modifier></type><name>ccstate</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scandesc</name> <init>= <expr><name><name>ccstate</name><operator>-&gt;</operator><name>scandesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scandesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>ccstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Move data from the given hypertable's main table to chunks.
 *
 * The data moving is essentially a COPY from the main table to the chunks
 * followed by a TRUNCATE on the main table.
 */</comment>
<function><type><name>void</name></type>
<name>timescaledb_move_from_table_to_chunks</name><parameter_list>(<parameter><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyChunkState</name> <modifier>*</modifier></type><name>ccstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attnums</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>copycontext</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeVar</name></type> <name>rv</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>schemaname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>relname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>inh</name> <operator>=</operator> <name>false</name></expr>, <comment type="block">/* Don't recurse */</comment>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TruncateStmt</name></type> <name>stmt</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_TruncateStmt</name></expr>,
		<expr><operator>.</operator><name>relations</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rv</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>behavior</name> <operator>=</operator> <name>DROP_RESTRICT</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>copycontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><literal type="string">"COPY"</literal></expr></argument>, <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_constraints_and_check</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>table_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ccstate</name> <operator>=</operator> <call><name>copy_chunk_state_create</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>next_copy_from_table_to_chunks</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copyfrom</name><argument_list>(<argument><expr><name>ccstate</name></expr></argument>,
			 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>,
			 <argument><expr><name>ht</name></expr></argument>,
			 <argument><expr><name>copycontext</name></expr></argument>,
			 <argument><expr><name>copy_table_to_chunk_error_callback</name></expr></argument>,
			 <argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_chunk_state_destroy</name><argument_list>(<argument><expr><name>ccstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>copycontext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>copycontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecuteTruncate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
