<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/sort_transform.c"><comment type="block">/*
 * This file and its contents are licensed under the Apache License 2.0.
 * Please see the included NOTICE for copyright information and
 * LICENSE-APACHE for a copy of the license.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/makefuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/nodeFuncs.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/plannodes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/paths.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optimizer/planner.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parsetree.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/fmgroids.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"func_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sort_transform.h"</cpp:file></cpp:include>

<comment type="block">/* This optimizations allows GROUP BY clauses that transform time in
 * order-preserving ways to use indexes on the time field. It works
 * by transforming sorting clauses from their more complex versions
 * to simplified ones that can use the plain index, if the transform
 * is order preserving.
 *
 * For example, an ordering on date_trunc('minute', time) can be transformed
 * to an ordering on time.
 */</comment>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ts_sort_transform_optimization</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>transform_timestamp_cast</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * transform cast from timestamptz to timestamp
	 *
	 * timestamp(var) =&gt; var
	 *
	 * proof: timestamp(time1) &gt;= timestamp(time2) iff time1 &gt; time2
	 *
	 */</comment>

	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>first</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>func</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>first</name> <operator>=</operator> <call><name>ts_sort_transform_expr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>func</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>transform_timestamptz_cast</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Transform cast from date to timestamptz, or timestamp to timestamptz,
	 * or abstime to timestamptz Handles only single-argument versions of the
	 * cast to avoid explicit timezone specifiers
	 *
	 *
	 * timestamptz(var) =&gt; var
	 *
	 * proof: timestamptz(time1) &gt;= timestamptz(time2) iff time1 &gt; time2
	 *
	 */</comment>

	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>first</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>func</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>first</name> <operator>=</operator> <call><name>ts_sort_transform_expr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>func</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>transform_time_op_const_interval</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * optimize timestamp(tz) +/- const interval
	 *
	 * Sort of ts + 1 minute fulfilled by sort of ts
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>left</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>right</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>left</name> <operator>==</operator> <name>TIMESTAMPOID</name> <operator>&amp;&amp;</operator> <name>right</name> <operator>==</operator> <name>INTERVALOID</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>left</name> <operator>==</operator> <name>TIMESTAMPTZOID</name> <operator>&amp;&amp;</operator> <name>right</name> <operator>==</operator> <name>INTERVALOID</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>left</name> <operator>==</operator> <name>DATEOID</name> <operator>&amp;&amp;</operator> <name>right</name> <operator>==</operator> <name>INTERVALOID</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>get_opname</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>first</name> <init>= <expr><call><name>ts_sort_transform_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>op</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>transform_int_op_const</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Optimize int op const (or const op int), whenever possible. e.g. sort
	 * of  some_int + const fulfilled by sort of some_int same for the
	 * following operator: + - / *
	 *
	 * Note that / is not commutative and const / var does NOT work (namely it
	 * reverses sort order, which we don't handle yet)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>left</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>right</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>left</name> <operator>==</operator> <name>INT8OID</name> <operator>&amp;&amp;</operator> <name>right</name> <operator>==</operator> <name>INT8OID</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>left</name> <operator>==</operator> <name>INT4OID</name> <operator>&amp;&amp;</operator> <name>right</name> <operator>==</operator> <name>INT4OID</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>left</name> <operator>==</operator> <name>INT2OID</name> <operator>&amp;&amp;</operator> <name>right</name> <operator>==</operator> <name>INT2OID</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>get_opname</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<switch>switch <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="char">'-'</literal></expr>:</case>
					<case>case <expr><literal type="char">'+'</literal></expr>:</case>
					<case>case <expr><literal type="char">'*'</literal></expr>:</case>
						<comment type="block">/* commutative cases */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>nonconst</name> <init>= <expr><call><name>ts_sort_transform_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>nonconst</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>nonconst</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>nonconst</name> <init>= <expr><call><name>ts_sort_transform_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>nonconst</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>nonconst</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
						</block_content>}</block></else></if_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'/'</literal></expr>:</case>
						<comment type="block">/* only if second arg is const */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>nonconst</name> <init>= <expr><call><name>ts_sort_transform_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>nonconst</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>nonconst</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>op</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* sort_transforms_expr returns a simplified sort expression in a form
 * more common for indexes. Must return same data type &amp; collation too.
 *
 * Sort transforms have the following correctness condition:
 *	Any ordering provided by the returned expression is a valid
 *	ordering under the original expression. The reverse need not
 *	be true to apply the transformation to the last member of pathkeys
 *	but it would need to be true to apply the transformation to
 *	arbitrary members of pathkeys.
 *
 * Namely if orig_expr(X) &gt; orig_expr(Y) then
 *			 new_expr(X) &gt; new_expr(Y).
 *
 * Note that if orig_expr(X) = orig_expr(Y) then
 *			 the ordering under new_expr is unconstrained.
 * */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>ts_sort_transform_expr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>orig_expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>orig_expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>orig_expr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name> <init>= <expr><call><name>ts_func_cache_get_bucketing_func</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>finfo</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>finfo</name><operator>-&gt;</operator><name>sort_transform</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>orig_expr</name></expr>;</return></block_content></block></if></if_stmt>

			<return>return <expr><call><name><name>finfo</name><operator>-&gt;</operator><name>sort_transform</name></name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Functions of one argument that convert something to timestamp(tz). */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>funcid</name></name> <operator>==</operator> <name>F_DATE_TIMESTAMP</name> <operator>||</operator> <name><name>func</name><operator>-&gt;</operator><name>funcid</name></name> <operator>==</operator> <name>F_TIMESTAMPTZ_TIMESTAMP</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if_stmt><if>if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>funcid</name></name> <operator>==</operator> <name>F_TIMESTAMP_DATE</name> <operator>||</operator> <name><name>func</name><operator>-&gt;</operator><name>funcid</name></name> <operator>==</operator> <name>F_TIMESTAMP_TIMESTAMPTZ</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<return>return <expr><call><name>transform_timestamp_cast</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG14_LT</name></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>funcid</name></name> <operator>==</operator> <name>F_DATE_TIMESTAMPTZ</name> <operator>||</operator> <name><name>func</name><operator>-&gt;</operator><name>funcid</name></name> <operator>==</operator> <name>F_TIMESTAMP_TIMESTAMPTZ</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if_stmt><if>if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>funcid</name></name> <operator>==</operator> <name>F_TIMESTAMPTZ_DATE</name> <operator>||</operator> <name><name>func</name><operator>-&gt;</operator><name>funcid</name></name> <operator>==</operator> <name>F_TIMESTAMPTZ_TIMESTAMP</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<return>return <expr><call><name>transform_timestamptz_cast</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>orig_expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>orig_expr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>type_first</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>type_first</name> <operator>==</operator> <name>TIMESTAMPOID</name> <operator>||</operator> <name>type_first</name> <operator>==</operator> <name>TIMESTAMPTZOID</name> <operator>||</operator> <name>type_first</name> <operator>==</operator> <name>DATEOID</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>transform_time_op_const_interval</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>type_first</name> <operator>==</operator> <name>INT2OID</name> <operator>||</operator> <name>type_first</name> <operator>==</operator> <name>INT4OID</name> <operator>||</operator> <name>type_first</name> <operator>==</operator> <name>INT8OID</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>transform_int_op_const</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>orig_expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*	sort_transform_ec creates a new EquivalenceClass with transformed
 *	expressions if any of the members of the original EC can be transformed for the sort.
 */</comment>

<function><type><specifier>static</specifier> <name>EquivalenceClass</name> <modifier>*</modifier></type>
<name>sort_transform_ec</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_member</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>newec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>propagate_to_children</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check all members, adding only transformable members to new ec */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc_member</argument>, <argument>orig-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>ec_mem</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc_member</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>transformed_expr</name> <init>= <expr><call><name>ts_sort_transform_expr</name><argument_list>(<argument><expr><name><name>ec_mem</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>transformed_expr</name> <operator>!=</operator> <name><name>ec_mem</name><operator>-&gt;</operator><name>em_expr</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>type_oid</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>transformed_expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>opfamilies</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>orig</name><operator>-&gt;</operator><name>ec_opfamilies</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * if the transform already exists for even one member, assume
			 * exists for all
			 */</comment>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>exist</name> <init>= <expr><call><name>get_eclass_for_sort_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															   <argument><expr><name>transformed_expr</name></expr></argument>,
															   <argument><expr><name><name>ec_mem</name><operator>-&gt;</operator><name>em_nullable_relids</name></name></expr></argument>,
															   <argument><expr><name>opfamilies</name></expr></argument>,
															   <argument><expr><name>type_oid</name></expr></argument>,
															   <argument><expr><name><name>orig</name><operator>-&gt;</operator><name>ec_collation</name></name></expr></argument>,
															   <argument><expr><name><name>orig</name><operator>-&gt;</operator><name>ec_sortref</name></name></expr></argument>,
															   <argument><expr><name><name>ec_mem</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>,
															   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>exist</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>exist</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>em</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>EquivalenceMember</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name> <operator>=</operator> <name>transformed_expr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>ec_mem</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_nullable_relids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>ec_mem</name><operator>-&gt;</operator><name>em_nullable_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name> <operator>=</operator> <name><name>ec_mem</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>=</operator> <name><name>ec_mem</name><operator>-&gt;</operator><name>em_is_child</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name> <operator>=</operator> <name>type_oid</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>newec</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* lazy create the ec. */</comment>
				<expr_stmt><expr><name>newec</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>EquivalenceClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_opfamilies</name></name> <operator>=</operator> <name>opfamilies</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_collation</name></name> <operator>=</operator> <name><name>orig</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_members</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_sources</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>orig</name><operator>-&gt;</operator><name>ec_sources</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_derives</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>orig</name><operator>-&gt;</operator><name>ec_derives</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_relids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>orig</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_has_const</name></name> <operator>=</operator> <name><name>orig</name><operator>-&gt;</operator><name>ec_has_const</name></name></expr>;</expr_stmt>

				<comment type="block">/* Even if the original EC has volatile (it has time_bucket_gapfill)
				 * this ordering is purely on the time column, so it is non-volatile
				 * and should be propagated to the children.
				 */</comment>
				<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name> <operator>=</operator> <name><name>orig</name><operator>-&gt;</operator><name>ec_below_outer_join</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_broken</name></name> <operator>=</operator> <name><name>orig</name><operator>-&gt;</operator><name>ec_broken</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>=</operator> <name><name>orig</name><operator>-&gt;</operator><name>ec_sortref</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_merged</name></name> <operator>=</operator> <name><name>orig</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>;</expr_stmt>

				<comment type="block">/* Volatile ECs only ever have one member, that of the root,
				 * so if the original EC was volatile, we need to propagate the
				 * new EC to the children ourselves.
				 */</comment>
				<expr_stmt><expr><name>propagate_to_children</name> <operator>=</operator> <name><name>orig</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>;</expr_stmt>
				<comment type="block">/* Even though time_bucket_gapfill is marked as VOLATILE to
				 * prevent the planner from removing the call, it's still safe
				 * to use values from child tables in lieu of the output of the
				 * root table. Among other things, this allows us to use the
				 * sort-order from the child tables for the output.
				 */</comment>
				<expr_stmt><expr><name><name>orig</name><operator>-&gt;</operator><name>ec_has_volatile</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_members</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>, <argument><expr><name>em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<comment type="block">/* if any transforms were found return new ec */</comment>
	<if_stmt><if>if <condition>(<expr><name>newec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></argument>, <argument><expr><name>newec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>propagate_to_children</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>parents</name> <init>= <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>newec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>parent</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>bms_get_singleton_member</name><argument_list>(<argument><expr><name>parents</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>==</operator> <operator>(</operator><name>Index</name><operator>)</operator> <name>parent</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>add_child_rel_equivalences</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>appinfo</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>newec</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	This optimization transforms between equivalent sort operations to try
 *	to find useful indexes.
 *
 *	For example: an ORDER BY date_trunc('minute', time) can be implemented by
 *	an ordering of time.
 */</comment>
<function><type><name>void</name></type>
<name>ts_sort_transform_optimization</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We attack this problem in three steps:
	 *
	 * 1) Create a pathkey for the transformed (simplified) sort.
	 *
	 * 2) Use the transformed pathkey to find new useful index paths.
	 *
	 * 3) Transform the  pathkey of the new paths back into the original form
	 * to make this transparent to upper levels in the planner.
	 *
	 */</comment>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>transformed_query_pathkey</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>orig_query_pathkeys</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>last_pk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>new_pk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>transformed</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * nothing to do for empty pathkeys
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>orig_query_pathkeys</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * These sort transformations are only safe for single member ORDER BY
	 * clauses or as last member of the ORDER BY clause.
	 * Using it for other ORDER BY clauses will result in wrong ordering.
	 */</comment>
	<expr_stmt><expr><name>last_pk</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>transformed</name> <operator>=</operator> <call><name>sort_transform_ec</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>last_pk</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>transformed</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>new_pk</name> <operator>=</operator> <call><name>make_canonical_pathkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name>transformed</name></expr></argument>,
									<argument><expr><name><name>last_pk</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
									<argument><expr><name><name>last_pk</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>,
									<argument><expr><name><name>last_pk</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create complete transformed pathkeys
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>root-&gt;query_pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>last_pk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>transformed_query_pathkey</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>transformed_query_pathkey</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>transformed_query_pathkey</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>transformed_query_pathkey</name></expr></argument>, <argument><expr><name>new_pk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* search for indexes on transformed pathkeys */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name>transformed_query_pathkey</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>create_index_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name>orig_query_pathkeys</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * change returned paths to use original pathkeys. have to go through
	 * all paths since create_index_paths might have modified existing
	 * pathkey. Always safe to do transform since ordering of
	 * transformed_query_pathkey implements ordering of
	 * orig_query_pathkeys.
	 */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>compare_pathkeys</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>, <argument><expr><name>transformed_query_pathkey</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PATHKEYS_EQUAL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>orig_query_pathkeys</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>
</unit>
