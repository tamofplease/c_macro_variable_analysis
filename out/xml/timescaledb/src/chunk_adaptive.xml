<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/timescaledb/src/chunk_adaptive.c"><comment type="block">/*
 * The contents and feature provided by this file (and its associated header
 * file) -- adaptive chunking -- are currently in BETA.
 * Feedback, suggestions, and bugs should be reported
 * on the GitHub repository issues page, or in our public slack.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_proc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;catalog/pg_type.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/acl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/syscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/lsyscache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/guc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/builtins.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/array.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/snapmgr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils/typcache.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;funcapi.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parser/parse_func.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;miscadmin.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypertable_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compat/compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk_adaptive.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chunk.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hypercube.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CHUNK_SIZING_FN_NAME</name></cpp:macro> <cpp:value>"calculate_chunk_interval"</cpp:value></cpp:define>

<comment type="block">/* This can be set to a positive number (and non-zero) value from tests to
 * simulate memory cache size. This makes it possible to run tests
 * deterministically. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int64</name></type> <name>fixed_memory_cache_size</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Takes a PostgreSQL text representation of data (e.g., 40MB) and converts it
 * into a int64 for calculations
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>convert_text_memory_amount_to_bytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>memory_amount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hintmsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>bytes</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>memory_amount</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid memory amount"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int</name><argument_list>(<argument><expr><name>memory_amount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nblocks</name></expr></argument>, <argument><expr><name>GUC_UNIT_BLOCKS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hintmsg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid data amount"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bytes</name> <operator>=</operator> <name>nblocks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytes</name> <operator>*=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>

	<return>return <expr><name>bytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exposed for testing purposes to be able to simulate a different memory
 * cache size in tests.
 */</comment>
<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_set_memory_cache_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type>
<name>ts_set_memory_cache_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>memory_amount</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>fixed_memory_cache_size</name> <operator>=</operator> <call><name>convert_text_memory_amount_to_bytes</name><argument_list>(<argument><expr><name>memory_amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>fixed_memory_cache_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the amount of cache memory for chunks.
 * We use shared_buffers converted to bytes.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>get_memory_cache_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hintmsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shared_buffers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>memory_bytes</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fixed_memory_cache_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>fixed_memory_cache_size</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>GetConfigOption</name><argument_list>(<argument><expr><literal type="string">"shared_buffers"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing configuration for 'shared_buffers'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shared_buffers</name></expr></argument>, <argument><expr><name>GUC_UNIT_BLOCKS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hintmsg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not parse 'shared_buffers' setting: %s"</literal></expr></argument>, <argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>memory_bytes</name> <operator>=</operator> <name>shared_buffers</name></expr>;</expr_stmt>

	<comment type="block">/* Value is in blocks, so convert to bytes */</comment>
	<expr_stmt><expr><name>memory_bytes</name> <operator>*=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>

	<return>return <expr><name>memory_bytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For chunk sizing, we don't want to set chunk size exactly the same as the
 * available cache memory, since chunk sizes won't be exact. We therefore give
 * some slack here.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CACHE_MEMORY_SLACK</name></cpp:macro> <cpp:value>0.9</cpp:value></cpp:define>

<function><type><specifier>extern</specifier> <specifier>inline</specifier> <name>int64</name></type>
<name>ts_chunk_calculate_initial_chunk_target_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <call><name>get_memory_cache_size</name><argument_list>()</argument_list></call> <operator>*</operator> <name>DEFAULT_CACHE_MEMORY_SLACK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <name>MinMaxResult</name>
<block>{
	<decl><name>MINMAX_NO_INDEX</name></decl>,
	<decl><name>MINMAX_NO_TUPLES</name></decl>,
	<decl><name>MINMAX_FOUND</name></decl>,
}</block></enum></type> <name>MinMaxResult</name>;</typedef>

<comment type="block">/*
 * Use a heap scan to find the min and max of a given column of a chunk. This
 * could be a rather costly operation. Should figure out how to keep min-max
 * stats cached.
 */</comment>
<function><type><specifier>static</specifier> <name>MinMaxResult</name></type>
<name>minmax_heapscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>atttype</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name><name>minmax</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>table_slot_create</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tce</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>true</name></expr>, <expr><name>true</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Lookup the tuple comparison function from the type cache */</comment>
	<expr_stmt><expr><name>tce</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>, <argument><expr><name>TYPECACHE_CMP_PROC</name> <operator>|</operator> <name>TYPECACHE_CMP_PROC_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>tce</name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tce</name><operator>-&gt;</operator><name>cmp_proc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no comparison function for type %u"</literal></expr></argument>, <argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>table_scan_getnextslot</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>value</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Check for new min */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tce</name><operator>-&gt;</operator><name>cmp_proc_finfo</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>minmax</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>minmax</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check for new max */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tce</name><operator>-&gt;</operator><name>cmp_proc_finfo</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>minmax</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>minmax</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><name>MINMAX_NO_TUPLES</name></expr> </then><else>: <expr><name>MINMAX_FOUND</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Use an index scan to find the min and max of a given column of a chunk.
 */</comment>
<function><type><specifier>static</specifier> <name>MinMaxResult</name></type>
<name>minmax_indexscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>idxrel</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name><name>minmax</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>index_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>idxrel</name></expr></argument>, <argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>table_slot_create</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>true</name></expr>, <expr><name>true</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>ScanDirection</name></type> <name><name>directions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>BackwardScanDirection</name></expr>, <expr><name>ForwardScanDirection</name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>found_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>found_tuple</name> <operator>=</operator> <call><name>index_getnext_slot</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name><name>directions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_tuple</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>minmax</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><name>MINMAX_NO_TUPLES</name></expr> </then><else>: <expr><name>MINMAX_FOUND</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do a scan for min and max using and index on the given column.
 */</comment>
<function><type><specifier>static</specifier> <name>MinMaxResult</name></type>
<name>relation_minmax_indexscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>atttype</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>attname</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name></type> <name><name>minmax</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexlist</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinMaxResult</name></type> <name>res</name> <init>= <expr><name>MINMAX_NO_INDEX</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>indexlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>idxrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>idxattr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>idxrel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idxattr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>idxrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>idxattr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>==</operator> <name>atttype</name> <operator>&amp;&amp;</operator> <call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>idxattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>minmax_indexscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>minmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>MINMAX_FOUND</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determines if a table has an appropriate index for finding the minimum and
 * maximum time value. This would be an index whose first column is the same as
 * the column used for time partitioning.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>table_has_minmax_index</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>atttype</name></decl></parameter>, <parameter><decl><type><name>Name</name></type> <name>attname</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>minmax</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinMaxResult</name></type> <name>res</name> <init>= <expr><call><name>relation_minmax_indexscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>atttype</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>minmax</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name> <operator>!=</operator> <name>MINMAX_NO_INDEX</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the min and max value for a given column of a chunk.
 *
 * Returns true iff min and max is found, otherwise false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunk_get_minmax</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>atttype</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name><name>minmax</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type> <name>attname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinMaxResult</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attname</name></expr></argument>, <argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>relation_minmax_indexscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>atttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attname</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>minmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>MINMAX_NO_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no index on \"%s\" found for adaptive chunking on chunk \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Adaptive chunking works best with an index on the dimension being "</literal>
						   <literal type="string">"adapted."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>minmax_heapscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>atttype</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>minmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name> <operator>==</operator> <name>MINMAX_FOUND</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AttrNumber</name></type>
<name>chunk_get_attno</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>hypertable_relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>chunk_relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>hypertable_attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>get_attname</name><argument_list>(<argument><expr><name>hypertable_relid</name></expr></argument>, <argument><expr><name>hypertable_attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name>chunk_relid</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_SIZING_FUNC_NARGS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CHUNK_WINDOW</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* Tuples must have filled this fraction of the chunk interval to use it to
 * estimate a new chunk time interval */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTERVAL_FILLFACTOR_THRESH</name></cpp:macro> <cpp:value>0.5</cpp:value></cpp:define>
<comment type="block">/* A chunk must fill this (extrapolated) fraction of the target size to use it
 * to estimate a new chunk time interval.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_FILLFACTOR_THRESH</name></cpp:macro> <cpp:value>0.15</cpp:value></cpp:define>

<comment type="block">/* The calculated chunk time interval must differ this much to actually change
 * the interval */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTERVAL_MIN_CHANGE_THRESH</name></cpp:macro> <cpp:value>0.15</cpp:value></cpp:define>

<comment type="block">/* More than this number of intervals must be undersized in order to use the
 * undersized calculation path */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_UNDERSIZED_INTERVALS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* Threshold to boost to if there are only undersized intervals to make
 * predictions from. This should be slightly above the SIZE_FILLFACTOR_THRESH
 * so that the next chunks made with this are likely to meet that threshold
 * and be used in normal prediction mode */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNDERSIZED_FILLFACTOR_THRESH</name></cpp:macro> <cpp:value>(SIZE_FILLFACTOR_THRESH * 1.1)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_calculate_chunk_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Calculate a new interval for a chunk in a given dimension.
 *
 * This function implements the main algorithm for adaptive chunking. Given a
 * dimension, coordinate (point) on the dimensional axis (e.g., point in time),
 * and a chunk target size (in bytes), the function should return a new
 * interval that best fills the chunk to the target size.
 *
 * The intuition behind the current implementation is to look back at the recent
 * past chunks in the dimension and look at how close they are to the target
 * size (the fillfactor) and then use that information to calculate a new
 * interval. I.e., if the fillfactor of a past chunk was below 1.0 we increase
 * the interval, and if it was above 1.0 we decrease it. Thus, for each past
 * chunk, we calculate the interval that would have filled the chunk to the
 * target size. Then, to calculate the new chunk interval, we average the
 * intervals of the past chunks.
 *
 * Note, however, that there are a couple of caveats. First, we cannot look back
 * at the most recently created chunks, because there is no guarantee that data
 * was written exactly in order of the dimension we are looking at. Therefore,
 * we "look back" along the dimension axis instead of by, e.g., chunk
 * ID. Second, chunks can be filled unevenly. Below are three examples of how
 * chunks can be filled ('*' represents data):
 *
 *' |--------|
 *' | * * * *|  1. Evenly filled (ideal)
 *' |--------|
 *
 *' |--------|
 *' |    ****|  2. Partially filled
 *' |--------|
 *
 *' |--------|
 *' |  * * **|  3. Unevenly filled
 *' |--------|
 *
 * Chunk (1) above represents the ideal situation. The chunk is evenly filled
 * across the entire chunk interval. This indicates a steady stream of data at
 * an even rate. Given the size and interval of this chunk, it would be
 * straightforward to calculate a new interval to hit a given target size.
 *
 * Chunk (2) has the same amount of data as (1), but it is reasonable to believe
 * that the following chunk will be fully filled with about twice the amount of
 * data. It is common for the first chunk in a hypertable to look like
 * this. Thus, to be able to use the first chunk for prediction, we compensate
 * by finding the MIN and MAX dimension values of the data in the chunk and then
 * use max-min (difference) as the interval instead of the chunk's actual
 * interval (i.e., since we are more interested in data rate/density we pretend
 * that this is a smaller chunk in terms of the given dimension.)
 *
 * Chunk (3) is probably a common real world scenario. We don't do anything
 * special to handle this case.
 *
 * We use a number of thresholds to avoid changing intervals
 * unnecessarily. I.e., if we are close to the target interval, we avoid
 * changing the interval since there might be a natural variance in the
 * fillfactor across chunks. This is intended to avoid flip-flopping or unstable
 * behavior.
 *
 * Additionally, two other thresholds govern much of the algorithm's behavior.
 * First is the SIZE_FILLFACTOR_THRESH, which is the minimum percentage of
 * the extrapolated size a chunk should fill to be used in computing a new
 * target size. We want a minimum so as to not overreact to a chunk that is too
 * small to get an accurate extrapolation from. For example, a chunk that is
 * only a percentage point or two of the extrapolated size (or less!) may not
 * contain enough data to give a true sense of the data rate, i.e., if it was
 * made in a particularly bursty or slow period.
 *
 * However, in the event that an initial chunk size was set
 * way too small, the algorithm will never adjust because
 * _all_ the chunks fall below this threshold. Therefore we have another
 * threshold -- NUM_UNDERSIZED_INTERVALS -- that helps our algorithm make
 * progress to the correct estimate. If there are _no_ chunks that
 * meet SIZE_FILLFACTOR_THRESH, and at least NUM_UNDERSIZED_INTERVALS chunks
 * we are sufficiently full, we use those chunks to adjust the target chunk
 * size so that the next chunks created at least meet SIZE_FILLFACTOR_THRESH.
 * This will then allow the algorithm to work in the normal way to adjust
 * further if needed.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_calculate_chunk_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>dimension_id</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>dimension_coord</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>chunk_target_size_bytes</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>chunk_interval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>undersized_intervals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>current_interval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>hypertable_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunks</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_intervals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_undersized_intervals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>interval_diff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>undersized_fillfactor</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type> <name>acl_result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>CHUNK_SIZING_FUNC_NARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid number of arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunk_target_size_bytes</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"[adaptive] chunk_target_size_bytes="</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>chunk_target_size_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hypertable_id</name> <operator>=</operator> <call><name>ts_dimension_get_hypertable_id</name><argument_list>(<argument><expr><name>dimension_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hypertable_id</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find a matching hypertable for dimension %u"</literal></expr></argument>, <argument><expr><name>dimension_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_get_by_id</name><argument_list>(<argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ht</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>acl_result</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>acl_result</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for table %s"</literal></expr></argument>, <argument><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>table_name</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>hypertable_is_distributed</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"adaptive chunking not supported on distributed hypertables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ts_hyperspace_get_dimension_by_id</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>dimension_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dim</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>current_interval</name> <operator>=</operator> <name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>interval_length</name></name></expr>;</expr_stmt>

	<comment type="block">/* Get a window of recent chunks */</comment>
	<expr_stmt><expr><name>chunks</name> <operator>=</operator> <call><name>ts_chunk_get_window</name><argument_list>(<argument><expr><name>dimension_id</name></expr></argument>,
								 <argument><expr><name>dimension_coord</name></expr></argument>,
								 <argument><expr><name>DEFAULT_CHUNK_WINDOW</name></expr></argument>,
								 <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>chunks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Chunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>DimensionSlice</name> <modifier>*</modifier></type><name>slice</name> <init>=
			<expr><call><name>ts_hypercube_get_slice_by_dimension_id</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>cube</name></name></expr></argument>, <argument><expr><name>dimension_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>chunk_size</name></decl>, <decl><type ref="prev"/><name>slice_interval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>minmax</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attno</name> <init>=
			<expr><call><name>chunk_get_attno</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>main_table_relid</name></name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>column_attno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>chunk_size</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(
			<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_total_relation_size</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>slice_interval</name> <operator>=</operator> <name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_end</name></name> <operator>-</operator> <name><name>slice</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>range_start</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>chunk_get_minmax</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>table_id</name></name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>minmax</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type> <name>min</name> <init>= <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name><name>minmax</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type> <name>max</name> <init>= <expr><call><name>ts_time_value_to_internal</name><argument_list>(<argument><expr><name><name>minmax</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type> <name>interval_fillfactor</name></decl>, <decl><type ref="prev"/><name>size_fillfactor</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type> <name>extrapolated_chunk_size</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * The fillfactor of the slice interval that the data actually
			 * spans
			 */</comment>
			<expr_stmt><expr><name>interval_fillfactor</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>max</name> <operator>-</operator> <name>min</name><operator>)</operator> <operator>/</operator> <name>slice_interval</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Extrapolate the size the chunk would have if it spanned the
			 * entire interval
			 */</comment>
			<expr_stmt><expr><name>extrapolated_chunk_size</name> <operator>=</operator> <name>chunk_size</name> <operator>/</operator> <name>interval_fillfactor</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>size_fillfactor</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>extrapolated_chunk_size</name><operator>)</operator> <operator>/</operator> <name>chunk_target_size_bytes</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				 <argument><expr><literal type="string">"[adaptive] slice_interval="</literal> <name>UINT64_FORMAT</name> <literal type="string">" interval_fillfactor=%lf"</literal>
				 <literal type="string">" current_chunk_size="</literal> <name>UINT64_FORMAT</name> <literal type="string">" extrapolated_chunk_size="</literal> <name>UINT64_FORMAT</name>
				 <literal type="string">" size_fillfactor=%lf"</literal></expr></argument>,
				 <argument><expr><name>slice_interval</name></expr></argument>,
				 <argument><expr><name>interval_fillfactor</name></expr></argument>,
				 <argument><expr><name>chunk_size</name></expr></argument>,
				 <argument><expr><name>extrapolated_chunk_size</name></expr></argument>,
				 <argument><expr><name>size_fillfactor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the chunk is sufficiently filled with data and its
			 * extrapolated size is large enough to make a good estimate, use
			 * it
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>interval_fillfactor</name> <operator>&gt;</operator> <name>INTERVAL_FILLFACTOR_THRESH</name> <operator>&amp;&amp;</operator>
				<name>size_fillfactor</name> <operator>&gt;</operator> <name>SIZE_FILLFACTOR_THRESH</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>chunk_interval</name> <operator>+=</operator> <operator>(</operator><name>slice_interval</name> <operator>/</operator> <name>size_fillfactor</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>num_intervals</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>

			<comment type="block">/*
			 * If the chunk is sufficiently filled with data but its
			 * extrapolated size is too small, track it and maybe use it if it
			 * is all we have
			 */</comment>
			<if type="elseif">else if <condition>(<expr><name>interval_fillfactor</name> <operator>&gt;</operator> <name>INTERVAL_FILLFACTOR_THRESH</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					 <argument><expr><literal type="string">"[adaptive] chunk sufficiently full, "</literal>
					 <literal type="string">"but undersized. may use for prediction."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>undersized_intervals</name> <operator>+=</operator> <name>slice_interval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>undersized_fillfactor</name> <operator>+=</operator> <name>size_fillfactor</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>num_undersized_intervals</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
		 <argument><expr><literal type="string">"[adaptive] current interval="</literal> <name>UINT64_FORMAT</name>
		 <literal type="string">" num_intervals=%d num_undersized_intervals=%d"</literal></expr></argument>,
		 <argument><expr><name>current_interval</name></expr></argument>,
		 <argument><expr><name>num_intervals</name></expr></argument>,
		 <argument><expr><name>num_undersized_intervals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No full sized intervals, but enough undersized intervals to adjust
	 * higher. We only want to do this if there are no sufficiently sized
	 * intervals to use for a normal adjustment. This keeps us from getting
	 * stuck with a really small interval size.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_intervals</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>num_undersized_intervals</name> <operator>&gt;</operator> <name>NUM_UNDERSIZED_INTERVALS</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type> <name>avg_fillfactor</name> <init>= <expr><name>undersized_fillfactor</name> <operator>/</operator> <name>num_undersized_intervals</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>incr_factor</name> <init>= <expr><name>UNDERSIZED_FILLFACTOR_THRESH</name> <operator>/</operator> <name>avg_fillfactor</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>avg_interval</name> <init>= <expr><name>undersized_intervals</name> <operator>/</operator> <name>num_undersized_intervals</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			 <argument><expr><literal type="string">"[adaptive] no sufficiently large intervals found, but "</literal>
			 <literal type="string">"some undersized ones found. increase interval to probe for better"</literal>
			 <literal type="string">" threshold. factor=%lf"</literal></expr></argument>,
			 <argument><expr><name>incr_factor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunk_interval</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><name>avg_interval</name> <operator>*</operator> <name>incr_factor</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* No data &amp; insufficient amount of undersized chunks, keep old interval */</comment>
	<if type="elseif">else if <condition>(<expr><name>num_intervals</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			 <argument><expr><literal type="string">"[adaptive] no sufficiently large intervals found, "</literal>
			 <literal type="string">"nor enough undersized chunks to estimate. "</literal>
			 <literal type="string">"use previous size of "</literal> <name>UINT64_FORMAT</name></expr></argument>,
			 <argument><expr><name>current_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>current_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>chunk_interval</name> <operator>/=</operator> <name>num_intervals</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If the interval hasn't really changed much from before, we keep the old
	 * interval to ensure we do not have fluctuating behavior around the
	 * target size.
	 */</comment>
	<expr_stmt><expr><name>interval_diff</name> <operator>=</operator> <call><name>fabs</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>-</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>chunk_interval</name> <operator>/</operator> <name>current_interval</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>interval_diff</name> <operator>&lt;=</operator> <name>INTERVAL_MIN_CHANGE_THRESH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			 <argument><expr><literal type="string">"[adaptive] calculated chunk interval="</literal> <name>UINT64_FORMAT</name>
			 <literal type="string">", but is below change threshold, keeping old interval"</literal></expr></argument>,
			 <argument><expr><name>chunk_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunk_interval</name> <operator>=</operator> <name>current_interval</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"[adaptive] calculated chunk interval="</literal> <name>UINT64_FORMAT</name>
			 <literal type="string">" for hypertable %d, making change"</literal></expr></argument>,
			 <argument><expr><name>chunk_interval</name></expr></argument>,
			 <argument><expr><name>hypertable_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>chunk_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Validate that the provided function in the catalog can be used for
 * determining a new chunk size, i.e., has form (int,bigint,bigint) -&gt; bigint.
 *
 * Parameter 'info' will be updated with the function's information
 */</comment>
<function><type><name>void</name></type>
<name>ts_chunk_sizing_func_validate</name><parameter_list>(<parameter><decl><type><name>regproc</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>ChunkSizingInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typearr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator> <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid chunk sizing function"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typearr</name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>form</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>!=</operator> <name>CHUNK_SIZING_FUNC_NARGS</name> <operator>||</operator> <name><name>typearr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>INT4OID</name> <operator>||</operator>
		<name><name>typearr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>INT8OID</name> <operator>||</operator> <name><name>typearr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <name>INT8OID</name> <operator>||</operator> <name><name>form</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>INT8OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid function signature"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"A chunk sizing function's signature should be (int, bigint, bigint) -&gt; "</literal>
						 <literal type="string">"bigint"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>info</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>func_schema</name></name></expr></argument>, <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>form</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>func_name</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse the target size text into an integer amount of bytes.
 *
 * 'off' / 'disable' - returns a target of 0
 * 'estimate' - returns a target based on number of bytes in shared memory
 * 'XXMB' / etc - converts from PostgreSQL pretty text into number of bytes
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>chunk_target_size_in_bytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>text</name> <modifier>*</modifier></type><name>target_size_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target_size</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>target_size_text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>target_size_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>target_size</name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>target_size</name></expr></argument>, <argument><expr><literal type="string">"disable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>target_size</name></expr></argument>, <argument><expr><literal type="string">"estimate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>target_size_bytes</name> <operator>=</operator> <call><name>ts_chunk_calculate_initial_chunk_target_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>target_size_bytes</name> <operator>=</operator> <call><name>convert_text_memory_amount_to_bytes</name><argument_list>(<argument><expr><name>target_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Disable if target size is zero or less */</comment>
	<if_stmt><if>if <condition>(<expr><name>target_size_bytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>target_size_bytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>target_size_bytes</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MB</name></cpp:macro> <cpp:value>(1024 * 1024)</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>ts_chunk_adaptive_sizing_info_validate</name><parameter_list>(<parameter><decl><type><name>ChunkSizingInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type> <name>attname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>atttype</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>table_relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_hypertable_permissions_check</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>table_relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_DIMENSION_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no open dimension found for adaptive chunking"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>table_relid</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attname</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>atttype</name> <operator>=</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>table_relid</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_chunk_sizing_func_validate</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>func</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>info</name><operator>-&gt;</operator><name>target_size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>target_size_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>target_size_bytes</name></name> <operator>=</operator> <call><name>chunk_target_size_in_bytes</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>target_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Don't validate further if disabled */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>target_size_bytes</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Warn of small target sizes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>target_size_bytes</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>info</name><operator>-&gt;</operator><name>target_size_bytes</name></name> <operator>&lt;</operator> <operator>(</operator><literal type="number">10</literal> <operator>*</operator> <name>MB</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"target chunk size for adaptive chunking is less than 10 MB"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>check_for_index</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>table_has_minmax_index</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>table_relid</name></name></expr></argument>, <argument><expr><name>atttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attname</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no index on \"%s\" found for adaptive chunking on hypertable \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>info</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>table_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Adaptive chunking works best with an index on the dimension being "</literal>
						   <literal type="string">"adapted."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TS_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>ts_chunk_adaptive_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Change the settings for adaptive chunking.
 */</comment>
<function><type><name>Datum</name></type>
<name>ts_chunk_adaptive_set</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkSizingInfo</name></type> <name>info</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>table_relid</name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>target_size</name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>?</operator> <name>NULL</name> <operator>:</operator> <call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>func</name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>?</operator> <name>InvalidOid</name> <operator>:</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>colname</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>check_for_index</name> <operator>=</operator> <name>true</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Hypertable</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Dimension</name> <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cache</name> <modifier>*</modifier></type><name>hcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogSecurityContext</name></type> <name>sec_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr>, <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TS_PREVENT_FUNC_IF_READ_ONLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid hypertable: cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>table_relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ts_hypertable_permissions_check</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>table_relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>ts_hypertable_cache_get_cache_and_entry</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>table_relid</name></name></expr></argument>, <argument><expr><name>CACHE_FLAG_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the first open dimension that we will adapt on */</comment>
	<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ts_hyperspace_get_dimension</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>DIMENSION_TYPE_OPEN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>dim</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TS_DIMENSION_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no open dimension found for adaptive chunking"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>colname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>dim</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_chunk_adaptive_sizing_info_validate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function returning record called in context that cannot accept type record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>chunk_sizing_func</name></name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>func</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>chunk_sizing_func</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ts_chunk_sizing_func_validate</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>chunk_sizing_func</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>chunk_sizing_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid chunk sizing function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>target_size_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the hypertable entry */</comment>
	<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>chunk_target_size</name></name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>target_size_bytes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_database_info_become_owner</name><argument_list>(<argument><expr><call><name>ts_catalog_database_info_get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_hypertable_update</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ts_catalog_restore_user</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sec_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ts_cache_release</name><argument_list>(<argument><expr><name>hcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_default_chunk_sizing_fn_oid</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name><name>chunkfnargtypes</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>INT4OID</name></expr>, <expr><name>INT8OID</name></expr>, <expr><name>INT8OID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcname</name> <init>=
		<expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>INTERNAL_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>DEFAULT_CHUNK_SIZING_FN_NAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>chunkfnargtypes</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>chunkfnargtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>chunkfnoid</name> <init>= <expr><call><name>LookupFuncName</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>chunkfnargtypes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>chunkfnoid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ChunkSizingInfo</name> <modifier>*</modifier></type>
<name>ts_chunk_sizing_info_get_default_disabled</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkSizingInfo</name> <modifier>*</modifier></type><name>chunk_sizing_info</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>chunk_sizing_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>chunk_sizing_info</name> <operator>=</operator> <operator>(</operator><name>ChunkSizingInfo</name><operator>)</operator><block>{
		<expr><operator>.</operator><name>table_relid</name> <operator>=</operator> <name>table_relid</name></expr>,
		<expr><operator>.</operator><name>target_size</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>func</name> <operator>=</operator> <call><name>get_default_chunk_sizing_fn_oid</name><argument_list>()</argument_list></call></expr>,
		<expr><operator>.</operator><name>colname</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>check_for_index</name> <operator>=</operator> <name>false</name></expr>,
	}</block></expr>;</expr_stmt>
	<return>return <expr><name>chunk_sizing_info</name></expr>;</return>
</block_content>}</block></function>
</unit>
